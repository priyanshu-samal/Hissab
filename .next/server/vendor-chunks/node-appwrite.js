/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/node-appwrite";
exports.ids = ["vendor-chunks/node-appwrite"];
exports.modules = {

/***/ "(action-browser)/./node_modules/node-appwrite/index.js":
/*!*********************************************!*\
  !*** ./node_modules/node-appwrite/index.js ***!
  \*********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("const Client = __webpack_require__(/*! ./lib/client.js */ \"(action-browser)/./node_modules/node-appwrite/lib/client.js\");\nconst Query = __webpack_require__(/*! ./lib/query.js */ \"(action-browser)/./node_modules/node-appwrite/lib/query.js\");\nconst Permission = __webpack_require__(/*! ./lib/permission.js */ \"(action-browser)/./node_modules/node-appwrite/lib/permission.js\");\nconst Role = __webpack_require__(/*! ./lib/role.js */ \"(action-browser)/./node_modules/node-appwrite/lib/role.js\");\nconst ID = __webpack_require__(/*! ./lib/id.js */ \"(action-browser)/./node_modules/node-appwrite/lib/id.js\");\nconst InputFile = __webpack_require__(/*! ./lib/inputFile.js */ \"(action-browser)/./node_modules/node-appwrite/lib/inputFile.js\");\nconst AppwriteException = __webpack_require__(/*! ./lib/exception.js */ \"(action-browser)/./node_modules/node-appwrite/lib/exception.js\");\nconst Account = __webpack_require__(/*! ./lib/services/account.js */ \"(action-browser)/./node_modules/node-appwrite/lib/services/account.js\");\nconst Avatars = __webpack_require__(/*! ./lib/services/avatars.js */ \"(action-browser)/./node_modules/node-appwrite/lib/services/avatars.js\");\nconst Databases = __webpack_require__(/*! ./lib/services/databases.js */ \"(action-browser)/./node_modules/node-appwrite/lib/services/databases.js\");\nconst Functions = __webpack_require__(/*! ./lib/services/functions.js */ \"(action-browser)/./node_modules/node-appwrite/lib/services/functions.js\");\nconst Graphql = __webpack_require__(/*! ./lib/services/graphql.js */ \"(action-browser)/./node_modules/node-appwrite/lib/services/graphql.js\");\nconst Health = __webpack_require__(/*! ./lib/services/health.js */ \"(action-browser)/./node_modules/node-appwrite/lib/services/health.js\");\nconst Locale = __webpack_require__(/*! ./lib/services/locale.js */ \"(action-browser)/./node_modules/node-appwrite/lib/services/locale.js\");\nconst Messaging = __webpack_require__(/*! ./lib/services/messaging.js */ \"(action-browser)/./node_modules/node-appwrite/lib/services/messaging.js\");\nconst Storage = __webpack_require__(/*! ./lib/services/storage.js */ \"(action-browser)/./node_modules/node-appwrite/lib/services/storage.js\");\nconst Teams = __webpack_require__(/*! ./lib/services/teams.js */ \"(action-browser)/./node_modules/node-appwrite/lib/services/teams.js\");\nconst Users = __webpack_require__(/*! ./lib/services/users.js */ \"(action-browser)/./node_modules/node-appwrite/lib/services/users.js\");\nconst AuthenticatorType = __webpack_require__(/*! ./lib/enums/authenticator-type.js */ \"(action-browser)/./node_modules/node-appwrite/lib/enums/authenticator-type.js\");\nconst AuthenticationFactor = __webpack_require__(/*! ./lib/enums/authentication-factor.js */ \"(action-browser)/./node_modules/node-appwrite/lib/enums/authentication-factor.js\");\nconst OAuthProvider = __webpack_require__(/*! ./lib/enums/o-auth-provider.js */ \"(action-browser)/./node_modules/node-appwrite/lib/enums/o-auth-provider.js\");\nconst Browser = __webpack_require__(/*! ./lib/enums/browser.js */ \"(action-browser)/./node_modules/node-appwrite/lib/enums/browser.js\");\nconst CreditCard = __webpack_require__(/*! ./lib/enums/credit-card.js */ \"(action-browser)/./node_modules/node-appwrite/lib/enums/credit-card.js\");\nconst Flag = __webpack_require__(/*! ./lib/enums/flag.js */ \"(action-browser)/./node_modules/node-appwrite/lib/enums/flag.js\");\nconst RelationshipType = __webpack_require__(/*! ./lib/enums/relationship-type.js */ \"(action-browser)/./node_modules/node-appwrite/lib/enums/relationship-type.js\");\nconst RelationMutate = __webpack_require__(/*! ./lib/enums/relation-mutate.js */ \"(action-browser)/./node_modules/node-appwrite/lib/enums/relation-mutate.js\");\nconst IndexType = __webpack_require__(/*! ./lib/enums/index-type.js */ \"(action-browser)/./node_modules/node-appwrite/lib/enums/index-type.js\");\nconst Runtime = __webpack_require__(/*! ./lib/enums/runtime.js */ \"(action-browser)/./node_modules/node-appwrite/lib/enums/runtime.js\");\nconst ExecutionMethod = __webpack_require__(/*! ./lib/enums/execution-method.js */ \"(action-browser)/./node_modules/node-appwrite/lib/enums/execution-method.js\");\nconst Name = __webpack_require__(/*! ./lib/enums/name.js */ \"(action-browser)/./node_modules/node-appwrite/lib/enums/name.js\");\nconst SmtpEncryption = __webpack_require__(/*! ./lib/enums/smtp-encryption.js */ \"(action-browser)/./node_modules/node-appwrite/lib/enums/smtp-encryption.js\");\nconst Compression = __webpack_require__(/*! ./lib/enums/compression.js */ \"(action-browser)/./node_modules/node-appwrite/lib/enums/compression.js\");\nconst ImageGravity = __webpack_require__(/*! ./lib/enums/image-gravity.js */ \"(action-browser)/./node_modules/node-appwrite/lib/enums/image-gravity.js\");\nconst ImageFormat = __webpack_require__(/*! ./lib/enums/image-format.js */ \"(action-browser)/./node_modules/node-appwrite/lib/enums/image-format.js\");\nconst PasswordHash = __webpack_require__(/*! ./lib/enums/password-hash.js */ \"(action-browser)/./node_modules/node-appwrite/lib/enums/password-hash.js\");\nconst MessagingProviderType = __webpack_require__(/*! ./lib/enums/messaging-provider-type.js */ \"(action-browser)/./node_modules/node-appwrite/lib/enums/messaging-provider-type.js\");\n\nmodule.exports = {\n    Client,\n    Query,\n    Permission,\n    Role,\n    ID,\n    InputFile,\n    AppwriteException,\n    Account,\n    Avatars,\n    Databases,\n    Functions,\n    Graphql,\n    Health,\n    Locale,\n    Messaging,\n    Storage,\n    Teams,\n    Users,\n    AuthenticatorType,\n    AuthenticationFactor,\n    OAuthProvider,\n    Browser,\n    CreditCard,\n    Flag,\n    RelationshipType,\n    RelationMutate,\n    IndexType,\n    Runtime,\n    ExecutionMethod,\n    Name,\n    SmtpEncryption,\n    Compression,\n    ImageGravity,\n    ImageFormat,\n    PasswordHash,\n    MessagingProviderType,\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFjdGlvbi1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9ub2RlLWFwcHdyaXRlL2luZGV4LmpzIiwibWFwcGluZ3MiOiJBQUFBLGVBQWUsbUJBQU8sQ0FBQyxvRkFBaUI7QUFDeEMsY0FBYyxtQkFBTyxDQUFDLGtGQUFnQjtBQUN0QyxtQkFBbUIsbUJBQU8sQ0FBQyw0RkFBcUI7QUFDaEQsYUFBYSxtQkFBTyxDQUFDLGdGQUFlO0FBQ3BDLFdBQVcsbUJBQU8sQ0FBQyw0RUFBYTtBQUNoQyxrQkFBa0IsbUJBQU8sQ0FBQywwRkFBb0I7QUFDOUMsMEJBQTBCLG1CQUFPLENBQUMsMEZBQW9CO0FBQ3RELGdCQUFnQixtQkFBTyxDQUFDLHdHQUEyQjtBQUNuRCxnQkFBZ0IsbUJBQU8sQ0FBQyx3R0FBMkI7QUFDbkQsa0JBQWtCLG1CQUFPLENBQUMsNEdBQTZCO0FBQ3ZELGtCQUFrQixtQkFBTyxDQUFDLDRHQUE2QjtBQUN2RCxnQkFBZ0IsbUJBQU8sQ0FBQyx3R0FBMkI7QUFDbkQsZUFBZSxtQkFBTyxDQUFDLHNHQUEwQjtBQUNqRCxlQUFlLG1CQUFPLENBQUMsc0dBQTBCO0FBQ2pELGtCQUFrQixtQkFBTyxDQUFDLDRHQUE2QjtBQUN2RCxnQkFBZ0IsbUJBQU8sQ0FBQyx3R0FBMkI7QUFDbkQsY0FBYyxtQkFBTyxDQUFDLG9HQUF5QjtBQUMvQyxjQUFjLG1CQUFPLENBQUMsb0dBQXlCO0FBQy9DLDBCQUEwQixtQkFBTyxDQUFDLHdIQUFtQztBQUNyRSw2QkFBNkIsbUJBQU8sQ0FBQyw4SEFBc0M7QUFDM0Usc0JBQXNCLG1CQUFPLENBQUMsa0hBQWdDO0FBQzlELGdCQUFnQixtQkFBTyxDQUFDLGtHQUF3QjtBQUNoRCxtQkFBbUIsbUJBQU8sQ0FBQywwR0FBNEI7QUFDdkQsYUFBYSxtQkFBTyxDQUFDLDRGQUFxQjtBQUMxQyx5QkFBeUIsbUJBQU8sQ0FBQyxzSEFBa0M7QUFDbkUsdUJBQXVCLG1CQUFPLENBQUMsa0hBQWdDO0FBQy9ELGtCQUFrQixtQkFBTyxDQUFDLHdHQUEyQjtBQUNyRCxnQkFBZ0IsbUJBQU8sQ0FBQyxrR0FBd0I7QUFDaEQsd0JBQXdCLG1CQUFPLENBQUMsb0hBQWlDO0FBQ2pFLGFBQWEsbUJBQU8sQ0FBQyw0RkFBcUI7QUFDMUMsdUJBQXVCLG1CQUFPLENBQUMsa0hBQWdDO0FBQy9ELG9CQUFvQixtQkFBTyxDQUFDLDBHQUE0QjtBQUN4RCxxQkFBcUIsbUJBQU8sQ0FBQyw4R0FBOEI7QUFDM0Qsb0JBQW9CLG1CQUFPLENBQUMsNEdBQTZCO0FBQ3pELHFCQUFxQixtQkFBTyxDQUFDLDhHQUE4QjtBQUMzRCw4QkFBOEIsbUJBQU8sQ0FBQyxrSUFBd0M7O0FBRTlFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9qc21fYmFua2luZy8uL25vZGVfbW9kdWxlcy9ub2RlLWFwcHdyaXRlL2luZGV4LmpzP2Q0NzUiXSwic291cmNlc0NvbnRlbnQiOlsiY29uc3QgQ2xpZW50ID0gcmVxdWlyZSgnLi9saWIvY2xpZW50LmpzJyk7XG5jb25zdCBRdWVyeSA9IHJlcXVpcmUoJy4vbGliL3F1ZXJ5LmpzJyk7XG5jb25zdCBQZXJtaXNzaW9uID0gcmVxdWlyZSgnLi9saWIvcGVybWlzc2lvbi5qcycpO1xuY29uc3QgUm9sZSA9IHJlcXVpcmUoJy4vbGliL3JvbGUuanMnKTtcbmNvbnN0IElEID0gcmVxdWlyZSgnLi9saWIvaWQuanMnKTtcbmNvbnN0IElucHV0RmlsZSA9IHJlcXVpcmUoJy4vbGliL2lucHV0RmlsZS5qcycpO1xuY29uc3QgQXBwd3JpdGVFeGNlcHRpb24gPSByZXF1aXJlKCcuL2xpYi9leGNlcHRpb24uanMnKTtcbmNvbnN0IEFjY291bnQgPSByZXF1aXJlKCcuL2xpYi9zZXJ2aWNlcy9hY2NvdW50LmpzJyk7XG5jb25zdCBBdmF0YXJzID0gcmVxdWlyZSgnLi9saWIvc2VydmljZXMvYXZhdGFycy5qcycpO1xuY29uc3QgRGF0YWJhc2VzID0gcmVxdWlyZSgnLi9saWIvc2VydmljZXMvZGF0YWJhc2VzLmpzJyk7XG5jb25zdCBGdW5jdGlvbnMgPSByZXF1aXJlKCcuL2xpYi9zZXJ2aWNlcy9mdW5jdGlvbnMuanMnKTtcbmNvbnN0IEdyYXBocWwgPSByZXF1aXJlKCcuL2xpYi9zZXJ2aWNlcy9ncmFwaHFsLmpzJyk7XG5jb25zdCBIZWFsdGggPSByZXF1aXJlKCcuL2xpYi9zZXJ2aWNlcy9oZWFsdGguanMnKTtcbmNvbnN0IExvY2FsZSA9IHJlcXVpcmUoJy4vbGliL3NlcnZpY2VzL2xvY2FsZS5qcycpO1xuY29uc3QgTWVzc2FnaW5nID0gcmVxdWlyZSgnLi9saWIvc2VydmljZXMvbWVzc2FnaW5nLmpzJyk7XG5jb25zdCBTdG9yYWdlID0gcmVxdWlyZSgnLi9saWIvc2VydmljZXMvc3RvcmFnZS5qcycpO1xuY29uc3QgVGVhbXMgPSByZXF1aXJlKCcuL2xpYi9zZXJ2aWNlcy90ZWFtcy5qcycpO1xuY29uc3QgVXNlcnMgPSByZXF1aXJlKCcuL2xpYi9zZXJ2aWNlcy91c2Vycy5qcycpO1xuY29uc3QgQXV0aGVudGljYXRvclR5cGUgPSByZXF1aXJlKFwiLi9saWIvZW51bXMvYXV0aGVudGljYXRvci10eXBlLmpzXCIpO1xuY29uc3QgQXV0aGVudGljYXRpb25GYWN0b3IgPSByZXF1aXJlKFwiLi9saWIvZW51bXMvYXV0aGVudGljYXRpb24tZmFjdG9yLmpzXCIpO1xuY29uc3QgT0F1dGhQcm92aWRlciA9IHJlcXVpcmUoXCIuL2xpYi9lbnVtcy9vLWF1dGgtcHJvdmlkZXIuanNcIik7XG5jb25zdCBCcm93c2VyID0gcmVxdWlyZShcIi4vbGliL2VudW1zL2Jyb3dzZXIuanNcIik7XG5jb25zdCBDcmVkaXRDYXJkID0gcmVxdWlyZShcIi4vbGliL2VudW1zL2NyZWRpdC1jYXJkLmpzXCIpO1xuY29uc3QgRmxhZyA9IHJlcXVpcmUoXCIuL2xpYi9lbnVtcy9mbGFnLmpzXCIpO1xuY29uc3QgUmVsYXRpb25zaGlwVHlwZSA9IHJlcXVpcmUoXCIuL2xpYi9lbnVtcy9yZWxhdGlvbnNoaXAtdHlwZS5qc1wiKTtcbmNvbnN0IFJlbGF0aW9uTXV0YXRlID0gcmVxdWlyZShcIi4vbGliL2VudW1zL3JlbGF0aW9uLW11dGF0ZS5qc1wiKTtcbmNvbnN0IEluZGV4VHlwZSA9IHJlcXVpcmUoXCIuL2xpYi9lbnVtcy9pbmRleC10eXBlLmpzXCIpO1xuY29uc3QgUnVudGltZSA9IHJlcXVpcmUoXCIuL2xpYi9lbnVtcy9ydW50aW1lLmpzXCIpO1xuY29uc3QgRXhlY3V0aW9uTWV0aG9kID0gcmVxdWlyZShcIi4vbGliL2VudW1zL2V4ZWN1dGlvbi1tZXRob2QuanNcIik7XG5jb25zdCBOYW1lID0gcmVxdWlyZShcIi4vbGliL2VudW1zL25hbWUuanNcIik7XG5jb25zdCBTbXRwRW5jcnlwdGlvbiA9IHJlcXVpcmUoXCIuL2xpYi9lbnVtcy9zbXRwLWVuY3J5cHRpb24uanNcIik7XG5jb25zdCBDb21wcmVzc2lvbiA9IHJlcXVpcmUoXCIuL2xpYi9lbnVtcy9jb21wcmVzc2lvbi5qc1wiKTtcbmNvbnN0IEltYWdlR3Jhdml0eSA9IHJlcXVpcmUoXCIuL2xpYi9lbnVtcy9pbWFnZS1ncmF2aXR5LmpzXCIpO1xuY29uc3QgSW1hZ2VGb3JtYXQgPSByZXF1aXJlKFwiLi9saWIvZW51bXMvaW1hZ2UtZm9ybWF0LmpzXCIpO1xuY29uc3QgUGFzc3dvcmRIYXNoID0gcmVxdWlyZShcIi4vbGliL2VudW1zL3Bhc3N3b3JkLWhhc2guanNcIik7XG5jb25zdCBNZXNzYWdpbmdQcm92aWRlclR5cGUgPSByZXF1aXJlKFwiLi9saWIvZW51bXMvbWVzc2FnaW5nLXByb3ZpZGVyLXR5cGUuanNcIik7XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICAgIENsaWVudCxcbiAgICBRdWVyeSxcbiAgICBQZXJtaXNzaW9uLFxuICAgIFJvbGUsXG4gICAgSUQsXG4gICAgSW5wdXRGaWxlLFxuICAgIEFwcHdyaXRlRXhjZXB0aW9uLFxuICAgIEFjY291bnQsXG4gICAgQXZhdGFycyxcbiAgICBEYXRhYmFzZXMsXG4gICAgRnVuY3Rpb25zLFxuICAgIEdyYXBocWwsXG4gICAgSGVhbHRoLFxuICAgIExvY2FsZSxcbiAgICBNZXNzYWdpbmcsXG4gICAgU3RvcmFnZSxcbiAgICBUZWFtcyxcbiAgICBVc2VycyxcbiAgICBBdXRoZW50aWNhdG9yVHlwZSxcbiAgICBBdXRoZW50aWNhdGlvbkZhY3RvcixcbiAgICBPQXV0aFByb3ZpZGVyLFxuICAgIEJyb3dzZXIsXG4gICAgQ3JlZGl0Q2FyZCxcbiAgICBGbGFnLFxuICAgIFJlbGF0aW9uc2hpcFR5cGUsXG4gICAgUmVsYXRpb25NdXRhdGUsXG4gICAgSW5kZXhUeXBlLFxuICAgIFJ1bnRpbWUsXG4gICAgRXhlY3V0aW9uTWV0aG9kLFxuICAgIE5hbWUsXG4gICAgU210cEVuY3J5cHRpb24sXG4gICAgQ29tcHJlc3Npb24sXG4gICAgSW1hZ2VHcmF2aXR5LFxuICAgIEltYWdlRm9ybWF0LFxuICAgIFBhc3N3b3JkSGFzaCxcbiAgICBNZXNzYWdpbmdQcm92aWRlclR5cGUsXG59O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(action-browser)/./node_modules/node-appwrite/index.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/node-appwrite/index.js":
/*!*********************************************!*\
  !*** ./node_modules/node-appwrite/index.js ***!
  \*********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("const Client = __webpack_require__(/*! ./lib/client.js */ \"(rsc)/./node_modules/node-appwrite/lib/client.js\");\nconst Query = __webpack_require__(/*! ./lib/query.js */ \"(rsc)/./node_modules/node-appwrite/lib/query.js\");\nconst Permission = __webpack_require__(/*! ./lib/permission.js */ \"(rsc)/./node_modules/node-appwrite/lib/permission.js\");\nconst Role = __webpack_require__(/*! ./lib/role.js */ \"(rsc)/./node_modules/node-appwrite/lib/role.js\");\nconst ID = __webpack_require__(/*! ./lib/id.js */ \"(rsc)/./node_modules/node-appwrite/lib/id.js\");\nconst InputFile = __webpack_require__(/*! ./lib/inputFile.js */ \"(rsc)/./node_modules/node-appwrite/lib/inputFile.js\");\nconst AppwriteException = __webpack_require__(/*! ./lib/exception.js */ \"(rsc)/./node_modules/node-appwrite/lib/exception.js\");\nconst Account = __webpack_require__(/*! ./lib/services/account.js */ \"(rsc)/./node_modules/node-appwrite/lib/services/account.js\");\nconst Avatars = __webpack_require__(/*! ./lib/services/avatars.js */ \"(rsc)/./node_modules/node-appwrite/lib/services/avatars.js\");\nconst Databases = __webpack_require__(/*! ./lib/services/databases.js */ \"(rsc)/./node_modules/node-appwrite/lib/services/databases.js\");\nconst Functions = __webpack_require__(/*! ./lib/services/functions.js */ \"(rsc)/./node_modules/node-appwrite/lib/services/functions.js\");\nconst Graphql = __webpack_require__(/*! ./lib/services/graphql.js */ \"(rsc)/./node_modules/node-appwrite/lib/services/graphql.js\");\nconst Health = __webpack_require__(/*! ./lib/services/health.js */ \"(rsc)/./node_modules/node-appwrite/lib/services/health.js\");\nconst Locale = __webpack_require__(/*! ./lib/services/locale.js */ \"(rsc)/./node_modules/node-appwrite/lib/services/locale.js\");\nconst Messaging = __webpack_require__(/*! ./lib/services/messaging.js */ \"(rsc)/./node_modules/node-appwrite/lib/services/messaging.js\");\nconst Storage = __webpack_require__(/*! ./lib/services/storage.js */ \"(rsc)/./node_modules/node-appwrite/lib/services/storage.js\");\nconst Teams = __webpack_require__(/*! ./lib/services/teams.js */ \"(rsc)/./node_modules/node-appwrite/lib/services/teams.js\");\nconst Users = __webpack_require__(/*! ./lib/services/users.js */ \"(rsc)/./node_modules/node-appwrite/lib/services/users.js\");\nconst AuthenticatorType = __webpack_require__(/*! ./lib/enums/authenticator-type.js */ \"(rsc)/./node_modules/node-appwrite/lib/enums/authenticator-type.js\");\nconst AuthenticationFactor = __webpack_require__(/*! ./lib/enums/authentication-factor.js */ \"(rsc)/./node_modules/node-appwrite/lib/enums/authentication-factor.js\");\nconst OAuthProvider = __webpack_require__(/*! ./lib/enums/o-auth-provider.js */ \"(rsc)/./node_modules/node-appwrite/lib/enums/o-auth-provider.js\");\nconst Browser = __webpack_require__(/*! ./lib/enums/browser.js */ \"(rsc)/./node_modules/node-appwrite/lib/enums/browser.js\");\nconst CreditCard = __webpack_require__(/*! ./lib/enums/credit-card.js */ \"(rsc)/./node_modules/node-appwrite/lib/enums/credit-card.js\");\nconst Flag = __webpack_require__(/*! ./lib/enums/flag.js */ \"(rsc)/./node_modules/node-appwrite/lib/enums/flag.js\");\nconst RelationshipType = __webpack_require__(/*! ./lib/enums/relationship-type.js */ \"(rsc)/./node_modules/node-appwrite/lib/enums/relationship-type.js\");\nconst RelationMutate = __webpack_require__(/*! ./lib/enums/relation-mutate.js */ \"(rsc)/./node_modules/node-appwrite/lib/enums/relation-mutate.js\");\nconst IndexType = __webpack_require__(/*! ./lib/enums/index-type.js */ \"(rsc)/./node_modules/node-appwrite/lib/enums/index-type.js\");\nconst Runtime = __webpack_require__(/*! ./lib/enums/runtime.js */ \"(rsc)/./node_modules/node-appwrite/lib/enums/runtime.js\");\nconst ExecutionMethod = __webpack_require__(/*! ./lib/enums/execution-method.js */ \"(rsc)/./node_modules/node-appwrite/lib/enums/execution-method.js\");\nconst Name = __webpack_require__(/*! ./lib/enums/name.js */ \"(rsc)/./node_modules/node-appwrite/lib/enums/name.js\");\nconst SmtpEncryption = __webpack_require__(/*! ./lib/enums/smtp-encryption.js */ \"(rsc)/./node_modules/node-appwrite/lib/enums/smtp-encryption.js\");\nconst Compression = __webpack_require__(/*! ./lib/enums/compression.js */ \"(rsc)/./node_modules/node-appwrite/lib/enums/compression.js\");\nconst ImageGravity = __webpack_require__(/*! ./lib/enums/image-gravity.js */ \"(rsc)/./node_modules/node-appwrite/lib/enums/image-gravity.js\");\nconst ImageFormat = __webpack_require__(/*! ./lib/enums/image-format.js */ \"(rsc)/./node_modules/node-appwrite/lib/enums/image-format.js\");\nconst PasswordHash = __webpack_require__(/*! ./lib/enums/password-hash.js */ \"(rsc)/./node_modules/node-appwrite/lib/enums/password-hash.js\");\nconst MessagingProviderType = __webpack_require__(/*! ./lib/enums/messaging-provider-type.js */ \"(rsc)/./node_modules/node-appwrite/lib/enums/messaging-provider-type.js\");\n\nmodule.exports = {\n    Client,\n    Query,\n    Permission,\n    Role,\n    ID,\n    InputFile,\n    AppwriteException,\n    Account,\n    Avatars,\n    Databases,\n    Functions,\n    Graphql,\n    Health,\n    Locale,\n    Messaging,\n    Storage,\n    Teams,\n    Users,\n    AuthenticatorType,\n    AuthenticationFactor,\n    OAuthProvider,\n    Browser,\n    CreditCard,\n    Flag,\n    RelationshipType,\n    RelationMutate,\n    IndexType,\n    Runtime,\n    ExecutionMethod,\n    Name,\n    SmtpEncryption,\n    Compression,\n    ImageGravity,\n    ImageFormat,\n    PasswordHash,\n    MessagingProviderType,\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvbm9kZS1hcHB3cml0ZS9pbmRleC5qcyIsIm1hcHBpbmdzIjoiQUFBQSxlQUFlLG1CQUFPLENBQUMseUVBQWlCO0FBQ3hDLGNBQWMsbUJBQU8sQ0FBQyx1RUFBZ0I7QUFDdEMsbUJBQW1CLG1CQUFPLENBQUMsaUZBQXFCO0FBQ2hELGFBQWEsbUJBQU8sQ0FBQyxxRUFBZTtBQUNwQyxXQUFXLG1CQUFPLENBQUMsaUVBQWE7QUFDaEMsa0JBQWtCLG1CQUFPLENBQUMsK0VBQW9CO0FBQzlDLDBCQUEwQixtQkFBTyxDQUFDLCtFQUFvQjtBQUN0RCxnQkFBZ0IsbUJBQU8sQ0FBQyw2RkFBMkI7QUFDbkQsZ0JBQWdCLG1CQUFPLENBQUMsNkZBQTJCO0FBQ25ELGtCQUFrQixtQkFBTyxDQUFDLGlHQUE2QjtBQUN2RCxrQkFBa0IsbUJBQU8sQ0FBQyxpR0FBNkI7QUFDdkQsZ0JBQWdCLG1CQUFPLENBQUMsNkZBQTJCO0FBQ25ELGVBQWUsbUJBQU8sQ0FBQywyRkFBMEI7QUFDakQsZUFBZSxtQkFBTyxDQUFDLDJGQUEwQjtBQUNqRCxrQkFBa0IsbUJBQU8sQ0FBQyxpR0FBNkI7QUFDdkQsZ0JBQWdCLG1CQUFPLENBQUMsNkZBQTJCO0FBQ25ELGNBQWMsbUJBQU8sQ0FBQyx5RkFBeUI7QUFDL0MsY0FBYyxtQkFBTyxDQUFDLHlGQUF5QjtBQUMvQywwQkFBMEIsbUJBQU8sQ0FBQyw2R0FBbUM7QUFDckUsNkJBQTZCLG1CQUFPLENBQUMsbUhBQXNDO0FBQzNFLHNCQUFzQixtQkFBTyxDQUFDLHVHQUFnQztBQUM5RCxnQkFBZ0IsbUJBQU8sQ0FBQyx1RkFBd0I7QUFDaEQsbUJBQW1CLG1CQUFPLENBQUMsK0ZBQTRCO0FBQ3ZELGFBQWEsbUJBQU8sQ0FBQyxpRkFBcUI7QUFDMUMseUJBQXlCLG1CQUFPLENBQUMsMkdBQWtDO0FBQ25FLHVCQUF1QixtQkFBTyxDQUFDLHVHQUFnQztBQUMvRCxrQkFBa0IsbUJBQU8sQ0FBQyw2RkFBMkI7QUFDckQsZ0JBQWdCLG1CQUFPLENBQUMsdUZBQXdCO0FBQ2hELHdCQUF3QixtQkFBTyxDQUFDLHlHQUFpQztBQUNqRSxhQUFhLG1CQUFPLENBQUMsaUZBQXFCO0FBQzFDLHVCQUF1QixtQkFBTyxDQUFDLHVHQUFnQztBQUMvRCxvQkFBb0IsbUJBQU8sQ0FBQywrRkFBNEI7QUFDeEQscUJBQXFCLG1CQUFPLENBQUMsbUdBQThCO0FBQzNELG9CQUFvQixtQkFBTyxDQUFDLGlHQUE2QjtBQUN6RCxxQkFBcUIsbUJBQU8sQ0FBQyxtR0FBOEI7QUFDM0QsOEJBQThCLG1CQUFPLENBQUMsdUhBQXdDOztBQUU5RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vanNtX2JhbmtpbmcvLi9ub2RlX21vZHVsZXMvbm9kZS1hcHB3cml0ZS9pbmRleC5qcz85ZjMzIl0sInNvdXJjZXNDb250ZW50IjpbImNvbnN0IENsaWVudCA9IHJlcXVpcmUoJy4vbGliL2NsaWVudC5qcycpO1xuY29uc3QgUXVlcnkgPSByZXF1aXJlKCcuL2xpYi9xdWVyeS5qcycpO1xuY29uc3QgUGVybWlzc2lvbiA9IHJlcXVpcmUoJy4vbGliL3Blcm1pc3Npb24uanMnKTtcbmNvbnN0IFJvbGUgPSByZXF1aXJlKCcuL2xpYi9yb2xlLmpzJyk7XG5jb25zdCBJRCA9IHJlcXVpcmUoJy4vbGliL2lkLmpzJyk7XG5jb25zdCBJbnB1dEZpbGUgPSByZXF1aXJlKCcuL2xpYi9pbnB1dEZpbGUuanMnKTtcbmNvbnN0IEFwcHdyaXRlRXhjZXB0aW9uID0gcmVxdWlyZSgnLi9saWIvZXhjZXB0aW9uLmpzJyk7XG5jb25zdCBBY2NvdW50ID0gcmVxdWlyZSgnLi9saWIvc2VydmljZXMvYWNjb3VudC5qcycpO1xuY29uc3QgQXZhdGFycyA9IHJlcXVpcmUoJy4vbGliL3NlcnZpY2VzL2F2YXRhcnMuanMnKTtcbmNvbnN0IERhdGFiYXNlcyA9IHJlcXVpcmUoJy4vbGliL3NlcnZpY2VzL2RhdGFiYXNlcy5qcycpO1xuY29uc3QgRnVuY3Rpb25zID0gcmVxdWlyZSgnLi9saWIvc2VydmljZXMvZnVuY3Rpb25zLmpzJyk7XG5jb25zdCBHcmFwaHFsID0gcmVxdWlyZSgnLi9saWIvc2VydmljZXMvZ3JhcGhxbC5qcycpO1xuY29uc3QgSGVhbHRoID0gcmVxdWlyZSgnLi9saWIvc2VydmljZXMvaGVhbHRoLmpzJyk7XG5jb25zdCBMb2NhbGUgPSByZXF1aXJlKCcuL2xpYi9zZXJ2aWNlcy9sb2NhbGUuanMnKTtcbmNvbnN0IE1lc3NhZ2luZyA9IHJlcXVpcmUoJy4vbGliL3NlcnZpY2VzL21lc3NhZ2luZy5qcycpO1xuY29uc3QgU3RvcmFnZSA9IHJlcXVpcmUoJy4vbGliL3NlcnZpY2VzL3N0b3JhZ2UuanMnKTtcbmNvbnN0IFRlYW1zID0gcmVxdWlyZSgnLi9saWIvc2VydmljZXMvdGVhbXMuanMnKTtcbmNvbnN0IFVzZXJzID0gcmVxdWlyZSgnLi9saWIvc2VydmljZXMvdXNlcnMuanMnKTtcbmNvbnN0IEF1dGhlbnRpY2F0b3JUeXBlID0gcmVxdWlyZShcIi4vbGliL2VudW1zL2F1dGhlbnRpY2F0b3ItdHlwZS5qc1wiKTtcbmNvbnN0IEF1dGhlbnRpY2F0aW9uRmFjdG9yID0gcmVxdWlyZShcIi4vbGliL2VudW1zL2F1dGhlbnRpY2F0aW9uLWZhY3Rvci5qc1wiKTtcbmNvbnN0IE9BdXRoUHJvdmlkZXIgPSByZXF1aXJlKFwiLi9saWIvZW51bXMvby1hdXRoLXByb3ZpZGVyLmpzXCIpO1xuY29uc3QgQnJvd3NlciA9IHJlcXVpcmUoXCIuL2xpYi9lbnVtcy9icm93c2VyLmpzXCIpO1xuY29uc3QgQ3JlZGl0Q2FyZCA9IHJlcXVpcmUoXCIuL2xpYi9lbnVtcy9jcmVkaXQtY2FyZC5qc1wiKTtcbmNvbnN0IEZsYWcgPSByZXF1aXJlKFwiLi9saWIvZW51bXMvZmxhZy5qc1wiKTtcbmNvbnN0IFJlbGF0aW9uc2hpcFR5cGUgPSByZXF1aXJlKFwiLi9saWIvZW51bXMvcmVsYXRpb25zaGlwLXR5cGUuanNcIik7XG5jb25zdCBSZWxhdGlvbk11dGF0ZSA9IHJlcXVpcmUoXCIuL2xpYi9lbnVtcy9yZWxhdGlvbi1tdXRhdGUuanNcIik7XG5jb25zdCBJbmRleFR5cGUgPSByZXF1aXJlKFwiLi9saWIvZW51bXMvaW5kZXgtdHlwZS5qc1wiKTtcbmNvbnN0IFJ1bnRpbWUgPSByZXF1aXJlKFwiLi9saWIvZW51bXMvcnVudGltZS5qc1wiKTtcbmNvbnN0IEV4ZWN1dGlvbk1ldGhvZCA9IHJlcXVpcmUoXCIuL2xpYi9lbnVtcy9leGVjdXRpb24tbWV0aG9kLmpzXCIpO1xuY29uc3QgTmFtZSA9IHJlcXVpcmUoXCIuL2xpYi9lbnVtcy9uYW1lLmpzXCIpO1xuY29uc3QgU210cEVuY3J5cHRpb24gPSByZXF1aXJlKFwiLi9saWIvZW51bXMvc210cC1lbmNyeXB0aW9uLmpzXCIpO1xuY29uc3QgQ29tcHJlc3Npb24gPSByZXF1aXJlKFwiLi9saWIvZW51bXMvY29tcHJlc3Npb24uanNcIik7XG5jb25zdCBJbWFnZUdyYXZpdHkgPSByZXF1aXJlKFwiLi9saWIvZW51bXMvaW1hZ2UtZ3Jhdml0eS5qc1wiKTtcbmNvbnN0IEltYWdlRm9ybWF0ID0gcmVxdWlyZShcIi4vbGliL2VudW1zL2ltYWdlLWZvcm1hdC5qc1wiKTtcbmNvbnN0IFBhc3N3b3JkSGFzaCA9IHJlcXVpcmUoXCIuL2xpYi9lbnVtcy9wYXNzd29yZC1oYXNoLmpzXCIpO1xuY29uc3QgTWVzc2FnaW5nUHJvdmlkZXJUeXBlID0gcmVxdWlyZShcIi4vbGliL2VudW1zL21lc3NhZ2luZy1wcm92aWRlci10eXBlLmpzXCIpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgICBDbGllbnQsXG4gICAgUXVlcnksXG4gICAgUGVybWlzc2lvbixcbiAgICBSb2xlLFxuICAgIElELFxuICAgIElucHV0RmlsZSxcbiAgICBBcHB3cml0ZUV4Y2VwdGlvbixcbiAgICBBY2NvdW50LFxuICAgIEF2YXRhcnMsXG4gICAgRGF0YWJhc2VzLFxuICAgIEZ1bmN0aW9ucyxcbiAgICBHcmFwaHFsLFxuICAgIEhlYWx0aCxcbiAgICBMb2NhbGUsXG4gICAgTWVzc2FnaW5nLFxuICAgIFN0b3JhZ2UsXG4gICAgVGVhbXMsXG4gICAgVXNlcnMsXG4gICAgQXV0aGVudGljYXRvclR5cGUsXG4gICAgQXV0aGVudGljYXRpb25GYWN0b3IsXG4gICAgT0F1dGhQcm92aWRlcixcbiAgICBCcm93c2VyLFxuICAgIENyZWRpdENhcmQsXG4gICAgRmxhZyxcbiAgICBSZWxhdGlvbnNoaXBUeXBlLFxuICAgIFJlbGF0aW9uTXV0YXRlLFxuICAgIEluZGV4VHlwZSxcbiAgICBSdW50aW1lLFxuICAgIEV4ZWN1dGlvbk1ldGhvZCxcbiAgICBOYW1lLFxuICAgIFNtdHBFbmNyeXB0aW9uLFxuICAgIENvbXByZXNzaW9uLFxuICAgIEltYWdlR3Jhdml0eSxcbiAgICBJbWFnZUZvcm1hdCxcbiAgICBQYXNzd29yZEhhc2gsXG4gICAgTWVzc2FnaW5nUHJvdmlkZXJUeXBlLFxufTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/node-appwrite/index.js\n");

/***/ }),

/***/ "(action-browser)/./node_modules/node-appwrite/lib/client.js":
/*!**************************************************!*\
  !*** ./node_modules/node-appwrite/lib/client.js ***!
  \**************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("const os = __webpack_require__(/*! os */ \"os\");\nconst URL = (__webpack_require__(/*! url */ \"url\").URL);\nconst Query = __webpack_require__(/*! ./query.js */ \"(action-browser)/./node_modules/node-appwrite/lib/query.js\");\nconst {fetch, FormData, Agent} = __webpack_require__(/*! undici */ \"undici\");\nconst AppwriteException = __webpack_require__(/*! ./exception.js */ \"(action-browser)/./node_modules/node-appwrite/lib/exception.js\");\n\nclass Client {\n    static CHUNK_SIZE = 5*1024*1024; // 5MB\n    \n    constructor() {\n        this.endpoint = 'https://cloud.appwrite.io/v1';\n        this.headers = {\n            'accept-encoding': '*',\n            'content-type': '',\n            'user-agent' : `AppwriteNodeJSSDK/12.0.1 (${os.type()}; ${os.version()}; ${os.arch()})`,\n            'x-sdk-name': 'Node.js',\n            'x-sdk-platform': 'server',\n            'x-sdk-language': 'nodejs',\n            'x-sdk-version': '12.0.1',\n            'X-Appwrite-Response-Format' : '1.5.0',\n        };\n        this.selfSigned = false;\n    }\n\n    /**\n     * Set Project\n     *\n     * Your project ID\n     *\n     * @param {string} project\n     *\n     * @return Client\n     */\n    setProject(project) {\n        this.addHeader('X-Appwrite-Project', project);\n\n        return this;\n    }\n\n    /**\n     * Set Key\n     *\n     * Your secret API key\n     *\n     * @param {string} key\n     *\n     * @return Client\n     */\n    setKey(key) {\n        this.addHeader('X-Appwrite-Key', key);\n\n        return this;\n    }\n\n    /**\n     * Set JWT\n     *\n     * Your secret JSON Web Token\n     *\n     * @param {string} jwt\n     *\n     * @return Client\n     */\n    setJWT(jwt) {\n        this.addHeader('X-Appwrite-JWT', jwt);\n\n        return this;\n    }\n\n    /**\n     * Set Locale\n     *\n     * @param {string} locale\n     *\n     * @return Client\n     */\n    setLocale(locale) {\n        this.addHeader('X-Appwrite-Locale', locale);\n\n        return this;\n    }\n\n    /**\n     * Set Session\n     *\n     * The user session to authenticate with\n     *\n     * @param {string} session\n     *\n     * @return Client\n     */\n    setSession(session) {\n        this.addHeader('X-Appwrite-Session', session);\n\n        return this;\n    }\n\n    /**\n     * Set ForwardedUserAgent\n     *\n     * The user agent string of the client that made the request\n     *\n     * @param {string} forwardeduseragent\n     *\n     * @return Client\n     */\n    setForwardedUserAgent(forwardeduseragent) {\n        this.addHeader('X-Forwarded-User-Agent', forwardeduseragent);\n\n        return this;\n    }\n\n    /**\n     * Set self signed.\n     *\n     * @param {bool} status\n     *\n     * @return this\n     */\n    setSelfSigned(status = true) {\n        this.selfSigned = status;\n\n        return this;\n    }\n\n    /**\n     * Set endpoint.\n     *\n     * @param {string} endpoint\n     *\n     * @return this\n     */\n    setEndpoint(endpoint)\n    {\n        this.endpoint = endpoint;\n\n        return this;\n    }\n\n    /**\n     * Sets a header for requests.\n     * \n     * @param {string} key\n     * @param {string} value\n     * \n     * @return this\n     */\n    addHeader(key, value) {\n        this.headers[key.toLowerCase()] = value;\n        \n        return this;\n    }\n      \n    async call(method, path = \"\", headers = {}, params = {}, responseType = \"json\") {\n        headers = {...this.headers, ...headers};\n        const url = new URL(this.endpoint + path);\n\n        let body = undefined;\n\n        if (method.toUpperCase() === \"GET\") {\n            url.search = new URLSearchParams(Client.flatten(params)).toString();\n        } else if (headers[\"content-type\"]?.toLowerCase().startsWith(\"multipart/form-data\")) {\n            delete headers[\"content-type\"];\n            const formData = new FormData();\n\n            const flatParams = Client.flatten(params);\n\n            for (const [key, value] of Object.entries(flatParams)) {\n                if (value && value.type && value.type === \"file\") {\n                    formData.append(key, value.file, value.filename);\n                } else {\n                    formData.append(key, value);\n                }\n            }\n\n            body = formData;\n        } else {\n            body = JSON.stringify(params);\n        }\n\n      let response = undefined;\n      try {\n        response = await fetch(url.toString(), {\n            method: method.toUpperCase(),\n            headers,\n            body,\n            redirect: responseType === \"location\" ? \"manual\" : \"follow\",\n            dispatcher: new Agent({\n                connect: {\n                    rejectUnauthorized: !this.selfSigned,\n                },\n            }),\n        });\n      } catch (error) {\n        throw new AppwriteException(error.message);\n      }\n\n      if (response.status >= 400) {\n        const text = await response.text();\n        let json = undefined;\n        try {\n            json = JSON.parse(text);\n        } catch (error) {\n            throw new AppwriteException(text, response.status, \"\", text);\n        }\n        throw new AppwriteException(json.message, json.code, json.type, json);\n      }\n\n      if (responseType === \"arraybuffer\") {\n        const data = await response.arrayBuffer();\n        return data;\n      }\n\n      if (responseType === \"location\") {\n        return response.headers.get(\"location\");\n      }\n\n      const text = await response.text();\n      let json = undefined;\n      try {\n          json = JSON.parse(text);\n      } catch (error) {\n          return text;\n      }\n      return json;\n    }\n\n    static flatten(data, prefix = \"\") {\n        let output = {};\n\n        for (const [key, value] of Object.entries(data)) {\n            let finalKey = prefix ? prefix + \"[\" + key + \"]\" : key;\n\n            if (Array.isArray(value)) {\n                output = { ...output, ...Client.flatten(value, finalKey) };\n            } else {\n                output[finalKey] = value;\n            }\n        }\n\n        return output;\n    }\n}\n\nmodule.exports = Client;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFjdGlvbi1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9ub2RlLWFwcHdyaXRlL2xpYi9jbGllbnQuanMiLCJtYXBwaW5ncyI6IkFBQUEsV0FBVyxtQkFBTyxDQUFDLGNBQUk7QUFDdkIsWUFBWSwyQ0FBa0I7QUFDOUIsY0FBYyxtQkFBTyxDQUFDLDhFQUFZO0FBQ2xDLE9BQU8sd0JBQXdCLEVBQUUsbUJBQU8sQ0FBQyxzQkFBUTtBQUNqRCwwQkFBMEIsbUJBQU8sQ0FBQyxzRkFBZ0I7O0FBRWxEO0FBQ0EscUNBQXFDO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdEQUF3RCxZQUFZLEVBQUUsZUFBZSxFQUFFLFVBQVU7QUFDakc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsTUFBTTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QixlQUFlLFFBQVE7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQThDLGFBQWE7QUFDM0QsbUJBQW1CO0FBQ25COztBQUVBOztBQUVBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBOztBQUVBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakIsYUFBYTtBQUNiLFNBQVM7QUFDVCxRQUFRO0FBQ1I7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSwyQkFBMkI7QUFDM0IsY0FBYztBQUNkO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9qc21fYmFua2luZy8uL25vZGVfbW9kdWxlcy9ub2RlLWFwcHdyaXRlL2xpYi9jbGllbnQuanM/Y2QzYSJdLCJzb3VyY2VzQ29udGVudCI6WyJjb25zdCBvcyA9IHJlcXVpcmUoJ29zJyk7XG5jb25zdCBVUkwgPSByZXF1aXJlKCd1cmwnKS5VUkw7XG5jb25zdCBRdWVyeSA9IHJlcXVpcmUoJy4vcXVlcnkuanMnKTtcbmNvbnN0IHtmZXRjaCwgRm9ybURhdGEsIEFnZW50fSA9IHJlcXVpcmUoJ3VuZGljaScpO1xuY29uc3QgQXBwd3JpdGVFeGNlcHRpb24gPSByZXF1aXJlKCcuL2V4Y2VwdGlvbi5qcycpO1xuXG5jbGFzcyBDbGllbnQge1xuICAgIHN0YXRpYyBDSFVOS19TSVpFID0gNSoxMDI0KjEwMjQ7IC8vIDVNQlxuICAgIFxuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICB0aGlzLmVuZHBvaW50ID0gJ2h0dHBzOi8vY2xvdWQuYXBwd3JpdGUuaW8vdjEnO1xuICAgICAgICB0aGlzLmhlYWRlcnMgPSB7XG4gICAgICAgICAgICAnYWNjZXB0LWVuY29kaW5nJzogJyonLFxuICAgICAgICAgICAgJ2NvbnRlbnQtdHlwZSc6ICcnLFxuICAgICAgICAgICAgJ3VzZXItYWdlbnQnIDogYEFwcHdyaXRlTm9kZUpTU0RLLzEyLjAuMSAoJHtvcy50eXBlKCl9OyAke29zLnZlcnNpb24oKX07ICR7b3MuYXJjaCgpfSlgLFxuICAgICAgICAgICAgJ3gtc2RrLW5hbWUnOiAnTm9kZS5qcycsXG4gICAgICAgICAgICAneC1zZGstcGxhdGZvcm0nOiAnc2VydmVyJyxcbiAgICAgICAgICAgICd4LXNkay1sYW5ndWFnZSc6ICdub2RlanMnLFxuICAgICAgICAgICAgJ3gtc2RrLXZlcnNpb24nOiAnMTIuMC4xJyxcbiAgICAgICAgICAgICdYLUFwcHdyaXRlLVJlc3BvbnNlLUZvcm1hdCcgOiAnMS41LjAnLFxuICAgICAgICB9O1xuICAgICAgICB0aGlzLnNlbGZTaWduZWQgPSBmYWxzZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBTZXQgUHJvamVjdFxuICAgICAqXG4gICAgICogWW91ciBwcm9qZWN0IElEXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gcHJvamVjdFxuICAgICAqXG4gICAgICogQHJldHVybiBDbGllbnRcbiAgICAgKi9cbiAgICBzZXRQcm9qZWN0KHByb2plY3QpIHtcbiAgICAgICAgdGhpcy5hZGRIZWFkZXIoJ1gtQXBwd3JpdGUtUHJvamVjdCcsIHByb2plY3QpO1xuXG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFNldCBLZXlcbiAgICAgKlxuICAgICAqIFlvdXIgc2VjcmV0IEFQSSBrZXlcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBrZXlcbiAgICAgKlxuICAgICAqIEByZXR1cm4gQ2xpZW50XG4gICAgICovXG4gICAgc2V0S2V5KGtleSkge1xuICAgICAgICB0aGlzLmFkZEhlYWRlcignWC1BcHB3cml0ZS1LZXknLCBrZXkpO1xuXG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFNldCBKV1RcbiAgICAgKlxuICAgICAqIFlvdXIgc2VjcmV0IEpTT04gV2ViIFRva2VuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gand0XG4gICAgICpcbiAgICAgKiBAcmV0dXJuIENsaWVudFxuICAgICAqL1xuICAgIHNldEpXVChqd3QpIHtcbiAgICAgICAgdGhpcy5hZGRIZWFkZXIoJ1gtQXBwd3JpdGUtSldUJywgand0KTtcblxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBTZXQgTG9jYWxlXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gbG9jYWxlXG4gICAgICpcbiAgICAgKiBAcmV0dXJuIENsaWVudFxuICAgICAqL1xuICAgIHNldExvY2FsZShsb2NhbGUpIHtcbiAgICAgICAgdGhpcy5hZGRIZWFkZXIoJ1gtQXBwd3JpdGUtTG9jYWxlJywgbG9jYWxlKTtcblxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBTZXQgU2Vzc2lvblxuICAgICAqXG4gICAgICogVGhlIHVzZXIgc2Vzc2lvbiB0byBhdXRoZW50aWNhdGUgd2l0aFxuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHNlc3Npb25cbiAgICAgKlxuICAgICAqIEByZXR1cm4gQ2xpZW50XG4gICAgICovXG4gICAgc2V0U2Vzc2lvbihzZXNzaW9uKSB7XG4gICAgICAgIHRoaXMuYWRkSGVhZGVyKCdYLUFwcHdyaXRlLVNlc3Npb24nLCBzZXNzaW9uKTtcblxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBTZXQgRm9yd2FyZGVkVXNlckFnZW50XG4gICAgICpcbiAgICAgKiBUaGUgdXNlciBhZ2VudCBzdHJpbmcgb2YgdGhlIGNsaWVudCB0aGF0IG1hZGUgdGhlIHJlcXVlc3RcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBmb3J3YXJkZWR1c2VyYWdlbnRcbiAgICAgKlxuICAgICAqIEByZXR1cm4gQ2xpZW50XG4gICAgICovXG4gICAgc2V0Rm9yd2FyZGVkVXNlckFnZW50KGZvcndhcmRlZHVzZXJhZ2VudCkge1xuICAgICAgICB0aGlzLmFkZEhlYWRlcignWC1Gb3J3YXJkZWQtVXNlci1BZ2VudCcsIGZvcndhcmRlZHVzZXJhZ2VudCk7XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogU2V0IHNlbGYgc2lnbmVkLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtib29sfSBzdGF0dXNcbiAgICAgKlxuICAgICAqIEByZXR1cm4gdGhpc1xuICAgICAqL1xuICAgIHNldFNlbGZTaWduZWQoc3RhdHVzID0gdHJ1ZSkge1xuICAgICAgICB0aGlzLnNlbGZTaWduZWQgPSBzdGF0dXM7XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogU2V0IGVuZHBvaW50LlxuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGVuZHBvaW50XG4gICAgICpcbiAgICAgKiBAcmV0dXJuIHRoaXNcbiAgICAgKi9cbiAgICBzZXRFbmRwb2ludChlbmRwb2ludClcbiAgICB7XG4gICAgICAgIHRoaXMuZW5kcG9pbnQgPSBlbmRwb2ludDtcblxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBTZXRzIGEgaGVhZGVyIGZvciByZXF1ZXN0cy5cbiAgICAgKiBcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30ga2V5XG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHZhbHVlXG4gICAgICogXG4gICAgICogQHJldHVybiB0aGlzXG4gICAgICovXG4gICAgYWRkSGVhZGVyKGtleSwgdmFsdWUpIHtcbiAgICAgICAgdGhpcy5oZWFkZXJzW2tleS50b0xvd2VyQ2FzZSgpXSA9IHZhbHVlO1xuICAgICAgICBcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgICAgXG4gICAgYXN5bmMgY2FsbChtZXRob2QsIHBhdGggPSBcIlwiLCBoZWFkZXJzID0ge30sIHBhcmFtcyA9IHt9LCByZXNwb25zZVR5cGUgPSBcImpzb25cIikge1xuICAgICAgICBoZWFkZXJzID0gey4uLnRoaXMuaGVhZGVycywgLi4uaGVhZGVyc307XG4gICAgICAgIGNvbnN0IHVybCA9IG5ldyBVUkwodGhpcy5lbmRwb2ludCArIHBhdGgpO1xuXG4gICAgICAgIGxldCBib2R5ID0gdW5kZWZpbmVkO1xuXG4gICAgICAgIGlmIChtZXRob2QudG9VcHBlckNhc2UoKSA9PT0gXCJHRVRcIikge1xuICAgICAgICAgICAgdXJsLnNlYXJjaCA9IG5ldyBVUkxTZWFyY2hQYXJhbXMoQ2xpZW50LmZsYXR0ZW4ocGFyYW1zKSkudG9TdHJpbmcoKTtcbiAgICAgICAgfSBlbHNlIGlmIChoZWFkZXJzW1wiY29udGVudC10eXBlXCJdPy50b0xvd2VyQ2FzZSgpLnN0YXJ0c1dpdGgoXCJtdWx0aXBhcnQvZm9ybS1kYXRhXCIpKSB7XG4gICAgICAgICAgICBkZWxldGUgaGVhZGVyc1tcImNvbnRlbnQtdHlwZVwiXTtcbiAgICAgICAgICAgIGNvbnN0IGZvcm1EYXRhID0gbmV3IEZvcm1EYXRhKCk7XG5cbiAgICAgICAgICAgIGNvbnN0IGZsYXRQYXJhbXMgPSBDbGllbnQuZmxhdHRlbihwYXJhbXMpO1xuXG4gICAgICAgICAgICBmb3IgKGNvbnN0IFtrZXksIHZhbHVlXSBvZiBPYmplY3QuZW50cmllcyhmbGF0UGFyYW1zKSkge1xuICAgICAgICAgICAgICAgIGlmICh2YWx1ZSAmJiB2YWx1ZS50eXBlICYmIHZhbHVlLnR5cGUgPT09IFwiZmlsZVwiKSB7XG4gICAgICAgICAgICAgICAgICAgIGZvcm1EYXRhLmFwcGVuZChrZXksIHZhbHVlLmZpbGUsIHZhbHVlLmZpbGVuYW1lKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBmb3JtRGF0YS5hcHBlbmQoa2V5LCB2YWx1ZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBib2R5ID0gZm9ybURhdGE7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBib2R5ID0gSlNPTi5zdHJpbmdpZnkocGFyYW1zKTtcbiAgICAgICAgfVxuXG4gICAgICBsZXQgcmVzcG9uc2UgPSB1bmRlZmluZWQ7XG4gICAgICB0cnkge1xuICAgICAgICByZXNwb25zZSA9IGF3YWl0IGZldGNoKHVybC50b1N0cmluZygpLCB7XG4gICAgICAgICAgICBtZXRob2Q6IG1ldGhvZC50b1VwcGVyQ2FzZSgpLFxuICAgICAgICAgICAgaGVhZGVycyxcbiAgICAgICAgICAgIGJvZHksXG4gICAgICAgICAgICByZWRpcmVjdDogcmVzcG9uc2VUeXBlID09PSBcImxvY2F0aW9uXCIgPyBcIm1hbnVhbFwiIDogXCJmb2xsb3dcIixcbiAgICAgICAgICAgIGRpc3BhdGNoZXI6IG5ldyBBZ2VudCh7XG4gICAgICAgICAgICAgICAgY29ubmVjdDoge1xuICAgICAgICAgICAgICAgICAgICByZWplY3RVbmF1dGhvcml6ZWQ6ICF0aGlzLnNlbGZTaWduZWQsXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIH0pLFxuICAgICAgICB9KTtcbiAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIHRocm93IG5ldyBBcHB3cml0ZUV4Y2VwdGlvbihlcnJvci5tZXNzYWdlKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHJlc3BvbnNlLnN0YXR1cyA+PSA0MDApIHtcbiAgICAgICAgY29uc3QgdGV4dCA9IGF3YWl0IHJlc3BvbnNlLnRleHQoKTtcbiAgICAgICAgbGV0IGpzb24gPSB1bmRlZmluZWQ7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBqc29uID0gSlNPTi5wYXJzZSh0ZXh0KTtcbiAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBBcHB3cml0ZUV4Y2VwdGlvbih0ZXh0LCByZXNwb25zZS5zdGF0dXMsIFwiXCIsIHRleHQpO1xuICAgICAgICB9XG4gICAgICAgIHRocm93IG5ldyBBcHB3cml0ZUV4Y2VwdGlvbihqc29uLm1lc3NhZ2UsIGpzb24uY29kZSwganNvbi50eXBlLCBqc29uKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHJlc3BvbnNlVHlwZSA9PT0gXCJhcnJheWJ1ZmZlclwiKSB7XG4gICAgICAgIGNvbnN0IGRhdGEgPSBhd2FpdCByZXNwb25zZS5hcnJheUJ1ZmZlcigpO1xuICAgICAgICByZXR1cm4gZGF0YTtcbiAgICAgIH1cblxuICAgICAgaWYgKHJlc3BvbnNlVHlwZSA9PT0gXCJsb2NhdGlvblwiKSB7XG4gICAgICAgIHJldHVybiByZXNwb25zZS5oZWFkZXJzLmdldChcImxvY2F0aW9uXCIpO1xuICAgICAgfVxuXG4gICAgICBjb25zdCB0ZXh0ID0gYXdhaXQgcmVzcG9uc2UudGV4dCgpO1xuICAgICAgbGV0IGpzb24gPSB1bmRlZmluZWQ7XG4gICAgICB0cnkge1xuICAgICAgICAgIGpzb24gPSBKU09OLnBhcnNlKHRleHQpO1xuICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICByZXR1cm4gdGV4dDtcbiAgICAgIH1cbiAgICAgIHJldHVybiBqc29uO1xuICAgIH1cblxuICAgIHN0YXRpYyBmbGF0dGVuKGRhdGEsIHByZWZpeCA9IFwiXCIpIHtcbiAgICAgICAgbGV0IG91dHB1dCA9IHt9O1xuXG4gICAgICAgIGZvciAoY29uc3QgW2tleSwgdmFsdWVdIG9mIE9iamVjdC5lbnRyaWVzKGRhdGEpKSB7XG4gICAgICAgICAgICBsZXQgZmluYWxLZXkgPSBwcmVmaXggPyBwcmVmaXggKyBcIltcIiArIGtleSArIFwiXVwiIDoga2V5O1xuXG4gICAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAgICAgICAgICAgICBvdXRwdXQgPSB7IC4uLm91dHB1dCwgLi4uQ2xpZW50LmZsYXR0ZW4odmFsdWUsIGZpbmFsS2V5KSB9O1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBvdXRwdXRbZmluYWxLZXldID0gdmFsdWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gb3V0cHV0O1xuICAgIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBDbGllbnQ7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(action-browser)/./node_modules/node-appwrite/lib/client.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/node-appwrite/lib/client.js":
/*!**************************************************!*\
  !*** ./node_modules/node-appwrite/lib/client.js ***!
  \**************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("const os = __webpack_require__(/*! os */ \"os\");\nconst URL = (__webpack_require__(/*! url */ \"url\").URL);\nconst Query = __webpack_require__(/*! ./query.js */ \"(rsc)/./node_modules/node-appwrite/lib/query.js\");\nconst {fetch, FormData, Agent} = __webpack_require__(/*! undici */ \"undici\");\nconst AppwriteException = __webpack_require__(/*! ./exception.js */ \"(rsc)/./node_modules/node-appwrite/lib/exception.js\");\n\nclass Client {\n    static CHUNK_SIZE = 5*1024*1024; // 5MB\n    \n    constructor() {\n        this.endpoint = 'https://cloud.appwrite.io/v1';\n        this.headers = {\n            'accept-encoding': '*',\n            'content-type': '',\n            'user-agent' : `AppwriteNodeJSSDK/12.0.1 (${os.type()}; ${os.version()}; ${os.arch()})`,\n            'x-sdk-name': 'Node.js',\n            'x-sdk-platform': 'server',\n            'x-sdk-language': 'nodejs',\n            'x-sdk-version': '12.0.1',\n            'X-Appwrite-Response-Format' : '1.5.0',\n        };\n        this.selfSigned = false;\n    }\n\n    /**\n     * Set Project\n     *\n     * Your project ID\n     *\n     * @param {string} project\n     *\n     * @return Client\n     */\n    setProject(project) {\n        this.addHeader('X-Appwrite-Project', project);\n\n        return this;\n    }\n\n    /**\n     * Set Key\n     *\n     * Your secret API key\n     *\n     * @param {string} key\n     *\n     * @return Client\n     */\n    setKey(key) {\n        this.addHeader('X-Appwrite-Key', key);\n\n        return this;\n    }\n\n    /**\n     * Set JWT\n     *\n     * Your secret JSON Web Token\n     *\n     * @param {string} jwt\n     *\n     * @return Client\n     */\n    setJWT(jwt) {\n        this.addHeader('X-Appwrite-JWT', jwt);\n\n        return this;\n    }\n\n    /**\n     * Set Locale\n     *\n     * @param {string} locale\n     *\n     * @return Client\n     */\n    setLocale(locale) {\n        this.addHeader('X-Appwrite-Locale', locale);\n\n        return this;\n    }\n\n    /**\n     * Set Session\n     *\n     * The user session to authenticate with\n     *\n     * @param {string} session\n     *\n     * @return Client\n     */\n    setSession(session) {\n        this.addHeader('X-Appwrite-Session', session);\n\n        return this;\n    }\n\n    /**\n     * Set ForwardedUserAgent\n     *\n     * The user agent string of the client that made the request\n     *\n     * @param {string} forwardeduseragent\n     *\n     * @return Client\n     */\n    setForwardedUserAgent(forwardeduseragent) {\n        this.addHeader('X-Forwarded-User-Agent', forwardeduseragent);\n\n        return this;\n    }\n\n    /**\n     * Set self signed.\n     *\n     * @param {bool} status\n     *\n     * @return this\n     */\n    setSelfSigned(status = true) {\n        this.selfSigned = status;\n\n        return this;\n    }\n\n    /**\n     * Set endpoint.\n     *\n     * @param {string} endpoint\n     *\n     * @return this\n     */\n    setEndpoint(endpoint)\n    {\n        this.endpoint = endpoint;\n\n        return this;\n    }\n\n    /**\n     * Sets a header for requests.\n     * \n     * @param {string} key\n     * @param {string} value\n     * \n     * @return this\n     */\n    addHeader(key, value) {\n        this.headers[key.toLowerCase()] = value;\n        \n        return this;\n    }\n      \n    async call(method, path = \"\", headers = {}, params = {}, responseType = \"json\") {\n        headers = {...this.headers, ...headers};\n        const url = new URL(this.endpoint + path);\n\n        let body = undefined;\n\n        if (method.toUpperCase() === \"GET\") {\n            url.search = new URLSearchParams(Client.flatten(params)).toString();\n        } else if (headers[\"content-type\"]?.toLowerCase().startsWith(\"multipart/form-data\")) {\n            delete headers[\"content-type\"];\n            const formData = new FormData();\n\n            const flatParams = Client.flatten(params);\n\n            for (const [key, value] of Object.entries(flatParams)) {\n                if (value && value.type && value.type === \"file\") {\n                    formData.append(key, value.file, value.filename);\n                } else {\n                    formData.append(key, value);\n                }\n            }\n\n            body = formData;\n        } else {\n            body = JSON.stringify(params);\n        }\n\n      let response = undefined;\n      try {\n        response = await fetch(url.toString(), {\n            method: method.toUpperCase(),\n            headers,\n            body,\n            redirect: responseType === \"location\" ? \"manual\" : \"follow\",\n            dispatcher: new Agent({\n                connect: {\n                    rejectUnauthorized: !this.selfSigned,\n                },\n            }),\n        });\n      } catch (error) {\n        throw new AppwriteException(error.message);\n      }\n\n      if (response.status >= 400) {\n        const text = await response.text();\n        let json = undefined;\n        try {\n            json = JSON.parse(text);\n        } catch (error) {\n            throw new AppwriteException(text, response.status, \"\", text);\n        }\n        throw new AppwriteException(json.message, json.code, json.type, json);\n      }\n\n      if (responseType === \"arraybuffer\") {\n        const data = await response.arrayBuffer();\n        return data;\n      }\n\n      if (responseType === \"location\") {\n        return response.headers.get(\"location\");\n      }\n\n      const text = await response.text();\n      let json = undefined;\n      try {\n          json = JSON.parse(text);\n      } catch (error) {\n          return text;\n      }\n      return json;\n    }\n\n    static flatten(data, prefix = \"\") {\n        let output = {};\n\n        for (const [key, value] of Object.entries(data)) {\n            let finalKey = prefix ? prefix + \"[\" + key + \"]\" : key;\n\n            if (Array.isArray(value)) {\n                output = { ...output, ...Client.flatten(value, finalKey) };\n            } else {\n                output[finalKey] = value;\n            }\n        }\n\n        return output;\n    }\n}\n\nmodule.exports = Client;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvbm9kZS1hcHB3cml0ZS9saWIvY2xpZW50LmpzIiwibWFwcGluZ3MiOiJBQUFBLFdBQVcsbUJBQU8sQ0FBQyxjQUFJO0FBQ3ZCLFlBQVksMkNBQWtCO0FBQzlCLGNBQWMsbUJBQU8sQ0FBQyxtRUFBWTtBQUNsQyxPQUFPLHdCQUF3QixFQUFFLG1CQUFPLENBQUMsc0JBQVE7QUFDakQsMEJBQTBCLG1CQUFPLENBQUMsMkVBQWdCOztBQUVsRDtBQUNBLHFDQUFxQztBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3REFBd0QsWUFBWSxFQUFFLGVBQWUsRUFBRSxVQUFVO0FBQ2pHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLE1BQU07QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkIsZUFBZSxRQUFRO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE4QyxhQUFhO0FBQzNELG1CQUFtQjtBQUNuQjs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFVBQVU7QUFDVjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCLGFBQWE7QUFDYixTQUFTO0FBQ1QsUUFBUTtBQUNSO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsMkJBQTJCO0FBQzNCLGNBQWM7QUFDZDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vanNtX2JhbmtpbmcvLi9ub2RlX21vZHVsZXMvbm9kZS1hcHB3cml0ZS9saWIvY2xpZW50LmpzPzIzZmIiXSwic291cmNlc0NvbnRlbnQiOlsiY29uc3Qgb3MgPSByZXF1aXJlKCdvcycpO1xuY29uc3QgVVJMID0gcmVxdWlyZSgndXJsJykuVVJMO1xuY29uc3QgUXVlcnkgPSByZXF1aXJlKCcuL3F1ZXJ5LmpzJyk7XG5jb25zdCB7ZmV0Y2gsIEZvcm1EYXRhLCBBZ2VudH0gPSByZXF1aXJlKCd1bmRpY2knKTtcbmNvbnN0IEFwcHdyaXRlRXhjZXB0aW9uID0gcmVxdWlyZSgnLi9leGNlcHRpb24uanMnKTtcblxuY2xhc3MgQ2xpZW50IHtcbiAgICBzdGF0aWMgQ0hVTktfU0laRSA9IDUqMTAyNCoxMDI0OyAvLyA1TUJcbiAgICBcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgdGhpcy5lbmRwb2ludCA9ICdodHRwczovL2Nsb3VkLmFwcHdyaXRlLmlvL3YxJztcbiAgICAgICAgdGhpcy5oZWFkZXJzID0ge1xuICAgICAgICAgICAgJ2FjY2VwdC1lbmNvZGluZyc6ICcqJyxcbiAgICAgICAgICAgICdjb250ZW50LXR5cGUnOiAnJyxcbiAgICAgICAgICAgICd1c2VyLWFnZW50JyA6IGBBcHB3cml0ZU5vZGVKU1NESy8xMi4wLjEgKCR7b3MudHlwZSgpfTsgJHtvcy52ZXJzaW9uKCl9OyAke29zLmFyY2goKX0pYCxcbiAgICAgICAgICAgICd4LXNkay1uYW1lJzogJ05vZGUuanMnLFxuICAgICAgICAgICAgJ3gtc2RrLXBsYXRmb3JtJzogJ3NlcnZlcicsXG4gICAgICAgICAgICAneC1zZGstbGFuZ3VhZ2UnOiAnbm9kZWpzJyxcbiAgICAgICAgICAgICd4LXNkay12ZXJzaW9uJzogJzEyLjAuMScsXG4gICAgICAgICAgICAnWC1BcHB3cml0ZS1SZXNwb25zZS1Gb3JtYXQnIDogJzEuNS4wJyxcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5zZWxmU2lnbmVkID0gZmFsc2U7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogU2V0IFByb2plY3RcbiAgICAgKlxuICAgICAqIFlvdXIgcHJvamVjdCBJRFxuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHByb2plY3RcbiAgICAgKlxuICAgICAqIEByZXR1cm4gQ2xpZW50XG4gICAgICovXG4gICAgc2V0UHJvamVjdChwcm9qZWN0KSB7XG4gICAgICAgIHRoaXMuYWRkSGVhZGVyKCdYLUFwcHdyaXRlLVByb2plY3QnLCBwcm9qZWN0KTtcblxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBTZXQgS2V5XG4gICAgICpcbiAgICAgKiBZb3VyIHNlY3JldCBBUEkga2V5XG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30ga2V5XG4gICAgICpcbiAgICAgKiBAcmV0dXJuIENsaWVudFxuICAgICAqL1xuICAgIHNldEtleShrZXkpIHtcbiAgICAgICAgdGhpcy5hZGRIZWFkZXIoJ1gtQXBwd3JpdGUtS2V5Jywga2V5KTtcblxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBTZXQgSldUXG4gICAgICpcbiAgICAgKiBZb3VyIHNlY3JldCBKU09OIFdlYiBUb2tlblxuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGp3dFxuICAgICAqXG4gICAgICogQHJldHVybiBDbGllbnRcbiAgICAgKi9cbiAgICBzZXRKV1Qoand0KSB7XG4gICAgICAgIHRoaXMuYWRkSGVhZGVyKCdYLUFwcHdyaXRlLUpXVCcsIGp3dCk7XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogU2V0IExvY2FsZVxuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGxvY2FsZVxuICAgICAqXG4gICAgICogQHJldHVybiBDbGllbnRcbiAgICAgKi9cbiAgICBzZXRMb2NhbGUobG9jYWxlKSB7XG4gICAgICAgIHRoaXMuYWRkSGVhZGVyKCdYLUFwcHdyaXRlLUxvY2FsZScsIGxvY2FsZSk7XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogU2V0IFNlc3Npb25cbiAgICAgKlxuICAgICAqIFRoZSB1c2VyIHNlc3Npb24gdG8gYXV0aGVudGljYXRlIHdpdGhcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBzZXNzaW9uXG4gICAgICpcbiAgICAgKiBAcmV0dXJuIENsaWVudFxuICAgICAqL1xuICAgIHNldFNlc3Npb24oc2Vzc2lvbikge1xuICAgICAgICB0aGlzLmFkZEhlYWRlcignWC1BcHB3cml0ZS1TZXNzaW9uJywgc2Vzc2lvbik7XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogU2V0IEZvcndhcmRlZFVzZXJBZ2VudFxuICAgICAqXG4gICAgICogVGhlIHVzZXIgYWdlbnQgc3RyaW5nIG9mIHRoZSBjbGllbnQgdGhhdCBtYWRlIHRoZSByZXF1ZXN0XG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gZm9yd2FyZGVkdXNlcmFnZW50XG4gICAgICpcbiAgICAgKiBAcmV0dXJuIENsaWVudFxuICAgICAqL1xuICAgIHNldEZvcndhcmRlZFVzZXJBZ2VudChmb3J3YXJkZWR1c2VyYWdlbnQpIHtcbiAgICAgICAgdGhpcy5hZGRIZWFkZXIoJ1gtRm9yd2FyZGVkLVVzZXItQWdlbnQnLCBmb3J3YXJkZWR1c2VyYWdlbnQpO1xuXG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFNldCBzZWxmIHNpZ25lZC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7Ym9vbH0gc3RhdHVzXG4gICAgICpcbiAgICAgKiBAcmV0dXJuIHRoaXNcbiAgICAgKi9cbiAgICBzZXRTZWxmU2lnbmVkKHN0YXR1cyA9IHRydWUpIHtcbiAgICAgICAgdGhpcy5zZWxmU2lnbmVkID0gc3RhdHVzO1xuXG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFNldCBlbmRwb2ludC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBlbmRwb2ludFxuICAgICAqXG4gICAgICogQHJldHVybiB0aGlzXG4gICAgICovXG4gICAgc2V0RW5kcG9pbnQoZW5kcG9pbnQpXG4gICAge1xuICAgICAgICB0aGlzLmVuZHBvaW50ID0gZW5kcG9pbnQ7XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogU2V0cyBhIGhlYWRlciBmb3IgcmVxdWVzdHMuXG4gICAgICogXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGtleVxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSB2YWx1ZVxuICAgICAqIFxuICAgICAqIEByZXR1cm4gdGhpc1xuICAgICAqL1xuICAgIGFkZEhlYWRlcihrZXksIHZhbHVlKSB7XG4gICAgICAgIHRoaXMuaGVhZGVyc1trZXkudG9Mb3dlckNhc2UoKV0gPSB2YWx1ZTtcbiAgICAgICAgXG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICAgIFxuICAgIGFzeW5jIGNhbGwobWV0aG9kLCBwYXRoID0gXCJcIiwgaGVhZGVycyA9IHt9LCBwYXJhbXMgPSB7fSwgcmVzcG9uc2VUeXBlID0gXCJqc29uXCIpIHtcbiAgICAgICAgaGVhZGVycyA9IHsuLi50aGlzLmhlYWRlcnMsIC4uLmhlYWRlcnN9O1xuICAgICAgICBjb25zdCB1cmwgPSBuZXcgVVJMKHRoaXMuZW5kcG9pbnQgKyBwYXRoKTtcblxuICAgICAgICBsZXQgYm9keSA9IHVuZGVmaW5lZDtcblxuICAgICAgICBpZiAobWV0aG9kLnRvVXBwZXJDYXNlKCkgPT09IFwiR0VUXCIpIHtcbiAgICAgICAgICAgIHVybC5zZWFyY2ggPSBuZXcgVVJMU2VhcmNoUGFyYW1zKENsaWVudC5mbGF0dGVuKHBhcmFtcykpLnRvU3RyaW5nKCk7XG4gICAgICAgIH0gZWxzZSBpZiAoaGVhZGVyc1tcImNvbnRlbnQtdHlwZVwiXT8udG9Mb3dlckNhc2UoKS5zdGFydHNXaXRoKFwibXVsdGlwYXJ0L2Zvcm0tZGF0YVwiKSkge1xuICAgICAgICAgICAgZGVsZXRlIGhlYWRlcnNbXCJjb250ZW50LXR5cGVcIl07XG4gICAgICAgICAgICBjb25zdCBmb3JtRGF0YSA9IG5ldyBGb3JtRGF0YSgpO1xuXG4gICAgICAgICAgICBjb25zdCBmbGF0UGFyYW1zID0gQ2xpZW50LmZsYXR0ZW4ocGFyYW1zKTtcblxuICAgICAgICAgICAgZm9yIChjb25zdCBba2V5LCB2YWx1ZV0gb2YgT2JqZWN0LmVudHJpZXMoZmxhdFBhcmFtcykpIHtcbiAgICAgICAgICAgICAgICBpZiAodmFsdWUgJiYgdmFsdWUudHlwZSAmJiB2YWx1ZS50eXBlID09PSBcImZpbGVcIikge1xuICAgICAgICAgICAgICAgICAgICBmb3JtRGF0YS5hcHBlbmQoa2V5LCB2YWx1ZS5maWxlLCB2YWx1ZS5maWxlbmFtZSk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgZm9ybURhdGEuYXBwZW5kKGtleSwgdmFsdWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgYm9keSA9IGZvcm1EYXRhO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgYm9keSA9IEpTT04uc3RyaW5naWZ5KHBhcmFtcyk7XG4gICAgICAgIH1cblxuICAgICAgbGV0IHJlc3BvbnNlID0gdW5kZWZpbmVkO1xuICAgICAgdHJ5IHtcbiAgICAgICAgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaCh1cmwudG9TdHJpbmcoKSwge1xuICAgICAgICAgICAgbWV0aG9kOiBtZXRob2QudG9VcHBlckNhc2UoKSxcbiAgICAgICAgICAgIGhlYWRlcnMsXG4gICAgICAgICAgICBib2R5LFxuICAgICAgICAgICAgcmVkaXJlY3Q6IHJlc3BvbnNlVHlwZSA9PT0gXCJsb2NhdGlvblwiID8gXCJtYW51YWxcIiA6IFwiZm9sbG93XCIsXG4gICAgICAgICAgICBkaXNwYXRjaGVyOiBuZXcgQWdlbnQoe1xuICAgICAgICAgICAgICAgIGNvbm5lY3Q6IHtcbiAgICAgICAgICAgICAgICAgICAgcmVqZWN0VW5hdXRob3JpemVkOiAhdGhpcy5zZWxmU2lnbmVkLFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB9KSxcbiAgICAgICAgfSk7XG4gICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICB0aHJvdyBuZXcgQXBwd3JpdGVFeGNlcHRpb24oZXJyb3IubWVzc2FnZSk7XG4gICAgICB9XG5cbiAgICAgIGlmIChyZXNwb25zZS5zdGF0dXMgPj0gNDAwKSB7XG4gICAgICAgIGNvbnN0IHRleHQgPSBhd2FpdCByZXNwb25zZS50ZXh0KCk7XG4gICAgICAgIGxldCBqc29uID0gdW5kZWZpbmVkO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAganNvbiA9IEpTT04ucGFyc2UodGV4dCk7XG4gICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgQXBwd3JpdGVFeGNlcHRpb24odGV4dCwgcmVzcG9uc2Uuc3RhdHVzLCBcIlwiLCB0ZXh0KTtcbiAgICAgICAgfVxuICAgICAgICB0aHJvdyBuZXcgQXBwd3JpdGVFeGNlcHRpb24oanNvbi5tZXNzYWdlLCBqc29uLmNvZGUsIGpzb24udHlwZSwganNvbik7XG4gICAgICB9XG5cbiAgICAgIGlmIChyZXNwb25zZVR5cGUgPT09IFwiYXJyYXlidWZmZXJcIikge1xuICAgICAgICBjb25zdCBkYXRhID0gYXdhaXQgcmVzcG9uc2UuYXJyYXlCdWZmZXIoKTtcbiAgICAgICAgcmV0dXJuIGRhdGE7XG4gICAgICB9XG5cbiAgICAgIGlmIChyZXNwb25zZVR5cGUgPT09IFwibG9jYXRpb25cIikge1xuICAgICAgICByZXR1cm4gcmVzcG9uc2UuaGVhZGVycy5nZXQoXCJsb2NhdGlvblwiKTtcbiAgICAgIH1cblxuICAgICAgY29uc3QgdGV4dCA9IGF3YWl0IHJlc3BvbnNlLnRleHQoKTtcbiAgICAgIGxldCBqc29uID0gdW5kZWZpbmVkO1xuICAgICAgdHJ5IHtcbiAgICAgICAgICBqc29uID0gSlNPTi5wYXJzZSh0ZXh0KTtcbiAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgcmV0dXJuIHRleHQ7XG4gICAgICB9XG4gICAgICByZXR1cm4ganNvbjtcbiAgICB9XG5cbiAgICBzdGF0aWMgZmxhdHRlbihkYXRhLCBwcmVmaXggPSBcIlwiKSB7XG4gICAgICAgIGxldCBvdXRwdXQgPSB7fTtcblxuICAgICAgICBmb3IgKGNvbnN0IFtrZXksIHZhbHVlXSBvZiBPYmplY3QuZW50cmllcyhkYXRhKSkge1xuICAgICAgICAgICAgbGV0IGZpbmFsS2V5ID0gcHJlZml4ID8gcHJlZml4ICsgXCJbXCIgKyBrZXkgKyBcIl1cIiA6IGtleTtcblxuICAgICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgb3V0cHV0ID0geyAuLi5vdXRwdXQsIC4uLkNsaWVudC5mbGF0dGVuKHZhbHVlLCBmaW5hbEtleSkgfTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgb3V0cHV0W2ZpbmFsS2V5XSA9IHZhbHVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIG91dHB1dDtcbiAgICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gQ2xpZW50O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/node-appwrite/lib/client.js\n");

/***/ }),

/***/ "(action-browser)/./node_modules/node-appwrite/lib/enums/authentication-factor.js":
/*!***********************************************************************!*\
  !*** ./node_modules/node-appwrite/lib/enums/authentication-factor.js ***!
  \***********************************************************************/
/***/ ((module) => {

eval("const AuthenticationFactor = Object.freeze({\n    Email: 'email' ,\n    Phone: 'phone' ,\n    Totp: 'totp' ,\n    Recoverycode: 'recoverycode' \n});\n\nmodule.exports = AuthenticationFactor;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFjdGlvbi1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9ub2RlLWFwcHdyaXRlL2xpYi9lbnVtcy9hdXRoZW50aWNhdGlvbi1mYWN0b3IuanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9qc21fYmFua2luZy8uL25vZGVfbW9kdWxlcy9ub2RlLWFwcHdyaXRlL2xpYi9lbnVtcy9hdXRoZW50aWNhdGlvbi1mYWN0b3IuanM/NjFmZCJdLCJzb3VyY2VzQ29udGVudCI6WyJjb25zdCBBdXRoZW50aWNhdGlvbkZhY3RvciA9IE9iamVjdC5mcmVlemUoe1xuICAgIEVtYWlsOiAnZW1haWwnICxcbiAgICBQaG9uZTogJ3Bob25lJyAsXG4gICAgVG90cDogJ3RvdHAnICxcbiAgICBSZWNvdmVyeWNvZGU6ICdyZWNvdmVyeWNvZGUnIFxufSk7XG5cbm1vZHVsZS5leHBvcnRzID0gQXV0aGVudGljYXRpb25GYWN0b3I7Il0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(action-browser)/./node_modules/node-appwrite/lib/enums/authentication-factor.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/node-appwrite/lib/enums/authentication-factor.js":
/*!***********************************************************************!*\
  !*** ./node_modules/node-appwrite/lib/enums/authentication-factor.js ***!
  \***********************************************************************/
/***/ ((module) => {

eval("const AuthenticationFactor = Object.freeze({\n    Email: 'email' ,\n    Phone: 'phone' ,\n    Totp: 'totp' ,\n    Recoverycode: 'recoverycode' \n});\n\nmodule.exports = AuthenticationFactor;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvbm9kZS1hcHB3cml0ZS9saWIvZW51bXMvYXV0aGVudGljYXRpb24tZmFjdG9yLmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vanNtX2JhbmtpbmcvLi9ub2RlX21vZHVsZXMvbm9kZS1hcHB3cml0ZS9saWIvZW51bXMvYXV0aGVudGljYXRpb24tZmFjdG9yLmpzP2YwNTMiXSwic291cmNlc0NvbnRlbnQiOlsiY29uc3QgQXV0aGVudGljYXRpb25GYWN0b3IgPSBPYmplY3QuZnJlZXplKHtcbiAgICBFbWFpbDogJ2VtYWlsJyAsXG4gICAgUGhvbmU6ICdwaG9uZScgLFxuICAgIFRvdHA6ICd0b3RwJyAsXG4gICAgUmVjb3Zlcnljb2RlOiAncmVjb3Zlcnljb2RlJyBcbn0pO1xuXG5tb2R1bGUuZXhwb3J0cyA9IEF1dGhlbnRpY2F0aW9uRmFjdG9yOyJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/node-appwrite/lib/enums/authentication-factor.js\n");

/***/ }),

/***/ "(action-browser)/./node_modules/node-appwrite/lib/enums/authenticator-type.js":
/*!********************************************************************!*\
  !*** ./node_modules/node-appwrite/lib/enums/authenticator-type.js ***!
  \********************************************************************/
/***/ ((module) => {

eval("const AuthenticatorType = Object.freeze({\n    Totp: 'totp' \n});\n\nmodule.exports = AuthenticatorType;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFjdGlvbi1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9ub2RlLWFwcHdyaXRlL2xpYi9lbnVtcy9hdXRoZW50aWNhdG9yLXR5cGUuanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBLENBQUM7O0FBRUQiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9qc21fYmFua2luZy8uL25vZGVfbW9kdWxlcy9ub2RlLWFwcHdyaXRlL2xpYi9lbnVtcy9hdXRoZW50aWNhdG9yLXR5cGUuanM/MDc4MyJdLCJzb3VyY2VzQ29udGVudCI6WyJjb25zdCBBdXRoZW50aWNhdG9yVHlwZSA9IE9iamVjdC5mcmVlemUoe1xuICAgIFRvdHA6ICd0b3RwJyBcbn0pO1xuXG5tb2R1bGUuZXhwb3J0cyA9IEF1dGhlbnRpY2F0b3JUeXBlOyJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(action-browser)/./node_modules/node-appwrite/lib/enums/authenticator-type.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/node-appwrite/lib/enums/authenticator-type.js":
/*!********************************************************************!*\
  !*** ./node_modules/node-appwrite/lib/enums/authenticator-type.js ***!
  \********************************************************************/
/***/ ((module) => {

eval("const AuthenticatorType = Object.freeze({\n    Totp: 'totp' \n});\n\nmodule.exports = AuthenticatorType;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvbm9kZS1hcHB3cml0ZS9saWIvZW51bXMvYXV0aGVudGljYXRvci10eXBlLmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQSxDQUFDOztBQUVEIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vanNtX2JhbmtpbmcvLi9ub2RlX21vZHVsZXMvbm9kZS1hcHB3cml0ZS9saWIvZW51bXMvYXV0aGVudGljYXRvci10eXBlLmpzPzBmZWIiXSwic291cmNlc0NvbnRlbnQiOlsiY29uc3QgQXV0aGVudGljYXRvclR5cGUgPSBPYmplY3QuZnJlZXplKHtcbiAgICBUb3RwOiAndG90cCcgXG59KTtcblxubW9kdWxlLmV4cG9ydHMgPSBBdXRoZW50aWNhdG9yVHlwZTsiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/node-appwrite/lib/enums/authenticator-type.js\n");

/***/ }),

/***/ "(action-browser)/./node_modules/node-appwrite/lib/enums/browser.js":
/*!*********************************************************!*\
  !*** ./node_modules/node-appwrite/lib/enums/browser.js ***!
  \*********************************************************/
/***/ ((module) => {

eval("const Browser = Object.freeze({\n    AvantBrowser: 'aa' ,\n    AndroidWebViewBeta: 'an' ,\n    GoogleChrome: 'ch' ,\n    GoogleChromeIOS: 'ci' ,\n    GoogleChromeMobile: 'cm' ,\n    Chromium: 'cr' ,\n    MozillaFirefox: 'ff' ,\n    Safari: 'sf' ,\n    MobileSafari: 'mf' ,\n    MicrosoftEdge: 'ps' ,\n    MicrosoftEdgeIOS: 'oi' ,\n    OperaMini: 'om' ,\n    Opera: 'op' ,\n    OperaNext: 'on' \n});\n\nmodule.exports = Browser;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFjdGlvbi1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9ub2RlLWFwcHdyaXRlL2xpYi9lbnVtcy9icm93c2VyLmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9qc21fYmFua2luZy8uL25vZGVfbW9kdWxlcy9ub2RlLWFwcHdyaXRlL2xpYi9lbnVtcy9icm93c2VyLmpzP2U0YjQiXSwic291cmNlc0NvbnRlbnQiOlsiY29uc3QgQnJvd3NlciA9IE9iamVjdC5mcmVlemUoe1xuICAgIEF2YW50QnJvd3NlcjogJ2FhJyAsXG4gICAgQW5kcm9pZFdlYlZpZXdCZXRhOiAnYW4nICxcbiAgICBHb29nbGVDaHJvbWU6ICdjaCcgLFxuICAgIEdvb2dsZUNocm9tZUlPUzogJ2NpJyAsXG4gICAgR29vZ2xlQ2hyb21lTW9iaWxlOiAnY20nICxcbiAgICBDaHJvbWl1bTogJ2NyJyAsXG4gICAgTW96aWxsYUZpcmVmb3g6ICdmZicgLFxuICAgIFNhZmFyaTogJ3NmJyAsXG4gICAgTW9iaWxlU2FmYXJpOiAnbWYnICxcbiAgICBNaWNyb3NvZnRFZGdlOiAncHMnICxcbiAgICBNaWNyb3NvZnRFZGdlSU9TOiAnb2knICxcbiAgICBPcGVyYU1pbmk6ICdvbScgLFxuICAgIE9wZXJhOiAnb3AnICxcbiAgICBPcGVyYU5leHQ6ICdvbicgXG59KTtcblxubW9kdWxlLmV4cG9ydHMgPSBCcm93c2VyOyJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(action-browser)/./node_modules/node-appwrite/lib/enums/browser.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/node-appwrite/lib/enums/browser.js":
/*!*********************************************************!*\
  !*** ./node_modules/node-appwrite/lib/enums/browser.js ***!
  \*********************************************************/
/***/ ((module) => {

eval("const Browser = Object.freeze({\n    AvantBrowser: 'aa' ,\n    AndroidWebViewBeta: 'an' ,\n    GoogleChrome: 'ch' ,\n    GoogleChromeIOS: 'ci' ,\n    GoogleChromeMobile: 'cm' ,\n    Chromium: 'cr' ,\n    MozillaFirefox: 'ff' ,\n    Safari: 'sf' ,\n    MobileSafari: 'mf' ,\n    MicrosoftEdge: 'ps' ,\n    MicrosoftEdgeIOS: 'oi' ,\n    OperaMini: 'om' ,\n    Opera: 'op' ,\n    OperaNext: 'on' \n});\n\nmodule.exports = Browser;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvbm9kZS1hcHB3cml0ZS9saWIvZW51bXMvYnJvd3Nlci5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vanNtX2JhbmtpbmcvLi9ub2RlX21vZHVsZXMvbm9kZS1hcHB3cml0ZS9saWIvZW51bXMvYnJvd3Nlci5qcz85OWI1Il0sInNvdXJjZXNDb250ZW50IjpbImNvbnN0IEJyb3dzZXIgPSBPYmplY3QuZnJlZXplKHtcbiAgICBBdmFudEJyb3dzZXI6ICdhYScgLFxuICAgIEFuZHJvaWRXZWJWaWV3QmV0YTogJ2FuJyAsXG4gICAgR29vZ2xlQ2hyb21lOiAnY2gnICxcbiAgICBHb29nbGVDaHJvbWVJT1M6ICdjaScgLFxuICAgIEdvb2dsZUNocm9tZU1vYmlsZTogJ2NtJyAsXG4gICAgQ2hyb21pdW06ICdjcicgLFxuICAgIE1vemlsbGFGaXJlZm94OiAnZmYnICxcbiAgICBTYWZhcmk6ICdzZicgLFxuICAgIE1vYmlsZVNhZmFyaTogJ21mJyAsXG4gICAgTWljcm9zb2Z0RWRnZTogJ3BzJyAsXG4gICAgTWljcm9zb2Z0RWRnZUlPUzogJ29pJyAsXG4gICAgT3BlcmFNaW5pOiAnb20nICxcbiAgICBPcGVyYTogJ29wJyAsXG4gICAgT3BlcmFOZXh0OiAnb24nIFxufSk7XG5cbm1vZHVsZS5leHBvcnRzID0gQnJvd3NlcjsiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/node-appwrite/lib/enums/browser.js\n");

/***/ }),

/***/ "(action-browser)/./node_modules/node-appwrite/lib/enums/compression.js":
/*!*************************************************************!*\
  !*** ./node_modules/node-appwrite/lib/enums/compression.js ***!
  \*************************************************************/
/***/ ((module) => {

eval("const Compression = Object.freeze({\n    None: 'none' ,\n    Gzip: 'gzip' ,\n    Zstd: 'zstd' \n});\n\nmodule.exports = Compression;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFjdGlvbi1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9ub2RlLWFwcHdyaXRlL2xpYi9lbnVtcy9jb21wcmVzc2lvbi5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9qc21fYmFua2luZy8uL25vZGVfbW9kdWxlcy9ub2RlLWFwcHdyaXRlL2xpYi9lbnVtcy9jb21wcmVzc2lvbi5qcz82NGZlIl0sInNvdXJjZXNDb250ZW50IjpbImNvbnN0IENvbXByZXNzaW9uID0gT2JqZWN0LmZyZWV6ZSh7XG4gICAgTm9uZTogJ25vbmUnICxcbiAgICBHemlwOiAnZ3ppcCcgLFxuICAgIFpzdGQ6ICd6c3RkJyBcbn0pO1xuXG5tb2R1bGUuZXhwb3J0cyA9IENvbXByZXNzaW9uOyJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(action-browser)/./node_modules/node-appwrite/lib/enums/compression.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/node-appwrite/lib/enums/compression.js":
/*!*************************************************************!*\
  !*** ./node_modules/node-appwrite/lib/enums/compression.js ***!
  \*************************************************************/
/***/ ((module) => {

eval("const Compression = Object.freeze({\n    None: 'none' ,\n    Gzip: 'gzip' ,\n    Zstd: 'zstd' \n});\n\nmodule.exports = Compression;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvbm9kZS1hcHB3cml0ZS9saWIvZW51bXMvY29tcHJlc3Npb24uanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vanNtX2JhbmtpbmcvLi9ub2RlX21vZHVsZXMvbm9kZS1hcHB3cml0ZS9saWIvZW51bXMvY29tcHJlc3Npb24uanM/YThhZCJdLCJzb3VyY2VzQ29udGVudCI6WyJjb25zdCBDb21wcmVzc2lvbiA9IE9iamVjdC5mcmVlemUoe1xuICAgIE5vbmU6ICdub25lJyAsXG4gICAgR3ppcDogJ2d6aXAnICxcbiAgICBac3RkOiAnenN0ZCcgXG59KTtcblxubW9kdWxlLmV4cG9ydHMgPSBDb21wcmVzc2lvbjsiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/node-appwrite/lib/enums/compression.js\n");

/***/ }),

/***/ "(action-browser)/./node_modules/node-appwrite/lib/enums/credit-card.js":
/*!*************************************************************!*\
  !*** ./node_modules/node-appwrite/lib/enums/credit-card.js ***!
  \*************************************************************/
/***/ ((module) => {

eval("const CreditCard = Object.freeze({\n    AmericanExpress: 'amex' ,\n    Argencard: 'argencard' ,\n    Cabal: 'cabal' ,\n    Consosud: 'censosud' ,\n    DinersClub: 'diners' ,\n    Discover: 'discover' ,\n    Elo: 'elo' ,\n    Hipercard: 'hipercard' ,\n    JCB: 'jcb' ,\n    Mastercard: 'mastercard' ,\n    Naranja: 'naranja' ,\n    TarjetaShopping: 'targeta-shopping' ,\n    UnionChinaPay: 'union-china-pay' ,\n    Visa: 'visa' ,\n    MIR: 'mir' ,\n    Maestro: 'maestro' \n});\n\nmodule.exports = CreditCard;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFjdGlvbi1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9ub2RlLWFwcHdyaXRlL2xpYi9lbnVtcy9jcmVkaXQtY2FyZC5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRCIsInNvdXJjZXMiOlsid2VicGFjazovL2pzbV9iYW5raW5nLy4vbm9kZV9tb2R1bGVzL25vZGUtYXBwd3JpdGUvbGliL2VudW1zL2NyZWRpdC1jYXJkLmpzP2ZjZDUiXSwic291cmNlc0NvbnRlbnQiOlsiY29uc3QgQ3JlZGl0Q2FyZCA9IE9iamVjdC5mcmVlemUoe1xuICAgIEFtZXJpY2FuRXhwcmVzczogJ2FtZXgnICxcbiAgICBBcmdlbmNhcmQ6ICdhcmdlbmNhcmQnICxcbiAgICBDYWJhbDogJ2NhYmFsJyAsXG4gICAgQ29uc29zdWQ6ICdjZW5zb3N1ZCcgLFxuICAgIERpbmVyc0NsdWI6ICdkaW5lcnMnICxcbiAgICBEaXNjb3ZlcjogJ2Rpc2NvdmVyJyAsXG4gICAgRWxvOiAnZWxvJyAsXG4gICAgSGlwZXJjYXJkOiAnaGlwZXJjYXJkJyAsXG4gICAgSkNCOiAnamNiJyAsXG4gICAgTWFzdGVyY2FyZDogJ21hc3RlcmNhcmQnICxcbiAgICBOYXJhbmphOiAnbmFyYW5qYScgLFxuICAgIFRhcmpldGFTaG9wcGluZzogJ3RhcmdldGEtc2hvcHBpbmcnICxcbiAgICBVbmlvbkNoaW5hUGF5OiAndW5pb24tY2hpbmEtcGF5JyAsXG4gICAgVmlzYTogJ3Zpc2EnICxcbiAgICBNSVI6ICdtaXInICxcbiAgICBNYWVzdHJvOiAnbWFlc3RybycgXG59KTtcblxubW9kdWxlLmV4cG9ydHMgPSBDcmVkaXRDYXJkOyJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(action-browser)/./node_modules/node-appwrite/lib/enums/credit-card.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/node-appwrite/lib/enums/credit-card.js":
/*!*************************************************************!*\
  !*** ./node_modules/node-appwrite/lib/enums/credit-card.js ***!
  \*************************************************************/
/***/ ((module) => {

eval("const CreditCard = Object.freeze({\n    AmericanExpress: 'amex' ,\n    Argencard: 'argencard' ,\n    Cabal: 'cabal' ,\n    Consosud: 'censosud' ,\n    DinersClub: 'diners' ,\n    Discover: 'discover' ,\n    Elo: 'elo' ,\n    Hipercard: 'hipercard' ,\n    JCB: 'jcb' ,\n    Mastercard: 'mastercard' ,\n    Naranja: 'naranja' ,\n    TarjetaShopping: 'targeta-shopping' ,\n    UnionChinaPay: 'union-china-pay' ,\n    Visa: 'visa' ,\n    MIR: 'mir' ,\n    Maestro: 'maestro' \n});\n\nmodule.exports = CreditCard;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvbm9kZS1hcHB3cml0ZS9saWIvZW51bXMvY3JlZGl0LWNhcmQuanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9qc21fYmFua2luZy8uL25vZGVfbW9kdWxlcy9ub2RlLWFwcHdyaXRlL2xpYi9lbnVtcy9jcmVkaXQtY2FyZC5qcz8xYzUyIl0sInNvdXJjZXNDb250ZW50IjpbImNvbnN0IENyZWRpdENhcmQgPSBPYmplY3QuZnJlZXplKHtcbiAgICBBbWVyaWNhbkV4cHJlc3M6ICdhbWV4JyAsXG4gICAgQXJnZW5jYXJkOiAnYXJnZW5jYXJkJyAsXG4gICAgQ2FiYWw6ICdjYWJhbCcgLFxuICAgIENvbnNvc3VkOiAnY2Vuc29zdWQnICxcbiAgICBEaW5lcnNDbHViOiAnZGluZXJzJyAsXG4gICAgRGlzY292ZXI6ICdkaXNjb3ZlcicgLFxuICAgIEVsbzogJ2VsbycgLFxuICAgIEhpcGVyY2FyZDogJ2hpcGVyY2FyZCcgLFxuICAgIEpDQjogJ2pjYicgLFxuICAgIE1hc3RlcmNhcmQ6ICdtYXN0ZXJjYXJkJyAsXG4gICAgTmFyYW5qYTogJ25hcmFuamEnICxcbiAgICBUYXJqZXRhU2hvcHBpbmc6ICd0YXJnZXRhLXNob3BwaW5nJyAsXG4gICAgVW5pb25DaGluYVBheTogJ3VuaW9uLWNoaW5hLXBheScgLFxuICAgIFZpc2E6ICd2aXNhJyAsXG4gICAgTUlSOiAnbWlyJyAsXG4gICAgTWFlc3RybzogJ21hZXN0cm8nIFxufSk7XG5cbm1vZHVsZS5leHBvcnRzID0gQ3JlZGl0Q2FyZDsiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/node-appwrite/lib/enums/credit-card.js\n");

/***/ }),

/***/ "(action-browser)/./node_modules/node-appwrite/lib/enums/execution-method.js":
/*!******************************************************************!*\
  !*** ./node_modules/node-appwrite/lib/enums/execution-method.js ***!
  \******************************************************************/
/***/ ((module) => {

eval("const ExecutionMethod = Object.freeze({\n    GET: 'GET' ,\n    POST: 'POST' ,\n    PUT: 'PUT' ,\n    PATCH: 'PATCH' ,\n    DELETE: 'DELETE' ,\n    OPTIONS: 'OPTIONS' \n});\n\nmodule.exports = ExecutionMethod;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFjdGlvbi1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9ub2RlLWFwcHdyaXRlL2xpYi9lbnVtcy9leGVjdXRpb24tbWV0aG9kLmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRCIsInNvdXJjZXMiOlsid2VicGFjazovL2pzbV9iYW5raW5nLy4vbm9kZV9tb2R1bGVzL25vZGUtYXBwd3JpdGUvbGliL2VudW1zL2V4ZWN1dGlvbi1tZXRob2QuanM/NTFlZSJdLCJzb3VyY2VzQ29udGVudCI6WyJjb25zdCBFeGVjdXRpb25NZXRob2QgPSBPYmplY3QuZnJlZXplKHtcbiAgICBHRVQ6ICdHRVQnICxcbiAgICBQT1NUOiAnUE9TVCcgLFxuICAgIFBVVDogJ1BVVCcgLFxuICAgIFBBVENIOiAnUEFUQ0gnICxcbiAgICBERUxFVEU6ICdERUxFVEUnICxcbiAgICBPUFRJT05TOiAnT1BUSU9OUycgXG59KTtcblxubW9kdWxlLmV4cG9ydHMgPSBFeGVjdXRpb25NZXRob2Q7Il0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(action-browser)/./node_modules/node-appwrite/lib/enums/execution-method.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/node-appwrite/lib/enums/execution-method.js":
/*!******************************************************************!*\
  !*** ./node_modules/node-appwrite/lib/enums/execution-method.js ***!
  \******************************************************************/
/***/ ((module) => {

eval("const ExecutionMethod = Object.freeze({\n    GET: 'GET' ,\n    POST: 'POST' ,\n    PUT: 'PUT' ,\n    PATCH: 'PATCH' ,\n    DELETE: 'DELETE' ,\n    OPTIONS: 'OPTIONS' \n});\n\nmodule.exports = ExecutionMethod;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvbm9kZS1hcHB3cml0ZS9saWIvZW51bXMvZXhlY3V0aW9uLW1ldGhvZC5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9qc21fYmFua2luZy8uL25vZGVfbW9kdWxlcy9ub2RlLWFwcHdyaXRlL2xpYi9lbnVtcy9leGVjdXRpb24tbWV0aG9kLmpzPzliNTAiXSwic291cmNlc0NvbnRlbnQiOlsiY29uc3QgRXhlY3V0aW9uTWV0aG9kID0gT2JqZWN0LmZyZWV6ZSh7XG4gICAgR0VUOiAnR0VUJyAsXG4gICAgUE9TVDogJ1BPU1QnICxcbiAgICBQVVQ6ICdQVVQnICxcbiAgICBQQVRDSDogJ1BBVENIJyAsXG4gICAgREVMRVRFOiAnREVMRVRFJyAsXG4gICAgT1BUSU9OUzogJ09QVElPTlMnIFxufSk7XG5cbm1vZHVsZS5leHBvcnRzID0gRXhlY3V0aW9uTWV0aG9kOyJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/node-appwrite/lib/enums/execution-method.js\n");

/***/ }),

/***/ "(action-browser)/./node_modules/node-appwrite/lib/enums/flag.js":
/*!******************************************************!*\
  !*** ./node_modules/node-appwrite/lib/enums/flag.js ***!
  \******************************************************/
/***/ ((module) => {

eval("const Flag = Object.freeze({\n    Afghanistan: 'af' ,\n    Angola: 'ao' ,\n    Albania: 'al' ,\n    Andorra: 'ad' ,\n    UnitedArabEmirates: 'ae' ,\n    Argentina: 'ar' ,\n    Armenia: 'am' ,\n    AntiguaAndBarbuda: 'ag' ,\n    Australia: 'au' ,\n    Austria: 'at' ,\n    Azerbaijan: 'az' ,\n    Burundi: 'bi' ,\n    Belgium: 'be' ,\n    Benin: 'bj' ,\n    BurkinaFaso: 'bf' ,\n    Bangladesh: 'bd' ,\n    Bulgaria: 'bg' ,\n    Bahrain: 'bh' ,\n    Bahamas: 'bs' ,\n    BosniaAndHerzegovina: 'ba' ,\n    Belarus: 'by' ,\n    Belize: 'bz' ,\n    Bolivia: 'bo' ,\n    Brazil: 'br' ,\n    Barbados: 'bb' ,\n    BruneiDarussalam: 'bn' ,\n    Bhutan: 'bt' ,\n    Botswana: 'bw' ,\n    CentralAfricanRepublic: 'cf' ,\n    Canada: 'ca' ,\n    Switzerland: 'ch' ,\n    Chile: 'cl' ,\n    China: 'cn' ,\n    CoteDIvoire: 'ci' ,\n    Cameroon: 'cm' ,\n    DemocraticRepublicOfTheCongo: 'cd' ,\n    RepublicOfTheCongo: 'cg' ,\n    Colombia: 'co' ,\n    Comoros: 'km' ,\n    CapeVerde: 'cv' ,\n    CostaRica: 'cr' ,\n    Cuba: 'cu' ,\n    Cyprus: 'cy' ,\n    CzechRepublic: 'cz' ,\n    Germany: 'de' ,\n    Djibouti: 'dj' ,\n    Dominica: 'dm' ,\n    Denmark: 'dk' ,\n    DominicanRepublic: 'do' ,\n    Algeria: 'dz' ,\n    Ecuador: 'ec' ,\n    Egypt: 'eg' ,\n    Eritrea: 'er' ,\n    Spain: 'es' ,\n    Estonia: 'ee' ,\n    Ethiopia: 'et' ,\n    Finland: 'fi' ,\n    Fiji: 'fj' ,\n    France: 'fr' ,\n    MicronesiaFederatedStatesOf: 'fm' ,\n    Gabon: 'ga' ,\n    UnitedKingdom: 'gb' ,\n    Georgia: 'ge' ,\n    Ghana: 'gh' ,\n    Guinea: 'gn' ,\n    Gambia: 'gm' ,\n    GuineaBissau: 'gw' ,\n    EquatorialGuinea: 'gq' ,\n    Greece: 'gr' ,\n    Grenada: 'gd' ,\n    Guatemala: 'gt' ,\n    Guyana: 'gy' ,\n    Honduras: 'hn' ,\n    Croatia: 'hr' ,\n    Haiti: 'ht' ,\n    Hungary: 'hu' ,\n    Indonesia: 'id' ,\n    India: 'in' ,\n    Ireland: 'ie' ,\n    IranIslamicRepublicOf: 'ir' ,\n    Iraq: 'iq' ,\n    Iceland: 'is' ,\n    Israel: 'il' ,\n    Italy: 'it' ,\n    Jamaica: 'jm' ,\n    Jordan: 'jo' ,\n    Japan: 'jp' ,\n    Kazakhstan: 'kz' ,\n    Kenya: 'ke' ,\n    Kyrgyzstan: 'kg' ,\n    Cambodia: 'kh' ,\n    Kiribati: 'ki' ,\n    SaintKittsAndNevis: 'kn' ,\n    SouthKorea: 'kr' ,\n    Kuwait: 'kw' ,\n    LaoPeopleSDemocraticRepublic: 'la' ,\n    Lebanon: 'lb' ,\n    Liberia: 'lr' ,\n    Libya: 'ly' ,\n    SaintLucia: 'lc' ,\n    Liechtenstein: 'li' ,\n    SriLanka: 'lk' ,\n    Lesotho: 'ls' ,\n    Lithuania: 'lt' ,\n    Luxembourg: 'lu' ,\n    Latvia: 'lv' ,\n    Morocco: 'ma' ,\n    Monaco: 'mc' ,\n    Moldova: 'md' ,\n    Madagascar: 'mg' ,\n    Maldives: 'mv' ,\n    Mexico: 'mx' ,\n    MarshallIslands: 'mh' ,\n    NorthMacedonia: 'mk' ,\n    Mali: 'ml' ,\n    Malta: 'mt' ,\n    Myanmar: 'mm' ,\n    Montenegro: 'me' ,\n    Mongolia: 'mn' ,\n    Mozambique: 'mz' ,\n    Mauritania: 'mr' ,\n    Mauritius: 'mu' ,\n    Malawi: 'mw' ,\n    Malaysia: 'my' ,\n    Namibia: 'na' ,\n    Niger: 'ne' ,\n    Nigeria: 'ng' ,\n    Nicaragua: 'ni' ,\n    Netherlands: 'nl' ,\n    Norway: 'no' ,\n    Nepal: 'np' ,\n    Nauru: 'nr' ,\n    NewZealand: 'nz' ,\n    Oman: 'om' ,\n    Pakistan: 'pk' ,\n    Panama: 'pa' ,\n    Peru: 'pe' ,\n    Philippines: 'ph' ,\n    Palau: 'pw' ,\n    PapuaNewGuinea: 'pg' ,\n    Poland: 'pl' ,\n    NorthKorea: 'kp' ,\n    Portugal: 'pt' ,\n    Paraguay: 'py' ,\n    Qatar: 'qa' ,\n    Romania: 'ro' ,\n    Russia: 'ru' ,\n    Rwanda: 'rw' ,\n    SaudiArabia: 'sa' ,\n    Sudan: 'sd' ,\n    Senegal: 'sn' ,\n    Singapore: 'sg' ,\n    SolomonIslands: 'sb' ,\n    SierraLeone: 'sl' ,\n    ElSalvador: 'sv' ,\n    SanMarino: 'sm' ,\n    Somalia: 'so' ,\n    Serbia: 'rs' ,\n    SouthSudan: 'ss' ,\n    SaoTomeAndPrincipe: 'st' ,\n    Suriname: 'sr' ,\n    Slovakia: 'sk' ,\n    Slovenia: 'si' ,\n    Sweden: 'se' ,\n    Eswatini: 'sz' ,\n    Seychelles: 'sc' ,\n    Syria: 'sy' ,\n    Chad: 'td' ,\n    Togo: 'tg' ,\n    Thailand: 'th' ,\n    Tajikistan: 'tj' ,\n    Turkmenistan: 'tm' ,\n    TimorLeste: 'tl' ,\n    Tonga: 'to' ,\n    TrinidadAndTobago: 'tt' ,\n    Tunisia: 'tn' ,\n    Turkey: 'tr' ,\n    Tuvalu: 'tv' ,\n    Tanzania: 'tz' ,\n    Uganda: 'ug' ,\n    Ukraine: 'ua' ,\n    Uruguay: 'uy' ,\n    UnitedStates: 'us' ,\n    Uzbekistan: 'uz' ,\n    VaticanCity: 'va' ,\n    SaintVincentAndTheGrenadines: 'vc' ,\n    Venezuela: 've' ,\n    Vietnam: 'vn' ,\n    Vanuatu: 'vu' ,\n    Samoa: 'ws' ,\n    Yemen: 'ye' ,\n    SouthAfrica: 'za' ,\n    Zambia: 'zm' ,\n    Zimbabwe: 'zw' \n});\n\nmodule.exports = Flag;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFjdGlvbi1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9ub2RlLWFwcHdyaXRlL2xpYi9lbnVtcy9mbGFnLmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9qc21fYmFua2luZy8uL25vZGVfbW9kdWxlcy9ub2RlLWFwcHdyaXRlL2xpYi9lbnVtcy9mbGFnLmpzPzA4OTIiXSwic291cmNlc0NvbnRlbnQiOlsiY29uc3QgRmxhZyA9IE9iamVjdC5mcmVlemUoe1xuICAgIEFmZ2hhbmlzdGFuOiAnYWYnICxcbiAgICBBbmdvbGE6ICdhbycgLFxuICAgIEFsYmFuaWE6ICdhbCcgLFxuICAgIEFuZG9ycmE6ICdhZCcgLFxuICAgIFVuaXRlZEFyYWJFbWlyYXRlczogJ2FlJyAsXG4gICAgQXJnZW50aW5hOiAnYXInICxcbiAgICBBcm1lbmlhOiAnYW0nICxcbiAgICBBbnRpZ3VhQW5kQmFyYnVkYTogJ2FnJyAsXG4gICAgQXVzdHJhbGlhOiAnYXUnICxcbiAgICBBdXN0cmlhOiAnYXQnICxcbiAgICBBemVyYmFpamFuOiAnYXonICxcbiAgICBCdXJ1bmRpOiAnYmknICxcbiAgICBCZWxnaXVtOiAnYmUnICxcbiAgICBCZW5pbjogJ2JqJyAsXG4gICAgQnVya2luYUZhc286ICdiZicgLFxuICAgIEJhbmdsYWRlc2g6ICdiZCcgLFxuICAgIEJ1bGdhcmlhOiAnYmcnICxcbiAgICBCYWhyYWluOiAnYmgnICxcbiAgICBCYWhhbWFzOiAnYnMnICxcbiAgICBCb3NuaWFBbmRIZXJ6ZWdvdmluYTogJ2JhJyAsXG4gICAgQmVsYXJ1czogJ2J5JyAsXG4gICAgQmVsaXplOiAnYnonICxcbiAgICBCb2xpdmlhOiAnYm8nICxcbiAgICBCcmF6aWw6ICdicicgLFxuICAgIEJhcmJhZG9zOiAnYmInICxcbiAgICBCcnVuZWlEYXJ1c3NhbGFtOiAnYm4nICxcbiAgICBCaHV0YW46ICdidCcgLFxuICAgIEJvdHN3YW5hOiAnYncnICxcbiAgICBDZW50cmFsQWZyaWNhblJlcHVibGljOiAnY2YnICxcbiAgICBDYW5hZGE6ICdjYScgLFxuICAgIFN3aXR6ZXJsYW5kOiAnY2gnICxcbiAgICBDaGlsZTogJ2NsJyAsXG4gICAgQ2hpbmE6ICdjbicgLFxuICAgIENvdGVESXZvaXJlOiAnY2knICxcbiAgICBDYW1lcm9vbjogJ2NtJyAsXG4gICAgRGVtb2NyYXRpY1JlcHVibGljT2ZUaGVDb25nbzogJ2NkJyAsXG4gICAgUmVwdWJsaWNPZlRoZUNvbmdvOiAnY2cnICxcbiAgICBDb2xvbWJpYTogJ2NvJyAsXG4gICAgQ29tb3JvczogJ2ttJyAsXG4gICAgQ2FwZVZlcmRlOiAnY3YnICxcbiAgICBDb3N0YVJpY2E6ICdjcicgLFxuICAgIEN1YmE6ICdjdScgLFxuICAgIEN5cHJ1czogJ2N5JyAsXG4gICAgQ3plY2hSZXB1YmxpYzogJ2N6JyAsXG4gICAgR2VybWFueTogJ2RlJyAsXG4gICAgRGppYm91dGk6ICdkaicgLFxuICAgIERvbWluaWNhOiAnZG0nICxcbiAgICBEZW5tYXJrOiAnZGsnICxcbiAgICBEb21pbmljYW5SZXB1YmxpYzogJ2RvJyAsXG4gICAgQWxnZXJpYTogJ2R6JyAsXG4gICAgRWN1YWRvcjogJ2VjJyAsXG4gICAgRWd5cHQ6ICdlZycgLFxuICAgIEVyaXRyZWE6ICdlcicgLFxuICAgIFNwYWluOiAnZXMnICxcbiAgICBFc3RvbmlhOiAnZWUnICxcbiAgICBFdGhpb3BpYTogJ2V0JyAsXG4gICAgRmlubGFuZDogJ2ZpJyAsXG4gICAgRmlqaTogJ2ZqJyAsXG4gICAgRnJhbmNlOiAnZnInICxcbiAgICBNaWNyb25lc2lhRmVkZXJhdGVkU3RhdGVzT2Y6ICdmbScgLFxuICAgIEdhYm9uOiAnZ2EnICxcbiAgICBVbml0ZWRLaW5nZG9tOiAnZ2InICxcbiAgICBHZW9yZ2lhOiAnZ2UnICxcbiAgICBHaGFuYTogJ2doJyAsXG4gICAgR3VpbmVhOiAnZ24nICxcbiAgICBHYW1iaWE6ICdnbScgLFxuICAgIEd1aW5lYUJpc3NhdTogJ2d3JyAsXG4gICAgRXF1YXRvcmlhbEd1aW5lYTogJ2dxJyAsXG4gICAgR3JlZWNlOiAnZ3InICxcbiAgICBHcmVuYWRhOiAnZ2QnICxcbiAgICBHdWF0ZW1hbGE6ICdndCcgLFxuICAgIEd1eWFuYTogJ2d5JyAsXG4gICAgSG9uZHVyYXM6ICdobicgLFxuICAgIENyb2F0aWE6ICdocicgLFxuICAgIEhhaXRpOiAnaHQnICxcbiAgICBIdW5nYXJ5OiAnaHUnICxcbiAgICBJbmRvbmVzaWE6ICdpZCcgLFxuICAgIEluZGlhOiAnaW4nICxcbiAgICBJcmVsYW5kOiAnaWUnICxcbiAgICBJcmFuSXNsYW1pY1JlcHVibGljT2Y6ICdpcicgLFxuICAgIElyYXE6ICdpcScgLFxuICAgIEljZWxhbmQ6ICdpcycgLFxuICAgIElzcmFlbDogJ2lsJyAsXG4gICAgSXRhbHk6ICdpdCcgLFxuICAgIEphbWFpY2E6ICdqbScgLFxuICAgIEpvcmRhbjogJ2pvJyAsXG4gICAgSmFwYW46ICdqcCcgLFxuICAgIEthemFraHN0YW46ICdreicgLFxuICAgIEtlbnlhOiAna2UnICxcbiAgICBLeXJneXpzdGFuOiAna2cnICxcbiAgICBDYW1ib2RpYTogJ2toJyAsXG4gICAgS2lyaWJhdGk6ICdraScgLFxuICAgIFNhaW50S2l0dHNBbmROZXZpczogJ2tuJyAsXG4gICAgU291dGhLb3JlYTogJ2tyJyAsXG4gICAgS3V3YWl0OiAna3cnICxcbiAgICBMYW9QZW9wbGVTRGVtb2NyYXRpY1JlcHVibGljOiAnbGEnICxcbiAgICBMZWJhbm9uOiAnbGInICxcbiAgICBMaWJlcmlhOiAnbHInICxcbiAgICBMaWJ5YTogJ2x5JyAsXG4gICAgU2FpbnRMdWNpYTogJ2xjJyAsXG4gICAgTGllY2h0ZW5zdGVpbjogJ2xpJyAsXG4gICAgU3JpTGFua2E6ICdsaycgLFxuICAgIExlc290aG86ICdscycgLFxuICAgIExpdGh1YW5pYTogJ2x0JyAsXG4gICAgTHV4ZW1ib3VyZzogJ2x1JyAsXG4gICAgTGF0dmlhOiAnbHYnICxcbiAgICBNb3JvY2NvOiAnbWEnICxcbiAgICBNb25hY286ICdtYycgLFxuICAgIE1vbGRvdmE6ICdtZCcgLFxuICAgIE1hZGFnYXNjYXI6ICdtZycgLFxuICAgIE1hbGRpdmVzOiAnbXYnICxcbiAgICBNZXhpY286ICdteCcgLFxuICAgIE1hcnNoYWxsSXNsYW5kczogJ21oJyAsXG4gICAgTm9ydGhNYWNlZG9uaWE6ICdtaycgLFxuICAgIE1hbGk6ICdtbCcgLFxuICAgIE1hbHRhOiAnbXQnICxcbiAgICBNeWFubWFyOiAnbW0nICxcbiAgICBNb250ZW5lZ3JvOiAnbWUnICxcbiAgICBNb25nb2xpYTogJ21uJyAsXG4gICAgTW96YW1iaXF1ZTogJ216JyAsXG4gICAgTWF1cml0YW5pYTogJ21yJyAsXG4gICAgTWF1cml0aXVzOiAnbXUnICxcbiAgICBNYWxhd2k6ICdtdycgLFxuICAgIE1hbGF5c2lhOiAnbXknICxcbiAgICBOYW1pYmlhOiAnbmEnICxcbiAgICBOaWdlcjogJ25lJyAsXG4gICAgTmlnZXJpYTogJ25nJyAsXG4gICAgTmljYXJhZ3VhOiAnbmknICxcbiAgICBOZXRoZXJsYW5kczogJ25sJyAsXG4gICAgTm9yd2F5OiAnbm8nICxcbiAgICBOZXBhbDogJ25wJyAsXG4gICAgTmF1cnU6ICducicgLFxuICAgIE5ld1plYWxhbmQ6ICdueicgLFxuICAgIE9tYW46ICdvbScgLFxuICAgIFBha2lzdGFuOiAncGsnICxcbiAgICBQYW5hbWE6ICdwYScgLFxuICAgIFBlcnU6ICdwZScgLFxuICAgIFBoaWxpcHBpbmVzOiAncGgnICxcbiAgICBQYWxhdTogJ3B3JyAsXG4gICAgUGFwdWFOZXdHdWluZWE6ICdwZycgLFxuICAgIFBvbGFuZDogJ3BsJyAsXG4gICAgTm9ydGhLb3JlYTogJ2twJyAsXG4gICAgUG9ydHVnYWw6ICdwdCcgLFxuICAgIFBhcmFndWF5OiAncHknICxcbiAgICBRYXRhcjogJ3FhJyAsXG4gICAgUm9tYW5pYTogJ3JvJyAsXG4gICAgUnVzc2lhOiAncnUnICxcbiAgICBSd2FuZGE6ICdydycgLFxuICAgIFNhdWRpQXJhYmlhOiAnc2EnICxcbiAgICBTdWRhbjogJ3NkJyAsXG4gICAgU2VuZWdhbDogJ3NuJyAsXG4gICAgU2luZ2Fwb3JlOiAnc2cnICxcbiAgICBTb2xvbW9uSXNsYW5kczogJ3NiJyAsXG4gICAgU2llcnJhTGVvbmU6ICdzbCcgLFxuICAgIEVsU2FsdmFkb3I6ICdzdicgLFxuICAgIFNhbk1hcmlubzogJ3NtJyAsXG4gICAgU29tYWxpYTogJ3NvJyAsXG4gICAgU2VyYmlhOiAncnMnICxcbiAgICBTb3V0aFN1ZGFuOiAnc3MnICxcbiAgICBTYW9Ub21lQW5kUHJpbmNpcGU6ICdzdCcgLFxuICAgIFN1cmluYW1lOiAnc3InICxcbiAgICBTbG92YWtpYTogJ3NrJyAsXG4gICAgU2xvdmVuaWE6ICdzaScgLFxuICAgIFN3ZWRlbjogJ3NlJyAsXG4gICAgRXN3YXRpbmk6ICdzeicgLFxuICAgIFNleWNoZWxsZXM6ICdzYycgLFxuICAgIFN5cmlhOiAnc3knICxcbiAgICBDaGFkOiAndGQnICxcbiAgICBUb2dvOiAndGcnICxcbiAgICBUaGFpbGFuZDogJ3RoJyAsXG4gICAgVGFqaWtpc3RhbjogJ3RqJyAsXG4gICAgVHVya21lbmlzdGFuOiAndG0nICxcbiAgICBUaW1vckxlc3RlOiAndGwnICxcbiAgICBUb25nYTogJ3RvJyAsXG4gICAgVHJpbmlkYWRBbmRUb2JhZ286ICd0dCcgLFxuICAgIFR1bmlzaWE6ICd0bicgLFxuICAgIFR1cmtleTogJ3RyJyAsXG4gICAgVHV2YWx1OiAndHYnICxcbiAgICBUYW56YW5pYTogJ3R6JyAsXG4gICAgVWdhbmRhOiAndWcnICxcbiAgICBVa3JhaW5lOiAndWEnICxcbiAgICBVcnVndWF5OiAndXknICxcbiAgICBVbml0ZWRTdGF0ZXM6ICd1cycgLFxuICAgIFV6YmVraXN0YW46ICd1eicgLFxuICAgIFZhdGljYW5DaXR5OiAndmEnICxcbiAgICBTYWludFZpbmNlbnRBbmRUaGVHcmVuYWRpbmVzOiAndmMnICxcbiAgICBWZW5lenVlbGE6ICd2ZScgLFxuICAgIFZpZXRuYW06ICd2bicgLFxuICAgIFZhbnVhdHU6ICd2dScgLFxuICAgIFNhbW9hOiAnd3MnICxcbiAgICBZZW1lbjogJ3llJyAsXG4gICAgU291dGhBZnJpY2E6ICd6YScgLFxuICAgIFphbWJpYTogJ3ptJyAsXG4gICAgWmltYmFid2U6ICd6dycgXG59KTtcblxubW9kdWxlLmV4cG9ydHMgPSBGbGFnOyJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(action-browser)/./node_modules/node-appwrite/lib/enums/flag.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/node-appwrite/lib/enums/flag.js":
/*!******************************************************!*\
  !*** ./node_modules/node-appwrite/lib/enums/flag.js ***!
  \******************************************************/
/***/ ((module) => {

eval("const Flag = Object.freeze({\n    Afghanistan: 'af' ,\n    Angola: 'ao' ,\n    Albania: 'al' ,\n    Andorra: 'ad' ,\n    UnitedArabEmirates: 'ae' ,\n    Argentina: 'ar' ,\n    Armenia: 'am' ,\n    AntiguaAndBarbuda: 'ag' ,\n    Australia: 'au' ,\n    Austria: 'at' ,\n    Azerbaijan: 'az' ,\n    Burundi: 'bi' ,\n    Belgium: 'be' ,\n    Benin: 'bj' ,\n    BurkinaFaso: 'bf' ,\n    Bangladesh: 'bd' ,\n    Bulgaria: 'bg' ,\n    Bahrain: 'bh' ,\n    Bahamas: 'bs' ,\n    BosniaAndHerzegovina: 'ba' ,\n    Belarus: 'by' ,\n    Belize: 'bz' ,\n    Bolivia: 'bo' ,\n    Brazil: 'br' ,\n    Barbados: 'bb' ,\n    BruneiDarussalam: 'bn' ,\n    Bhutan: 'bt' ,\n    Botswana: 'bw' ,\n    CentralAfricanRepublic: 'cf' ,\n    Canada: 'ca' ,\n    Switzerland: 'ch' ,\n    Chile: 'cl' ,\n    China: 'cn' ,\n    CoteDIvoire: 'ci' ,\n    Cameroon: 'cm' ,\n    DemocraticRepublicOfTheCongo: 'cd' ,\n    RepublicOfTheCongo: 'cg' ,\n    Colombia: 'co' ,\n    Comoros: 'km' ,\n    CapeVerde: 'cv' ,\n    CostaRica: 'cr' ,\n    Cuba: 'cu' ,\n    Cyprus: 'cy' ,\n    CzechRepublic: 'cz' ,\n    Germany: 'de' ,\n    Djibouti: 'dj' ,\n    Dominica: 'dm' ,\n    Denmark: 'dk' ,\n    DominicanRepublic: 'do' ,\n    Algeria: 'dz' ,\n    Ecuador: 'ec' ,\n    Egypt: 'eg' ,\n    Eritrea: 'er' ,\n    Spain: 'es' ,\n    Estonia: 'ee' ,\n    Ethiopia: 'et' ,\n    Finland: 'fi' ,\n    Fiji: 'fj' ,\n    France: 'fr' ,\n    MicronesiaFederatedStatesOf: 'fm' ,\n    Gabon: 'ga' ,\n    UnitedKingdom: 'gb' ,\n    Georgia: 'ge' ,\n    Ghana: 'gh' ,\n    Guinea: 'gn' ,\n    Gambia: 'gm' ,\n    GuineaBissau: 'gw' ,\n    EquatorialGuinea: 'gq' ,\n    Greece: 'gr' ,\n    Grenada: 'gd' ,\n    Guatemala: 'gt' ,\n    Guyana: 'gy' ,\n    Honduras: 'hn' ,\n    Croatia: 'hr' ,\n    Haiti: 'ht' ,\n    Hungary: 'hu' ,\n    Indonesia: 'id' ,\n    India: 'in' ,\n    Ireland: 'ie' ,\n    IranIslamicRepublicOf: 'ir' ,\n    Iraq: 'iq' ,\n    Iceland: 'is' ,\n    Israel: 'il' ,\n    Italy: 'it' ,\n    Jamaica: 'jm' ,\n    Jordan: 'jo' ,\n    Japan: 'jp' ,\n    Kazakhstan: 'kz' ,\n    Kenya: 'ke' ,\n    Kyrgyzstan: 'kg' ,\n    Cambodia: 'kh' ,\n    Kiribati: 'ki' ,\n    SaintKittsAndNevis: 'kn' ,\n    SouthKorea: 'kr' ,\n    Kuwait: 'kw' ,\n    LaoPeopleSDemocraticRepublic: 'la' ,\n    Lebanon: 'lb' ,\n    Liberia: 'lr' ,\n    Libya: 'ly' ,\n    SaintLucia: 'lc' ,\n    Liechtenstein: 'li' ,\n    SriLanka: 'lk' ,\n    Lesotho: 'ls' ,\n    Lithuania: 'lt' ,\n    Luxembourg: 'lu' ,\n    Latvia: 'lv' ,\n    Morocco: 'ma' ,\n    Monaco: 'mc' ,\n    Moldova: 'md' ,\n    Madagascar: 'mg' ,\n    Maldives: 'mv' ,\n    Mexico: 'mx' ,\n    MarshallIslands: 'mh' ,\n    NorthMacedonia: 'mk' ,\n    Mali: 'ml' ,\n    Malta: 'mt' ,\n    Myanmar: 'mm' ,\n    Montenegro: 'me' ,\n    Mongolia: 'mn' ,\n    Mozambique: 'mz' ,\n    Mauritania: 'mr' ,\n    Mauritius: 'mu' ,\n    Malawi: 'mw' ,\n    Malaysia: 'my' ,\n    Namibia: 'na' ,\n    Niger: 'ne' ,\n    Nigeria: 'ng' ,\n    Nicaragua: 'ni' ,\n    Netherlands: 'nl' ,\n    Norway: 'no' ,\n    Nepal: 'np' ,\n    Nauru: 'nr' ,\n    NewZealand: 'nz' ,\n    Oman: 'om' ,\n    Pakistan: 'pk' ,\n    Panama: 'pa' ,\n    Peru: 'pe' ,\n    Philippines: 'ph' ,\n    Palau: 'pw' ,\n    PapuaNewGuinea: 'pg' ,\n    Poland: 'pl' ,\n    NorthKorea: 'kp' ,\n    Portugal: 'pt' ,\n    Paraguay: 'py' ,\n    Qatar: 'qa' ,\n    Romania: 'ro' ,\n    Russia: 'ru' ,\n    Rwanda: 'rw' ,\n    SaudiArabia: 'sa' ,\n    Sudan: 'sd' ,\n    Senegal: 'sn' ,\n    Singapore: 'sg' ,\n    SolomonIslands: 'sb' ,\n    SierraLeone: 'sl' ,\n    ElSalvador: 'sv' ,\n    SanMarino: 'sm' ,\n    Somalia: 'so' ,\n    Serbia: 'rs' ,\n    SouthSudan: 'ss' ,\n    SaoTomeAndPrincipe: 'st' ,\n    Suriname: 'sr' ,\n    Slovakia: 'sk' ,\n    Slovenia: 'si' ,\n    Sweden: 'se' ,\n    Eswatini: 'sz' ,\n    Seychelles: 'sc' ,\n    Syria: 'sy' ,\n    Chad: 'td' ,\n    Togo: 'tg' ,\n    Thailand: 'th' ,\n    Tajikistan: 'tj' ,\n    Turkmenistan: 'tm' ,\n    TimorLeste: 'tl' ,\n    Tonga: 'to' ,\n    TrinidadAndTobago: 'tt' ,\n    Tunisia: 'tn' ,\n    Turkey: 'tr' ,\n    Tuvalu: 'tv' ,\n    Tanzania: 'tz' ,\n    Uganda: 'ug' ,\n    Ukraine: 'ua' ,\n    Uruguay: 'uy' ,\n    UnitedStates: 'us' ,\n    Uzbekistan: 'uz' ,\n    VaticanCity: 'va' ,\n    SaintVincentAndTheGrenadines: 'vc' ,\n    Venezuela: 've' ,\n    Vietnam: 'vn' ,\n    Vanuatu: 'vu' ,\n    Samoa: 'ws' ,\n    Yemen: 'ye' ,\n    SouthAfrica: 'za' ,\n    Zambia: 'zm' ,\n    Zimbabwe: 'zw' \n});\n\nmodule.exports = Flag;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvbm9kZS1hcHB3cml0ZS9saWIvZW51bXMvZmxhZy5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vanNtX2JhbmtpbmcvLi9ub2RlX21vZHVsZXMvbm9kZS1hcHB3cml0ZS9saWIvZW51bXMvZmxhZy5qcz9hNmI2Il0sInNvdXJjZXNDb250ZW50IjpbImNvbnN0IEZsYWcgPSBPYmplY3QuZnJlZXplKHtcbiAgICBBZmdoYW5pc3RhbjogJ2FmJyAsXG4gICAgQW5nb2xhOiAnYW8nICxcbiAgICBBbGJhbmlhOiAnYWwnICxcbiAgICBBbmRvcnJhOiAnYWQnICxcbiAgICBVbml0ZWRBcmFiRW1pcmF0ZXM6ICdhZScgLFxuICAgIEFyZ2VudGluYTogJ2FyJyAsXG4gICAgQXJtZW5pYTogJ2FtJyAsXG4gICAgQW50aWd1YUFuZEJhcmJ1ZGE6ICdhZycgLFxuICAgIEF1c3RyYWxpYTogJ2F1JyAsXG4gICAgQXVzdHJpYTogJ2F0JyAsXG4gICAgQXplcmJhaWphbjogJ2F6JyAsXG4gICAgQnVydW5kaTogJ2JpJyAsXG4gICAgQmVsZ2l1bTogJ2JlJyAsXG4gICAgQmVuaW46ICdiaicgLFxuICAgIEJ1cmtpbmFGYXNvOiAnYmYnICxcbiAgICBCYW5nbGFkZXNoOiAnYmQnICxcbiAgICBCdWxnYXJpYTogJ2JnJyAsXG4gICAgQmFocmFpbjogJ2JoJyAsXG4gICAgQmFoYW1hczogJ2JzJyAsXG4gICAgQm9zbmlhQW5kSGVyemVnb3ZpbmE6ICdiYScgLFxuICAgIEJlbGFydXM6ICdieScgLFxuICAgIEJlbGl6ZTogJ2J6JyAsXG4gICAgQm9saXZpYTogJ2JvJyAsXG4gICAgQnJhemlsOiAnYnInICxcbiAgICBCYXJiYWRvczogJ2JiJyAsXG4gICAgQnJ1bmVpRGFydXNzYWxhbTogJ2JuJyAsXG4gICAgQmh1dGFuOiAnYnQnICxcbiAgICBCb3Rzd2FuYTogJ2J3JyAsXG4gICAgQ2VudHJhbEFmcmljYW5SZXB1YmxpYzogJ2NmJyAsXG4gICAgQ2FuYWRhOiAnY2EnICxcbiAgICBTd2l0emVybGFuZDogJ2NoJyAsXG4gICAgQ2hpbGU6ICdjbCcgLFxuICAgIENoaW5hOiAnY24nICxcbiAgICBDb3RlREl2b2lyZTogJ2NpJyAsXG4gICAgQ2FtZXJvb246ICdjbScgLFxuICAgIERlbW9jcmF0aWNSZXB1YmxpY09mVGhlQ29uZ286ICdjZCcgLFxuICAgIFJlcHVibGljT2ZUaGVDb25nbzogJ2NnJyAsXG4gICAgQ29sb21iaWE6ICdjbycgLFxuICAgIENvbW9yb3M6ICdrbScgLFxuICAgIENhcGVWZXJkZTogJ2N2JyAsXG4gICAgQ29zdGFSaWNhOiAnY3InICxcbiAgICBDdWJhOiAnY3UnICxcbiAgICBDeXBydXM6ICdjeScgLFxuICAgIEN6ZWNoUmVwdWJsaWM6ICdjeicgLFxuICAgIEdlcm1hbnk6ICdkZScgLFxuICAgIERqaWJvdXRpOiAnZGonICxcbiAgICBEb21pbmljYTogJ2RtJyAsXG4gICAgRGVubWFyazogJ2RrJyAsXG4gICAgRG9taW5pY2FuUmVwdWJsaWM6ICdkbycgLFxuICAgIEFsZ2VyaWE6ICdkeicgLFxuICAgIEVjdWFkb3I6ICdlYycgLFxuICAgIEVneXB0OiAnZWcnICxcbiAgICBFcml0cmVhOiAnZXInICxcbiAgICBTcGFpbjogJ2VzJyAsXG4gICAgRXN0b25pYTogJ2VlJyAsXG4gICAgRXRoaW9waWE6ICdldCcgLFxuICAgIEZpbmxhbmQ6ICdmaScgLFxuICAgIEZpamk6ICdmaicgLFxuICAgIEZyYW5jZTogJ2ZyJyAsXG4gICAgTWljcm9uZXNpYUZlZGVyYXRlZFN0YXRlc09mOiAnZm0nICxcbiAgICBHYWJvbjogJ2dhJyAsXG4gICAgVW5pdGVkS2luZ2RvbTogJ2diJyAsXG4gICAgR2VvcmdpYTogJ2dlJyAsXG4gICAgR2hhbmE6ICdnaCcgLFxuICAgIEd1aW5lYTogJ2duJyAsXG4gICAgR2FtYmlhOiAnZ20nICxcbiAgICBHdWluZWFCaXNzYXU6ICdndycgLFxuICAgIEVxdWF0b3JpYWxHdWluZWE6ICdncScgLFxuICAgIEdyZWVjZTogJ2dyJyAsXG4gICAgR3JlbmFkYTogJ2dkJyAsXG4gICAgR3VhdGVtYWxhOiAnZ3QnICxcbiAgICBHdXlhbmE6ICdneScgLFxuICAgIEhvbmR1cmFzOiAnaG4nICxcbiAgICBDcm9hdGlhOiAnaHInICxcbiAgICBIYWl0aTogJ2h0JyAsXG4gICAgSHVuZ2FyeTogJ2h1JyAsXG4gICAgSW5kb25lc2lhOiAnaWQnICxcbiAgICBJbmRpYTogJ2luJyAsXG4gICAgSXJlbGFuZDogJ2llJyAsXG4gICAgSXJhbklzbGFtaWNSZXB1YmxpY09mOiAnaXInICxcbiAgICBJcmFxOiAnaXEnICxcbiAgICBJY2VsYW5kOiAnaXMnICxcbiAgICBJc3JhZWw6ICdpbCcgLFxuICAgIEl0YWx5OiAnaXQnICxcbiAgICBKYW1haWNhOiAnam0nICxcbiAgICBKb3JkYW46ICdqbycgLFxuICAgIEphcGFuOiAnanAnICxcbiAgICBLYXpha2hzdGFuOiAna3onICxcbiAgICBLZW55YTogJ2tlJyAsXG4gICAgS3lyZ3l6c3RhbjogJ2tnJyAsXG4gICAgQ2FtYm9kaWE6ICdraCcgLFxuICAgIEtpcmliYXRpOiAna2knICxcbiAgICBTYWludEtpdHRzQW5kTmV2aXM6ICdrbicgLFxuICAgIFNvdXRoS29yZWE6ICdrcicgLFxuICAgIEt1d2FpdDogJ2t3JyAsXG4gICAgTGFvUGVvcGxlU0RlbW9jcmF0aWNSZXB1YmxpYzogJ2xhJyAsXG4gICAgTGViYW5vbjogJ2xiJyAsXG4gICAgTGliZXJpYTogJ2xyJyAsXG4gICAgTGlieWE6ICdseScgLFxuICAgIFNhaW50THVjaWE6ICdsYycgLFxuICAgIExpZWNodGVuc3RlaW46ICdsaScgLFxuICAgIFNyaUxhbmthOiAnbGsnICxcbiAgICBMZXNvdGhvOiAnbHMnICxcbiAgICBMaXRodWFuaWE6ICdsdCcgLFxuICAgIEx1eGVtYm91cmc6ICdsdScgLFxuICAgIExhdHZpYTogJ2x2JyAsXG4gICAgTW9yb2NjbzogJ21hJyAsXG4gICAgTW9uYWNvOiAnbWMnICxcbiAgICBNb2xkb3ZhOiAnbWQnICxcbiAgICBNYWRhZ2FzY2FyOiAnbWcnICxcbiAgICBNYWxkaXZlczogJ212JyAsXG4gICAgTWV4aWNvOiAnbXgnICxcbiAgICBNYXJzaGFsbElzbGFuZHM6ICdtaCcgLFxuICAgIE5vcnRoTWFjZWRvbmlhOiAnbWsnICxcbiAgICBNYWxpOiAnbWwnICxcbiAgICBNYWx0YTogJ210JyAsXG4gICAgTXlhbm1hcjogJ21tJyAsXG4gICAgTW9udGVuZWdybzogJ21lJyAsXG4gICAgTW9uZ29saWE6ICdtbicgLFxuICAgIE1vemFtYmlxdWU6ICdteicgLFxuICAgIE1hdXJpdGFuaWE6ICdtcicgLFxuICAgIE1hdXJpdGl1czogJ211JyAsXG4gICAgTWFsYXdpOiAnbXcnICxcbiAgICBNYWxheXNpYTogJ215JyAsXG4gICAgTmFtaWJpYTogJ25hJyAsXG4gICAgTmlnZXI6ICduZScgLFxuICAgIE5pZ2VyaWE6ICduZycgLFxuICAgIE5pY2FyYWd1YTogJ25pJyAsXG4gICAgTmV0aGVybGFuZHM6ICdubCcgLFxuICAgIE5vcndheTogJ25vJyAsXG4gICAgTmVwYWw6ICducCcgLFxuICAgIE5hdXJ1OiAnbnInICxcbiAgICBOZXdaZWFsYW5kOiAnbnonICxcbiAgICBPbWFuOiAnb20nICxcbiAgICBQYWtpc3RhbjogJ3BrJyAsXG4gICAgUGFuYW1hOiAncGEnICxcbiAgICBQZXJ1OiAncGUnICxcbiAgICBQaGlsaXBwaW5lczogJ3BoJyAsXG4gICAgUGFsYXU6ICdwdycgLFxuICAgIFBhcHVhTmV3R3VpbmVhOiAncGcnICxcbiAgICBQb2xhbmQ6ICdwbCcgLFxuICAgIE5vcnRoS29yZWE6ICdrcCcgLFxuICAgIFBvcnR1Z2FsOiAncHQnICxcbiAgICBQYXJhZ3VheTogJ3B5JyAsXG4gICAgUWF0YXI6ICdxYScgLFxuICAgIFJvbWFuaWE6ICdybycgLFxuICAgIFJ1c3NpYTogJ3J1JyAsXG4gICAgUndhbmRhOiAncncnICxcbiAgICBTYXVkaUFyYWJpYTogJ3NhJyAsXG4gICAgU3VkYW46ICdzZCcgLFxuICAgIFNlbmVnYWw6ICdzbicgLFxuICAgIFNpbmdhcG9yZTogJ3NnJyAsXG4gICAgU29sb21vbklzbGFuZHM6ICdzYicgLFxuICAgIFNpZXJyYUxlb25lOiAnc2wnICxcbiAgICBFbFNhbHZhZG9yOiAnc3YnICxcbiAgICBTYW5NYXJpbm86ICdzbScgLFxuICAgIFNvbWFsaWE6ICdzbycgLFxuICAgIFNlcmJpYTogJ3JzJyAsXG4gICAgU291dGhTdWRhbjogJ3NzJyAsXG4gICAgU2FvVG9tZUFuZFByaW5jaXBlOiAnc3QnICxcbiAgICBTdXJpbmFtZTogJ3NyJyAsXG4gICAgU2xvdmFraWE6ICdzaycgLFxuICAgIFNsb3ZlbmlhOiAnc2knICxcbiAgICBTd2VkZW46ICdzZScgLFxuICAgIEVzd2F0aW5pOiAnc3onICxcbiAgICBTZXljaGVsbGVzOiAnc2MnICxcbiAgICBTeXJpYTogJ3N5JyAsXG4gICAgQ2hhZDogJ3RkJyAsXG4gICAgVG9nbzogJ3RnJyAsXG4gICAgVGhhaWxhbmQ6ICd0aCcgLFxuICAgIFRhamlraXN0YW46ICd0aicgLFxuICAgIFR1cmttZW5pc3RhbjogJ3RtJyAsXG4gICAgVGltb3JMZXN0ZTogJ3RsJyAsXG4gICAgVG9uZ2E6ICd0bycgLFxuICAgIFRyaW5pZGFkQW5kVG9iYWdvOiAndHQnICxcbiAgICBUdW5pc2lhOiAndG4nICxcbiAgICBUdXJrZXk6ICd0cicgLFxuICAgIFR1dmFsdTogJ3R2JyAsXG4gICAgVGFuemFuaWE6ICd0eicgLFxuICAgIFVnYW5kYTogJ3VnJyAsXG4gICAgVWtyYWluZTogJ3VhJyAsXG4gICAgVXJ1Z3VheTogJ3V5JyAsXG4gICAgVW5pdGVkU3RhdGVzOiAndXMnICxcbiAgICBVemJla2lzdGFuOiAndXonICxcbiAgICBWYXRpY2FuQ2l0eTogJ3ZhJyAsXG4gICAgU2FpbnRWaW5jZW50QW5kVGhlR3JlbmFkaW5lczogJ3ZjJyAsXG4gICAgVmVuZXp1ZWxhOiAndmUnICxcbiAgICBWaWV0bmFtOiAndm4nICxcbiAgICBWYW51YXR1OiAndnUnICxcbiAgICBTYW1vYTogJ3dzJyAsXG4gICAgWWVtZW46ICd5ZScgLFxuICAgIFNvdXRoQWZyaWNhOiAnemEnICxcbiAgICBaYW1iaWE6ICd6bScgLFxuICAgIFppbWJhYndlOiAnencnIFxufSk7XG5cbm1vZHVsZS5leHBvcnRzID0gRmxhZzsiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/node-appwrite/lib/enums/flag.js\n");

/***/ }),

/***/ "(action-browser)/./node_modules/node-appwrite/lib/enums/image-format.js":
/*!**************************************************************!*\
  !*** ./node_modules/node-appwrite/lib/enums/image-format.js ***!
  \**************************************************************/
/***/ ((module) => {

eval("const ImageFormat = Object.freeze({\n    Jpg: 'jpg' ,\n    Jpeg: 'jpeg' ,\n    Gif: 'gif' ,\n    Png: 'png' ,\n    Webp: 'webp' \n});\n\nmodule.exports = ImageFormat;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFjdGlvbi1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9ub2RlLWFwcHdyaXRlL2xpYi9lbnVtcy9pbWFnZS1mb3JtYXQuanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRCIsInNvdXJjZXMiOlsid2VicGFjazovL2pzbV9iYW5raW5nLy4vbm9kZV9tb2R1bGVzL25vZGUtYXBwd3JpdGUvbGliL2VudW1zL2ltYWdlLWZvcm1hdC5qcz9mMmM5Il0sInNvdXJjZXNDb250ZW50IjpbImNvbnN0IEltYWdlRm9ybWF0ID0gT2JqZWN0LmZyZWV6ZSh7XG4gICAgSnBnOiAnanBnJyAsXG4gICAgSnBlZzogJ2pwZWcnICxcbiAgICBHaWY6ICdnaWYnICxcbiAgICBQbmc6ICdwbmcnICxcbiAgICBXZWJwOiAnd2VicCcgXG59KTtcblxubW9kdWxlLmV4cG9ydHMgPSBJbWFnZUZvcm1hdDsiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(action-browser)/./node_modules/node-appwrite/lib/enums/image-format.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/node-appwrite/lib/enums/image-format.js":
/*!**************************************************************!*\
  !*** ./node_modules/node-appwrite/lib/enums/image-format.js ***!
  \**************************************************************/
/***/ ((module) => {

eval("const ImageFormat = Object.freeze({\n    Jpg: 'jpg' ,\n    Jpeg: 'jpeg' ,\n    Gif: 'gif' ,\n    Png: 'png' ,\n    Webp: 'webp' \n});\n\nmodule.exports = ImageFormat;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvbm9kZS1hcHB3cml0ZS9saWIvZW51bXMvaW1hZ2UtZm9ybWF0LmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9qc21fYmFua2luZy8uL25vZGVfbW9kdWxlcy9ub2RlLWFwcHdyaXRlL2xpYi9lbnVtcy9pbWFnZS1mb3JtYXQuanM/YzQ5NiJdLCJzb3VyY2VzQ29udGVudCI6WyJjb25zdCBJbWFnZUZvcm1hdCA9IE9iamVjdC5mcmVlemUoe1xuICAgIEpwZzogJ2pwZycgLFxuICAgIEpwZWc6ICdqcGVnJyAsXG4gICAgR2lmOiAnZ2lmJyAsXG4gICAgUG5nOiAncG5nJyAsXG4gICAgV2VicDogJ3dlYnAnIFxufSk7XG5cbm1vZHVsZS5leHBvcnRzID0gSW1hZ2VGb3JtYXQ7Il0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/node-appwrite/lib/enums/image-format.js\n");

/***/ }),

/***/ "(action-browser)/./node_modules/node-appwrite/lib/enums/image-gravity.js":
/*!***************************************************************!*\
  !*** ./node_modules/node-appwrite/lib/enums/image-gravity.js ***!
  \***************************************************************/
/***/ ((module) => {

eval("const ImageGravity = Object.freeze({\n    Center: 'center' ,\n    TopLeft: 'top-left' ,\n    Top: 'top' ,\n    TopRight: 'top-right' ,\n    Left: 'left' ,\n    Right: 'right' ,\n    BottomLeft: 'bottom-left' ,\n    Bottom: 'bottom' ,\n    BottomRight: 'bottom-right' \n});\n\nmodule.exports = ImageGravity;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFjdGlvbi1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9ub2RlLWFwcHdyaXRlL2xpYi9lbnVtcy9pbWFnZS1ncmF2aXR5LmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRCIsInNvdXJjZXMiOlsid2VicGFjazovL2pzbV9iYW5raW5nLy4vbm9kZV9tb2R1bGVzL25vZGUtYXBwd3JpdGUvbGliL2VudW1zL2ltYWdlLWdyYXZpdHkuanM/ZTVlNSJdLCJzb3VyY2VzQ29udGVudCI6WyJjb25zdCBJbWFnZUdyYXZpdHkgPSBPYmplY3QuZnJlZXplKHtcbiAgICBDZW50ZXI6ICdjZW50ZXInICxcbiAgICBUb3BMZWZ0OiAndG9wLWxlZnQnICxcbiAgICBUb3A6ICd0b3AnICxcbiAgICBUb3BSaWdodDogJ3RvcC1yaWdodCcgLFxuICAgIExlZnQ6ICdsZWZ0JyAsXG4gICAgUmlnaHQ6ICdyaWdodCcgLFxuICAgIEJvdHRvbUxlZnQ6ICdib3R0b20tbGVmdCcgLFxuICAgIEJvdHRvbTogJ2JvdHRvbScgLFxuICAgIEJvdHRvbVJpZ2h0OiAnYm90dG9tLXJpZ2h0JyBcbn0pO1xuXG5tb2R1bGUuZXhwb3J0cyA9IEltYWdlR3Jhdml0eTsiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(action-browser)/./node_modules/node-appwrite/lib/enums/image-gravity.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/node-appwrite/lib/enums/image-gravity.js":
/*!***************************************************************!*\
  !*** ./node_modules/node-appwrite/lib/enums/image-gravity.js ***!
  \***************************************************************/
/***/ ((module) => {

eval("const ImageGravity = Object.freeze({\n    Center: 'center' ,\n    TopLeft: 'top-left' ,\n    Top: 'top' ,\n    TopRight: 'top-right' ,\n    Left: 'left' ,\n    Right: 'right' ,\n    BottomLeft: 'bottom-left' ,\n    Bottom: 'bottom' ,\n    BottomRight: 'bottom-right' \n});\n\nmodule.exports = ImageGravity;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvbm9kZS1hcHB3cml0ZS9saWIvZW51bXMvaW1hZ2UtZ3Jhdml0eS5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9qc21fYmFua2luZy8uL25vZGVfbW9kdWxlcy9ub2RlLWFwcHdyaXRlL2xpYi9lbnVtcy9pbWFnZS1ncmF2aXR5LmpzP2YzNDIiXSwic291cmNlc0NvbnRlbnQiOlsiY29uc3QgSW1hZ2VHcmF2aXR5ID0gT2JqZWN0LmZyZWV6ZSh7XG4gICAgQ2VudGVyOiAnY2VudGVyJyAsXG4gICAgVG9wTGVmdDogJ3RvcC1sZWZ0JyAsXG4gICAgVG9wOiAndG9wJyAsXG4gICAgVG9wUmlnaHQ6ICd0b3AtcmlnaHQnICxcbiAgICBMZWZ0OiAnbGVmdCcgLFxuICAgIFJpZ2h0OiAncmlnaHQnICxcbiAgICBCb3R0b21MZWZ0OiAnYm90dG9tLWxlZnQnICxcbiAgICBCb3R0b206ICdib3R0b20nICxcbiAgICBCb3R0b21SaWdodDogJ2JvdHRvbS1yaWdodCcgXG59KTtcblxubW9kdWxlLmV4cG9ydHMgPSBJbWFnZUdyYXZpdHk7Il0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/node-appwrite/lib/enums/image-gravity.js\n");

/***/ }),

/***/ "(action-browser)/./node_modules/node-appwrite/lib/enums/index-type.js":
/*!************************************************************!*\
  !*** ./node_modules/node-appwrite/lib/enums/index-type.js ***!
  \************************************************************/
/***/ ((module) => {

eval("const IndexType = Object.freeze({\n    Key: 'key' ,\n    Fulltext: 'fulltext' ,\n    Unique: 'unique' \n});\n\nmodule.exports = IndexType;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFjdGlvbi1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9ub2RlLWFwcHdyaXRlL2xpYi9lbnVtcy9pbmRleC10eXBlLmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRCIsInNvdXJjZXMiOlsid2VicGFjazovL2pzbV9iYW5raW5nLy4vbm9kZV9tb2R1bGVzL25vZGUtYXBwd3JpdGUvbGliL2VudW1zL2luZGV4LXR5cGUuanM/Yzk4MCJdLCJzb3VyY2VzQ29udGVudCI6WyJjb25zdCBJbmRleFR5cGUgPSBPYmplY3QuZnJlZXplKHtcbiAgICBLZXk6ICdrZXknICxcbiAgICBGdWxsdGV4dDogJ2Z1bGx0ZXh0JyAsXG4gICAgVW5pcXVlOiAndW5pcXVlJyBcbn0pO1xuXG5tb2R1bGUuZXhwb3J0cyA9IEluZGV4VHlwZTsiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(action-browser)/./node_modules/node-appwrite/lib/enums/index-type.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/node-appwrite/lib/enums/index-type.js":
/*!************************************************************!*\
  !*** ./node_modules/node-appwrite/lib/enums/index-type.js ***!
  \************************************************************/
/***/ ((module) => {

eval("const IndexType = Object.freeze({\n    Key: 'key' ,\n    Fulltext: 'fulltext' ,\n    Unique: 'unique' \n});\n\nmodule.exports = IndexType;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvbm9kZS1hcHB3cml0ZS9saWIvZW51bXMvaW5kZXgtdHlwZS5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9qc21fYmFua2luZy8uL25vZGVfbW9kdWxlcy9ub2RlLWFwcHdyaXRlL2xpYi9lbnVtcy9pbmRleC10eXBlLmpzPzkwNDIiXSwic291cmNlc0NvbnRlbnQiOlsiY29uc3QgSW5kZXhUeXBlID0gT2JqZWN0LmZyZWV6ZSh7XG4gICAgS2V5OiAna2V5JyAsXG4gICAgRnVsbHRleHQ6ICdmdWxsdGV4dCcgLFxuICAgIFVuaXF1ZTogJ3VuaXF1ZScgXG59KTtcblxubW9kdWxlLmV4cG9ydHMgPSBJbmRleFR5cGU7Il0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/node-appwrite/lib/enums/index-type.js\n");

/***/ }),

/***/ "(action-browser)/./node_modules/node-appwrite/lib/enums/messaging-provider-type.js":
/*!*************************************************************************!*\
  !*** ./node_modules/node-appwrite/lib/enums/messaging-provider-type.js ***!
  \*************************************************************************/
/***/ ((module) => {

eval("const MessagingProviderType = Object.freeze({\n    Email: 'email' ,\n    Sms: 'sms' ,\n    Push: 'push' \n});\n\nmodule.exports = MessagingProviderType;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFjdGlvbi1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9ub2RlLWFwcHdyaXRlL2xpYi9lbnVtcy9tZXNzYWdpbmctcHJvdmlkZXItdHlwZS5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9qc21fYmFua2luZy8uL25vZGVfbW9kdWxlcy9ub2RlLWFwcHdyaXRlL2xpYi9lbnVtcy9tZXNzYWdpbmctcHJvdmlkZXItdHlwZS5qcz82OGJhIl0sInNvdXJjZXNDb250ZW50IjpbImNvbnN0IE1lc3NhZ2luZ1Byb3ZpZGVyVHlwZSA9IE9iamVjdC5mcmVlemUoe1xuICAgIEVtYWlsOiAnZW1haWwnICxcbiAgICBTbXM6ICdzbXMnICxcbiAgICBQdXNoOiAncHVzaCcgXG59KTtcblxubW9kdWxlLmV4cG9ydHMgPSBNZXNzYWdpbmdQcm92aWRlclR5cGU7Il0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(action-browser)/./node_modules/node-appwrite/lib/enums/messaging-provider-type.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/node-appwrite/lib/enums/messaging-provider-type.js":
/*!*************************************************************************!*\
  !*** ./node_modules/node-appwrite/lib/enums/messaging-provider-type.js ***!
  \*************************************************************************/
/***/ ((module) => {

eval("const MessagingProviderType = Object.freeze({\n    Email: 'email' ,\n    Sms: 'sms' ,\n    Push: 'push' \n});\n\nmodule.exports = MessagingProviderType;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvbm9kZS1hcHB3cml0ZS9saWIvZW51bXMvbWVzc2FnaW5nLXByb3ZpZGVyLXR5cGUuanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vanNtX2JhbmtpbmcvLi9ub2RlX21vZHVsZXMvbm9kZS1hcHB3cml0ZS9saWIvZW51bXMvbWVzc2FnaW5nLXByb3ZpZGVyLXR5cGUuanM/YThiNiJdLCJzb3VyY2VzQ29udGVudCI6WyJjb25zdCBNZXNzYWdpbmdQcm92aWRlclR5cGUgPSBPYmplY3QuZnJlZXplKHtcbiAgICBFbWFpbDogJ2VtYWlsJyAsXG4gICAgU21zOiAnc21zJyAsXG4gICAgUHVzaDogJ3B1c2gnIFxufSk7XG5cbm1vZHVsZS5leHBvcnRzID0gTWVzc2FnaW5nUHJvdmlkZXJUeXBlOyJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/node-appwrite/lib/enums/messaging-provider-type.js\n");

/***/ }),

/***/ "(action-browser)/./node_modules/node-appwrite/lib/enums/name.js":
/*!******************************************************!*\
  !*** ./node_modules/node-appwrite/lib/enums/name.js ***!
  \******************************************************/
/***/ ((module) => {

eval("const Name = Object.freeze({\n    V1Database: 'v1-database' ,\n    V1Deletes: 'v1-deletes' ,\n    V1Audits: 'v1-audits' ,\n    V1Mails: 'v1-mails' ,\n    V1Functions: 'v1-functions' ,\n    V1Usage: 'v1-usage' ,\n    V1UsageDump: 'v1-usage-dump' ,\n    Webhooksv1: 'webhooksv1' ,\n    V1Certificates: 'v1-certificates' ,\n    V1Builds: 'v1-builds' ,\n    V1Messaging: 'v1-messaging' ,\n    V1Migrations: 'v1-migrations' ,\n    Hamsterv1: 'hamsterv1' \n});\n\nmodule.exports = Name;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFjdGlvbi1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9ub2RlLWFwcHdyaXRlL2xpYi9lbnVtcy9uYW1lLmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vanNtX2JhbmtpbmcvLi9ub2RlX21vZHVsZXMvbm9kZS1hcHB3cml0ZS9saWIvZW51bXMvbmFtZS5qcz80ODNiIl0sInNvdXJjZXNDb250ZW50IjpbImNvbnN0IE5hbWUgPSBPYmplY3QuZnJlZXplKHtcbiAgICBWMURhdGFiYXNlOiAndjEtZGF0YWJhc2UnICxcbiAgICBWMURlbGV0ZXM6ICd2MS1kZWxldGVzJyAsXG4gICAgVjFBdWRpdHM6ICd2MS1hdWRpdHMnICxcbiAgICBWMU1haWxzOiAndjEtbWFpbHMnICxcbiAgICBWMUZ1bmN0aW9uczogJ3YxLWZ1bmN0aW9ucycgLFxuICAgIFYxVXNhZ2U6ICd2MS11c2FnZScgLFxuICAgIFYxVXNhZ2VEdW1wOiAndjEtdXNhZ2UtZHVtcCcgLFxuICAgIFdlYmhvb2tzdjE6ICd3ZWJob29rc3YxJyAsXG4gICAgVjFDZXJ0aWZpY2F0ZXM6ICd2MS1jZXJ0aWZpY2F0ZXMnICxcbiAgICBWMUJ1aWxkczogJ3YxLWJ1aWxkcycgLFxuICAgIFYxTWVzc2FnaW5nOiAndjEtbWVzc2FnaW5nJyAsXG4gICAgVjFNaWdyYXRpb25zOiAndjEtbWlncmF0aW9ucycgLFxuICAgIEhhbXN0ZXJ2MTogJ2hhbXN0ZXJ2MScgXG59KTtcblxubW9kdWxlLmV4cG9ydHMgPSBOYW1lOyJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(action-browser)/./node_modules/node-appwrite/lib/enums/name.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/node-appwrite/lib/enums/name.js":
/*!******************************************************!*\
  !*** ./node_modules/node-appwrite/lib/enums/name.js ***!
  \******************************************************/
/***/ ((module) => {

eval("const Name = Object.freeze({\n    V1Database: 'v1-database' ,\n    V1Deletes: 'v1-deletes' ,\n    V1Audits: 'v1-audits' ,\n    V1Mails: 'v1-mails' ,\n    V1Functions: 'v1-functions' ,\n    V1Usage: 'v1-usage' ,\n    V1UsageDump: 'v1-usage-dump' ,\n    Webhooksv1: 'webhooksv1' ,\n    V1Certificates: 'v1-certificates' ,\n    V1Builds: 'v1-builds' ,\n    V1Messaging: 'v1-messaging' ,\n    V1Migrations: 'v1-migrations' ,\n    Hamsterv1: 'hamsterv1' \n});\n\nmodule.exports = Name;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvbm9kZS1hcHB3cml0ZS9saWIvZW51bXMvbmFtZS5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRCIsInNvdXJjZXMiOlsid2VicGFjazovL2pzbV9iYW5raW5nLy4vbm9kZV9tb2R1bGVzL25vZGUtYXBwd3JpdGUvbGliL2VudW1zL25hbWUuanM/ODgwYiJdLCJzb3VyY2VzQ29udGVudCI6WyJjb25zdCBOYW1lID0gT2JqZWN0LmZyZWV6ZSh7XG4gICAgVjFEYXRhYmFzZTogJ3YxLWRhdGFiYXNlJyAsXG4gICAgVjFEZWxldGVzOiAndjEtZGVsZXRlcycgLFxuICAgIFYxQXVkaXRzOiAndjEtYXVkaXRzJyAsXG4gICAgVjFNYWlsczogJ3YxLW1haWxzJyAsXG4gICAgVjFGdW5jdGlvbnM6ICd2MS1mdW5jdGlvbnMnICxcbiAgICBWMVVzYWdlOiAndjEtdXNhZ2UnICxcbiAgICBWMVVzYWdlRHVtcDogJ3YxLXVzYWdlLWR1bXAnICxcbiAgICBXZWJob29rc3YxOiAnd2ViaG9va3N2MScgLFxuICAgIFYxQ2VydGlmaWNhdGVzOiAndjEtY2VydGlmaWNhdGVzJyAsXG4gICAgVjFCdWlsZHM6ICd2MS1idWlsZHMnICxcbiAgICBWMU1lc3NhZ2luZzogJ3YxLW1lc3NhZ2luZycgLFxuICAgIFYxTWlncmF0aW9uczogJ3YxLW1pZ3JhdGlvbnMnICxcbiAgICBIYW1zdGVydjE6ICdoYW1zdGVydjEnIFxufSk7XG5cbm1vZHVsZS5leHBvcnRzID0gTmFtZTsiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/node-appwrite/lib/enums/name.js\n");

/***/ }),

/***/ "(action-browser)/./node_modules/node-appwrite/lib/enums/o-auth-provider.js":
/*!*****************************************************************!*\
  !*** ./node_modules/node-appwrite/lib/enums/o-auth-provider.js ***!
  \*****************************************************************/
/***/ ((module) => {

eval("const OAuthProvider = Object.freeze({\n    Amazon: 'amazon' ,\n    Apple: 'apple' ,\n    Auth0: 'auth0' ,\n    Authentik: 'authentik' ,\n    Autodesk: 'autodesk' ,\n    Bitbucket: 'bitbucket' ,\n    Bitly: 'bitly' ,\n    Box: 'box' ,\n    Dailymotion: 'dailymotion' ,\n    Discord: 'discord' ,\n    Disqus: 'disqus' ,\n    Dropbox: 'dropbox' ,\n    Etsy: 'etsy' ,\n    Facebook: 'facebook' ,\n    Github: 'github' ,\n    Gitlab: 'gitlab' ,\n    Google: 'google' ,\n    Linkedin: 'linkedin' ,\n    Microsoft: 'microsoft' ,\n    Notion: 'notion' ,\n    Oidc: 'oidc' ,\n    Okta: 'okta' ,\n    Paypal: 'paypal' ,\n    PaypalSandbox: 'paypalSandbox' ,\n    Podio: 'podio' ,\n    Salesforce: 'salesforce' ,\n    Slack: 'slack' ,\n    Spotify: 'spotify' ,\n    Stripe: 'stripe' ,\n    Tradeshift: 'tradeshift' ,\n    TradeshiftBox: 'tradeshiftBox' ,\n    Twitch: 'twitch' ,\n    Wordpress: 'wordpress' ,\n    Yahoo: 'yahoo' ,\n    Yammer: 'yammer' ,\n    Yandex: 'yandex' ,\n    Zoho: 'zoho' ,\n    Zoom: 'zoom' ,\n    Mock: 'mock' \n});\n\nmodule.exports = OAuthProvider;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFjdGlvbi1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9ub2RlLWFwcHdyaXRlL2xpYi9lbnVtcy9vLWF1dGgtcHJvdmlkZXIuanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vanNtX2JhbmtpbmcvLi9ub2RlX21vZHVsZXMvbm9kZS1hcHB3cml0ZS9saWIvZW51bXMvby1hdXRoLXByb3ZpZGVyLmpzPzdiZDUiXSwic291cmNlc0NvbnRlbnQiOlsiY29uc3QgT0F1dGhQcm92aWRlciA9IE9iamVjdC5mcmVlemUoe1xuICAgIEFtYXpvbjogJ2FtYXpvbicgLFxuICAgIEFwcGxlOiAnYXBwbGUnICxcbiAgICBBdXRoMDogJ2F1dGgwJyAsXG4gICAgQXV0aGVudGlrOiAnYXV0aGVudGlrJyAsXG4gICAgQXV0b2Rlc2s6ICdhdXRvZGVzaycgLFxuICAgIEJpdGJ1Y2tldDogJ2JpdGJ1Y2tldCcgLFxuICAgIEJpdGx5OiAnYml0bHknICxcbiAgICBCb3g6ICdib3gnICxcbiAgICBEYWlseW1vdGlvbjogJ2RhaWx5bW90aW9uJyAsXG4gICAgRGlzY29yZDogJ2Rpc2NvcmQnICxcbiAgICBEaXNxdXM6ICdkaXNxdXMnICxcbiAgICBEcm9wYm94OiAnZHJvcGJveCcgLFxuICAgIEV0c3k6ICdldHN5JyAsXG4gICAgRmFjZWJvb2s6ICdmYWNlYm9vaycgLFxuICAgIEdpdGh1YjogJ2dpdGh1YicgLFxuICAgIEdpdGxhYjogJ2dpdGxhYicgLFxuICAgIEdvb2dsZTogJ2dvb2dsZScgLFxuICAgIExpbmtlZGluOiAnbGlua2VkaW4nICxcbiAgICBNaWNyb3NvZnQ6ICdtaWNyb3NvZnQnICxcbiAgICBOb3Rpb246ICdub3Rpb24nICxcbiAgICBPaWRjOiAnb2lkYycgLFxuICAgIE9rdGE6ICdva3RhJyAsXG4gICAgUGF5cGFsOiAncGF5cGFsJyAsXG4gICAgUGF5cGFsU2FuZGJveDogJ3BheXBhbFNhbmRib3gnICxcbiAgICBQb2RpbzogJ3BvZGlvJyAsXG4gICAgU2FsZXNmb3JjZTogJ3NhbGVzZm9yY2UnICxcbiAgICBTbGFjazogJ3NsYWNrJyAsXG4gICAgU3BvdGlmeTogJ3Nwb3RpZnknICxcbiAgICBTdHJpcGU6ICdzdHJpcGUnICxcbiAgICBUcmFkZXNoaWZ0OiAndHJhZGVzaGlmdCcgLFxuICAgIFRyYWRlc2hpZnRCb3g6ICd0cmFkZXNoaWZ0Qm94JyAsXG4gICAgVHdpdGNoOiAndHdpdGNoJyAsXG4gICAgV29yZHByZXNzOiAnd29yZHByZXNzJyAsXG4gICAgWWFob286ICd5YWhvbycgLFxuICAgIFlhbW1lcjogJ3lhbW1lcicgLFxuICAgIFlhbmRleDogJ3lhbmRleCcgLFxuICAgIFpvaG86ICd6b2hvJyAsXG4gICAgWm9vbTogJ3pvb20nICxcbiAgICBNb2NrOiAnbW9jaycgXG59KTtcblxubW9kdWxlLmV4cG9ydHMgPSBPQXV0aFByb3ZpZGVyOyJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(action-browser)/./node_modules/node-appwrite/lib/enums/o-auth-provider.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/node-appwrite/lib/enums/o-auth-provider.js":
/*!*****************************************************************!*\
  !*** ./node_modules/node-appwrite/lib/enums/o-auth-provider.js ***!
  \*****************************************************************/
/***/ ((module) => {

eval("const OAuthProvider = Object.freeze({\n    Amazon: 'amazon' ,\n    Apple: 'apple' ,\n    Auth0: 'auth0' ,\n    Authentik: 'authentik' ,\n    Autodesk: 'autodesk' ,\n    Bitbucket: 'bitbucket' ,\n    Bitly: 'bitly' ,\n    Box: 'box' ,\n    Dailymotion: 'dailymotion' ,\n    Discord: 'discord' ,\n    Disqus: 'disqus' ,\n    Dropbox: 'dropbox' ,\n    Etsy: 'etsy' ,\n    Facebook: 'facebook' ,\n    Github: 'github' ,\n    Gitlab: 'gitlab' ,\n    Google: 'google' ,\n    Linkedin: 'linkedin' ,\n    Microsoft: 'microsoft' ,\n    Notion: 'notion' ,\n    Oidc: 'oidc' ,\n    Okta: 'okta' ,\n    Paypal: 'paypal' ,\n    PaypalSandbox: 'paypalSandbox' ,\n    Podio: 'podio' ,\n    Salesforce: 'salesforce' ,\n    Slack: 'slack' ,\n    Spotify: 'spotify' ,\n    Stripe: 'stripe' ,\n    Tradeshift: 'tradeshift' ,\n    TradeshiftBox: 'tradeshiftBox' ,\n    Twitch: 'twitch' ,\n    Wordpress: 'wordpress' ,\n    Yahoo: 'yahoo' ,\n    Yammer: 'yammer' ,\n    Yandex: 'yandex' ,\n    Zoho: 'zoho' ,\n    Zoom: 'zoom' ,\n    Mock: 'mock' \n});\n\nmodule.exports = OAuthProvider;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvbm9kZS1hcHB3cml0ZS9saWIvZW51bXMvby1hdXRoLXByb3ZpZGVyLmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRCIsInNvdXJjZXMiOlsid2VicGFjazovL2pzbV9iYW5raW5nLy4vbm9kZV9tb2R1bGVzL25vZGUtYXBwd3JpdGUvbGliL2VudW1zL28tYXV0aC1wcm92aWRlci5qcz9mY2YzIl0sInNvdXJjZXNDb250ZW50IjpbImNvbnN0IE9BdXRoUHJvdmlkZXIgPSBPYmplY3QuZnJlZXplKHtcbiAgICBBbWF6b246ICdhbWF6b24nICxcbiAgICBBcHBsZTogJ2FwcGxlJyAsXG4gICAgQXV0aDA6ICdhdXRoMCcgLFxuICAgIEF1dGhlbnRpazogJ2F1dGhlbnRpaycgLFxuICAgIEF1dG9kZXNrOiAnYXV0b2Rlc2snICxcbiAgICBCaXRidWNrZXQ6ICdiaXRidWNrZXQnICxcbiAgICBCaXRseTogJ2JpdGx5JyAsXG4gICAgQm94OiAnYm94JyAsXG4gICAgRGFpbHltb3Rpb246ICdkYWlseW1vdGlvbicgLFxuICAgIERpc2NvcmQ6ICdkaXNjb3JkJyAsXG4gICAgRGlzcXVzOiAnZGlzcXVzJyAsXG4gICAgRHJvcGJveDogJ2Ryb3Bib3gnICxcbiAgICBFdHN5OiAnZXRzeScgLFxuICAgIEZhY2Vib29rOiAnZmFjZWJvb2snICxcbiAgICBHaXRodWI6ICdnaXRodWInICxcbiAgICBHaXRsYWI6ICdnaXRsYWInICxcbiAgICBHb29nbGU6ICdnb29nbGUnICxcbiAgICBMaW5rZWRpbjogJ2xpbmtlZGluJyAsXG4gICAgTWljcm9zb2Z0OiAnbWljcm9zb2Z0JyAsXG4gICAgTm90aW9uOiAnbm90aW9uJyAsXG4gICAgT2lkYzogJ29pZGMnICxcbiAgICBPa3RhOiAnb2t0YScgLFxuICAgIFBheXBhbDogJ3BheXBhbCcgLFxuICAgIFBheXBhbFNhbmRib3g6ICdwYXlwYWxTYW5kYm94JyAsXG4gICAgUG9kaW86ICdwb2RpbycgLFxuICAgIFNhbGVzZm9yY2U6ICdzYWxlc2ZvcmNlJyAsXG4gICAgU2xhY2s6ICdzbGFjaycgLFxuICAgIFNwb3RpZnk6ICdzcG90aWZ5JyAsXG4gICAgU3RyaXBlOiAnc3RyaXBlJyAsXG4gICAgVHJhZGVzaGlmdDogJ3RyYWRlc2hpZnQnICxcbiAgICBUcmFkZXNoaWZ0Qm94OiAndHJhZGVzaGlmdEJveCcgLFxuICAgIFR3aXRjaDogJ3R3aXRjaCcgLFxuICAgIFdvcmRwcmVzczogJ3dvcmRwcmVzcycgLFxuICAgIFlhaG9vOiAneWFob28nICxcbiAgICBZYW1tZXI6ICd5YW1tZXInICxcbiAgICBZYW5kZXg6ICd5YW5kZXgnICxcbiAgICBab2hvOiAnem9obycgLFxuICAgIFpvb206ICd6b29tJyAsXG4gICAgTW9jazogJ21vY2snIFxufSk7XG5cbm1vZHVsZS5leHBvcnRzID0gT0F1dGhQcm92aWRlcjsiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/node-appwrite/lib/enums/o-auth-provider.js\n");

/***/ }),

/***/ "(action-browser)/./node_modules/node-appwrite/lib/enums/password-hash.js":
/*!***************************************************************!*\
  !*** ./node_modules/node-appwrite/lib/enums/password-hash.js ***!
  \***************************************************************/
/***/ ((module) => {

eval("const PasswordHash = Object.freeze({\n    Sha1: 'sha1' ,\n    Sha224: 'sha224' ,\n    Sha256: 'sha256' ,\n    Sha384: 'sha384' ,\n    Sha512224: 'sha512/224' ,\n    Sha512256: 'sha512/256' ,\n    Sha512: 'sha512' ,\n    Sha3224: 'sha3-224' ,\n    Sha3256: 'sha3-256' ,\n    Sha3384: 'sha3-384' ,\n    Sha3512: 'sha3-512' \n});\n\nmodule.exports = PasswordHash;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFjdGlvbi1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9ub2RlLWFwcHdyaXRlL2xpYi9lbnVtcy9wYXNzd29yZC1oYXNoLmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9qc21fYmFua2luZy8uL25vZGVfbW9kdWxlcy9ub2RlLWFwcHdyaXRlL2xpYi9lbnVtcy9wYXNzd29yZC1oYXNoLmpzP2ZmOTEiXSwic291cmNlc0NvbnRlbnQiOlsiY29uc3QgUGFzc3dvcmRIYXNoID0gT2JqZWN0LmZyZWV6ZSh7XG4gICAgU2hhMTogJ3NoYTEnICxcbiAgICBTaGEyMjQ6ICdzaGEyMjQnICxcbiAgICBTaGEyNTY6ICdzaGEyNTYnICxcbiAgICBTaGEzODQ6ICdzaGEzODQnICxcbiAgICBTaGE1MTIyMjQ6ICdzaGE1MTIvMjI0JyAsXG4gICAgU2hhNTEyMjU2OiAnc2hhNTEyLzI1NicgLFxuICAgIFNoYTUxMjogJ3NoYTUxMicgLFxuICAgIFNoYTMyMjQ6ICdzaGEzLTIyNCcgLFxuICAgIFNoYTMyNTY6ICdzaGEzLTI1NicgLFxuICAgIFNoYTMzODQ6ICdzaGEzLTM4NCcgLFxuICAgIFNoYTM1MTI6ICdzaGEzLTUxMicgXG59KTtcblxubW9kdWxlLmV4cG9ydHMgPSBQYXNzd29yZEhhc2g7Il0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(action-browser)/./node_modules/node-appwrite/lib/enums/password-hash.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/node-appwrite/lib/enums/password-hash.js":
/*!***************************************************************!*\
  !*** ./node_modules/node-appwrite/lib/enums/password-hash.js ***!
  \***************************************************************/
/***/ ((module) => {

eval("const PasswordHash = Object.freeze({\n    Sha1: 'sha1' ,\n    Sha224: 'sha224' ,\n    Sha256: 'sha256' ,\n    Sha384: 'sha384' ,\n    Sha512224: 'sha512/224' ,\n    Sha512256: 'sha512/256' ,\n    Sha512: 'sha512' ,\n    Sha3224: 'sha3-224' ,\n    Sha3256: 'sha3-256' ,\n    Sha3384: 'sha3-384' ,\n    Sha3512: 'sha3-512' \n});\n\nmodule.exports = PasswordHash;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvbm9kZS1hcHB3cml0ZS9saWIvZW51bXMvcGFzc3dvcmQtaGFzaC5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vanNtX2JhbmtpbmcvLi9ub2RlX21vZHVsZXMvbm9kZS1hcHB3cml0ZS9saWIvZW51bXMvcGFzc3dvcmQtaGFzaC5qcz83ZGFkIl0sInNvdXJjZXNDb250ZW50IjpbImNvbnN0IFBhc3N3b3JkSGFzaCA9IE9iamVjdC5mcmVlemUoe1xuICAgIFNoYTE6ICdzaGExJyAsXG4gICAgU2hhMjI0OiAnc2hhMjI0JyAsXG4gICAgU2hhMjU2OiAnc2hhMjU2JyAsXG4gICAgU2hhMzg0OiAnc2hhMzg0JyAsXG4gICAgU2hhNTEyMjI0OiAnc2hhNTEyLzIyNCcgLFxuICAgIFNoYTUxMjI1NjogJ3NoYTUxMi8yNTYnICxcbiAgICBTaGE1MTI6ICdzaGE1MTInICxcbiAgICBTaGEzMjI0OiAnc2hhMy0yMjQnICxcbiAgICBTaGEzMjU2OiAnc2hhMy0yNTYnICxcbiAgICBTaGEzMzg0OiAnc2hhMy0zODQnICxcbiAgICBTaGEzNTEyOiAnc2hhMy01MTInIFxufSk7XG5cbm1vZHVsZS5leHBvcnRzID0gUGFzc3dvcmRIYXNoOyJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/node-appwrite/lib/enums/password-hash.js\n");

/***/ }),

/***/ "(action-browser)/./node_modules/node-appwrite/lib/enums/relation-mutate.js":
/*!*****************************************************************!*\
  !*** ./node_modules/node-appwrite/lib/enums/relation-mutate.js ***!
  \*****************************************************************/
/***/ ((module) => {

eval("const RelationMutate = Object.freeze({\n    Cascade: 'cascade' ,\n    Restrict: 'restrict' ,\n    SetNull: 'setNull' \n});\n\nmodule.exports = RelationMutate;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFjdGlvbi1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9ub2RlLWFwcHdyaXRlL2xpYi9lbnVtcy9yZWxhdGlvbi1tdXRhdGUuanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vanNtX2JhbmtpbmcvLi9ub2RlX21vZHVsZXMvbm9kZS1hcHB3cml0ZS9saWIvZW51bXMvcmVsYXRpb24tbXV0YXRlLmpzPzZjZjAiXSwic291cmNlc0NvbnRlbnQiOlsiY29uc3QgUmVsYXRpb25NdXRhdGUgPSBPYmplY3QuZnJlZXplKHtcbiAgICBDYXNjYWRlOiAnY2FzY2FkZScgLFxuICAgIFJlc3RyaWN0OiAncmVzdHJpY3QnICxcbiAgICBTZXROdWxsOiAnc2V0TnVsbCcgXG59KTtcblxubW9kdWxlLmV4cG9ydHMgPSBSZWxhdGlvbk11dGF0ZTsiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(action-browser)/./node_modules/node-appwrite/lib/enums/relation-mutate.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/node-appwrite/lib/enums/relation-mutate.js":
/*!*****************************************************************!*\
  !*** ./node_modules/node-appwrite/lib/enums/relation-mutate.js ***!
  \*****************************************************************/
/***/ ((module) => {

eval("const RelationMutate = Object.freeze({\n    Cascade: 'cascade' ,\n    Restrict: 'restrict' ,\n    SetNull: 'setNull' \n});\n\nmodule.exports = RelationMutate;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvbm9kZS1hcHB3cml0ZS9saWIvZW51bXMvcmVsYXRpb24tbXV0YXRlLmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRCIsInNvdXJjZXMiOlsid2VicGFjazovL2pzbV9iYW5raW5nLy4vbm9kZV9tb2R1bGVzL25vZGUtYXBwd3JpdGUvbGliL2VudW1zL3JlbGF0aW9uLW11dGF0ZS5qcz81MzhiIl0sInNvdXJjZXNDb250ZW50IjpbImNvbnN0IFJlbGF0aW9uTXV0YXRlID0gT2JqZWN0LmZyZWV6ZSh7XG4gICAgQ2FzY2FkZTogJ2Nhc2NhZGUnICxcbiAgICBSZXN0cmljdDogJ3Jlc3RyaWN0JyAsXG4gICAgU2V0TnVsbDogJ3NldE51bGwnIFxufSk7XG5cbm1vZHVsZS5leHBvcnRzID0gUmVsYXRpb25NdXRhdGU7Il0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/node-appwrite/lib/enums/relation-mutate.js\n");

/***/ }),

/***/ "(action-browser)/./node_modules/node-appwrite/lib/enums/relationship-type.js":
/*!*******************************************************************!*\
  !*** ./node_modules/node-appwrite/lib/enums/relationship-type.js ***!
  \*******************************************************************/
/***/ ((module) => {

eval("const RelationshipType = Object.freeze({\n    OneToOne: 'oneToOne' ,\n    ManyToOne: 'manyToOne' ,\n    ManyToMany: 'manyToMany' ,\n    OneToMany: 'oneToMany' \n});\n\nmodule.exports = RelationshipType;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFjdGlvbi1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9ub2RlLWFwcHdyaXRlL2xpYi9lbnVtcy9yZWxhdGlvbnNoaXAtdHlwZS5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRCIsInNvdXJjZXMiOlsid2VicGFjazovL2pzbV9iYW5raW5nLy4vbm9kZV9tb2R1bGVzL25vZGUtYXBwd3JpdGUvbGliL2VudW1zL3JlbGF0aW9uc2hpcC10eXBlLmpzPzBjYjQiXSwic291cmNlc0NvbnRlbnQiOlsiY29uc3QgUmVsYXRpb25zaGlwVHlwZSA9IE9iamVjdC5mcmVlemUoe1xuICAgIE9uZVRvT25lOiAnb25lVG9PbmUnICxcbiAgICBNYW55VG9PbmU6ICdtYW55VG9PbmUnICxcbiAgICBNYW55VG9NYW55OiAnbWFueVRvTWFueScgLFxuICAgIE9uZVRvTWFueTogJ29uZVRvTWFueScgXG59KTtcblxubW9kdWxlLmV4cG9ydHMgPSBSZWxhdGlvbnNoaXBUeXBlOyJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(action-browser)/./node_modules/node-appwrite/lib/enums/relationship-type.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/node-appwrite/lib/enums/relationship-type.js":
/*!*******************************************************************!*\
  !*** ./node_modules/node-appwrite/lib/enums/relationship-type.js ***!
  \*******************************************************************/
/***/ ((module) => {

eval("const RelationshipType = Object.freeze({\n    OneToOne: 'oneToOne' ,\n    ManyToOne: 'manyToOne' ,\n    ManyToMany: 'manyToMany' ,\n    OneToMany: 'oneToMany' \n});\n\nmodule.exports = RelationshipType;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvbm9kZS1hcHB3cml0ZS9saWIvZW51bXMvcmVsYXRpb25zaGlwLXR5cGUuanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9qc21fYmFua2luZy8uL25vZGVfbW9kdWxlcy9ub2RlLWFwcHdyaXRlL2xpYi9lbnVtcy9yZWxhdGlvbnNoaXAtdHlwZS5qcz9mY2ZkIl0sInNvdXJjZXNDb250ZW50IjpbImNvbnN0IFJlbGF0aW9uc2hpcFR5cGUgPSBPYmplY3QuZnJlZXplKHtcbiAgICBPbmVUb09uZTogJ29uZVRvT25lJyAsXG4gICAgTWFueVRvT25lOiAnbWFueVRvT25lJyAsXG4gICAgTWFueVRvTWFueTogJ21hbnlUb01hbnknICxcbiAgICBPbmVUb01hbnk6ICdvbmVUb01hbnknIFxufSk7XG5cbm1vZHVsZS5leHBvcnRzID0gUmVsYXRpb25zaGlwVHlwZTsiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/node-appwrite/lib/enums/relationship-type.js\n");

/***/ }),

/***/ "(action-browser)/./node_modules/node-appwrite/lib/enums/runtime.js":
/*!*********************************************************!*\
  !*** ./node_modules/node-appwrite/lib/enums/runtime.js ***!
  \*********************************************************/
/***/ ((module) => {

eval("const Runtime = Object.freeze({\n    Node145: 'node-14.5' ,\n    Node160: 'node-16.0' ,\n    Node180: 'node-18.0' ,\n    Node190: 'node-19.0' ,\n    Node200: 'node-20.0' ,\n    Node210: 'node-21.0' ,\n    Php80: 'php-8.0' ,\n    Php81: 'php-8.1' ,\n    Php82: 'php-8.2' ,\n    Php83: 'php-8.3' ,\n    Ruby30: 'ruby-3.0' ,\n    Ruby31: 'ruby-3.1' ,\n    Ruby32: 'ruby-3.2' ,\n    Ruby33: 'ruby-3.3' ,\n    Python38: 'python-3.8' ,\n    Python39: 'python-3.9' ,\n    Python310: 'python-3.10' ,\n    Python311: 'python-3.11' ,\n    Python312: 'python-3.12' ,\n    Deno140: 'deno-1.40' ,\n    Dart215: 'dart-2.15' ,\n    Dart216: 'dart-2.16' ,\n    Dart217: 'dart-2.17' ,\n    Dart218: 'dart-2.18' ,\n    Dart30: 'dart-3.0' ,\n    Dart31: 'dart-3.1' ,\n    Dart33: 'dart-3.3' ,\n    Dotnet31: 'dotnet-3.1' ,\n    Dotnet60: 'dotnet-6.0' ,\n    Dotnet70: 'dotnet-7.0' ,\n    Java80: 'java-8.0' ,\n    Java110: 'java-11.0' ,\n    Java170: 'java-17.0' ,\n    Java180: 'java-18.0' ,\n    Java210: 'java-21.0' ,\n    Swift55: 'swift-5.5' ,\n    Swift58: 'swift-5.8' ,\n    Swift59: 'swift-5.9' ,\n    Kotlin16: 'kotlin-1.6' ,\n    Kotlin18: 'kotlin-1.8' ,\n    Kotlin19: 'kotlin-1.9' ,\n    Cpp17: 'cpp-17' ,\n    Cpp20: 'cpp-20' ,\n    Bun10: 'bun-1.0' \n});\n\nmodule.exports = Runtime;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFjdGlvbi1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9ub2RlLWFwcHdyaXRlL2xpYi9lbnVtcy9ydW50aW1lLmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9qc21fYmFua2luZy8uL25vZGVfbW9kdWxlcy9ub2RlLWFwcHdyaXRlL2xpYi9lbnVtcy9ydW50aW1lLmpzPzNlMTEiXSwic291cmNlc0NvbnRlbnQiOlsiY29uc3QgUnVudGltZSA9IE9iamVjdC5mcmVlemUoe1xuICAgIE5vZGUxNDU6ICdub2RlLTE0LjUnICxcbiAgICBOb2RlMTYwOiAnbm9kZS0xNi4wJyAsXG4gICAgTm9kZTE4MDogJ25vZGUtMTguMCcgLFxuICAgIE5vZGUxOTA6ICdub2RlLTE5LjAnICxcbiAgICBOb2RlMjAwOiAnbm9kZS0yMC4wJyAsXG4gICAgTm9kZTIxMDogJ25vZGUtMjEuMCcgLFxuICAgIFBocDgwOiAncGhwLTguMCcgLFxuICAgIFBocDgxOiAncGhwLTguMScgLFxuICAgIFBocDgyOiAncGhwLTguMicgLFxuICAgIFBocDgzOiAncGhwLTguMycgLFxuICAgIFJ1YnkzMDogJ3J1YnktMy4wJyAsXG4gICAgUnVieTMxOiAncnVieS0zLjEnICxcbiAgICBSdWJ5MzI6ICdydWJ5LTMuMicgLFxuICAgIFJ1YnkzMzogJ3J1YnktMy4zJyAsXG4gICAgUHl0aG9uMzg6ICdweXRob24tMy44JyAsXG4gICAgUHl0aG9uMzk6ICdweXRob24tMy45JyAsXG4gICAgUHl0aG9uMzEwOiAncHl0aG9uLTMuMTAnICxcbiAgICBQeXRob24zMTE6ICdweXRob24tMy4xMScgLFxuICAgIFB5dGhvbjMxMjogJ3B5dGhvbi0zLjEyJyAsXG4gICAgRGVubzE0MDogJ2Rlbm8tMS40MCcgLFxuICAgIERhcnQyMTU6ICdkYXJ0LTIuMTUnICxcbiAgICBEYXJ0MjE2OiAnZGFydC0yLjE2JyAsXG4gICAgRGFydDIxNzogJ2RhcnQtMi4xNycgLFxuICAgIERhcnQyMTg6ICdkYXJ0LTIuMTgnICxcbiAgICBEYXJ0MzA6ICdkYXJ0LTMuMCcgLFxuICAgIERhcnQzMTogJ2RhcnQtMy4xJyAsXG4gICAgRGFydDMzOiAnZGFydC0zLjMnICxcbiAgICBEb3RuZXQzMTogJ2RvdG5ldC0zLjEnICxcbiAgICBEb3RuZXQ2MDogJ2RvdG5ldC02LjAnICxcbiAgICBEb3RuZXQ3MDogJ2RvdG5ldC03LjAnICxcbiAgICBKYXZhODA6ICdqYXZhLTguMCcgLFxuICAgIEphdmExMTA6ICdqYXZhLTExLjAnICxcbiAgICBKYXZhMTcwOiAnamF2YS0xNy4wJyAsXG4gICAgSmF2YTE4MDogJ2phdmEtMTguMCcgLFxuICAgIEphdmEyMTA6ICdqYXZhLTIxLjAnICxcbiAgICBTd2lmdDU1OiAnc3dpZnQtNS41JyAsXG4gICAgU3dpZnQ1ODogJ3N3aWZ0LTUuOCcgLFxuICAgIFN3aWZ0NTk6ICdzd2lmdC01LjknICxcbiAgICBLb3RsaW4xNjogJ2tvdGxpbi0xLjYnICxcbiAgICBLb3RsaW4xODogJ2tvdGxpbi0xLjgnICxcbiAgICBLb3RsaW4xOTogJ2tvdGxpbi0xLjknICxcbiAgICBDcHAxNzogJ2NwcC0xNycgLFxuICAgIENwcDIwOiAnY3BwLTIwJyAsXG4gICAgQnVuMTA6ICdidW4tMS4wJyBcbn0pO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFJ1bnRpbWU7Il0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(action-browser)/./node_modules/node-appwrite/lib/enums/runtime.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/node-appwrite/lib/enums/runtime.js":
/*!*********************************************************!*\
  !*** ./node_modules/node-appwrite/lib/enums/runtime.js ***!
  \*********************************************************/
/***/ ((module) => {

eval("const Runtime = Object.freeze({\n    Node145: 'node-14.5' ,\n    Node160: 'node-16.0' ,\n    Node180: 'node-18.0' ,\n    Node190: 'node-19.0' ,\n    Node200: 'node-20.0' ,\n    Node210: 'node-21.0' ,\n    Php80: 'php-8.0' ,\n    Php81: 'php-8.1' ,\n    Php82: 'php-8.2' ,\n    Php83: 'php-8.3' ,\n    Ruby30: 'ruby-3.0' ,\n    Ruby31: 'ruby-3.1' ,\n    Ruby32: 'ruby-3.2' ,\n    Ruby33: 'ruby-3.3' ,\n    Python38: 'python-3.8' ,\n    Python39: 'python-3.9' ,\n    Python310: 'python-3.10' ,\n    Python311: 'python-3.11' ,\n    Python312: 'python-3.12' ,\n    Deno140: 'deno-1.40' ,\n    Dart215: 'dart-2.15' ,\n    Dart216: 'dart-2.16' ,\n    Dart217: 'dart-2.17' ,\n    Dart218: 'dart-2.18' ,\n    Dart30: 'dart-3.0' ,\n    Dart31: 'dart-3.1' ,\n    Dart33: 'dart-3.3' ,\n    Dotnet31: 'dotnet-3.1' ,\n    Dotnet60: 'dotnet-6.0' ,\n    Dotnet70: 'dotnet-7.0' ,\n    Java80: 'java-8.0' ,\n    Java110: 'java-11.0' ,\n    Java170: 'java-17.0' ,\n    Java180: 'java-18.0' ,\n    Java210: 'java-21.0' ,\n    Swift55: 'swift-5.5' ,\n    Swift58: 'swift-5.8' ,\n    Swift59: 'swift-5.9' ,\n    Kotlin16: 'kotlin-1.6' ,\n    Kotlin18: 'kotlin-1.8' ,\n    Kotlin19: 'kotlin-1.9' ,\n    Cpp17: 'cpp-17' ,\n    Cpp20: 'cpp-20' ,\n    Bun10: 'bun-1.0' \n});\n\nmodule.exports = Runtime;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvbm9kZS1hcHB3cml0ZS9saWIvZW51bXMvcnVudGltZS5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vanNtX2JhbmtpbmcvLi9ub2RlX21vZHVsZXMvbm9kZS1hcHB3cml0ZS9saWIvZW51bXMvcnVudGltZS5qcz81NzVlIl0sInNvdXJjZXNDb250ZW50IjpbImNvbnN0IFJ1bnRpbWUgPSBPYmplY3QuZnJlZXplKHtcbiAgICBOb2RlMTQ1OiAnbm9kZS0xNC41JyAsXG4gICAgTm9kZTE2MDogJ25vZGUtMTYuMCcgLFxuICAgIE5vZGUxODA6ICdub2RlLTE4LjAnICxcbiAgICBOb2RlMTkwOiAnbm9kZS0xOS4wJyAsXG4gICAgTm9kZTIwMDogJ25vZGUtMjAuMCcgLFxuICAgIE5vZGUyMTA6ICdub2RlLTIxLjAnICxcbiAgICBQaHA4MDogJ3BocC04LjAnICxcbiAgICBQaHA4MTogJ3BocC04LjEnICxcbiAgICBQaHA4MjogJ3BocC04LjInICxcbiAgICBQaHA4MzogJ3BocC04LjMnICxcbiAgICBSdWJ5MzA6ICdydWJ5LTMuMCcgLFxuICAgIFJ1YnkzMTogJ3J1YnktMy4xJyAsXG4gICAgUnVieTMyOiAncnVieS0zLjInICxcbiAgICBSdWJ5MzM6ICdydWJ5LTMuMycgLFxuICAgIFB5dGhvbjM4OiAncHl0aG9uLTMuOCcgLFxuICAgIFB5dGhvbjM5OiAncHl0aG9uLTMuOScgLFxuICAgIFB5dGhvbjMxMDogJ3B5dGhvbi0zLjEwJyAsXG4gICAgUHl0aG9uMzExOiAncHl0aG9uLTMuMTEnICxcbiAgICBQeXRob24zMTI6ICdweXRob24tMy4xMicgLFxuICAgIERlbm8xNDA6ICdkZW5vLTEuNDAnICxcbiAgICBEYXJ0MjE1OiAnZGFydC0yLjE1JyAsXG4gICAgRGFydDIxNjogJ2RhcnQtMi4xNicgLFxuICAgIERhcnQyMTc6ICdkYXJ0LTIuMTcnICxcbiAgICBEYXJ0MjE4OiAnZGFydC0yLjE4JyAsXG4gICAgRGFydDMwOiAnZGFydC0zLjAnICxcbiAgICBEYXJ0MzE6ICdkYXJ0LTMuMScgLFxuICAgIERhcnQzMzogJ2RhcnQtMy4zJyAsXG4gICAgRG90bmV0MzE6ICdkb3RuZXQtMy4xJyAsXG4gICAgRG90bmV0NjA6ICdkb3RuZXQtNi4wJyAsXG4gICAgRG90bmV0NzA6ICdkb3RuZXQtNy4wJyAsXG4gICAgSmF2YTgwOiAnamF2YS04LjAnICxcbiAgICBKYXZhMTEwOiAnamF2YS0xMS4wJyAsXG4gICAgSmF2YTE3MDogJ2phdmEtMTcuMCcgLFxuICAgIEphdmExODA6ICdqYXZhLTE4LjAnICxcbiAgICBKYXZhMjEwOiAnamF2YS0yMS4wJyAsXG4gICAgU3dpZnQ1NTogJ3N3aWZ0LTUuNScgLFxuICAgIFN3aWZ0NTg6ICdzd2lmdC01LjgnICxcbiAgICBTd2lmdDU5OiAnc3dpZnQtNS45JyAsXG4gICAgS290bGluMTY6ICdrb3RsaW4tMS42JyAsXG4gICAgS290bGluMTg6ICdrb3RsaW4tMS44JyAsXG4gICAgS290bGluMTk6ICdrb3RsaW4tMS45JyAsXG4gICAgQ3BwMTc6ICdjcHAtMTcnICxcbiAgICBDcHAyMDogJ2NwcC0yMCcgLFxuICAgIEJ1bjEwOiAnYnVuLTEuMCcgXG59KTtcblxubW9kdWxlLmV4cG9ydHMgPSBSdW50aW1lOyJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/node-appwrite/lib/enums/runtime.js\n");

/***/ }),

/***/ "(action-browser)/./node_modules/node-appwrite/lib/enums/smtp-encryption.js":
/*!*****************************************************************!*\
  !*** ./node_modules/node-appwrite/lib/enums/smtp-encryption.js ***!
  \*****************************************************************/
/***/ ((module) => {

eval("const SmtpEncryption = Object.freeze({\n    None: 'none' ,\n    Ssl: 'ssl' ,\n    Tls: 'tls' \n});\n\nmodule.exports = SmtpEncryption;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFjdGlvbi1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9ub2RlLWFwcHdyaXRlL2xpYi9lbnVtcy9zbXRwLWVuY3J5cHRpb24uanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vanNtX2JhbmtpbmcvLi9ub2RlX21vZHVsZXMvbm9kZS1hcHB3cml0ZS9saWIvZW51bXMvc210cC1lbmNyeXB0aW9uLmpzP2Q5NGEiXSwic291cmNlc0NvbnRlbnQiOlsiY29uc3QgU210cEVuY3J5cHRpb24gPSBPYmplY3QuZnJlZXplKHtcbiAgICBOb25lOiAnbm9uZScgLFxuICAgIFNzbDogJ3NzbCcgLFxuICAgIFRsczogJ3RscycgXG59KTtcblxubW9kdWxlLmV4cG9ydHMgPSBTbXRwRW5jcnlwdGlvbjsiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(action-browser)/./node_modules/node-appwrite/lib/enums/smtp-encryption.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/node-appwrite/lib/enums/smtp-encryption.js":
/*!*****************************************************************!*\
  !*** ./node_modules/node-appwrite/lib/enums/smtp-encryption.js ***!
  \*****************************************************************/
/***/ ((module) => {

eval("const SmtpEncryption = Object.freeze({\n    None: 'none' ,\n    Ssl: 'ssl' ,\n    Tls: 'tls' \n});\n\nmodule.exports = SmtpEncryption;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvbm9kZS1hcHB3cml0ZS9saWIvZW51bXMvc210cC1lbmNyeXB0aW9uLmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRCIsInNvdXJjZXMiOlsid2VicGFjazovL2pzbV9iYW5raW5nLy4vbm9kZV9tb2R1bGVzL25vZGUtYXBwd3JpdGUvbGliL2VudW1zL3NtdHAtZW5jcnlwdGlvbi5qcz80YmRjIl0sInNvdXJjZXNDb250ZW50IjpbImNvbnN0IFNtdHBFbmNyeXB0aW9uID0gT2JqZWN0LmZyZWV6ZSh7XG4gICAgTm9uZTogJ25vbmUnICxcbiAgICBTc2w6ICdzc2wnICxcbiAgICBUbHM6ICd0bHMnIFxufSk7XG5cbm1vZHVsZS5leHBvcnRzID0gU210cEVuY3J5cHRpb247Il0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/node-appwrite/lib/enums/smtp-encryption.js\n");

/***/ }),

/***/ "(action-browser)/./node_modules/node-appwrite/lib/exception.js":
/*!*****************************************************!*\
  !*** ./node_modules/node-appwrite/lib/exception.js ***!
  \*****************************************************/
/***/ ((module) => {

eval("class AppwriteException extends Error {\n  constructor(message, code, type, response) {\n    super(message);\n    this.code = code;\n    this.type = type;\n    this.response = response;\n  }\n}\n\nmodule.exports = AppwriteException;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFjdGlvbi1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9ub2RlLWFwcHdyaXRlL2xpYi9leGNlcHRpb24uanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSIsInNvdXJjZXMiOlsid2VicGFjazovL2pzbV9iYW5raW5nLy4vbm9kZV9tb2R1bGVzL25vZGUtYXBwd3JpdGUvbGliL2V4Y2VwdGlvbi5qcz8wZGFjIl0sInNvdXJjZXNDb250ZW50IjpbImNsYXNzIEFwcHdyaXRlRXhjZXB0aW9uIGV4dGVuZHMgRXJyb3Ige1xuICBjb25zdHJ1Y3RvcihtZXNzYWdlLCBjb2RlLCB0eXBlLCByZXNwb25zZSkge1xuICAgIHN1cGVyKG1lc3NhZ2UpO1xuICAgIHRoaXMuY29kZSA9IGNvZGU7XG4gICAgdGhpcy50eXBlID0gdHlwZTtcbiAgICB0aGlzLnJlc3BvbnNlID0gcmVzcG9uc2U7XG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBBcHB3cml0ZUV4Y2VwdGlvbjsiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(action-browser)/./node_modules/node-appwrite/lib/exception.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/node-appwrite/lib/exception.js":
/*!*****************************************************!*\
  !*** ./node_modules/node-appwrite/lib/exception.js ***!
  \*****************************************************/
/***/ ((module) => {

eval("class AppwriteException extends Error {\n  constructor(message, code, type, response) {\n    super(message);\n    this.code = code;\n    this.type = type;\n    this.response = response;\n  }\n}\n\nmodule.exports = AppwriteException;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvbm9kZS1hcHB3cml0ZS9saWIvZXhjZXB0aW9uLmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9qc21fYmFua2luZy8uL25vZGVfbW9kdWxlcy9ub2RlLWFwcHdyaXRlL2xpYi9leGNlcHRpb24uanM/NWFkMyJdLCJzb3VyY2VzQ29udGVudCI6WyJjbGFzcyBBcHB3cml0ZUV4Y2VwdGlvbiBleHRlbmRzIEVycm9yIHtcbiAgY29uc3RydWN0b3IobWVzc2FnZSwgY29kZSwgdHlwZSwgcmVzcG9uc2UpIHtcbiAgICBzdXBlcihtZXNzYWdlKTtcbiAgICB0aGlzLmNvZGUgPSBjb2RlO1xuICAgIHRoaXMudHlwZSA9IHR5cGU7XG4gICAgdGhpcy5yZXNwb25zZSA9IHJlc3BvbnNlO1xuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gQXBwd3JpdGVFeGNlcHRpb247Il0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/node-appwrite/lib/exception.js\n");

/***/ }),

/***/ "(action-browser)/./node_modules/node-appwrite/lib/id.js":
/*!**********************************************!*\
  !*** ./node_modules/node-appwrite/lib/id.js ***!
  \**********************************************/
/***/ ((module) => {

eval("class ID {\n    // Generate an hex ID based on timestamp\n    // Recreated from https://www.php.net/manual/en/function.uniqid.php\n    static #hexTimestamp = () => {\n        const now = new Date();\n        const sec = Math.floor(now.getTime() / 1000);\n        const msec = now.getMilliseconds();\n\n        // Convert to hexadecimal\n        const hexTimestamp = sec.toString(16) + msec.toString(16).padStart(5, '0');\n        return hexTimestamp;\n    }\n\n    // Generate a unique ID with padding to have a longer ID\n    static unique = (padding = 7) => {\n        const baseId = ID.#hexTimestamp();\n        let randomPadding = '';\n\n        for (let i = 0; i < padding; i++) {\n            const randomHexDigit = Math.floor(Math.random() * 16).toString(16);\n            randomPadding += randomHexDigit;\n        }\n\n        return baseId + randomPadding;\n    }\n\n    static custom = (id) => {\n         return id\n    }\n}\n\nmodule.exports = ID;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFjdGlvbi1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9ub2RlLWFwcHdyaXRlL2xpYi9pZC5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSx3QkFBd0IsYUFBYTtBQUNyQztBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSIsInNvdXJjZXMiOlsid2VicGFjazovL2pzbV9iYW5raW5nLy4vbm9kZV9tb2R1bGVzL25vZGUtYXBwd3JpdGUvbGliL2lkLmpzPzZmYzQiXSwic291cmNlc0NvbnRlbnQiOlsiY2xhc3MgSUQge1xuICAgIC8vIEdlbmVyYXRlIGFuIGhleCBJRCBiYXNlZCBvbiB0aW1lc3RhbXBcbiAgICAvLyBSZWNyZWF0ZWQgZnJvbSBodHRwczovL3d3dy5waHAubmV0L21hbnVhbC9lbi9mdW5jdGlvbi51bmlxaWQucGhwXG4gICAgc3RhdGljICNoZXhUaW1lc3RhbXAgPSAoKSA9PiB7XG4gICAgICAgIGNvbnN0IG5vdyA9IG5ldyBEYXRlKCk7XG4gICAgICAgIGNvbnN0IHNlYyA9IE1hdGguZmxvb3Iobm93LmdldFRpbWUoKSAvIDEwMDApO1xuICAgICAgICBjb25zdCBtc2VjID0gbm93LmdldE1pbGxpc2Vjb25kcygpO1xuXG4gICAgICAgIC8vIENvbnZlcnQgdG8gaGV4YWRlY2ltYWxcbiAgICAgICAgY29uc3QgaGV4VGltZXN0YW1wID0gc2VjLnRvU3RyaW5nKDE2KSArIG1zZWMudG9TdHJpbmcoMTYpLnBhZFN0YXJ0KDUsICcwJyk7XG4gICAgICAgIHJldHVybiBoZXhUaW1lc3RhbXA7XG4gICAgfVxuXG4gICAgLy8gR2VuZXJhdGUgYSB1bmlxdWUgSUQgd2l0aCBwYWRkaW5nIHRvIGhhdmUgYSBsb25nZXIgSURcbiAgICBzdGF0aWMgdW5pcXVlID0gKHBhZGRpbmcgPSA3KSA9PiB7XG4gICAgICAgIGNvbnN0IGJhc2VJZCA9IElELiNoZXhUaW1lc3RhbXAoKTtcbiAgICAgICAgbGV0IHJhbmRvbVBhZGRpbmcgPSAnJztcblxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHBhZGRpbmc7IGkrKykge1xuICAgICAgICAgICAgY29uc3QgcmFuZG9tSGV4RGlnaXQgPSBNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiAxNikudG9TdHJpbmcoMTYpO1xuICAgICAgICAgICAgcmFuZG9tUGFkZGluZyArPSByYW5kb21IZXhEaWdpdDtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBiYXNlSWQgKyByYW5kb21QYWRkaW5nO1xuICAgIH1cblxuICAgIHN0YXRpYyBjdXN0b20gPSAoaWQpID0+IHtcbiAgICAgICAgIHJldHVybiBpZFxuICAgIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBJRDtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(action-browser)/./node_modules/node-appwrite/lib/id.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/node-appwrite/lib/id.js":
/*!**********************************************!*\
  !*** ./node_modules/node-appwrite/lib/id.js ***!
  \**********************************************/
/***/ ((module) => {

eval("class ID {\n    // Generate an hex ID based on timestamp\n    // Recreated from https://www.php.net/manual/en/function.uniqid.php\n    static #hexTimestamp = () => {\n        const now = new Date();\n        const sec = Math.floor(now.getTime() / 1000);\n        const msec = now.getMilliseconds();\n\n        // Convert to hexadecimal\n        const hexTimestamp = sec.toString(16) + msec.toString(16).padStart(5, '0');\n        return hexTimestamp;\n    }\n\n    // Generate a unique ID with padding to have a longer ID\n    static unique = (padding = 7) => {\n        const baseId = ID.#hexTimestamp();\n        let randomPadding = '';\n\n        for (let i = 0; i < padding; i++) {\n            const randomHexDigit = Math.floor(Math.random() * 16).toString(16);\n            randomPadding += randomHexDigit;\n        }\n\n        return baseId + randomPadding;\n    }\n\n    static custom = (id) => {\n         return id\n    }\n}\n\nmodule.exports = ID;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvbm9kZS1hcHB3cml0ZS9saWIvaWQuanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsd0JBQXdCLGFBQWE7QUFDckM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9qc21fYmFua2luZy8uL25vZGVfbW9kdWxlcy9ub2RlLWFwcHdyaXRlL2xpYi9pZC5qcz8xYzA5Il0sInNvdXJjZXNDb250ZW50IjpbImNsYXNzIElEIHtcbiAgICAvLyBHZW5lcmF0ZSBhbiBoZXggSUQgYmFzZWQgb24gdGltZXN0YW1wXG4gICAgLy8gUmVjcmVhdGVkIGZyb20gaHR0cHM6Ly93d3cucGhwLm5ldC9tYW51YWwvZW4vZnVuY3Rpb24udW5pcWlkLnBocFxuICAgIHN0YXRpYyAjaGV4VGltZXN0YW1wID0gKCkgPT4ge1xuICAgICAgICBjb25zdCBub3cgPSBuZXcgRGF0ZSgpO1xuICAgICAgICBjb25zdCBzZWMgPSBNYXRoLmZsb29yKG5vdy5nZXRUaW1lKCkgLyAxMDAwKTtcbiAgICAgICAgY29uc3QgbXNlYyA9IG5vdy5nZXRNaWxsaXNlY29uZHMoKTtcblxuICAgICAgICAvLyBDb252ZXJ0IHRvIGhleGFkZWNpbWFsXG4gICAgICAgIGNvbnN0IGhleFRpbWVzdGFtcCA9IHNlYy50b1N0cmluZygxNikgKyBtc2VjLnRvU3RyaW5nKDE2KS5wYWRTdGFydCg1LCAnMCcpO1xuICAgICAgICByZXR1cm4gaGV4VGltZXN0YW1wO1xuICAgIH1cblxuICAgIC8vIEdlbmVyYXRlIGEgdW5pcXVlIElEIHdpdGggcGFkZGluZyB0byBoYXZlIGEgbG9uZ2VyIElEXG4gICAgc3RhdGljIHVuaXF1ZSA9IChwYWRkaW5nID0gNykgPT4ge1xuICAgICAgICBjb25zdCBiYXNlSWQgPSBJRC4jaGV4VGltZXN0YW1wKCk7XG4gICAgICAgIGxldCByYW5kb21QYWRkaW5nID0gJyc7XG5cbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBwYWRkaW5nOyBpKyspIHtcbiAgICAgICAgICAgIGNvbnN0IHJhbmRvbUhleERpZ2l0ID0gTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogMTYpLnRvU3RyaW5nKDE2KTtcbiAgICAgICAgICAgIHJhbmRvbVBhZGRpbmcgKz0gcmFuZG9tSGV4RGlnaXQ7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gYmFzZUlkICsgcmFuZG9tUGFkZGluZztcbiAgICB9XG5cbiAgICBzdGF0aWMgY3VzdG9tID0gKGlkKSA9PiB7XG4gICAgICAgICByZXR1cm4gaWRcbiAgICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gSUQ7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/node-appwrite/lib/id.js\n");

/***/ }),

/***/ "(action-browser)/./node_modules/node-appwrite/lib/inputFile.js":
/*!*****************************************************!*\
  !*** ./node_modules/node-appwrite/lib/inputFile.js ***!
  \*****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("const fs = __webpack_require__(/*! fs */ \"fs\");\nconst { ReadableStream } = __webpack_require__(/*! stream/web */ \"stream/web\");\n\n/**\n * @param {fs.ReadStream} readStream\n * @returns {ReadableStream}\n */\nfunction convertReadStreamToReadableStream(readStream) {\n  return new ReadableStream({\n    start(controller) {\n      readStream.on(\"data\", (chunk) => {\n        controller.enqueue(chunk);\n      });\n      readStream.on(\"end\", () => {\n        controller.close();\n      });\n      readStream.on(\"error\", (err) => {\n        controller.error(err);\n      });\n    },\n    cancel() {\n      readStream.destroy();\n    },\n  });\n}\n\n/**\n * @param {Buffer} buffer\n * @returns {ReadableStream}\n */\nfunction bufferToReadableStream(buffer) {\n  return new ReadableStream({\n    start(controller) {\n      controller.enqueue(buffer);\n      controller.close();\n    },\n  });\n}\n\nclass InputFile {\n  /** @type {ReadableStream} Content of file as a stream */\n  stream;\n\n  /** @type {number} Total final size of the file content */\n  size;\n\n  /** @type {string} File name */\n  filename;\n\n  /**\n   * @param {string} filePath\n   * @param {string} filename\n   * @returns {InputFile}\n   */\n  static fromPath = (filePath, filename) => {\n    const nodeStream = fs.createReadStream(filePath);\n    const stream = convertReadStreamToReadableStream(nodeStream);\n    const size = fs.statSync(filePath).size;\n    return new InputFile(stream, filename, size);\n  };\n\n  /**\n   * @param {Buffer} buffer\n   * @param {string} filename\n   * @returns {InputFile}\n   */\n  static fromBuffer = (buffer, filename) => {\n    const stream = bufferToReadableStream(buffer);\n    const size = buffer.byteLength;\n    return new InputFile(stream, filename, size);\n  };\n\n  /**\n   * @param {string} content\n   * @param {string} filename\n   * @returns {InputFile}\n   */\n  static fromPlainText = (content, filename) => {\n    const array = new TextEncoder().encode(content);\n    const buffer = Buffer.from(array);\n    return InputFile.fromBuffer(buffer, filename);\n  };\n\n  /**\n   * @param {ReadableStream} stream\n   * @param {string} filename\n   * @param {number} size\n   * @returns {InputFile}\n   */\n  static fromStream = (stream, filename, size) => {\n    return new InputFile(stream, filename, size);\n  };\n\n  /**\n   * @param {Blob} blob\n   * @param {string} filename\n   * @returns {InputFile}\n   */\n  static fromBlob = (blob, filename) => {\n    const stream = blob.stream();\n    const size = blob.size;\n    return new InputFile(stream, filename, size);\n  };\n\n  /**\n   * @param {ReadableStream} stream\n   * @param {string} filename\n   * @param {number} size\n   */\n  constructor(stream, filename, size) {\n    this.stream = stream;\n    this.filename = filename;\n    this.size = size;\n  }\n}\n\nmodule.exports = InputFile;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFjdGlvbi1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9ub2RlLWFwcHdyaXRlL2xpYi9pbnB1dEZpbGUuanMiLCJtYXBwaW5ncyI6IkFBQUEsV0FBVyxtQkFBTyxDQUFDLGNBQUk7QUFDdkIsUUFBUSxpQkFBaUIsRUFBRSxtQkFBTyxDQUFDLDhCQUFZOztBQUUvQztBQUNBLFdBQVcsZUFBZTtBQUMxQixhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTCxHQUFHO0FBQ0g7O0FBRUE7QUFDQSxXQUFXLFFBQVE7QUFDbkIsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxHQUFHO0FBQ0g7O0FBRUE7QUFDQSxhQUFhLGdCQUFnQjtBQUM3Qjs7QUFFQSxhQUFhLFFBQVE7QUFDckI7O0FBRUEsYUFBYSxRQUFRO0FBQ3JCOztBQUVBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCLGFBQWEsUUFBUTtBQUNyQixlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxhQUFhLFFBQVE7QUFDckIsYUFBYSxRQUFRO0FBQ3JCLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxhQUFhLFFBQVE7QUFDckIsYUFBYSxRQUFRO0FBQ3JCLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxhQUFhLGdCQUFnQjtBQUM3QixhQUFhLFFBQVE7QUFDckIsYUFBYSxRQUFRO0FBQ3JCLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGFBQWEsTUFBTTtBQUNuQixhQUFhLFFBQVE7QUFDckIsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGFBQWEsZ0JBQWdCO0FBQzdCLGFBQWEsUUFBUTtBQUNyQixhQUFhLFFBQVE7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9qc21fYmFua2luZy8uL25vZGVfbW9kdWxlcy9ub2RlLWFwcHdyaXRlL2xpYi9pbnB1dEZpbGUuanM/M2NmYyJdLCJzb3VyY2VzQ29udGVudCI6WyJjb25zdCBmcyA9IHJlcXVpcmUoXCJmc1wiKTtcbmNvbnN0IHsgUmVhZGFibGVTdHJlYW0gfSA9IHJlcXVpcmUoXCJzdHJlYW0vd2ViXCIpO1xuXG4vKipcbiAqIEBwYXJhbSB7ZnMuUmVhZFN0cmVhbX0gcmVhZFN0cmVhbVxuICogQHJldHVybnMge1JlYWRhYmxlU3RyZWFtfVxuICovXG5mdW5jdGlvbiBjb252ZXJ0UmVhZFN0cmVhbVRvUmVhZGFibGVTdHJlYW0ocmVhZFN0cmVhbSkge1xuICByZXR1cm4gbmV3IFJlYWRhYmxlU3RyZWFtKHtcbiAgICBzdGFydChjb250cm9sbGVyKSB7XG4gICAgICByZWFkU3RyZWFtLm9uKFwiZGF0YVwiLCAoY2h1bmspID0+IHtcbiAgICAgICAgY29udHJvbGxlci5lbnF1ZXVlKGNodW5rKTtcbiAgICAgIH0pO1xuICAgICAgcmVhZFN0cmVhbS5vbihcImVuZFwiLCAoKSA9PiB7XG4gICAgICAgIGNvbnRyb2xsZXIuY2xvc2UoKTtcbiAgICAgIH0pO1xuICAgICAgcmVhZFN0cmVhbS5vbihcImVycm9yXCIsIChlcnIpID0+IHtcbiAgICAgICAgY29udHJvbGxlci5lcnJvcihlcnIpO1xuICAgICAgfSk7XG4gICAgfSxcbiAgICBjYW5jZWwoKSB7XG4gICAgICByZWFkU3RyZWFtLmRlc3Ryb3koKTtcbiAgICB9LFxuICB9KTtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge0J1ZmZlcn0gYnVmZmVyXG4gKiBAcmV0dXJucyB7UmVhZGFibGVTdHJlYW19XG4gKi9cbmZ1bmN0aW9uIGJ1ZmZlclRvUmVhZGFibGVTdHJlYW0oYnVmZmVyKSB7XG4gIHJldHVybiBuZXcgUmVhZGFibGVTdHJlYW0oe1xuICAgIHN0YXJ0KGNvbnRyb2xsZXIpIHtcbiAgICAgIGNvbnRyb2xsZXIuZW5xdWV1ZShidWZmZXIpO1xuICAgICAgY29udHJvbGxlci5jbG9zZSgpO1xuICAgIH0sXG4gIH0pO1xufVxuXG5jbGFzcyBJbnB1dEZpbGUge1xuICAvKiogQHR5cGUge1JlYWRhYmxlU3RyZWFtfSBDb250ZW50IG9mIGZpbGUgYXMgYSBzdHJlYW0gKi9cbiAgc3RyZWFtO1xuXG4gIC8qKiBAdHlwZSB7bnVtYmVyfSBUb3RhbCBmaW5hbCBzaXplIG9mIHRoZSBmaWxlIGNvbnRlbnQgKi9cbiAgc2l6ZTtcblxuICAvKiogQHR5cGUge3N0cmluZ30gRmlsZSBuYW1lICovXG4gIGZpbGVuYW1lO1xuXG4gIC8qKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gZmlsZVBhdGhcbiAgICogQHBhcmFtIHtzdHJpbmd9IGZpbGVuYW1lXG4gICAqIEByZXR1cm5zIHtJbnB1dEZpbGV9XG4gICAqL1xuICBzdGF0aWMgZnJvbVBhdGggPSAoZmlsZVBhdGgsIGZpbGVuYW1lKSA9PiB7XG4gICAgY29uc3Qgbm9kZVN0cmVhbSA9IGZzLmNyZWF0ZVJlYWRTdHJlYW0oZmlsZVBhdGgpO1xuICAgIGNvbnN0IHN0cmVhbSA9IGNvbnZlcnRSZWFkU3RyZWFtVG9SZWFkYWJsZVN0cmVhbShub2RlU3RyZWFtKTtcbiAgICBjb25zdCBzaXplID0gZnMuc3RhdFN5bmMoZmlsZVBhdGgpLnNpemU7XG4gICAgcmV0dXJuIG5ldyBJbnB1dEZpbGUoc3RyZWFtLCBmaWxlbmFtZSwgc2l6ZSk7XG4gIH07XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7QnVmZmVyfSBidWZmZXJcbiAgICogQHBhcmFtIHtzdHJpbmd9IGZpbGVuYW1lXG4gICAqIEByZXR1cm5zIHtJbnB1dEZpbGV9XG4gICAqL1xuICBzdGF0aWMgZnJvbUJ1ZmZlciA9IChidWZmZXIsIGZpbGVuYW1lKSA9PiB7XG4gICAgY29uc3Qgc3RyZWFtID0gYnVmZmVyVG9SZWFkYWJsZVN0cmVhbShidWZmZXIpO1xuICAgIGNvbnN0IHNpemUgPSBidWZmZXIuYnl0ZUxlbmd0aDtcbiAgICByZXR1cm4gbmV3IElucHV0RmlsZShzdHJlYW0sIGZpbGVuYW1lLCBzaXplKTtcbiAgfTtcblxuICAvKipcbiAgICogQHBhcmFtIHtzdHJpbmd9IGNvbnRlbnRcbiAgICogQHBhcmFtIHtzdHJpbmd9IGZpbGVuYW1lXG4gICAqIEByZXR1cm5zIHtJbnB1dEZpbGV9XG4gICAqL1xuICBzdGF0aWMgZnJvbVBsYWluVGV4dCA9IChjb250ZW50LCBmaWxlbmFtZSkgPT4ge1xuICAgIGNvbnN0IGFycmF5ID0gbmV3IFRleHRFbmNvZGVyKCkuZW5jb2RlKGNvbnRlbnQpO1xuICAgIGNvbnN0IGJ1ZmZlciA9IEJ1ZmZlci5mcm9tKGFycmF5KTtcbiAgICByZXR1cm4gSW5wdXRGaWxlLmZyb21CdWZmZXIoYnVmZmVyLCBmaWxlbmFtZSk7XG4gIH07XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7UmVhZGFibGVTdHJlYW19IHN0cmVhbVxuICAgKiBAcGFyYW0ge3N0cmluZ30gZmlsZW5hbWVcbiAgICogQHBhcmFtIHtudW1iZXJ9IHNpemVcbiAgICogQHJldHVybnMge0lucHV0RmlsZX1cbiAgICovXG4gIHN0YXRpYyBmcm9tU3RyZWFtID0gKHN0cmVhbSwgZmlsZW5hbWUsIHNpemUpID0+IHtcbiAgICByZXR1cm4gbmV3IElucHV0RmlsZShzdHJlYW0sIGZpbGVuYW1lLCBzaXplKTtcbiAgfTtcblxuICAvKipcbiAgICogQHBhcmFtIHtCbG9ifSBibG9iXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBmaWxlbmFtZVxuICAgKiBAcmV0dXJucyB7SW5wdXRGaWxlfVxuICAgKi9cbiAgc3RhdGljIGZyb21CbG9iID0gKGJsb2IsIGZpbGVuYW1lKSA9PiB7XG4gICAgY29uc3Qgc3RyZWFtID0gYmxvYi5zdHJlYW0oKTtcbiAgICBjb25zdCBzaXplID0gYmxvYi5zaXplO1xuICAgIHJldHVybiBuZXcgSW5wdXRGaWxlKHN0cmVhbSwgZmlsZW5hbWUsIHNpemUpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBAcGFyYW0ge1JlYWRhYmxlU3RyZWFtfSBzdHJlYW1cbiAgICogQHBhcmFtIHtzdHJpbmd9IGZpbGVuYW1lXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBzaXplXG4gICAqL1xuICBjb25zdHJ1Y3RvcihzdHJlYW0sIGZpbGVuYW1lLCBzaXplKSB7XG4gICAgdGhpcy5zdHJlYW0gPSBzdHJlYW07XG4gICAgdGhpcy5maWxlbmFtZSA9IGZpbGVuYW1lO1xuICAgIHRoaXMuc2l6ZSA9IHNpemU7XG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBJbnB1dEZpbGU7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(action-browser)/./node_modules/node-appwrite/lib/inputFile.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/node-appwrite/lib/inputFile.js":
/*!*****************************************************!*\
  !*** ./node_modules/node-appwrite/lib/inputFile.js ***!
  \*****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("const fs = __webpack_require__(/*! fs */ \"fs\");\nconst { ReadableStream } = __webpack_require__(/*! stream/web */ \"stream/web\");\n\n/**\n * @param {fs.ReadStream} readStream\n * @returns {ReadableStream}\n */\nfunction convertReadStreamToReadableStream(readStream) {\n  return new ReadableStream({\n    start(controller) {\n      readStream.on(\"data\", (chunk) => {\n        controller.enqueue(chunk);\n      });\n      readStream.on(\"end\", () => {\n        controller.close();\n      });\n      readStream.on(\"error\", (err) => {\n        controller.error(err);\n      });\n    },\n    cancel() {\n      readStream.destroy();\n    },\n  });\n}\n\n/**\n * @param {Buffer} buffer\n * @returns {ReadableStream}\n */\nfunction bufferToReadableStream(buffer) {\n  return new ReadableStream({\n    start(controller) {\n      controller.enqueue(buffer);\n      controller.close();\n    },\n  });\n}\n\nclass InputFile {\n  /** @type {ReadableStream} Content of file as a stream */\n  stream;\n\n  /** @type {number} Total final size of the file content */\n  size;\n\n  /** @type {string} File name */\n  filename;\n\n  /**\n   * @param {string} filePath\n   * @param {string} filename\n   * @returns {InputFile}\n   */\n  static fromPath = (filePath, filename) => {\n    const nodeStream = fs.createReadStream(filePath);\n    const stream = convertReadStreamToReadableStream(nodeStream);\n    const size = fs.statSync(filePath).size;\n    return new InputFile(stream, filename, size);\n  };\n\n  /**\n   * @param {Buffer} buffer\n   * @param {string} filename\n   * @returns {InputFile}\n   */\n  static fromBuffer = (buffer, filename) => {\n    const stream = bufferToReadableStream(buffer);\n    const size = buffer.byteLength;\n    return new InputFile(stream, filename, size);\n  };\n\n  /**\n   * @param {string} content\n   * @param {string} filename\n   * @returns {InputFile}\n   */\n  static fromPlainText = (content, filename) => {\n    const array = new TextEncoder().encode(content);\n    const buffer = Buffer.from(array);\n    return InputFile.fromBuffer(buffer, filename);\n  };\n\n  /**\n   * @param {ReadableStream} stream\n   * @param {string} filename\n   * @param {number} size\n   * @returns {InputFile}\n   */\n  static fromStream = (stream, filename, size) => {\n    return new InputFile(stream, filename, size);\n  };\n\n  /**\n   * @param {Blob} blob\n   * @param {string} filename\n   * @returns {InputFile}\n   */\n  static fromBlob = (blob, filename) => {\n    const stream = blob.stream();\n    const size = blob.size;\n    return new InputFile(stream, filename, size);\n  };\n\n  /**\n   * @param {ReadableStream} stream\n   * @param {string} filename\n   * @param {number} size\n   */\n  constructor(stream, filename, size) {\n    this.stream = stream;\n    this.filename = filename;\n    this.size = size;\n  }\n}\n\nmodule.exports = InputFile;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvbm9kZS1hcHB3cml0ZS9saWIvaW5wdXRGaWxlLmpzIiwibWFwcGluZ3MiOiJBQUFBLFdBQVcsbUJBQU8sQ0FBQyxjQUFJO0FBQ3ZCLFFBQVEsaUJBQWlCLEVBQUUsbUJBQU8sQ0FBQyw4QkFBWTs7QUFFL0M7QUFDQSxXQUFXLGVBQWU7QUFDMUIsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsR0FBRztBQUNIOztBQUVBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsR0FBRztBQUNIOztBQUVBO0FBQ0EsYUFBYSxnQkFBZ0I7QUFDN0I7O0FBRUEsYUFBYSxRQUFRO0FBQ3JCOztBQUVBLGFBQWEsUUFBUTtBQUNyQjs7QUFFQTtBQUNBLGFBQWEsUUFBUTtBQUNyQixhQUFhLFFBQVE7QUFDckIsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCLGFBQWEsUUFBUTtBQUNyQixlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCLGFBQWEsUUFBUTtBQUNyQixlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsYUFBYSxnQkFBZ0I7QUFDN0IsYUFBYSxRQUFRO0FBQ3JCLGFBQWEsUUFBUTtBQUNyQixlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxhQUFhLE1BQU07QUFDbkIsYUFBYSxRQUFRO0FBQ3JCLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxhQUFhLGdCQUFnQjtBQUM3QixhQUFhLFFBQVE7QUFDckIsYUFBYSxRQUFRO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vanNtX2JhbmtpbmcvLi9ub2RlX21vZHVsZXMvbm9kZS1hcHB3cml0ZS9saWIvaW5wdXRGaWxlLmpzP2QwZTgiXSwic291cmNlc0NvbnRlbnQiOlsiY29uc3QgZnMgPSByZXF1aXJlKFwiZnNcIik7XG5jb25zdCB7IFJlYWRhYmxlU3RyZWFtIH0gPSByZXF1aXJlKFwic3RyZWFtL3dlYlwiKTtcblxuLyoqXG4gKiBAcGFyYW0ge2ZzLlJlYWRTdHJlYW19IHJlYWRTdHJlYW1cbiAqIEByZXR1cm5zIHtSZWFkYWJsZVN0cmVhbX1cbiAqL1xuZnVuY3Rpb24gY29udmVydFJlYWRTdHJlYW1Ub1JlYWRhYmxlU3RyZWFtKHJlYWRTdHJlYW0pIHtcbiAgcmV0dXJuIG5ldyBSZWFkYWJsZVN0cmVhbSh7XG4gICAgc3RhcnQoY29udHJvbGxlcikge1xuICAgICAgcmVhZFN0cmVhbS5vbihcImRhdGFcIiwgKGNodW5rKSA9PiB7XG4gICAgICAgIGNvbnRyb2xsZXIuZW5xdWV1ZShjaHVuayk7XG4gICAgICB9KTtcbiAgICAgIHJlYWRTdHJlYW0ub24oXCJlbmRcIiwgKCkgPT4ge1xuICAgICAgICBjb250cm9sbGVyLmNsb3NlKCk7XG4gICAgICB9KTtcbiAgICAgIHJlYWRTdHJlYW0ub24oXCJlcnJvclwiLCAoZXJyKSA9PiB7XG4gICAgICAgIGNvbnRyb2xsZXIuZXJyb3IoZXJyKTtcbiAgICAgIH0pO1xuICAgIH0sXG4gICAgY2FuY2VsKCkge1xuICAgICAgcmVhZFN0cmVhbS5kZXN0cm95KCk7XG4gICAgfSxcbiAgfSk7XG59XG5cbi8qKlxuICogQHBhcmFtIHtCdWZmZXJ9IGJ1ZmZlclxuICogQHJldHVybnMge1JlYWRhYmxlU3RyZWFtfVxuICovXG5mdW5jdGlvbiBidWZmZXJUb1JlYWRhYmxlU3RyZWFtKGJ1ZmZlcikge1xuICByZXR1cm4gbmV3IFJlYWRhYmxlU3RyZWFtKHtcbiAgICBzdGFydChjb250cm9sbGVyKSB7XG4gICAgICBjb250cm9sbGVyLmVucXVldWUoYnVmZmVyKTtcbiAgICAgIGNvbnRyb2xsZXIuY2xvc2UoKTtcbiAgICB9LFxuICB9KTtcbn1cblxuY2xhc3MgSW5wdXRGaWxlIHtcbiAgLyoqIEB0eXBlIHtSZWFkYWJsZVN0cmVhbX0gQ29udGVudCBvZiBmaWxlIGFzIGEgc3RyZWFtICovXG4gIHN0cmVhbTtcblxuICAvKiogQHR5cGUge251bWJlcn0gVG90YWwgZmluYWwgc2l6ZSBvZiB0aGUgZmlsZSBjb250ZW50ICovXG4gIHNpemU7XG5cbiAgLyoqIEB0eXBlIHtzdHJpbmd9IEZpbGUgbmFtZSAqL1xuICBmaWxlbmFtZTtcblxuICAvKipcbiAgICogQHBhcmFtIHtzdHJpbmd9IGZpbGVQYXRoXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBmaWxlbmFtZVxuICAgKiBAcmV0dXJucyB7SW5wdXRGaWxlfVxuICAgKi9cbiAgc3RhdGljIGZyb21QYXRoID0gKGZpbGVQYXRoLCBmaWxlbmFtZSkgPT4ge1xuICAgIGNvbnN0IG5vZGVTdHJlYW0gPSBmcy5jcmVhdGVSZWFkU3RyZWFtKGZpbGVQYXRoKTtcbiAgICBjb25zdCBzdHJlYW0gPSBjb252ZXJ0UmVhZFN0cmVhbVRvUmVhZGFibGVTdHJlYW0obm9kZVN0cmVhbSk7XG4gICAgY29uc3Qgc2l6ZSA9IGZzLnN0YXRTeW5jKGZpbGVQYXRoKS5zaXplO1xuICAgIHJldHVybiBuZXcgSW5wdXRGaWxlKHN0cmVhbSwgZmlsZW5hbWUsIHNpemUpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBAcGFyYW0ge0J1ZmZlcn0gYnVmZmVyXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBmaWxlbmFtZVxuICAgKiBAcmV0dXJucyB7SW5wdXRGaWxlfVxuICAgKi9cbiAgc3RhdGljIGZyb21CdWZmZXIgPSAoYnVmZmVyLCBmaWxlbmFtZSkgPT4ge1xuICAgIGNvbnN0IHN0cmVhbSA9IGJ1ZmZlclRvUmVhZGFibGVTdHJlYW0oYnVmZmVyKTtcbiAgICBjb25zdCBzaXplID0gYnVmZmVyLmJ5dGVMZW5ndGg7XG4gICAgcmV0dXJuIG5ldyBJbnB1dEZpbGUoc3RyZWFtLCBmaWxlbmFtZSwgc2l6ZSk7XG4gIH07XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBjb250ZW50XG4gICAqIEBwYXJhbSB7c3RyaW5nfSBmaWxlbmFtZVxuICAgKiBAcmV0dXJucyB7SW5wdXRGaWxlfVxuICAgKi9cbiAgc3RhdGljIGZyb21QbGFpblRleHQgPSAoY29udGVudCwgZmlsZW5hbWUpID0+IHtcbiAgICBjb25zdCBhcnJheSA9IG5ldyBUZXh0RW5jb2RlcigpLmVuY29kZShjb250ZW50KTtcbiAgICBjb25zdCBidWZmZXIgPSBCdWZmZXIuZnJvbShhcnJheSk7XG4gICAgcmV0dXJuIElucHV0RmlsZS5mcm9tQnVmZmVyKGJ1ZmZlciwgZmlsZW5hbWUpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBAcGFyYW0ge1JlYWRhYmxlU3RyZWFtfSBzdHJlYW1cbiAgICogQHBhcmFtIHtzdHJpbmd9IGZpbGVuYW1lXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBzaXplXG4gICAqIEByZXR1cm5zIHtJbnB1dEZpbGV9XG4gICAqL1xuICBzdGF0aWMgZnJvbVN0cmVhbSA9IChzdHJlYW0sIGZpbGVuYW1lLCBzaXplKSA9PiB7XG4gICAgcmV0dXJuIG5ldyBJbnB1dEZpbGUoc3RyZWFtLCBmaWxlbmFtZSwgc2l6ZSk7XG4gIH07XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7QmxvYn0gYmxvYlxuICAgKiBAcGFyYW0ge3N0cmluZ30gZmlsZW5hbWVcbiAgICogQHJldHVybnMge0lucHV0RmlsZX1cbiAgICovXG4gIHN0YXRpYyBmcm9tQmxvYiA9IChibG9iLCBmaWxlbmFtZSkgPT4ge1xuICAgIGNvbnN0IHN0cmVhbSA9IGJsb2Iuc3RyZWFtKCk7XG4gICAgY29uc3Qgc2l6ZSA9IGJsb2Iuc2l6ZTtcbiAgICByZXR1cm4gbmV3IElucHV0RmlsZShzdHJlYW0sIGZpbGVuYW1lLCBzaXplKTtcbiAgfTtcblxuICAvKipcbiAgICogQHBhcmFtIHtSZWFkYWJsZVN0cmVhbX0gc3RyZWFtXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBmaWxlbmFtZVxuICAgKiBAcGFyYW0ge251bWJlcn0gc2l6ZVxuICAgKi9cbiAgY29uc3RydWN0b3Ioc3RyZWFtLCBmaWxlbmFtZSwgc2l6ZSkge1xuICAgIHRoaXMuc3RyZWFtID0gc3RyZWFtO1xuICAgIHRoaXMuZmlsZW5hbWUgPSBmaWxlbmFtZTtcbiAgICB0aGlzLnNpemUgPSBzaXplO1xuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gSW5wdXRGaWxlO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/node-appwrite/lib/inputFile.js\n");

/***/ }),

/***/ "(action-browser)/./node_modules/node-appwrite/lib/permission.js":
/*!******************************************************!*\
  !*** ./node_modules/node-appwrite/lib/permission.js ***!
  \******************************************************/
/***/ ((module) => {

eval("class Permission {\n\n    static read = (role) => {\n         return `read(\"${role}\")`\n    }\n\n    static write = (role) => {\n         return `write(\"${role}\")`\n    }\n\n    static create = (role) => {\n         return `create(\"${role}\")`\n    }\n\n    static update = (role) => {\n         return `update(\"${role}\")`\n    }\n\n    static delete = (role) => {\n         return `delete(\"${role}\")`\n    }\n}\n\nmodule.exports = Permission;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFjdGlvbi1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9ub2RlLWFwcHdyaXRlL2xpYi9wZXJtaXNzaW9uLmpzIiwibWFwcGluZ3MiOiJBQUFBOztBQUVBO0FBQ0EseUJBQXlCLEtBQUs7QUFDOUI7O0FBRUE7QUFDQSwwQkFBMEIsS0FBSztBQUMvQjs7QUFFQTtBQUNBLDJCQUEyQixLQUFLO0FBQ2hDOztBQUVBO0FBQ0EsMkJBQTJCLEtBQUs7QUFDaEM7O0FBRUE7QUFDQSwyQkFBMkIsS0FBSztBQUNoQztBQUNBOztBQUVBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vanNtX2JhbmtpbmcvLi9ub2RlX21vZHVsZXMvbm9kZS1hcHB3cml0ZS9saWIvcGVybWlzc2lvbi5qcz83NzYzIl0sInNvdXJjZXNDb250ZW50IjpbImNsYXNzIFBlcm1pc3Npb24ge1xuXG4gICAgc3RhdGljIHJlYWQgPSAocm9sZSkgPT4ge1xuICAgICAgICAgcmV0dXJuIGByZWFkKFwiJHtyb2xlfVwiKWBcbiAgICB9XG5cbiAgICBzdGF0aWMgd3JpdGUgPSAocm9sZSkgPT4ge1xuICAgICAgICAgcmV0dXJuIGB3cml0ZShcIiR7cm9sZX1cIilgXG4gICAgfVxuXG4gICAgc3RhdGljIGNyZWF0ZSA9IChyb2xlKSA9PiB7XG4gICAgICAgICByZXR1cm4gYGNyZWF0ZShcIiR7cm9sZX1cIilgXG4gICAgfVxuXG4gICAgc3RhdGljIHVwZGF0ZSA9IChyb2xlKSA9PiB7XG4gICAgICAgICByZXR1cm4gYHVwZGF0ZShcIiR7cm9sZX1cIilgXG4gICAgfVxuXG4gICAgc3RhdGljIGRlbGV0ZSA9IChyb2xlKSA9PiB7XG4gICAgICAgICByZXR1cm4gYGRlbGV0ZShcIiR7cm9sZX1cIilgXG4gICAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IFBlcm1pc3Npb247XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(action-browser)/./node_modules/node-appwrite/lib/permission.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/node-appwrite/lib/permission.js":
/*!******************************************************!*\
  !*** ./node_modules/node-appwrite/lib/permission.js ***!
  \******************************************************/
/***/ ((module) => {

eval("class Permission {\n\n    static read = (role) => {\n         return `read(\"${role}\")`\n    }\n\n    static write = (role) => {\n         return `write(\"${role}\")`\n    }\n\n    static create = (role) => {\n         return `create(\"${role}\")`\n    }\n\n    static update = (role) => {\n         return `update(\"${role}\")`\n    }\n\n    static delete = (role) => {\n         return `delete(\"${role}\")`\n    }\n}\n\nmodule.exports = Permission;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvbm9kZS1hcHB3cml0ZS9saWIvcGVybWlzc2lvbi5qcyIsIm1hcHBpbmdzIjoiQUFBQTs7QUFFQTtBQUNBLHlCQUF5QixLQUFLO0FBQzlCOztBQUVBO0FBQ0EsMEJBQTBCLEtBQUs7QUFDL0I7O0FBRUE7QUFDQSwyQkFBMkIsS0FBSztBQUNoQzs7QUFFQTtBQUNBLDJCQUEyQixLQUFLO0FBQ2hDOztBQUVBO0FBQ0EsMkJBQTJCLEtBQUs7QUFDaEM7QUFDQTs7QUFFQSIsInNvdXJjZXMiOlsid2VicGFjazovL2pzbV9iYW5raW5nLy4vbm9kZV9tb2R1bGVzL25vZGUtYXBwd3JpdGUvbGliL3Blcm1pc3Npb24uanM/MTdjOCJdLCJzb3VyY2VzQ29udGVudCI6WyJjbGFzcyBQZXJtaXNzaW9uIHtcblxuICAgIHN0YXRpYyByZWFkID0gKHJvbGUpID0+IHtcbiAgICAgICAgIHJldHVybiBgcmVhZChcIiR7cm9sZX1cIilgXG4gICAgfVxuXG4gICAgc3RhdGljIHdyaXRlID0gKHJvbGUpID0+IHtcbiAgICAgICAgIHJldHVybiBgd3JpdGUoXCIke3JvbGV9XCIpYFxuICAgIH1cblxuICAgIHN0YXRpYyBjcmVhdGUgPSAocm9sZSkgPT4ge1xuICAgICAgICAgcmV0dXJuIGBjcmVhdGUoXCIke3JvbGV9XCIpYFxuICAgIH1cblxuICAgIHN0YXRpYyB1cGRhdGUgPSAocm9sZSkgPT4ge1xuICAgICAgICAgcmV0dXJuIGB1cGRhdGUoXCIke3JvbGV9XCIpYFxuICAgIH1cblxuICAgIHN0YXRpYyBkZWxldGUgPSAocm9sZSkgPT4ge1xuICAgICAgICAgcmV0dXJuIGBkZWxldGUoXCIke3JvbGV9XCIpYFxuICAgIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBQZXJtaXNzaW9uO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/node-appwrite/lib/permission.js\n");

/***/ }),

/***/ "(action-browser)/./node_modules/node-appwrite/lib/query.js":
/*!*************************************************!*\
  !*** ./node_modules/node-appwrite/lib/query.js ***!
  \*************************************************/
/***/ ((module) => {

eval("class Query {\n  constructor(method, attribute, values) {\n    this.method = method\n    this.attribute = attribute\n\n    if (values !== undefined) {\n      if (Array.isArray(values)) {\n        this.values = values\n      } else {\n        this.values = [values]\n      }\n    }\n  }\n\n  static equal = (attribute, value) =>\n    new Query(\"equal\", attribute, value).toString()\n\n  static notEqual = (attribute, value) =>\n    new Query(\"notEqual\", attribute, value).toString()\n\n  static lessThan = (attribute, value) =>\n    new Query(\"lessThan\", attribute, value).toString()\n\n  static lessThanEqual = (attribute, value) =>\n    new Query(\"lessThanEqual\", attribute, value).toString()\n\n  static greaterThan = (attribute, value) =>\n    new Query(\"greaterThan\", attribute, value).toString()\n\n  static greaterThanEqual = (attribute, value) =>\n    new Query(\"greaterThanEqual\", attribute, value).toString()\n\n  static isNull = attribute =>\n    new Query(\"isNull\", attribute).toString()\n\n  static isNotNull = attribute =>\n    new Query(\"isNotNull\", attribute).toString()\n\n  static between = (attribute, start, end) =>\n    new Query(\"between\", attribute, [start, end]).toString()\n\n  static startsWith = (attribute, value) =>\n    new Query(\"startsWith\", attribute, value).toString()\n\n  static endsWith = (attribute, value) =>\n    new Query(\"endsWith\", attribute, value).toString()\n\n  static select = attributes =>\n    new Query(\"select\", undefined, attributes).toString()\n\n  static search = (attribute, value) =>\n    new Query(\"search\", attribute, value).toString()\n\n  static orderDesc = attribute =>\n    new Query(\"orderDesc\", attribute).toString()\n\n  static orderAsc = attribute =>\n    new Query(\"orderAsc\", attribute).toString()\n\n  static cursorAfter = documentId =>\n    new Query(\"cursorAfter\", undefined, documentId).toString()\n\n  static cursorBefore = documentId =>\n    new Query(\"cursorBefore\", undefined, documentId).toString()\n\n  static limit = limit =>\n    new Query(\"limit\", undefined, limit).toString()\n\n  static offset = offset =>\n    new Query(\"offset\", undefined, offset).toString()\n\n  static contains = (attribute, value) =>\n    new Query(\"contains\", attribute, value).toString()\n\n  static or = (queries) =>\n    new Query(\"or\", undefined, queries.map((query) => JSON.parse(query))).toString()\n\n  static and = (queries) =>\n    new Query(\"and\", undefined, queries.map((query) => JSON.parse(query))).toString();\n}\n\nQuery.prototype.toString = function () {\n  return JSON.stringify({\n    method: this.method,\n    attribute: this.attribute,\n    values: this.values\n  })\n} \n\nmodule.exports = Query;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFjdGlvbi1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9ub2RlLWFwcHdyaXRlL2xpYi9xdWVyeS5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUEiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9qc21fYmFua2luZy8uL25vZGVfbW9kdWxlcy9ub2RlLWFwcHdyaXRlL2xpYi9xdWVyeS5qcz84MDM0Il0sInNvdXJjZXNDb250ZW50IjpbImNsYXNzIFF1ZXJ5IHtcbiAgY29uc3RydWN0b3IobWV0aG9kLCBhdHRyaWJ1dGUsIHZhbHVlcykge1xuICAgIHRoaXMubWV0aG9kID0gbWV0aG9kXG4gICAgdGhpcy5hdHRyaWJ1dGUgPSBhdHRyaWJ1dGVcblxuICAgIGlmICh2YWx1ZXMgIT09IHVuZGVmaW5lZCkge1xuICAgICAgaWYgKEFycmF5LmlzQXJyYXkodmFsdWVzKSkge1xuICAgICAgICB0aGlzLnZhbHVlcyA9IHZhbHVlc1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy52YWx1ZXMgPSBbdmFsdWVzXVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHN0YXRpYyBlcXVhbCA9IChhdHRyaWJ1dGUsIHZhbHVlKSA9PlxuICAgIG5ldyBRdWVyeShcImVxdWFsXCIsIGF0dHJpYnV0ZSwgdmFsdWUpLnRvU3RyaW5nKClcblxuICBzdGF0aWMgbm90RXF1YWwgPSAoYXR0cmlidXRlLCB2YWx1ZSkgPT5cbiAgICBuZXcgUXVlcnkoXCJub3RFcXVhbFwiLCBhdHRyaWJ1dGUsIHZhbHVlKS50b1N0cmluZygpXG5cbiAgc3RhdGljIGxlc3NUaGFuID0gKGF0dHJpYnV0ZSwgdmFsdWUpID0+XG4gICAgbmV3IFF1ZXJ5KFwibGVzc1RoYW5cIiwgYXR0cmlidXRlLCB2YWx1ZSkudG9TdHJpbmcoKVxuXG4gIHN0YXRpYyBsZXNzVGhhbkVxdWFsID0gKGF0dHJpYnV0ZSwgdmFsdWUpID0+XG4gICAgbmV3IFF1ZXJ5KFwibGVzc1RoYW5FcXVhbFwiLCBhdHRyaWJ1dGUsIHZhbHVlKS50b1N0cmluZygpXG5cbiAgc3RhdGljIGdyZWF0ZXJUaGFuID0gKGF0dHJpYnV0ZSwgdmFsdWUpID0+XG4gICAgbmV3IFF1ZXJ5KFwiZ3JlYXRlclRoYW5cIiwgYXR0cmlidXRlLCB2YWx1ZSkudG9TdHJpbmcoKVxuXG4gIHN0YXRpYyBncmVhdGVyVGhhbkVxdWFsID0gKGF0dHJpYnV0ZSwgdmFsdWUpID0+XG4gICAgbmV3IFF1ZXJ5KFwiZ3JlYXRlclRoYW5FcXVhbFwiLCBhdHRyaWJ1dGUsIHZhbHVlKS50b1N0cmluZygpXG5cbiAgc3RhdGljIGlzTnVsbCA9IGF0dHJpYnV0ZSA9PlxuICAgIG5ldyBRdWVyeShcImlzTnVsbFwiLCBhdHRyaWJ1dGUpLnRvU3RyaW5nKClcblxuICBzdGF0aWMgaXNOb3ROdWxsID0gYXR0cmlidXRlID0+XG4gICAgbmV3IFF1ZXJ5KFwiaXNOb3ROdWxsXCIsIGF0dHJpYnV0ZSkudG9TdHJpbmcoKVxuXG4gIHN0YXRpYyBiZXR3ZWVuID0gKGF0dHJpYnV0ZSwgc3RhcnQsIGVuZCkgPT5cbiAgICBuZXcgUXVlcnkoXCJiZXR3ZWVuXCIsIGF0dHJpYnV0ZSwgW3N0YXJ0LCBlbmRdKS50b1N0cmluZygpXG5cbiAgc3RhdGljIHN0YXJ0c1dpdGggPSAoYXR0cmlidXRlLCB2YWx1ZSkgPT5cbiAgICBuZXcgUXVlcnkoXCJzdGFydHNXaXRoXCIsIGF0dHJpYnV0ZSwgdmFsdWUpLnRvU3RyaW5nKClcblxuICBzdGF0aWMgZW5kc1dpdGggPSAoYXR0cmlidXRlLCB2YWx1ZSkgPT5cbiAgICBuZXcgUXVlcnkoXCJlbmRzV2l0aFwiLCBhdHRyaWJ1dGUsIHZhbHVlKS50b1N0cmluZygpXG5cbiAgc3RhdGljIHNlbGVjdCA9IGF0dHJpYnV0ZXMgPT5cbiAgICBuZXcgUXVlcnkoXCJzZWxlY3RcIiwgdW5kZWZpbmVkLCBhdHRyaWJ1dGVzKS50b1N0cmluZygpXG5cbiAgc3RhdGljIHNlYXJjaCA9IChhdHRyaWJ1dGUsIHZhbHVlKSA9PlxuICAgIG5ldyBRdWVyeShcInNlYXJjaFwiLCBhdHRyaWJ1dGUsIHZhbHVlKS50b1N0cmluZygpXG5cbiAgc3RhdGljIG9yZGVyRGVzYyA9IGF0dHJpYnV0ZSA9PlxuICAgIG5ldyBRdWVyeShcIm9yZGVyRGVzY1wiLCBhdHRyaWJ1dGUpLnRvU3RyaW5nKClcblxuICBzdGF0aWMgb3JkZXJBc2MgPSBhdHRyaWJ1dGUgPT5cbiAgICBuZXcgUXVlcnkoXCJvcmRlckFzY1wiLCBhdHRyaWJ1dGUpLnRvU3RyaW5nKClcblxuICBzdGF0aWMgY3Vyc29yQWZ0ZXIgPSBkb2N1bWVudElkID0+XG4gICAgbmV3IFF1ZXJ5KFwiY3Vyc29yQWZ0ZXJcIiwgdW5kZWZpbmVkLCBkb2N1bWVudElkKS50b1N0cmluZygpXG5cbiAgc3RhdGljIGN1cnNvckJlZm9yZSA9IGRvY3VtZW50SWQgPT5cbiAgICBuZXcgUXVlcnkoXCJjdXJzb3JCZWZvcmVcIiwgdW5kZWZpbmVkLCBkb2N1bWVudElkKS50b1N0cmluZygpXG5cbiAgc3RhdGljIGxpbWl0ID0gbGltaXQgPT5cbiAgICBuZXcgUXVlcnkoXCJsaW1pdFwiLCB1bmRlZmluZWQsIGxpbWl0KS50b1N0cmluZygpXG5cbiAgc3RhdGljIG9mZnNldCA9IG9mZnNldCA9PlxuICAgIG5ldyBRdWVyeShcIm9mZnNldFwiLCB1bmRlZmluZWQsIG9mZnNldCkudG9TdHJpbmcoKVxuXG4gIHN0YXRpYyBjb250YWlucyA9IChhdHRyaWJ1dGUsIHZhbHVlKSA9PlxuICAgIG5ldyBRdWVyeShcImNvbnRhaW5zXCIsIGF0dHJpYnV0ZSwgdmFsdWUpLnRvU3RyaW5nKClcblxuICBzdGF0aWMgb3IgPSAocXVlcmllcykgPT5cbiAgICBuZXcgUXVlcnkoXCJvclwiLCB1bmRlZmluZWQsIHF1ZXJpZXMubWFwKChxdWVyeSkgPT4gSlNPTi5wYXJzZShxdWVyeSkpKS50b1N0cmluZygpXG5cbiAgc3RhdGljIGFuZCA9IChxdWVyaWVzKSA9PlxuICAgIG5ldyBRdWVyeShcImFuZFwiLCB1bmRlZmluZWQsIHF1ZXJpZXMubWFwKChxdWVyeSkgPT4gSlNPTi5wYXJzZShxdWVyeSkpKS50b1N0cmluZygpO1xufVxuXG5RdWVyeS5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiBKU09OLnN0cmluZ2lmeSh7XG4gICAgbWV0aG9kOiB0aGlzLm1ldGhvZCxcbiAgICBhdHRyaWJ1dGU6IHRoaXMuYXR0cmlidXRlLFxuICAgIHZhbHVlczogdGhpcy52YWx1ZXNcbiAgfSlcbn0gXG5cbm1vZHVsZS5leHBvcnRzID0gUXVlcnk7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(action-browser)/./node_modules/node-appwrite/lib/query.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/node-appwrite/lib/query.js":
/*!*************************************************!*\
  !*** ./node_modules/node-appwrite/lib/query.js ***!
  \*************************************************/
/***/ ((module) => {

eval("class Query {\n  constructor(method, attribute, values) {\n    this.method = method\n    this.attribute = attribute\n\n    if (values !== undefined) {\n      if (Array.isArray(values)) {\n        this.values = values\n      } else {\n        this.values = [values]\n      }\n    }\n  }\n\n  static equal = (attribute, value) =>\n    new Query(\"equal\", attribute, value).toString()\n\n  static notEqual = (attribute, value) =>\n    new Query(\"notEqual\", attribute, value).toString()\n\n  static lessThan = (attribute, value) =>\n    new Query(\"lessThan\", attribute, value).toString()\n\n  static lessThanEqual = (attribute, value) =>\n    new Query(\"lessThanEqual\", attribute, value).toString()\n\n  static greaterThan = (attribute, value) =>\n    new Query(\"greaterThan\", attribute, value).toString()\n\n  static greaterThanEqual = (attribute, value) =>\n    new Query(\"greaterThanEqual\", attribute, value).toString()\n\n  static isNull = attribute =>\n    new Query(\"isNull\", attribute).toString()\n\n  static isNotNull = attribute =>\n    new Query(\"isNotNull\", attribute).toString()\n\n  static between = (attribute, start, end) =>\n    new Query(\"between\", attribute, [start, end]).toString()\n\n  static startsWith = (attribute, value) =>\n    new Query(\"startsWith\", attribute, value).toString()\n\n  static endsWith = (attribute, value) =>\n    new Query(\"endsWith\", attribute, value).toString()\n\n  static select = attributes =>\n    new Query(\"select\", undefined, attributes).toString()\n\n  static search = (attribute, value) =>\n    new Query(\"search\", attribute, value).toString()\n\n  static orderDesc = attribute =>\n    new Query(\"orderDesc\", attribute).toString()\n\n  static orderAsc = attribute =>\n    new Query(\"orderAsc\", attribute).toString()\n\n  static cursorAfter = documentId =>\n    new Query(\"cursorAfter\", undefined, documentId).toString()\n\n  static cursorBefore = documentId =>\n    new Query(\"cursorBefore\", undefined, documentId).toString()\n\n  static limit = limit =>\n    new Query(\"limit\", undefined, limit).toString()\n\n  static offset = offset =>\n    new Query(\"offset\", undefined, offset).toString()\n\n  static contains = (attribute, value) =>\n    new Query(\"contains\", attribute, value).toString()\n\n  static or = (queries) =>\n    new Query(\"or\", undefined, queries.map((query) => JSON.parse(query))).toString()\n\n  static and = (queries) =>\n    new Query(\"and\", undefined, queries.map((query) => JSON.parse(query))).toString();\n}\n\nQuery.prototype.toString = function () {\n  return JSON.stringify({\n    method: this.method,\n    attribute: this.attribute,\n    values: this.values\n  })\n} \n\nmodule.exports = Query;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvbm9kZS1hcHB3cml0ZS9saWIvcXVlcnkuanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vanNtX2JhbmtpbmcvLi9ub2RlX21vZHVsZXMvbm9kZS1hcHB3cml0ZS9saWIvcXVlcnkuanM/OWRjZSJdLCJzb3VyY2VzQ29udGVudCI6WyJjbGFzcyBRdWVyeSB7XG4gIGNvbnN0cnVjdG9yKG1ldGhvZCwgYXR0cmlidXRlLCB2YWx1ZXMpIHtcbiAgICB0aGlzLm1ldGhvZCA9IG1ldGhvZFxuICAgIHRoaXMuYXR0cmlidXRlID0gYXR0cmlidXRlXG5cbiAgICBpZiAodmFsdWVzICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIGlmIChBcnJheS5pc0FycmF5KHZhbHVlcykpIHtcbiAgICAgICAgdGhpcy52YWx1ZXMgPSB2YWx1ZXNcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMudmFsdWVzID0gW3ZhbHVlc11cbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBzdGF0aWMgZXF1YWwgPSAoYXR0cmlidXRlLCB2YWx1ZSkgPT5cbiAgICBuZXcgUXVlcnkoXCJlcXVhbFwiLCBhdHRyaWJ1dGUsIHZhbHVlKS50b1N0cmluZygpXG5cbiAgc3RhdGljIG5vdEVxdWFsID0gKGF0dHJpYnV0ZSwgdmFsdWUpID0+XG4gICAgbmV3IFF1ZXJ5KFwibm90RXF1YWxcIiwgYXR0cmlidXRlLCB2YWx1ZSkudG9TdHJpbmcoKVxuXG4gIHN0YXRpYyBsZXNzVGhhbiA9IChhdHRyaWJ1dGUsIHZhbHVlKSA9PlxuICAgIG5ldyBRdWVyeShcImxlc3NUaGFuXCIsIGF0dHJpYnV0ZSwgdmFsdWUpLnRvU3RyaW5nKClcblxuICBzdGF0aWMgbGVzc1RoYW5FcXVhbCA9IChhdHRyaWJ1dGUsIHZhbHVlKSA9PlxuICAgIG5ldyBRdWVyeShcImxlc3NUaGFuRXF1YWxcIiwgYXR0cmlidXRlLCB2YWx1ZSkudG9TdHJpbmcoKVxuXG4gIHN0YXRpYyBncmVhdGVyVGhhbiA9IChhdHRyaWJ1dGUsIHZhbHVlKSA9PlxuICAgIG5ldyBRdWVyeShcImdyZWF0ZXJUaGFuXCIsIGF0dHJpYnV0ZSwgdmFsdWUpLnRvU3RyaW5nKClcblxuICBzdGF0aWMgZ3JlYXRlclRoYW5FcXVhbCA9IChhdHRyaWJ1dGUsIHZhbHVlKSA9PlxuICAgIG5ldyBRdWVyeShcImdyZWF0ZXJUaGFuRXF1YWxcIiwgYXR0cmlidXRlLCB2YWx1ZSkudG9TdHJpbmcoKVxuXG4gIHN0YXRpYyBpc051bGwgPSBhdHRyaWJ1dGUgPT5cbiAgICBuZXcgUXVlcnkoXCJpc051bGxcIiwgYXR0cmlidXRlKS50b1N0cmluZygpXG5cbiAgc3RhdGljIGlzTm90TnVsbCA9IGF0dHJpYnV0ZSA9PlxuICAgIG5ldyBRdWVyeShcImlzTm90TnVsbFwiLCBhdHRyaWJ1dGUpLnRvU3RyaW5nKClcblxuICBzdGF0aWMgYmV0d2VlbiA9IChhdHRyaWJ1dGUsIHN0YXJ0LCBlbmQpID0+XG4gICAgbmV3IFF1ZXJ5KFwiYmV0d2VlblwiLCBhdHRyaWJ1dGUsIFtzdGFydCwgZW5kXSkudG9TdHJpbmcoKVxuXG4gIHN0YXRpYyBzdGFydHNXaXRoID0gKGF0dHJpYnV0ZSwgdmFsdWUpID0+XG4gICAgbmV3IFF1ZXJ5KFwic3RhcnRzV2l0aFwiLCBhdHRyaWJ1dGUsIHZhbHVlKS50b1N0cmluZygpXG5cbiAgc3RhdGljIGVuZHNXaXRoID0gKGF0dHJpYnV0ZSwgdmFsdWUpID0+XG4gICAgbmV3IFF1ZXJ5KFwiZW5kc1dpdGhcIiwgYXR0cmlidXRlLCB2YWx1ZSkudG9TdHJpbmcoKVxuXG4gIHN0YXRpYyBzZWxlY3QgPSBhdHRyaWJ1dGVzID0+XG4gICAgbmV3IFF1ZXJ5KFwic2VsZWN0XCIsIHVuZGVmaW5lZCwgYXR0cmlidXRlcykudG9TdHJpbmcoKVxuXG4gIHN0YXRpYyBzZWFyY2ggPSAoYXR0cmlidXRlLCB2YWx1ZSkgPT5cbiAgICBuZXcgUXVlcnkoXCJzZWFyY2hcIiwgYXR0cmlidXRlLCB2YWx1ZSkudG9TdHJpbmcoKVxuXG4gIHN0YXRpYyBvcmRlckRlc2MgPSBhdHRyaWJ1dGUgPT5cbiAgICBuZXcgUXVlcnkoXCJvcmRlckRlc2NcIiwgYXR0cmlidXRlKS50b1N0cmluZygpXG5cbiAgc3RhdGljIG9yZGVyQXNjID0gYXR0cmlidXRlID0+XG4gICAgbmV3IFF1ZXJ5KFwib3JkZXJBc2NcIiwgYXR0cmlidXRlKS50b1N0cmluZygpXG5cbiAgc3RhdGljIGN1cnNvckFmdGVyID0gZG9jdW1lbnRJZCA9PlxuICAgIG5ldyBRdWVyeShcImN1cnNvckFmdGVyXCIsIHVuZGVmaW5lZCwgZG9jdW1lbnRJZCkudG9TdHJpbmcoKVxuXG4gIHN0YXRpYyBjdXJzb3JCZWZvcmUgPSBkb2N1bWVudElkID0+XG4gICAgbmV3IFF1ZXJ5KFwiY3Vyc29yQmVmb3JlXCIsIHVuZGVmaW5lZCwgZG9jdW1lbnRJZCkudG9TdHJpbmcoKVxuXG4gIHN0YXRpYyBsaW1pdCA9IGxpbWl0ID0+XG4gICAgbmV3IFF1ZXJ5KFwibGltaXRcIiwgdW5kZWZpbmVkLCBsaW1pdCkudG9TdHJpbmcoKVxuXG4gIHN0YXRpYyBvZmZzZXQgPSBvZmZzZXQgPT5cbiAgICBuZXcgUXVlcnkoXCJvZmZzZXRcIiwgdW5kZWZpbmVkLCBvZmZzZXQpLnRvU3RyaW5nKClcblxuICBzdGF0aWMgY29udGFpbnMgPSAoYXR0cmlidXRlLCB2YWx1ZSkgPT5cbiAgICBuZXcgUXVlcnkoXCJjb250YWluc1wiLCBhdHRyaWJ1dGUsIHZhbHVlKS50b1N0cmluZygpXG5cbiAgc3RhdGljIG9yID0gKHF1ZXJpZXMpID0+XG4gICAgbmV3IFF1ZXJ5KFwib3JcIiwgdW5kZWZpbmVkLCBxdWVyaWVzLm1hcCgocXVlcnkpID0+IEpTT04ucGFyc2UocXVlcnkpKSkudG9TdHJpbmcoKVxuXG4gIHN0YXRpYyBhbmQgPSAocXVlcmllcykgPT5cbiAgICBuZXcgUXVlcnkoXCJhbmRcIiwgdW5kZWZpbmVkLCBxdWVyaWVzLm1hcCgocXVlcnkpID0+IEpTT04ucGFyc2UocXVlcnkpKSkudG9TdHJpbmcoKTtcbn1cblxuUXVlcnkucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gSlNPTi5zdHJpbmdpZnkoe1xuICAgIG1ldGhvZDogdGhpcy5tZXRob2QsXG4gICAgYXR0cmlidXRlOiB0aGlzLmF0dHJpYnV0ZSxcbiAgICB2YWx1ZXM6IHRoaXMudmFsdWVzXG4gIH0pXG59IFxuXG5tb2R1bGUuZXhwb3J0cyA9IFF1ZXJ5O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/node-appwrite/lib/query.js\n");

/***/ }),

/***/ "(action-browser)/./node_modules/node-appwrite/lib/role.js":
/*!************************************************!*\
  !*** ./node_modules/node-appwrite/lib/role.js ***!
  \************************************************/
/***/ ((module) => {

eval("/**\n * Helper class to generate role strings for `Permission`.\n */\nclass Role {\n\n    /**\n     * Grants access to anyone.\n     *\n     * This includes authenticated and unauthenticated users.\n     *\n     * @returns {string}\n     */\n    static any = () => {\n        return 'any'\n    }\n\n    /**\n     * Grants access to a specific user by user ID.\n     *\n     * You can optionally pass verified or unverified for\n     * `status` to target specific types of users.\n     *\n     * @param {string} id \n     * @param {string} status \n     * @returns {string}\n     */\n    static user = (id, status = '') => {\n        if (status === '') {\n            return `user:${id}`\n        }\n        return `user:${id}/${status}`\n    }\n\n    /**\n     * Grants access to any authenticated or anonymous user.\n     *\n     * You can optionally pass verified or unverified for\n     * `status` to target specific types of users.\n     *\n     * @param {string} status \n     * @returns {string}\n     */\n    static users = (status = '') => {\n        if (status === '') {\n            return 'users'\n        }\n        return `users/${status}`\n    }\n\n    /**\n     * Grants access to any guest user without a session.\n     *\n     * Authenticated users don't have access to this role.\n     *\n     * @returns {string}\n     */\n    static guests = () => {\n        return 'guests'\n    }\n\n    /**\n     * Grants access to a team by team ID.\n     *\n     * You can optionally pass a role for `role` to target\n     * team members with the specified role.\n     * \n     * @param {string} id \n     * @param {string} role \n     * @returns {string}\n     */\n    static team = (id, role = '') => {\n        if (role === '') {\n            return 'team:' + id\n        }\n        return 'team:' + id + '/' + role\n    }\n\n    /**\n     * Grants access to a specific member of a team.\n     *\n     * When the member is removed from the team, they will\n     * no longer have access.\n     * \n     * @param {string} id \n     * @returns {string}\n     */\n    static member = (id) => {\n        return 'member:' + id\n    }\n\n    /**\n     * Grants access to a user with the specified label.\n     *\n     * @param {string} name \n     * @returns  {string}\n     */\n    static label = (name) => {\n        return 'label:' + name;\n    }\n}\n\nmodule.exports = Role;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFjdGlvbi1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9ub2RlLWFwcHdyaXRlL2xpYi9yb2xlLmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsUUFBUTtBQUN2QixpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLEdBQUc7QUFDOUI7QUFDQSx1QkFBdUIsR0FBRyxHQUFHLE9BQU87QUFDcEM7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLE9BQU87QUFDL0I7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkIsZUFBZSxRQUFRO0FBQ3ZCLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkIsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QixrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSIsInNvdXJjZXMiOlsid2VicGFjazovL2pzbV9iYW5raW5nLy4vbm9kZV9tb2R1bGVzL25vZGUtYXBwd3JpdGUvbGliL3JvbGUuanM/OTc5ZSJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEhlbHBlciBjbGFzcyB0byBnZW5lcmF0ZSByb2xlIHN0cmluZ3MgZm9yIGBQZXJtaXNzaW9uYC5cbiAqL1xuY2xhc3MgUm9sZSB7XG5cbiAgICAvKipcbiAgICAgKiBHcmFudHMgYWNjZXNzIHRvIGFueW9uZS5cbiAgICAgKlxuICAgICAqIFRoaXMgaW5jbHVkZXMgYXV0aGVudGljYXRlZCBhbmQgdW5hdXRoZW50aWNhdGVkIHVzZXJzLlxuICAgICAqXG4gICAgICogQHJldHVybnMge3N0cmluZ31cbiAgICAgKi9cbiAgICBzdGF0aWMgYW55ID0gKCkgPT4ge1xuICAgICAgICByZXR1cm4gJ2FueSdcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHcmFudHMgYWNjZXNzIHRvIGEgc3BlY2lmaWMgdXNlciBieSB1c2VyIElELlxuICAgICAqXG4gICAgICogWW91IGNhbiBvcHRpb25hbGx5IHBhc3MgdmVyaWZpZWQgb3IgdW52ZXJpZmllZCBmb3JcbiAgICAgKiBgc3RhdHVzYCB0byB0YXJnZXQgc3BlY2lmaWMgdHlwZXMgb2YgdXNlcnMuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gaWQgXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHN0YXR1cyBcbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfVxuICAgICAqL1xuICAgIHN0YXRpYyB1c2VyID0gKGlkLCBzdGF0dXMgPSAnJykgPT4ge1xuICAgICAgICBpZiAoc3RhdHVzID09PSAnJykge1xuICAgICAgICAgICAgcmV0dXJuIGB1c2VyOiR7aWR9YFxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBgdXNlcjoke2lkfS8ke3N0YXR1c31gXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR3JhbnRzIGFjY2VzcyB0byBhbnkgYXV0aGVudGljYXRlZCBvciBhbm9ueW1vdXMgdXNlci5cbiAgICAgKlxuICAgICAqIFlvdSBjYW4gb3B0aW9uYWxseSBwYXNzIHZlcmlmaWVkIG9yIHVudmVyaWZpZWQgZm9yXG4gICAgICogYHN0YXR1c2AgdG8gdGFyZ2V0IHNwZWNpZmljIHR5cGVzIG9mIHVzZXJzLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHN0YXR1cyBcbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfVxuICAgICAqL1xuICAgIHN0YXRpYyB1c2VycyA9IChzdGF0dXMgPSAnJykgPT4ge1xuICAgICAgICBpZiAoc3RhdHVzID09PSAnJykge1xuICAgICAgICAgICAgcmV0dXJuICd1c2VycydcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYHVzZXJzLyR7c3RhdHVzfWBcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHcmFudHMgYWNjZXNzIHRvIGFueSBndWVzdCB1c2VyIHdpdGhvdXQgYSBzZXNzaW9uLlxuICAgICAqXG4gICAgICogQXV0aGVudGljYXRlZCB1c2VycyBkb24ndCBoYXZlIGFjY2VzcyB0byB0aGlzIHJvbGUuXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfVxuICAgICAqL1xuICAgIHN0YXRpYyBndWVzdHMgPSAoKSA9PiB7XG4gICAgICAgIHJldHVybiAnZ3Vlc3RzJ1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdyYW50cyBhY2Nlc3MgdG8gYSB0ZWFtIGJ5IHRlYW0gSUQuXG4gICAgICpcbiAgICAgKiBZb3UgY2FuIG9wdGlvbmFsbHkgcGFzcyBhIHJvbGUgZm9yIGByb2xlYCB0byB0YXJnZXRcbiAgICAgKiB0ZWFtIG1lbWJlcnMgd2l0aCB0aGUgc3BlY2lmaWVkIHJvbGUuXG4gICAgICogXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGlkIFxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSByb2xlIFxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9XG4gICAgICovXG4gICAgc3RhdGljIHRlYW0gPSAoaWQsIHJvbGUgPSAnJykgPT4ge1xuICAgICAgICBpZiAocm9sZSA9PT0gJycpIHtcbiAgICAgICAgICAgIHJldHVybiAndGVhbTonICsgaWRcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gJ3RlYW06JyArIGlkICsgJy8nICsgcm9sZVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdyYW50cyBhY2Nlc3MgdG8gYSBzcGVjaWZpYyBtZW1iZXIgb2YgYSB0ZWFtLlxuICAgICAqXG4gICAgICogV2hlbiB0aGUgbWVtYmVyIGlzIHJlbW92ZWQgZnJvbSB0aGUgdGVhbSwgdGhleSB3aWxsXG4gICAgICogbm8gbG9uZ2VyIGhhdmUgYWNjZXNzLlxuICAgICAqIFxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBpZCBcbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfVxuICAgICAqL1xuICAgIHN0YXRpYyBtZW1iZXIgPSAoaWQpID0+IHtcbiAgICAgICAgcmV0dXJuICdtZW1iZXI6JyArIGlkXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR3JhbnRzIGFjY2VzcyB0byBhIHVzZXIgd2l0aCB0aGUgc3BlY2lmaWVkIGxhYmVsLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IG5hbWUgXG4gICAgICogQHJldHVybnMgIHtzdHJpbmd9XG4gICAgICovXG4gICAgc3RhdGljIGxhYmVsID0gKG5hbWUpID0+IHtcbiAgICAgICAgcmV0dXJuICdsYWJlbDonICsgbmFtZTtcbiAgICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gUm9sZTsiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(action-browser)/./node_modules/node-appwrite/lib/role.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/node-appwrite/lib/role.js":
/*!************************************************!*\
  !*** ./node_modules/node-appwrite/lib/role.js ***!
  \************************************************/
/***/ ((module) => {

eval("/**\n * Helper class to generate role strings for `Permission`.\n */\nclass Role {\n\n    /**\n     * Grants access to anyone.\n     *\n     * This includes authenticated and unauthenticated users.\n     *\n     * @returns {string}\n     */\n    static any = () => {\n        return 'any'\n    }\n\n    /**\n     * Grants access to a specific user by user ID.\n     *\n     * You can optionally pass verified or unverified for\n     * `status` to target specific types of users.\n     *\n     * @param {string} id \n     * @param {string} status \n     * @returns {string}\n     */\n    static user = (id, status = '') => {\n        if (status === '') {\n            return `user:${id}`\n        }\n        return `user:${id}/${status}`\n    }\n\n    /**\n     * Grants access to any authenticated or anonymous user.\n     *\n     * You can optionally pass verified or unverified for\n     * `status` to target specific types of users.\n     *\n     * @param {string} status \n     * @returns {string}\n     */\n    static users = (status = '') => {\n        if (status === '') {\n            return 'users'\n        }\n        return `users/${status}`\n    }\n\n    /**\n     * Grants access to any guest user without a session.\n     *\n     * Authenticated users don't have access to this role.\n     *\n     * @returns {string}\n     */\n    static guests = () => {\n        return 'guests'\n    }\n\n    /**\n     * Grants access to a team by team ID.\n     *\n     * You can optionally pass a role for `role` to target\n     * team members with the specified role.\n     * \n     * @param {string} id \n     * @param {string} role \n     * @returns {string}\n     */\n    static team = (id, role = '') => {\n        if (role === '') {\n            return 'team:' + id\n        }\n        return 'team:' + id + '/' + role\n    }\n\n    /**\n     * Grants access to a specific member of a team.\n     *\n     * When the member is removed from the team, they will\n     * no longer have access.\n     * \n     * @param {string} id \n     * @returns {string}\n     */\n    static member = (id) => {\n        return 'member:' + id\n    }\n\n    /**\n     * Grants access to a user with the specified label.\n     *\n     * @param {string} name \n     * @returns  {string}\n     */\n    static label = (name) => {\n        return 'label:' + name;\n    }\n}\n\nmodule.exports = Role;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvbm9kZS1hcHB3cml0ZS9saWIvcm9sZS5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QixlQUFlLFFBQVE7QUFDdkIsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQixHQUFHO0FBQzlCO0FBQ0EsdUJBQXVCLEdBQUcsR0FBRyxPQUFPO0FBQ3BDOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QixpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixPQUFPO0FBQy9COztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsUUFBUTtBQUN2QixpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkIsa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9qc21fYmFua2luZy8uL25vZGVfbW9kdWxlcy9ub2RlLWFwcHdyaXRlL2xpYi9yb2xlLmpzPzUzY2EiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBIZWxwZXIgY2xhc3MgdG8gZ2VuZXJhdGUgcm9sZSBzdHJpbmdzIGZvciBgUGVybWlzc2lvbmAuXG4gKi9cbmNsYXNzIFJvbGUge1xuXG4gICAgLyoqXG4gICAgICogR3JhbnRzIGFjY2VzcyB0byBhbnlvbmUuXG4gICAgICpcbiAgICAgKiBUaGlzIGluY2x1ZGVzIGF1dGhlbnRpY2F0ZWQgYW5kIHVuYXV0aGVudGljYXRlZCB1c2Vycy5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9XG4gICAgICovXG4gICAgc3RhdGljIGFueSA9ICgpID0+IHtcbiAgICAgICAgcmV0dXJuICdhbnknXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR3JhbnRzIGFjY2VzcyB0byBhIHNwZWNpZmljIHVzZXIgYnkgdXNlciBJRC5cbiAgICAgKlxuICAgICAqIFlvdSBjYW4gb3B0aW9uYWxseSBwYXNzIHZlcmlmaWVkIG9yIHVudmVyaWZpZWQgZm9yXG4gICAgICogYHN0YXR1c2AgdG8gdGFyZ2V0IHNwZWNpZmljIHR5cGVzIG9mIHVzZXJzLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGlkIFxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBzdGF0dXMgXG4gICAgICogQHJldHVybnMge3N0cmluZ31cbiAgICAgKi9cbiAgICBzdGF0aWMgdXNlciA9IChpZCwgc3RhdHVzID0gJycpID0+IHtcbiAgICAgICAgaWYgKHN0YXR1cyA9PT0gJycpIHtcbiAgICAgICAgICAgIHJldHVybiBgdXNlcjoke2lkfWBcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYHVzZXI6JHtpZH0vJHtzdGF0dXN9YFxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdyYW50cyBhY2Nlc3MgdG8gYW55IGF1dGhlbnRpY2F0ZWQgb3IgYW5vbnltb3VzIHVzZXIuXG4gICAgICpcbiAgICAgKiBZb3UgY2FuIG9wdGlvbmFsbHkgcGFzcyB2ZXJpZmllZCBvciB1bnZlcmlmaWVkIGZvclxuICAgICAqIGBzdGF0dXNgIHRvIHRhcmdldCBzcGVjaWZpYyB0eXBlcyBvZiB1c2Vycy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBzdGF0dXMgXG4gICAgICogQHJldHVybnMge3N0cmluZ31cbiAgICAgKi9cbiAgICBzdGF0aWMgdXNlcnMgPSAoc3RhdHVzID0gJycpID0+IHtcbiAgICAgICAgaWYgKHN0YXR1cyA9PT0gJycpIHtcbiAgICAgICAgICAgIHJldHVybiAndXNlcnMnXG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGB1c2Vycy8ke3N0YXR1c31gXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR3JhbnRzIGFjY2VzcyB0byBhbnkgZ3Vlc3QgdXNlciB3aXRob3V0IGEgc2Vzc2lvbi5cbiAgICAgKlxuICAgICAqIEF1dGhlbnRpY2F0ZWQgdXNlcnMgZG9uJ3QgaGF2ZSBhY2Nlc3MgdG8gdGhpcyByb2xlLlxuICAgICAqXG4gICAgICogQHJldHVybnMge3N0cmluZ31cbiAgICAgKi9cbiAgICBzdGF0aWMgZ3Vlc3RzID0gKCkgPT4ge1xuICAgICAgICByZXR1cm4gJ2d1ZXN0cydcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHcmFudHMgYWNjZXNzIHRvIGEgdGVhbSBieSB0ZWFtIElELlxuICAgICAqXG4gICAgICogWW91IGNhbiBvcHRpb25hbGx5IHBhc3MgYSByb2xlIGZvciBgcm9sZWAgdG8gdGFyZ2V0XG4gICAgICogdGVhbSBtZW1iZXJzIHdpdGggdGhlIHNwZWNpZmllZCByb2xlLlxuICAgICAqIFxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBpZCBcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gcm9sZSBcbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfVxuICAgICAqL1xuICAgIHN0YXRpYyB0ZWFtID0gKGlkLCByb2xlID0gJycpID0+IHtcbiAgICAgICAgaWYgKHJvbGUgPT09ICcnKSB7XG4gICAgICAgICAgICByZXR1cm4gJ3RlYW06JyArIGlkXG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuICd0ZWFtOicgKyBpZCArICcvJyArIHJvbGVcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHcmFudHMgYWNjZXNzIHRvIGEgc3BlY2lmaWMgbWVtYmVyIG9mIGEgdGVhbS5cbiAgICAgKlxuICAgICAqIFdoZW4gdGhlIG1lbWJlciBpcyByZW1vdmVkIGZyb20gdGhlIHRlYW0sIHRoZXkgd2lsbFxuICAgICAqIG5vIGxvbmdlciBoYXZlIGFjY2Vzcy5cbiAgICAgKiBcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gaWQgXG4gICAgICogQHJldHVybnMge3N0cmluZ31cbiAgICAgKi9cbiAgICBzdGF0aWMgbWVtYmVyID0gKGlkKSA9PiB7XG4gICAgICAgIHJldHVybiAnbWVtYmVyOicgKyBpZFxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdyYW50cyBhY2Nlc3MgdG8gYSB1c2VyIHdpdGggdGhlIHNwZWNpZmllZCBsYWJlbC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lIFxuICAgICAqIEByZXR1cm5zICB7c3RyaW5nfVxuICAgICAqL1xuICAgIHN0YXRpYyBsYWJlbCA9IChuYW1lKSA9PiB7XG4gICAgICAgIHJldHVybiAnbGFiZWw6JyArIG5hbWU7XG4gICAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IFJvbGU7Il0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/node-appwrite/lib/role.js\n");

/***/ }),

/***/ "(action-browser)/./node_modules/node-appwrite/lib/service.js":
/*!***************************************************!*\
  !*** ./node_modules/node-appwrite/lib/service.js ***!
  \***************************************************/
/***/ ((module) => {

eval("class Service {\n    /**\n     * @param client\n     */\n    constructor(client) {\n        this.client = client;\n    }\n}\n\nmodule.exports = Service;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFjdGlvbi1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9ub2RlLWFwcHdyaXRlL2xpYi9zZXJ2aWNlLmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9qc21fYmFua2luZy8uL25vZGVfbW9kdWxlcy9ub2RlLWFwcHdyaXRlL2xpYi9zZXJ2aWNlLmpzPzg0ZjAiXSwic291cmNlc0NvbnRlbnQiOlsiY2xhc3MgU2VydmljZSB7XG4gICAgLyoqXG4gICAgICogQHBhcmFtIGNsaWVudFxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKGNsaWVudCkge1xuICAgICAgICB0aGlzLmNsaWVudCA9IGNsaWVudDtcbiAgICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gU2VydmljZTsiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(action-browser)/./node_modules/node-appwrite/lib/service.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/node-appwrite/lib/service.js":
/*!***************************************************!*\
  !*** ./node_modules/node-appwrite/lib/service.js ***!
  \***************************************************/
/***/ ((module) => {

eval("class Service {\n    /**\n     * @param client\n     */\n    constructor(client) {\n        this.client = client;\n    }\n}\n\nmodule.exports = Service;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvbm9kZS1hcHB3cml0ZS9saWIvc2VydmljZS5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vanNtX2JhbmtpbmcvLi9ub2RlX21vZHVsZXMvbm9kZS1hcHB3cml0ZS9saWIvc2VydmljZS5qcz8xODdjIl0sInNvdXJjZXNDb250ZW50IjpbImNsYXNzIFNlcnZpY2Uge1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSBjbGllbnRcbiAgICAgKi9cbiAgICBjb25zdHJ1Y3RvcihjbGllbnQpIHtcbiAgICAgICAgdGhpcy5jbGllbnQgPSBjbGllbnQ7XG4gICAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IFNlcnZpY2U7Il0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/node-appwrite/lib/service.js\n");

/***/ }),

/***/ "(action-browser)/./node_modules/node-appwrite/lib/services/account.js":
/*!************************************************************!*\
  !*** ./node_modules/node-appwrite/lib/services/account.js ***!
  \************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("const Service = __webpack_require__(/*! ../service.js */ \"(action-browser)/./node_modules/node-appwrite/lib/service.js\");\nconst AppwriteException = __webpack_require__(/*! ../exception.js */ \"(action-browser)/./node_modules/node-appwrite/lib/exception.js\");\nconst InputFile = __webpack_require__(/*! ../inputFile.js */ \"(action-browser)/./node_modules/node-appwrite/lib/inputFile.js\");\nconst client = __webpack_require__(/*! ../client.js */ \"(action-browser)/./node_modules/node-appwrite/lib/client.js\");\nconst Stream = __webpack_require__(/*! stream */ \"stream\");\nconst { promisify } = __webpack_require__(/*! util */ \"util\");\nconst fs = __webpack_require__(/*! fs */ \"fs\");\nconst { File } = __webpack_require__(/*! undici */ \"undici\");\nconst Query = __webpack_require__(/*! ../query.js */ \"(action-browser)/./node_modules/node-appwrite/lib/query.js\");\n\nclass Account extends Service {\n\n     constructor(client)\n     {\n        super(client);\n     }\n\n\n    /**\n     * Get account\n     *\n     * Get the currently logged in user.\n     *\n     * @throws {AppwriteException}\n     * @returns {Promise}\n     */\n    async get() {\n        const apiPath = '/account';\n        let payload = {};\n\n        return await this.client.call('get', apiPath, {\n            'content-type': 'application/json',\n        }, payload);\n    }\n\n    /**\n     * Create account\n     *\n     * Use this endpoint to allow a new user to register a new account in your\n     * project. After the user registration completes successfully, you can use\n     * the\n     * [/account/verfication](https://appwrite.io/docs/references/cloud/client-web/account#createVerification)\n     * route to start verifying the user email address. To allow the new user to\n     * login to their new account, you need to create a new [account\n     * session](https://appwrite.io/docs/references/cloud/client-web/account#createEmailSession).\n     *\n     * @param {string} userId\n     * @param {string} email\n     * @param {string} password\n     * @param {string} name\n     * @throws {AppwriteException}\n     * @returns {Promise}\n     */\n    async create(userId, email, password, name) {\n        const apiPath = '/account';\n        let payload = {};\n        if (typeof userId === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"userId\"');\n        }\n\n        if (typeof email === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"email\"');\n        }\n\n        if (typeof password === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"password\"');\n        }\n\n\n        if (typeof userId !== 'undefined') {\n            payload['userId'] = userId;\n        }\n\n        if (typeof email !== 'undefined') {\n            payload['email'] = email;\n        }\n\n        if (typeof password !== 'undefined') {\n            payload['password'] = password;\n        }\n\n        if (typeof name !== 'undefined') {\n            payload['name'] = name;\n        }\n\n        return await this.client.call('post', apiPath, {\n            'content-type': 'application/json',\n        }, payload);\n    }\n\n    /**\n     * Update email\n     *\n     * Update currently logged in user account email address. After changing user\n     * address, the user confirmation status will get reset. A new confirmation\n     * email is not sent automatically however you can use the send confirmation\n     * email endpoint again to send the confirmation email. For security measures,\n     * user password is required to complete this request.\n     * This endpoint can also be used to convert an anonymous account to a normal\n     * one, by passing an email address and a new password.\n     * \n     *\n     * @param {string} email\n     * @param {string} password\n     * @throws {AppwriteException}\n     * @returns {Promise}\n     */\n    async updateEmail(email, password) {\n        const apiPath = '/account/email';\n        let payload = {};\n        if (typeof email === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"email\"');\n        }\n\n        if (typeof password === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"password\"');\n        }\n\n\n        if (typeof email !== 'undefined') {\n            payload['email'] = email;\n        }\n\n        if (typeof password !== 'undefined') {\n            payload['password'] = password;\n        }\n\n        return await this.client.call('patch', apiPath, {\n            'content-type': 'application/json',\n        }, payload);\n    }\n\n    /**\n     * List Identities\n     *\n     * Get the list of identities for the currently logged in user.\n     *\n     * @param {string[]} queries\n     * @throws {AppwriteException}\n     * @returns {Promise}\n     */\n    async listIdentities(queries) {\n        const apiPath = '/account/identities';\n        let payload = {};\n\n        if (typeof queries !== 'undefined') {\n            payload['queries'] = queries;\n        }\n\n        return await this.client.call('get', apiPath, {\n            'content-type': 'application/json',\n        }, payload);\n    }\n\n    /**\n     * Delete identity\n     *\n     * Delete an identity by its unique ID.\n     *\n     * @param {string} identityId\n     * @throws {AppwriteException}\n     * @returns {Promise}\n     */\n    async deleteIdentity(identityId) {\n        const apiPath = '/account/identities/{identityId}'.replace('{identityId}', identityId);\n        let payload = {};\n        if (typeof identityId === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"identityId\"');\n        }\n\n\n        return await this.client.call('delete', apiPath, {\n            'content-type': 'application/json',\n        }, payload);\n    }\n\n    /**\n     * Create JWT\n     *\n     * Use this endpoint to create a JSON Web Token. You can use the resulting JWT\n     * to authenticate on behalf of the current user when working with the\n     * Appwrite server-side API and SDKs. The JWT secret is valid for 15 minutes\n     * from its creation and will be invalid if the user will logout in that time\n     * frame.\n     *\n     * @throws {AppwriteException}\n     * @returns {Promise}\n     */\n    async createJWT() {\n        const apiPath = '/account/jwt';\n        let payload = {};\n\n        return await this.client.call('post', apiPath, {\n            'content-type': 'application/json',\n        }, payload);\n    }\n\n    /**\n     * List logs\n     *\n     * Get the list of latest security activity logs for the currently logged in\n     * user. Each log returns user IP address, location and date and time of log.\n     *\n     * @param {string[]} queries\n     * @throws {AppwriteException}\n     * @returns {Promise}\n     */\n    async listLogs(queries) {\n        const apiPath = '/account/logs';\n        let payload = {};\n\n        if (typeof queries !== 'undefined') {\n            payload['queries'] = queries;\n        }\n\n        return await this.client.call('get', apiPath, {\n            'content-type': 'application/json',\n        }, payload);\n    }\n\n    /**\n     * Update MFA\n     *\n     * Enable or disable MFA on an account.\n     *\n     * @param {boolean} mfa\n     * @throws {AppwriteException}\n     * @returns {Promise}\n     */\n    async updateMFA(mfa) {\n        const apiPath = '/account/mfa';\n        let payload = {};\n        if (typeof mfa === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"mfa\"');\n        }\n\n\n        if (typeof mfa !== 'undefined') {\n            payload['mfa'] = mfa;\n        }\n\n        return await this.client.call('patch', apiPath, {\n            'content-type': 'application/json',\n        }, payload);\n    }\n\n    /**\n     * Add Authenticator\n     *\n     * Add an authenticator app to be used as an MFA factor. Verify the\n     * authenticator using the [verify\n     * authenticator](/docs/references/cloud/client-web/account#verifyAuthenticator)\n     * method.\n     *\n     * @param {AuthenticatorType} type\n     * @throws {AppwriteException}\n     * @returns {Promise}\n     */\n    async createMfaAuthenticator(type) {\n        const apiPath = '/account/mfa/authenticators/{type}'.replace('{type}', type);\n        let payload = {};\n        if (typeof type === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"type\"');\n        }\n\n\n        return await this.client.call('post', apiPath, {\n            'content-type': 'application/json',\n        }, payload);\n    }\n\n    /**\n     * Verify Authenticator\n     *\n     * Verify an authenticator app after adding it using the [add\n     * authenticator](/docs/references/cloud/client-web/account#addAuthenticator)\n     * method.\n     *\n     * @param {AuthenticatorType} type\n     * @param {string} otp\n     * @throws {AppwriteException}\n     * @returns {Promise}\n     */\n    async updateMfaAuthenticator(type, otp) {\n        const apiPath = '/account/mfa/authenticators/{type}'.replace('{type}', type);\n        let payload = {};\n        if (typeof type === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"type\"');\n        }\n\n        if (typeof otp === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"otp\"');\n        }\n\n\n        if (typeof otp !== 'undefined') {\n            payload['otp'] = otp;\n        }\n\n        return await this.client.call('put', apiPath, {\n            'content-type': 'application/json',\n        }, payload);\n    }\n\n    /**\n     * Delete Authenticator\n     *\n     * Delete an authenticator for a user by ID.\n     *\n     * @param {AuthenticatorType} type\n     * @param {string} otp\n     * @throws {AppwriteException}\n     * @returns {Promise}\n     */\n    async deleteMfaAuthenticator(type, otp) {\n        const apiPath = '/account/mfa/authenticators/{type}'.replace('{type}', type);\n        let payload = {};\n        if (typeof type === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"type\"');\n        }\n\n        if (typeof otp === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"otp\"');\n        }\n\n\n        if (typeof otp !== 'undefined') {\n            payload['otp'] = otp;\n        }\n\n        return await this.client.call('delete', apiPath, {\n            'content-type': 'application/json',\n        }, payload);\n    }\n\n    /**\n     * Create 2FA Challenge\n     *\n     * Begin the process of MFA verification after sign-in. Finish the flow with\n     * [updateMfaChallenge](/docs/references/cloud/client-web/account#updateMfaChallenge)\n     * method.\n     *\n     * @param {AuthenticationFactor} factor\n     * @throws {AppwriteException}\n     * @returns {Promise}\n     */\n    async createMfaChallenge(factor) {\n        const apiPath = '/account/mfa/challenge';\n        let payload = {};\n        if (typeof factor === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"factor\"');\n        }\n\n\n        if (typeof factor !== 'undefined') {\n            payload['factor'] = factor;\n        }\n\n        return await this.client.call('post', apiPath, {\n            'content-type': 'application/json',\n        }, payload);\n    }\n\n    /**\n     * Create MFA Challenge (confirmation)\n     *\n     * Complete the MFA challenge by providing the one-time password. Finish the\n     * process of MFA verification by providing the one-time password. To begin\n     * the flow, use\n     * [createMfaChallenge](/docs/references/cloud/client-web/account#createMfaChallenge)\n     * method.\n     *\n     * @param {string} challengeId\n     * @param {string} otp\n     * @throws {AppwriteException}\n     * @returns {Promise}\n     */\n    async updateMfaChallenge(challengeId, otp) {\n        const apiPath = '/account/mfa/challenge';\n        let payload = {};\n        if (typeof challengeId === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"challengeId\"');\n        }\n\n        if (typeof otp === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"otp\"');\n        }\n\n\n        if (typeof challengeId !== 'undefined') {\n            payload['challengeId'] = challengeId;\n        }\n\n        if (typeof otp !== 'undefined') {\n            payload['otp'] = otp;\n        }\n\n        return await this.client.call('put', apiPath, {\n            'content-type': 'application/json',\n        }, payload);\n    }\n\n    /**\n     * List Factors\n     *\n     * List the factors available on the account to be used as a MFA challange.\n     *\n     * @throws {AppwriteException}\n     * @returns {Promise}\n     */\n    async listMfaFactors() {\n        const apiPath = '/account/mfa/factors';\n        let payload = {};\n\n        return await this.client.call('get', apiPath, {\n            'content-type': 'application/json',\n        }, payload);\n    }\n\n    /**\n     * Get MFA Recovery Codes\n     *\n     * Get recovery codes that can be used as backup for MFA flow. Before getting\n     * codes, they must be generated using\n     * [createMfaRecoveryCodes](/docs/references/cloud/client-web/account#createMfaRecoveryCodes)\n     * method. An OTP challenge is required to read recovery codes.\n     *\n     * @throws {AppwriteException}\n     * @returns {Promise}\n     */\n    async getMfaRecoveryCodes() {\n        const apiPath = '/account/mfa/recovery-codes';\n        let payload = {};\n\n        return await this.client.call('get', apiPath, {\n            'content-type': 'application/json',\n        }, payload);\n    }\n\n    /**\n     * Create MFA Recovery Codes\n     *\n     * Generate recovery codes as backup for MFA flow. It's recommended to\n     * generate and show then immediately after user successfully adds their\n     * authehticator. Recovery codes can be used as a MFA verification type in\n     * [createMfaChallenge](/docs/references/cloud/client-web/account#createMfaChallenge)\n     * method.\n     *\n     * @throws {AppwriteException}\n     * @returns {Promise}\n     */\n    async createMfaRecoveryCodes() {\n        const apiPath = '/account/mfa/recovery-codes';\n        let payload = {};\n\n        return await this.client.call('post', apiPath, {\n            'content-type': 'application/json',\n        }, payload);\n    }\n\n    /**\n     * Regenerate MFA Recovery Codes\n     *\n     * Regenerate recovery codes that can be used as backup for MFA flow. Before\n     * regenerating codes, they must be first generated using\n     * [createMfaRecoveryCodes](/docs/references/cloud/client-web/account#createMfaRecoveryCodes)\n     * method. An OTP challenge is required to regenreate recovery codes.\n     *\n     * @throws {AppwriteException}\n     * @returns {Promise}\n     */\n    async updateMfaRecoveryCodes() {\n        const apiPath = '/account/mfa/recovery-codes';\n        let payload = {};\n\n        return await this.client.call('patch', apiPath, {\n            'content-type': 'application/json',\n        }, payload);\n    }\n\n    /**\n     * Update name\n     *\n     * Update currently logged in user account name.\n     *\n     * @param {string} name\n     * @throws {AppwriteException}\n     * @returns {Promise}\n     */\n    async updateName(name) {\n        const apiPath = '/account/name';\n        let payload = {};\n        if (typeof name === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"name\"');\n        }\n\n\n        if (typeof name !== 'undefined') {\n            payload['name'] = name;\n        }\n\n        return await this.client.call('patch', apiPath, {\n            'content-type': 'application/json',\n        }, payload);\n    }\n\n    /**\n     * Update password\n     *\n     * Update currently logged in user password. For validation, user is required\n     * to pass in the new password, and the old password. For users created with\n     * OAuth, Team Invites and Magic URL, oldPassword is optional.\n     *\n     * @param {string} password\n     * @param {string} oldPassword\n     * @throws {AppwriteException}\n     * @returns {Promise}\n     */\n    async updatePassword(password, oldPassword) {\n        const apiPath = '/account/password';\n        let payload = {};\n        if (typeof password === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"password\"');\n        }\n\n\n        if (typeof password !== 'undefined') {\n            payload['password'] = password;\n        }\n\n        if (typeof oldPassword !== 'undefined') {\n            payload['oldPassword'] = oldPassword;\n        }\n\n        return await this.client.call('patch', apiPath, {\n            'content-type': 'application/json',\n        }, payload);\n    }\n\n    /**\n     * Update phone\n     *\n     * Update the currently logged in user's phone number. After updating the\n     * phone number, the phone verification status will be reset. A confirmation\n     * SMS is not sent automatically, however you can use the [POST\n     * /account/verification/phone](https://appwrite.io/docs/references/cloud/client-web/account#createPhoneVerification)\n     * endpoint to send a confirmation SMS.\n     *\n     * @param {string} phone\n     * @param {string} password\n     * @throws {AppwriteException}\n     * @returns {Promise}\n     */\n    async updatePhone(phone, password) {\n        const apiPath = '/account/phone';\n        let payload = {};\n        if (typeof phone === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"phone\"');\n        }\n\n        if (typeof password === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"password\"');\n        }\n\n\n        if (typeof phone !== 'undefined') {\n            payload['phone'] = phone;\n        }\n\n        if (typeof password !== 'undefined') {\n            payload['password'] = password;\n        }\n\n        return await this.client.call('patch', apiPath, {\n            'content-type': 'application/json',\n        }, payload);\n    }\n\n    /**\n     * Get account preferences\n     *\n     * Get the preferences as a key-value object for the currently logged in user.\n     *\n     * @throws {AppwriteException}\n     * @returns {Promise}\n     */\n    async getPrefs() {\n        const apiPath = '/account/prefs';\n        let payload = {};\n\n        return await this.client.call('get', apiPath, {\n            'content-type': 'application/json',\n        }, payload);\n    }\n\n    /**\n     * Update preferences\n     *\n     * Update currently logged in user account preferences. The object you pass is\n     * stored as is, and replaces any previous value. The maximum allowed prefs\n     * size is 64kB and throws error if exceeded.\n     *\n     * @param {object} prefs\n     * @throws {AppwriteException}\n     * @returns {Promise}\n     */\n    async updatePrefs(prefs) {\n        const apiPath = '/account/prefs';\n        let payload = {};\n        if (typeof prefs === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"prefs\"');\n        }\n\n\n        if (typeof prefs !== 'undefined') {\n            payload['prefs'] = prefs;\n        }\n\n        return await this.client.call('patch', apiPath, {\n            'content-type': 'application/json',\n        }, payload);\n    }\n\n    /**\n     * Create password recovery\n     *\n     * Sends the user an email with a temporary secret key for password reset.\n     * When the user clicks the confirmation link he is redirected back to your\n     * app password reset URL with the secret key and email address values\n     * attached to the URL query string. Use the query string params to submit a\n     * request to the [PUT\n     * /account/recovery](https://appwrite.io/docs/references/cloud/client-web/account#updateRecovery)\n     * endpoint to complete the process. The verification link sent to the user's\n     * email address is valid for 1 hour.\n     *\n     * @param {string} email\n     * @param {string} url\n     * @throws {AppwriteException}\n     * @returns {Promise}\n     */\n    async createRecovery(email, url) {\n        const apiPath = '/account/recovery';\n        let payload = {};\n        if (typeof email === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"email\"');\n        }\n\n        if (typeof url === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"url\"');\n        }\n\n\n        if (typeof email !== 'undefined') {\n            payload['email'] = email;\n        }\n\n        if (typeof url !== 'undefined') {\n            payload['url'] = url;\n        }\n\n        return await this.client.call('post', apiPath, {\n            'content-type': 'application/json',\n        }, payload);\n    }\n\n    /**\n     * Create password recovery (confirmation)\n     *\n     * Use this endpoint to complete the user account password reset. Both the\n     * **userId** and **secret** arguments will be passed as query parameters to\n     * the redirect URL you have provided when sending your request to the [POST\n     * /account/recovery](https://appwrite.io/docs/references/cloud/client-web/account#createRecovery)\n     * endpoint.\n     * \n     * Please note that in order to avoid a [Redirect\n     * Attack](https://github.com/OWASP/CheatSheetSeries/blob/master/cheatsheets/Unvalidated_Redirects_and_Forwards_Cheat_Sheet.md)\n     * the only valid redirect URLs are the ones from domains you have set when\n     * adding your platforms in the console interface.\n     *\n     * @param {string} userId\n     * @param {string} secret\n     * @param {string} password\n     * @throws {AppwriteException}\n     * @returns {Promise}\n     */\n    async updateRecovery(userId, secret, password) {\n        const apiPath = '/account/recovery';\n        let payload = {};\n        if (typeof userId === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"userId\"');\n        }\n\n        if (typeof secret === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"secret\"');\n        }\n\n        if (typeof password === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"password\"');\n        }\n\n\n        if (typeof userId !== 'undefined') {\n            payload['userId'] = userId;\n        }\n\n        if (typeof secret !== 'undefined') {\n            payload['secret'] = secret;\n        }\n\n        if (typeof password !== 'undefined') {\n            payload['password'] = password;\n        }\n\n        return await this.client.call('put', apiPath, {\n            'content-type': 'application/json',\n        }, payload);\n    }\n\n    /**\n     * List sessions\n     *\n     * Get the list of active sessions across different devices for the currently\n     * logged in user.\n     *\n     * @throws {AppwriteException}\n     * @returns {Promise}\n     */\n    async listSessions() {\n        const apiPath = '/account/sessions';\n        let payload = {};\n\n        return await this.client.call('get', apiPath, {\n            'content-type': 'application/json',\n        }, payload);\n    }\n\n    /**\n     * Delete sessions\n     *\n     * Delete all sessions from the user account and remove any sessions cookies\n     * from the end client.\n     *\n     * @throws {AppwriteException}\n     * @returns {Promise}\n     */\n    async deleteSessions() {\n        const apiPath = '/account/sessions';\n        let payload = {};\n\n        return await this.client.call('delete', apiPath, {\n            'content-type': 'application/json',\n        }, payload);\n    }\n\n    /**\n     * Create anonymous session\n     *\n     * Use this endpoint to allow a new user to register an anonymous account in\n     * your project. This route will also create a new session for the user. To\n     * allow the new user to convert an anonymous account to a normal account, you\n     * need to update its [email and\n     * password](https://appwrite.io/docs/references/cloud/client-web/account#updateEmail)\n     * or create an [OAuth2\n     * session](https://appwrite.io/docs/references/cloud/client-web/account#CreateOAuth2Session).\n     *\n     * @throws {AppwriteException}\n     * @returns {Promise}\n     */\n    async createAnonymousSession() {\n        const apiPath = '/account/sessions/anonymous';\n        let payload = {};\n\n        return await this.client.call('post', apiPath, {\n            'content-type': 'application/json',\n        }, payload);\n    }\n\n    /**\n     * Create email password session\n     *\n     * Allow the user to login into their account by providing a valid email and\n     * password combination. This route will create a new session for the user.\n     * \n     * A user is limited to 10 active sessions at a time by default. [Learn more\n     * about session\n     * limits](https://appwrite.io/docs/authentication-security#limits).\n     *\n     * @param {string} email\n     * @param {string} password\n     * @throws {AppwriteException}\n     * @returns {Promise}\n     */\n    async createEmailPasswordSession(email, password) {\n        const apiPath = '/account/sessions/email';\n        let payload = {};\n        if (typeof email === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"email\"');\n        }\n\n        if (typeof password === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"password\"');\n        }\n\n\n        if (typeof email !== 'undefined') {\n            payload['email'] = email;\n        }\n\n        if (typeof password !== 'undefined') {\n            payload['password'] = password;\n        }\n\n        return await this.client.call('post', apiPath, {\n            'content-type': 'application/json',\n        }, payload);\n    }\n\n    /**\n     * Update magic URL session\n     *\n     * Use this endpoint to create a session from token. Provide the **userId**\n     * and **secret** parameters from the successful response of authentication\n     * flows initiated by token creation. For example, magic URL and phone login.\n     *\n     * @param {string} userId\n     * @param {string} secret\n     * @throws {AppwriteException}\n     * @returns {Promise}\n     */\n    async updateMagicURLSession(userId, secret) {\n        const apiPath = '/account/sessions/magic-url';\n        let payload = {};\n        if (typeof userId === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"userId\"');\n        }\n\n        if (typeof secret === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"secret\"');\n        }\n\n\n        if (typeof userId !== 'undefined') {\n            payload['userId'] = userId;\n        }\n\n        if (typeof secret !== 'undefined') {\n            payload['secret'] = secret;\n        }\n\n        return await this.client.call('put', apiPath, {\n            'content-type': 'application/json',\n        }, payload);\n    }\n\n    /**\n     * Update phone session\n     *\n     * Use this endpoint to create a session from token. Provide the **userId**\n     * and **secret** parameters from the successful response of authentication\n     * flows initiated by token creation. For example, magic URL and phone login.\n     *\n     * @param {string} userId\n     * @param {string} secret\n     * @throws {AppwriteException}\n     * @returns {Promise}\n     */\n    async updatePhoneSession(userId, secret) {\n        const apiPath = '/account/sessions/phone';\n        let payload = {};\n        if (typeof userId === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"userId\"');\n        }\n\n        if (typeof secret === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"secret\"');\n        }\n\n\n        if (typeof userId !== 'undefined') {\n            payload['userId'] = userId;\n        }\n\n        if (typeof secret !== 'undefined') {\n            payload['secret'] = secret;\n        }\n\n        return await this.client.call('put', apiPath, {\n            'content-type': 'application/json',\n        }, payload);\n    }\n\n    /**\n     * Create session\n     *\n     * Use this endpoint to create a session from token. Provide the **userId**\n     * and **secret** parameters from the successful response of authentication\n     * flows initiated by token creation. For example, magic URL and phone login.\n     *\n     * @param {string} userId\n     * @param {string} secret\n     * @throws {AppwriteException}\n     * @returns {Promise}\n     */\n    async createSession(userId, secret) {\n        const apiPath = '/account/sessions/token';\n        let payload = {};\n        if (typeof userId === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"userId\"');\n        }\n\n        if (typeof secret === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"secret\"');\n        }\n\n\n        if (typeof userId !== 'undefined') {\n            payload['userId'] = userId;\n        }\n\n        if (typeof secret !== 'undefined') {\n            payload['secret'] = secret;\n        }\n\n        return await this.client.call('post', apiPath, {\n            'content-type': 'application/json',\n        }, payload);\n    }\n\n    /**\n     * Get session\n     *\n     * Use this endpoint to get a logged in user's session using a Session ID.\n     * Inputting 'current' will return the current session being used.\n     *\n     * @param {string} sessionId\n     * @throws {AppwriteException}\n     * @returns {Promise}\n     */\n    async getSession(sessionId) {\n        const apiPath = '/account/sessions/{sessionId}'.replace('{sessionId}', sessionId);\n        let payload = {};\n        if (typeof sessionId === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"sessionId\"');\n        }\n\n\n        return await this.client.call('get', apiPath, {\n            'content-type': 'application/json',\n        }, payload);\n    }\n\n    /**\n     * Update session\n     *\n     * Use this endpoint to extend a session's length. Extending a session is\n     * useful when session expiry is short. If the session was created using an\n     * OAuth provider, this endpoint refreshes the access token from the provider.\n     *\n     * @param {string} sessionId\n     * @throws {AppwriteException}\n     * @returns {Promise}\n     */\n    async updateSession(sessionId) {\n        const apiPath = '/account/sessions/{sessionId}'.replace('{sessionId}', sessionId);\n        let payload = {};\n        if (typeof sessionId === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"sessionId\"');\n        }\n\n\n        return await this.client.call('patch', apiPath, {\n            'content-type': 'application/json',\n        }, payload);\n    }\n\n    /**\n     * Delete session\n     *\n     * Logout the user. Use 'current' as the session ID to logout on this device,\n     * use a session ID to logout on another device. If you're looking to logout\n     * the user on all devices, use [Delete\n     * Sessions](https://appwrite.io/docs/references/cloud/client-web/account#deleteSessions)\n     * instead.\n     *\n     * @param {string} sessionId\n     * @throws {AppwriteException}\n     * @returns {Promise}\n     */\n    async deleteSession(sessionId) {\n        const apiPath = '/account/sessions/{sessionId}'.replace('{sessionId}', sessionId);\n        let payload = {};\n        if (typeof sessionId === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"sessionId\"');\n        }\n\n\n        return await this.client.call('delete', apiPath, {\n            'content-type': 'application/json',\n        }, payload);\n    }\n\n    /**\n     * Update status\n     *\n     * Block the currently logged in user account. Behind the scene, the user\n     * record is not deleted but permanently blocked from any access. To\n     * completely delete a user, use the Users API instead.\n     *\n     * @throws {AppwriteException}\n     * @returns {Promise}\n     */\n    async updateStatus() {\n        const apiPath = '/account/status';\n        let payload = {};\n\n        return await this.client.call('patch', apiPath, {\n            'content-type': 'application/json',\n        }, payload);\n    }\n\n    /**\n     * Create email token (OTP)\n     *\n     * Sends the user an email with a secret key for creating a session. If the\n     * provided user ID has not be registered, a new user will be created. Use the\n     * returned user ID and secret and submit a request to the [POST\n     * /v1/account/sessions/token](https://appwrite.io/docs/references/cloud/client-web/account#createSession)\n     * endpoint to complete the login process. The secret sent to the user's email\n     * is valid for 15 minutes.\n     * \n     * A user is limited to 10 active sessions at a time by default. [Learn more\n     * about session\n     * limits](https://appwrite.io/docs/authentication-security#limits).\n     *\n     * @param {string} userId\n     * @param {string} email\n     * @param {boolean} phrase\n     * @throws {AppwriteException}\n     * @returns {Promise}\n     */\n    async createEmailToken(userId, email, phrase) {\n        const apiPath = '/account/tokens/email';\n        let payload = {};\n        if (typeof userId === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"userId\"');\n        }\n\n        if (typeof email === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"email\"');\n        }\n\n\n        if (typeof userId !== 'undefined') {\n            payload['userId'] = userId;\n        }\n\n        if (typeof email !== 'undefined') {\n            payload['email'] = email;\n        }\n\n        if (typeof phrase !== 'undefined') {\n            payload['phrase'] = phrase;\n        }\n\n        return await this.client.call('post', apiPath, {\n            'content-type': 'application/json',\n        }, payload);\n    }\n\n    /**\n     * Create magic URL token\n     *\n     * Sends the user an email with a secret key for creating a session. If the\n     * provided user ID has not been registered, a new user will be created. When\n     * the user clicks the link in the email, the user is redirected back to the\n     * URL you provided with the secret key and userId values attached to the URL\n     * query string. Use the query string parameters to submit a request to the\n     * [POST\n     * /v1/account/sessions/token](https://appwrite.io/docs/references/cloud/client-web/account#createSession)\n     * endpoint to complete the login process. The link sent to the user's email\n     * address is valid for 1 hour. If you are on a mobile device you can leave\n     * the URL parameter empty, so that the login completion will be handled by\n     * your Appwrite instance by default.\n     * \n     * A user is limited to 10 active sessions at a time by default. [Learn more\n     * about session\n     * limits](https://appwrite.io/docs/authentication-security#limits).\n     * \n     *\n     * @param {string} userId\n     * @param {string} email\n     * @param {string} url\n     * @param {boolean} phrase\n     * @throws {AppwriteException}\n     * @returns {Promise}\n     */\n    async createMagicURLToken(userId, email, url, phrase) {\n        const apiPath = '/account/tokens/magic-url';\n        let payload = {};\n        if (typeof userId === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"userId\"');\n        }\n\n        if (typeof email === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"email\"');\n        }\n\n\n        if (typeof userId !== 'undefined') {\n            payload['userId'] = userId;\n        }\n\n        if (typeof email !== 'undefined') {\n            payload['email'] = email;\n        }\n\n        if (typeof url !== 'undefined') {\n            payload['url'] = url;\n        }\n\n        if (typeof phrase !== 'undefined') {\n            payload['phrase'] = phrase;\n        }\n\n        return await this.client.call('post', apiPath, {\n            'content-type': 'application/json',\n        }, payload);\n    }\n\n    /**\n     * Create OAuth2 token\n     *\n     * Allow the user to login to their account using the OAuth2 provider of their\n     * choice. Each OAuth2 provider should be enabled from the Appwrite console\n     * first. Use the success and failure arguments to provide a redirect URL's\n     * back to your app when login is completed. \n     * \n     * If authentication succeeds, `userId` and `secret` of a token will be\n     * appended to the success URL as query parameters. These can be used to\n     * create a new session using the [Create\n     * session](https://appwrite.io/docs/references/cloud/client-web/account#createSession)\n     * endpoint.\n     * \n     * A user is limited to 10 active sessions at a time by default. [Learn more\n     * about session\n     * limits](https://appwrite.io/docs/authentication-security#limits).\n     *\n     * @param {OAuthProvider} provider\n     * @param {string} success\n     * @param {string} failure\n     * @param {string[]} scopes\n     * @throws {AppwriteException}\n     * @returns {Promise}\n     */\n    async createOAuth2Token(provider, success, failure, scopes) {\n        const apiPath = '/account/tokens/oauth2/{provider}'.replace('{provider}', provider);\n        let payload = {};\n        if (typeof provider === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"provider\"');\n        }\n\n\n        if (typeof success !== 'undefined') {\n            payload['success'] = success;\n        }\n\n        if (typeof failure !== 'undefined') {\n            payload['failure'] = failure;\n        }\n\n        if (typeof scopes !== 'undefined') {\n            payload['scopes'] = scopes;\n        }\n\n        return await this.client.call('get', apiPath, {\n            'content-type': 'application/json',\n        }, payload, 'location');\n    }\n\n    /**\n     * Create phone token\n     *\n     * Sends the user an SMS with a secret key for creating a session. If the\n     * provided user ID has not be registered, a new user will be created. Use the\n     * returned user ID and secret and submit a request to the [POST\n     * /v1/account/sessions/token](https://appwrite.io/docs/references/cloud/client-web/account#createSession)\n     * endpoint to complete the login process. The secret sent to the user's phone\n     * is valid for 15 minutes.\n     * \n     * A user is limited to 10 active sessions at a time by default. [Learn more\n     * about session\n     * limits](https://appwrite.io/docs/authentication-security#limits).\n     *\n     * @param {string} userId\n     * @param {string} phone\n     * @throws {AppwriteException}\n     * @returns {Promise}\n     */\n    async createPhoneToken(userId, phone) {\n        const apiPath = '/account/tokens/phone';\n        let payload = {};\n        if (typeof userId === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"userId\"');\n        }\n\n        if (typeof phone === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"phone\"');\n        }\n\n\n        if (typeof userId !== 'undefined') {\n            payload['userId'] = userId;\n        }\n\n        if (typeof phone !== 'undefined') {\n            payload['phone'] = phone;\n        }\n\n        return await this.client.call('post', apiPath, {\n            'content-type': 'application/json',\n        }, payload);\n    }\n\n    /**\n     * Create email verification\n     *\n     * Use this endpoint to send a verification message to your user email address\n     * to confirm they are the valid owners of that address. Both the **userId**\n     * and **secret** arguments will be passed as query parameters to the URL you\n     * have provided to be attached to the verification email. The provided URL\n     * should redirect the user back to your app and allow you to complete the\n     * verification process by verifying both the **userId** and **secret**\n     * parameters. Learn more about how to [complete the verification\n     * process](https://appwrite.io/docs/references/cloud/client-web/account#updateVerification).\n     * The verification link sent to the user's email address is valid for 7 days.\n     * \n     * Please note that in order to avoid a [Redirect\n     * Attack](https://github.com/OWASP/CheatSheetSeries/blob/master/cheatsheets/Unvalidated_Redirects_and_Forwards_Cheat_Sheet.md),\n     * the only valid redirect URLs are the ones from domains you have set when\n     * adding your platforms in the console interface.\n     * \n     *\n     * @param {string} url\n     * @throws {AppwriteException}\n     * @returns {Promise}\n     */\n    async createVerification(url) {\n        const apiPath = '/account/verification';\n        let payload = {};\n        if (typeof url === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"url\"');\n        }\n\n\n        if (typeof url !== 'undefined') {\n            payload['url'] = url;\n        }\n\n        return await this.client.call('post', apiPath, {\n            'content-type': 'application/json',\n        }, payload);\n    }\n\n    /**\n     * Create email verification (confirmation)\n     *\n     * Use this endpoint to complete the user email verification process. Use both\n     * the **userId** and **secret** parameters that were attached to your app URL\n     * to verify the user email ownership. If confirmed this route will return a\n     * 200 status code.\n     *\n     * @param {string} userId\n     * @param {string} secret\n     * @throws {AppwriteException}\n     * @returns {Promise}\n     */\n    async updateVerification(userId, secret) {\n        const apiPath = '/account/verification';\n        let payload = {};\n        if (typeof userId === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"userId\"');\n        }\n\n        if (typeof secret === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"secret\"');\n        }\n\n\n        if (typeof userId !== 'undefined') {\n            payload['userId'] = userId;\n        }\n\n        if (typeof secret !== 'undefined') {\n            payload['secret'] = secret;\n        }\n\n        return await this.client.call('put', apiPath, {\n            'content-type': 'application/json',\n        }, payload);\n    }\n\n    /**\n     * Create phone verification\n     *\n     * Use this endpoint to send a verification SMS to the currently logged in\n     * user. This endpoint is meant for use after updating a user's phone number\n     * using the\n     * [accountUpdatePhone](https://appwrite.io/docs/references/cloud/client-web/account#updatePhone)\n     * endpoint. Learn more about how to [complete the verification\n     * process](https://appwrite.io/docs/references/cloud/client-web/account#updatePhoneVerification).\n     * The verification code sent to the user's phone number is valid for 15\n     * minutes.\n     *\n     * @throws {AppwriteException}\n     * @returns {Promise}\n     */\n    async createPhoneVerification() {\n        const apiPath = '/account/verification/phone';\n        let payload = {};\n\n        return await this.client.call('post', apiPath, {\n            'content-type': 'application/json',\n        }, payload);\n    }\n\n    /**\n     * Create phone verification (confirmation)\n     *\n     * Use this endpoint to complete the user phone verification process. Use the\n     * **userId** and **secret** that were sent to your user's phone number to\n     * verify the user email ownership. If confirmed this route will return a 200\n     * status code.\n     *\n     * @param {string} userId\n     * @param {string} secret\n     * @throws {AppwriteException}\n     * @returns {Promise}\n     */\n    async updatePhoneVerification(userId, secret) {\n        const apiPath = '/account/verification/phone';\n        let payload = {};\n        if (typeof userId === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"userId\"');\n        }\n\n        if (typeof secret === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"secret\"');\n        }\n\n\n        if (typeof userId !== 'undefined') {\n            payload['userId'] = userId;\n        }\n\n        if (typeof secret !== 'undefined') {\n            payload['secret'] = secret;\n        }\n\n        return await this.client.call('put', apiPath, {\n            'content-type': 'application/json',\n        }, payload);\n    }\n}\n\nmodule.exports = Account;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFjdGlvbi1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9ub2RlLWFwcHdyaXRlL2xpYi9zZXJ2aWNlcy9hY2NvdW50LmpzIiwibWFwcGluZ3MiOiJBQUFBLGdCQUFnQixtQkFBTyxDQUFDLG1GQUFlO0FBQ3ZDLDBCQUEwQixtQkFBTyxDQUFDLHVGQUFpQjtBQUNuRCxrQkFBa0IsbUJBQU8sQ0FBQyx1RkFBaUI7QUFDM0MsZUFBZSxtQkFBTyxDQUFDLGlGQUFjO0FBQ3JDLGVBQWUsbUJBQU8sQ0FBQyxzQkFBUTtBQUMvQixRQUFRLFlBQVksRUFBRSxtQkFBTyxDQUFDLGtCQUFNO0FBQ3BDLFdBQVcsbUJBQU8sQ0FBQyxjQUFJO0FBQ3ZCLFFBQVEsT0FBTyxFQUFFLG1CQUFPLENBQUMsc0JBQVE7QUFDakMsY0FBYyxtQkFBTyxDQUFDLCtFQUFhOztBQUVuQzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQixpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFNBQVM7QUFDVDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsUUFBUTtBQUN2QixlQUFlLFFBQVE7QUFDdkIsZUFBZSxRQUFRO0FBQ3ZCLGdCQUFnQjtBQUNoQixpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUs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RUE7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQixpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFNBQVM7QUFDVDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QixnQkFBZ0I7QUFDaEIsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFNBQVM7QUFDVDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkIsZUFBZSxRQUFRO0FBQ3ZCLGdCQUFnQjtBQUNoQixpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QixlQUFlLFFBQVE7QUFDdkIsZUFBZSxRQUFRO0FBQ3ZCLGdCQUFnQjtBQUNoQixpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFNBQVM7QUFDVDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEIsaUJBQWlCO0FB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QTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTs7QUFFQSIsInNvdXJjZXMiOlsid2VicGFjazovL2pzbV9iYW5raW5nLy4vbm9kZV9tb2R1bGVzL25vZGUtYXBwd3JpdGUvbGliL3NlcnZpY2VzL2FjY291bnQuanM/ODZjZSJdLCJzb3VyY2VzQ29udGVudCI6WyJjb25zdCBTZXJ2aWNlID0gcmVxdWlyZSgnLi4vc2VydmljZS5qcycpO1xuY29uc3QgQXBwd3JpdGVFeGNlcHRpb24gPSByZXF1aXJlKCcuLi9leGNlcHRpb24uanMnKTtcbmNvbnN0IElucHV0RmlsZSA9IHJlcXVpcmUoJy4uL2lucHV0RmlsZS5qcycpO1xuY29uc3QgY2xpZW50ID0gcmVxdWlyZSgnLi4vY2xpZW50LmpzJyk7XG5jb25zdCBTdHJlYW0gPSByZXF1aXJlKCdzdHJlYW0nKTtcbmNvbnN0IHsgcHJvbWlzaWZ5IH0gPSByZXF1aXJlKCd1dGlsJyk7XG5jb25zdCBmcyA9IHJlcXVpcmUoJ2ZzJyk7XG5jb25zdCB7IEZpbGUgfSA9IHJlcXVpcmUoJ3VuZGljaScpO1xuY29uc3QgUXVlcnkgPSByZXF1aXJlKCcuLi9xdWVyeS5qcycpO1xuXG5jbGFzcyBBY2NvdW50IGV4dGVuZHMgU2VydmljZSB7XG5cbiAgICAgY29uc3RydWN0b3IoY2xpZW50KVxuICAgICB7XG4gICAgICAgIHN1cGVyKGNsaWVudCk7XG4gICAgIH1cblxuXG4gICAgLyoqXG4gICAgICogR2V0IGFjY291bnRcbiAgICAgKlxuICAgICAqIEdldCB0aGUgY3VycmVudGx5IGxvZ2dlZCBpbiB1c2VyLlxuICAgICAqXG4gICAgICogQHRocm93cyB7QXBwd3JpdGVFeGNlcHRpb259XG4gICAgICogQHJldHVybnMge1Byb21pc2V9XG4gICAgICovXG4gICAgYXN5bmMgZ2V0KCkge1xuICAgICAgICBjb25zdCBhcGlQYXRoID0gJy9hY2NvdW50JztcbiAgICAgICAgbGV0IHBheWxvYWQgPSB7fTtcblxuICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy5jbGllbnQuY2FsbCgnZ2V0JywgYXBpUGF0aCwge1xuICAgICAgICAgICAgJ2NvbnRlbnQtdHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJyxcbiAgICAgICAgfSwgcGF5bG9hZCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlIGFjY291bnRcbiAgICAgKlxuICAgICAqIFVzZSB0aGlzIGVuZHBvaW50IHRvIGFsbG93IGEgbmV3IHVzZXIgdG8gcmVnaXN0ZXIgYSBuZXcgYWNjb3VudCBpbiB5b3VyXG4gICAgICogcHJvamVjdC4gQWZ0ZXIgdGhlIHVzZXIgcmVnaXN0cmF0aW9uIGNvbXBsZXRlcyBzdWNjZXNzZnVsbHksIHlvdSBjYW4gdXNlXG4gICAgICogdGhlXG4gICAgICogWy9hY2NvdW50L3ZlcmZpY2F0aW9uXShodHRwczovL2FwcHdyaXRlLmlvL2RvY3MvcmVmZXJlbmNlcy9jbG91ZC9jbGllbnQtd2ViL2FjY291bnQjY3JlYXRlVmVyaWZpY2F0aW9uKVxuICAgICAqIHJvdXRlIHRvIHN0YXJ0IHZlcmlmeWluZyB0aGUgdXNlciBlbWFpbCBhZGRyZXNzLiBUbyBhbGxvdyB0aGUgbmV3IHVzZXIgdG9cbiAgICAgKiBsb2dpbiB0byB0aGVpciBuZXcgYWNjb3VudCwgeW91IG5lZWQgdG8gY3JlYXRlIGEgbmV3IFthY2NvdW50XG4gICAgICogc2Vzc2lvbl0oaHR0cHM6Ly9hcHB3cml0ZS5pby9kb2NzL3JlZmVyZW5jZXMvY2xvdWQvY2xpZW50LXdlYi9hY2NvdW50I2NyZWF0ZUVtYWlsU2Vzc2lvbikuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gdXNlcklkXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGVtYWlsXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHBhc3N3b3JkXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IG5hbWVcbiAgICAgKiBAdGhyb3dzIHtBcHB3cml0ZUV4Y2VwdGlvbn1cbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZX1cbiAgICAgKi9cbiAgICBhc3luYyBjcmVhdGUodXNlcklkLCBlbWFpbCwgcGFzc3dvcmQsIG5hbWUpIHtcbiAgICAgICAgY29uc3QgYXBpUGF0aCA9ICcvYWNjb3VudCc7XG4gICAgICAgIGxldCBwYXlsb2FkID0ge307XG4gICAgICAgIGlmICh0eXBlb2YgdXNlcklkID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEFwcHdyaXRlRXhjZXB0aW9uKCdNaXNzaW5nIHJlcXVpcmVkIHBhcmFtZXRlcjogXCJ1c2VySWRcIicpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHR5cGVvZiBlbWFpbCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBBcHB3cml0ZUV4Y2VwdGlvbignTWlzc2luZyByZXF1aXJlZCBwYXJhbWV0ZXI6IFwiZW1haWxcIicpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHR5cGVvZiBwYXNzd29yZCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBBcHB3cml0ZUV4Y2VwdGlvbignTWlzc2luZyByZXF1aXJlZCBwYXJhbWV0ZXI6IFwicGFzc3dvcmRcIicpO1xuICAgICAgICB9XG5cblxuICAgICAgICBpZiAodHlwZW9mIHVzZXJJZCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHBheWxvYWRbJ3VzZXJJZCddID0gdXNlcklkO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHR5cGVvZiBlbWFpbCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHBheWxvYWRbJ2VtYWlsJ10gPSBlbWFpbDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0eXBlb2YgcGFzc3dvcmQgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICBwYXlsb2FkWydwYXNzd29yZCddID0gcGFzc3dvcmQ7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodHlwZW9mIG5hbWUgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICBwYXlsb2FkWyduYW1lJ10gPSBuYW1lO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMuY2xpZW50LmNhbGwoJ3Bvc3QnLCBhcGlQYXRoLCB7XG4gICAgICAgICAgICAnY29udGVudC10eXBlJzogJ2FwcGxpY2F0aW9uL2pzb24nLFxuICAgICAgICB9LCBwYXlsb2FkKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBVcGRhdGUgZW1haWxcbiAgICAgKlxuICAgICAqIFVwZGF0ZSBjdXJyZW50bHkgbG9nZ2VkIGluIHVzZXIgYWNjb3VudCBlbWFpbCBhZGRyZXNzLiBBZnRlciBjaGFuZ2luZyB1c2VyXG4gICAgICogYWRkcmVzcywgdGhlIHVzZXIgY29uZmlybWF0aW9uIHN0YXR1cyB3aWxsIGdldCByZXNldC4gQSBuZXcgY29uZmlybWF0aW9uXG4gICAgICogZW1haWwgaXMgbm90IHNlbnQgYXV0b21hdGljYWxseSBob3dldmVyIHlvdSBjYW4gdXNlIHRoZSBzZW5kIGNvbmZpcm1hdGlvblxuICAgICAqIGVtYWlsIGVuZHBvaW50IGFnYWluIHRvIHNlbmQgdGhlIGNvbmZpcm1hdGlvbiBlbWFpbC4gRm9yIHNlY3VyaXR5IG1lYXN1cmVzLFxuICAgICAqIHVzZXIgcGFzc3dvcmQgaXMgcmVxdWlyZWQgdG8gY29tcGxldGUgdGhpcyByZXF1ZXN0LlxuICAgICAqIFRoaXMgZW5kcG9pbnQgY2FuIGFsc28gYmUgdXNlZCB0byBjb252ZXJ0IGFuIGFub255bW91cyBhY2NvdW50IHRvIGEgbm9ybWFsXG4gICAgICogb25lLCBieSBwYXNzaW5nIGFuIGVtYWlsIGFkZHJlc3MgYW5kIGEgbmV3IHBhc3N3b3JkLlxuICAgICAqIFxuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGVtYWlsXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHBhc3N3b3JkXG4gICAgICogQHRocm93cyB7QXBwd3JpdGVFeGNlcHRpb259XG4gICAgICogQHJldHVybnMge1Byb21pc2V9XG4gICAgICovXG4gICAgYXN5bmMgdXBkYXRlRW1haWwoZW1haWwsIHBhc3N3b3JkKSB7XG4gICAgICAgIGNvbnN0IGFwaVBhdGggPSAnL2FjY291bnQvZW1haWwnO1xuICAgICAgICBsZXQgcGF5bG9hZCA9IHt9O1xuICAgICAgICBpZiAodHlwZW9mIGVtYWlsID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEFwcHdyaXRlRXhjZXB0aW9uKCdNaXNzaW5nIHJlcXVpcmVkIHBhcmFtZXRlcjogXCJlbWFpbFwiJyk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodHlwZW9mIHBhc3N3b3JkID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEFwcHdyaXRlRXhjZXB0aW9uKCdNaXNzaW5nIHJlcXVpcmVkIHBhcmFtZXRlcjogXCJwYXNzd29yZFwiJyk7XG4gICAgICAgIH1cblxuXG4gICAgICAgIGlmICh0eXBlb2YgZW1haWwgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICBwYXlsb2FkWydlbWFpbCddID0gZW1haWw7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodHlwZW9mIHBhc3N3b3JkICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgcGF5bG9hZFsncGFzc3dvcmQnXSA9IHBhc3N3b3JkO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMuY2xpZW50LmNhbGwoJ3BhdGNoJywgYXBpUGF0aCwge1xuICAgICAgICAgICAgJ2NvbnRlbnQtdHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJyxcbiAgICAgICAgfSwgcGF5bG9hZCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogTGlzdCBJZGVudGl0aWVzXG4gICAgICpcbiAgICAgKiBHZXQgdGhlIGxpc3Qgb2YgaWRlbnRpdGllcyBmb3IgdGhlIGN1cnJlbnRseSBsb2dnZWQgaW4gdXNlci5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nW119IHF1ZXJpZXNcbiAgICAgKiBAdGhyb3dzIHtBcHB3cml0ZUV4Y2VwdGlvbn1cbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZX1cbiAgICAgKi9cbiAgICBhc3luYyBsaXN0SWRlbnRpdGllcyhxdWVyaWVzKSB7XG4gICAgICAgIGNvbnN0IGFwaVBhdGggPSAnL2FjY291bnQvaWRlbnRpdGllcyc7XG4gICAgICAgIGxldCBwYXlsb2FkID0ge307XG5cbiAgICAgICAgaWYgKHR5cGVvZiBxdWVyaWVzICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgcGF5bG9hZFsncXVlcmllcyddID0gcXVlcmllcztcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBhd2FpdCB0aGlzLmNsaWVudC5jYWxsKCdnZXQnLCBhcGlQYXRoLCB7XG4gICAgICAgICAgICAnY29udGVudC10eXBlJzogJ2FwcGxpY2F0aW9uL2pzb24nLFxuICAgICAgICB9LCBwYXlsb2FkKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBEZWxldGUgaWRlbnRpdHlcbiAgICAgKlxuICAgICAqIERlbGV0ZSBhbiBpZGVudGl0eSBieSBpdHMgdW5pcXVlIElELlxuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGlkZW50aXR5SWRcbiAgICAgKiBAdGhyb3dzIHtBcHB3cml0ZUV4Y2VwdGlvbn1cbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZX1cbiAgICAgKi9cbiAgICBhc3luYyBkZWxldGVJZGVudGl0eShpZGVudGl0eUlkKSB7XG4gICAgICAgIGNvbnN0IGFwaVBhdGggPSAnL2FjY291bnQvaWRlbnRpdGllcy97aWRlbnRpdHlJZH0nLnJlcGxhY2UoJ3tpZGVudGl0eUlkfScsIGlkZW50aXR5SWQpO1xuICAgICAgICBsZXQgcGF5bG9hZCA9IHt9O1xuICAgICAgICBpZiAodHlwZW9mIGlkZW50aXR5SWQgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgQXBwd3JpdGVFeGNlcHRpb24oJ01pc3NpbmcgcmVxdWlyZWQgcGFyYW1ldGVyOiBcImlkZW50aXR5SWRcIicpO1xuICAgICAgICB9XG5cblxuICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy5jbGllbnQuY2FsbCgnZGVsZXRlJywgYXBpUGF0aCwge1xuICAgICAgICAgICAgJ2NvbnRlbnQtdHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJyxcbiAgICAgICAgfSwgcGF5bG9hZCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlIEpXVFxuICAgICAqXG4gICAgICogVXNlIHRoaXMgZW5kcG9pbnQgdG8gY3JlYXRlIGEgSlNPTiBXZWIgVG9rZW4uIFlvdSBjYW4gdXNlIHRoZSByZXN1bHRpbmcgSldUXG4gICAgICogdG8gYXV0aGVudGljYXRlIG9uIGJlaGFsZiBvZiB0aGUgY3VycmVudCB1c2VyIHdoZW4gd29ya2luZyB3aXRoIHRoZVxuICAgICAqIEFwcHdyaXRlIHNlcnZlci1zaWRlIEFQSSBhbmQgU0RLcy4gVGhlIEpXVCBzZWNyZXQgaXMgdmFsaWQgZm9yIDE1IG1pbnV0ZXNcbiAgICAgKiBmcm9tIGl0cyBjcmVhdGlvbiBhbmQgd2lsbCBiZSBpbnZhbGlkIGlmIHRoZSB1c2VyIHdpbGwgbG9nb3V0IGluIHRoYXQgdGltZVxuICAgICAqIGZyYW1lLlxuICAgICAqXG4gICAgICogQHRocm93cyB7QXBwd3JpdGVFeGNlcHRpb259XG4gICAgICogQHJldHVybnMge1Byb21pc2V9XG4gICAgICovXG4gICAgYXN5bmMgY3JlYXRlSldUKCkge1xuICAgICAgICBjb25zdCBhcGlQYXRoID0gJy9hY2NvdW50L2p3dCc7XG4gICAgICAgIGxldCBwYXlsb2FkID0ge307XG5cbiAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMuY2xpZW50LmNhbGwoJ3Bvc3QnLCBhcGlQYXRoLCB7XG4gICAgICAgICAgICAnY29udGVudC10eXBlJzogJ2FwcGxpY2F0aW9uL2pzb24nLFxuICAgICAgICB9LCBwYXlsb2FkKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBMaXN0IGxvZ3NcbiAgICAgKlxuICAgICAqIEdldCB0aGUgbGlzdCBvZiBsYXRlc3Qgc2VjdXJpdHkgYWN0aXZpdHkgbG9ncyBmb3IgdGhlIGN1cnJlbnRseSBsb2dnZWQgaW5cbiAgICAgKiB1c2VyLiBFYWNoIGxvZyByZXR1cm5zIHVzZXIgSVAgYWRkcmVzcywgbG9jYXRpb24gYW5kIGRhdGUgYW5kIHRpbWUgb2YgbG9nLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmdbXX0gcXVlcmllc1xuICAgICAqIEB0aHJvd3Mge0FwcHdyaXRlRXhjZXB0aW9ufVxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlfVxuICAgICAqL1xuICAgIGFzeW5jIGxpc3RMb2dzKHF1ZXJpZXMpIHtcbiAgICAgICAgY29uc3QgYXBpUGF0aCA9ICcvYWNjb3VudC9sb2dzJztcbiAgICAgICAgbGV0IHBheWxvYWQgPSB7fTtcblxuICAgICAgICBpZiAodHlwZW9mIHF1ZXJpZXMgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICBwYXlsb2FkWydxdWVyaWVzJ10gPSBxdWVyaWVzO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMuY2xpZW50LmNhbGwoJ2dldCcsIGFwaVBhdGgsIHtcbiAgICAgICAgICAgICdjb250ZW50LXR5cGUnOiAnYXBwbGljYXRpb24vanNvbicsXG4gICAgICAgIH0sIHBheWxvYWQpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFVwZGF0ZSBNRkFcbiAgICAgKlxuICAgICAqIEVuYWJsZSBvciBkaXNhYmxlIE1GQSBvbiBhbiBhY2NvdW50LlxuICAgICAqXG4gICAgICogQHBhcmFtIHtib29sZWFufSBtZmFcbiAgICAgKiBAdGhyb3dzIHtBcHB3cml0ZUV4Y2VwdGlvbn1cbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZX1cbiAgICAgKi9cbiAgICBhc3luYyB1cGRhdGVNRkEobWZhKSB7XG4gICAgICAgIGNvbnN0IGFwaVBhdGggPSAnL2FjY291bnQvbWZhJztcbiAgICAgICAgbGV0IHBheWxvYWQgPSB7fTtcbiAgICAgICAgaWYgKHR5cGVvZiBtZmEgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgQXBwd3JpdGVFeGNlcHRpb24oJ01pc3NpbmcgcmVxdWlyZWQgcGFyYW1ldGVyOiBcIm1mYVwiJyk7XG4gICAgICAgIH1cblxuXG4gICAgICAgIGlmICh0eXBlb2YgbWZhICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgcGF5bG9hZFsnbWZhJ10gPSBtZmE7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy5jbGllbnQuY2FsbCgncGF0Y2gnLCBhcGlQYXRoLCB7XG4gICAgICAgICAgICAnY29udGVudC10eXBlJzogJ2FwcGxpY2F0aW9uL2pzb24nLFxuICAgICAgICB9LCBwYXlsb2FkKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBBZGQgQXV0aGVudGljYXRvclxuICAgICAqXG4gICAgICogQWRkIGFuIGF1dGhlbnRpY2F0b3IgYXBwIHRvIGJlIHVzZWQgYXMgYW4gTUZBIGZhY3Rvci4gVmVyaWZ5IHRoZVxuICAgICAqIGF1dGhlbnRpY2F0b3IgdXNpbmcgdGhlIFt2ZXJpZnlcbiAgICAgKiBhdXRoZW50aWNhdG9yXSgvZG9jcy9yZWZlcmVuY2VzL2Nsb3VkL2NsaWVudC13ZWIvYWNjb3VudCN2ZXJpZnlBdXRoZW50aWNhdG9yKVxuICAgICAqIG1ldGhvZC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7QXV0aGVudGljYXRvclR5cGV9IHR5cGVcbiAgICAgKiBAdGhyb3dzIHtBcHB3cml0ZUV4Y2VwdGlvbn1cbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZX1cbiAgICAgKi9cbiAgICBhc3luYyBjcmVhdGVNZmFBdXRoZW50aWNhdG9yKHR5cGUpIHtcbiAgICAgICAgY29uc3QgYXBpUGF0aCA9ICcvYWNjb3VudC9tZmEvYXV0aGVudGljYXRvcnMve3R5cGV9Jy5yZXBsYWNlKCd7dHlwZX0nLCB0eXBlKTtcbiAgICAgICAgbGV0IHBheWxvYWQgPSB7fTtcbiAgICAgICAgaWYgKHR5cGVvZiB0eXBlID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEFwcHdyaXRlRXhjZXB0aW9uKCdNaXNzaW5nIHJlcXVpcmVkIHBhcmFtZXRlcjogXCJ0eXBlXCInKTtcbiAgICAgICAgfVxuXG5cbiAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMuY2xpZW50LmNhbGwoJ3Bvc3QnLCBhcGlQYXRoLCB7XG4gICAgICAgICAgICAnY29udGVudC10eXBlJzogJ2FwcGxpY2F0aW9uL2pzb24nLFxuICAgICAgICB9LCBwYXlsb2FkKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBWZXJpZnkgQXV0aGVudGljYXRvclxuICAgICAqXG4gICAgICogVmVyaWZ5IGFuIGF1dGhlbnRpY2F0b3IgYXBwIGFmdGVyIGFkZGluZyBpdCB1c2luZyB0aGUgW2FkZFxuICAgICAqIGF1dGhlbnRpY2F0b3JdKC9kb2NzL3JlZmVyZW5jZXMvY2xvdWQvY2xpZW50LXdlYi9hY2NvdW50I2FkZEF1dGhlbnRpY2F0b3IpXG4gICAgICogbWV0aG9kLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtBdXRoZW50aWNhdG9yVHlwZX0gdHlwZVxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBvdHBcbiAgICAgKiBAdGhyb3dzIHtBcHB3cml0ZUV4Y2VwdGlvbn1cbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZX1cbiAgICAgKi9cbiAgICBhc3luYyB1cGRhdGVNZmFBdXRoZW50aWNhdG9yKHR5cGUsIG90cCkge1xuICAgICAgICBjb25zdCBhcGlQYXRoID0gJy9hY2NvdW50L21mYS9hdXRoZW50aWNhdG9ycy97dHlwZX0nLnJlcGxhY2UoJ3t0eXBlfScsIHR5cGUpO1xuICAgICAgICBsZXQgcGF5bG9hZCA9IHt9O1xuICAgICAgICBpZiAodHlwZW9mIHR5cGUgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgQXBwd3JpdGVFeGNlcHRpb24oJ01pc3NpbmcgcmVxdWlyZWQgcGFyYW1ldGVyOiBcInR5cGVcIicpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHR5cGVvZiBvdHAgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgQXBwd3JpdGVFeGNlcHRpb24oJ01pc3NpbmcgcmVxdWlyZWQgcGFyYW1ldGVyOiBcIm90cFwiJyk7XG4gICAgICAgIH1cblxuXG4gICAgICAgIGlmICh0eXBlb2Ygb3RwICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgcGF5bG9hZFsnb3RwJ10gPSBvdHA7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy5jbGllbnQuY2FsbCgncHV0JywgYXBpUGF0aCwge1xuICAgICAgICAgICAgJ2NvbnRlbnQtdHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJyxcbiAgICAgICAgfSwgcGF5bG9hZCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRGVsZXRlIEF1dGhlbnRpY2F0b3JcbiAgICAgKlxuICAgICAqIERlbGV0ZSBhbiBhdXRoZW50aWNhdG9yIGZvciBhIHVzZXIgYnkgSUQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0F1dGhlbnRpY2F0b3JUeXBlfSB0eXBlXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IG90cFxuICAgICAqIEB0aHJvd3Mge0FwcHdyaXRlRXhjZXB0aW9ufVxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlfVxuICAgICAqL1xuICAgIGFzeW5jIGRlbGV0ZU1mYUF1dGhlbnRpY2F0b3IodHlwZSwgb3RwKSB7XG4gICAgICAgIGNvbnN0IGFwaVBhdGggPSAnL2FjY291bnQvbWZhL2F1dGhlbnRpY2F0b3JzL3t0eXBlfScucmVwbGFjZSgne3R5cGV9JywgdHlwZSk7XG4gICAgICAgIGxldCBwYXlsb2FkID0ge307XG4gICAgICAgIGlmICh0eXBlb2YgdHlwZSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBBcHB3cml0ZUV4Y2VwdGlvbignTWlzc2luZyByZXF1aXJlZCBwYXJhbWV0ZXI6IFwidHlwZVwiJyk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodHlwZW9mIG90cCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBBcHB3cml0ZUV4Y2VwdGlvbignTWlzc2luZyByZXF1aXJlZCBwYXJhbWV0ZXI6IFwib3RwXCInKTtcbiAgICAgICAgfVxuXG5cbiAgICAgICAgaWYgKHR5cGVvZiBvdHAgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICBwYXlsb2FkWydvdHAnXSA9IG90cDtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBhd2FpdCB0aGlzLmNsaWVudC5jYWxsKCdkZWxldGUnLCBhcGlQYXRoLCB7XG4gICAgICAgICAgICAnY29udGVudC10eXBlJzogJ2FwcGxpY2F0aW9uL2pzb24nLFxuICAgICAgICB9LCBwYXlsb2FkKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGUgMkZBIENoYWxsZW5nZVxuICAgICAqXG4gICAgICogQmVnaW4gdGhlIHByb2Nlc3Mgb2YgTUZBIHZlcmlmaWNhdGlvbiBhZnRlciBzaWduLWluLiBGaW5pc2ggdGhlIGZsb3cgd2l0aFxuICAgICAqIFt1cGRhdGVNZmFDaGFsbGVuZ2VdKC9kb2NzL3JlZmVyZW5jZXMvY2xvdWQvY2xpZW50LXdlYi9hY2NvdW50I3VwZGF0ZU1mYUNoYWxsZW5nZSlcbiAgICAgKiBtZXRob2QuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0F1dGhlbnRpY2F0aW9uRmFjdG9yfSBmYWN0b3JcbiAgICAgKiBAdGhyb3dzIHtBcHB3cml0ZUV4Y2VwdGlvbn1cbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZX1cbiAgICAgKi9cbiAgICBhc3luYyBjcmVhdGVNZmFDaGFsbGVuZ2UoZmFjdG9yKSB7XG4gICAgICAgIGNvbnN0IGFwaVBhdGggPSAnL2FjY291bnQvbWZhL2NoYWxsZW5nZSc7XG4gICAgICAgIGxldCBwYXlsb2FkID0ge307XG4gICAgICAgIGlmICh0eXBlb2YgZmFjdG9yID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEFwcHdyaXRlRXhjZXB0aW9uKCdNaXNzaW5nIHJlcXVpcmVkIHBhcmFtZXRlcjogXCJmYWN0b3JcIicpO1xuICAgICAgICB9XG5cblxuICAgICAgICBpZiAodHlwZW9mIGZhY3RvciAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHBheWxvYWRbJ2ZhY3RvciddID0gZmFjdG9yO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMuY2xpZW50LmNhbGwoJ3Bvc3QnLCBhcGlQYXRoLCB7XG4gICAgICAgICAgICAnY29udGVudC10eXBlJzogJ2FwcGxpY2F0aW9uL2pzb24nLFxuICAgICAgICB9LCBwYXlsb2FkKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGUgTUZBIENoYWxsZW5nZSAoY29uZmlybWF0aW9uKVxuICAgICAqXG4gICAgICogQ29tcGxldGUgdGhlIE1GQSBjaGFsbGVuZ2UgYnkgcHJvdmlkaW5nIHRoZSBvbmUtdGltZSBwYXNzd29yZC4gRmluaXNoIHRoZVxuICAgICAqIHByb2Nlc3Mgb2YgTUZBIHZlcmlmaWNhdGlvbiBieSBwcm92aWRpbmcgdGhlIG9uZS10aW1lIHBhc3N3b3JkLiBUbyBiZWdpblxuICAgICAqIHRoZSBmbG93LCB1c2VcbiAgICAgKiBbY3JlYXRlTWZhQ2hhbGxlbmdlXSgvZG9jcy9yZWZlcmVuY2VzL2Nsb3VkL2NsaWVudC13ZWIvYWNjb3VudCNjcmVhdGVNZmFDaGFsbGVuZ2UpXG4gICAgICogbWV0aG9kLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGNoYWxsZW5nZUlkXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IG90cFxuICAgICAqIEB0aHJvd3Mge0FwcHdyaXRlRXhjZXB0aW9ufVxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlfVxuICAgICAqL1xuICAgIGFzeW5jIHVwZGF0ZU1mYUNoYWxsZW5nZShjaGFsbGVuZ2VJZCwgb3RwKSB7XG4gICAgICAgIGNvbnN0IGFwaVBhdGggPSAnL2FjY291bnQvbWZhL2NoYWxsZW5nZSc7XG4gICAgICAgIGxldCBwYXlsb2FkID0ge307XG4gICAgICAgIGlmICh0eXBlb2YgY2hhbGxlbmdlSWQgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgQXBwd3JpdGVFeGNlcHRpb24oJ01pc3NpbmcgcmVxdWlyZWQgcGFyYW1ldGVyOiBcImNoYWxsZW5nZUlkXCInKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0eXBlb2Ygb3RwID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEFwcHdyaXRlRXhjZXB0aW9uKCdNaXNzaW5nIHJlcXVpcmVkIHBhcmFtZXRlcjogXCJvdHBcIicpO1xuICAgICAgICB9XG5cblxuICAgICAgICBpZiAodHlwZW9mIGNoYWxsZW5nZUlkICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgcGF5bG9hZFsnY2hhbGxlbmdlSWQnXSA9IGNoYWxsZW5nZUlkO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHR5cGVvZiBvdHAgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICBwYXlsb2FkWydvdHAnXSA9IG90cDtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBhd2FpdCB0aGlzLmNsaWVudC5jYWxsKCdwdXQnLCBhcGlQYXRoLCB7XG4gICAgICAgICAgICAnY29udGVudC10eXBlJzogJ2FwcGxpY2F0aW9uL2pzb24nLFxuICAgICAgICB9LCBwYXlsb2FkKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBMaXN0IEZhY3RvcnNcbiAgICAgKlxuICAgICAqIExpc3QgdGhlIGZhY3RvcnMgYXZhaWxhYmxlIG9uIHRoZSBhY2NvdW50IHRvIGJlIHVzZWQgYXMgYSBNRkEgY2hhbGxhbmdlLlxuICAgICAqXG4gICAgICogQHRocm93cyB7QXBwd3JpdGVFeGNlcHRpb259XG4gICAgICogQHJldHVybnMge1Byb21pc2V9XG4gICAgICovXG4gICAgYXN5bmMgbGlzdE1mYUZhY3RvcnMoKSB7XG4gICAgICAgIGNvbnN0IGFwaVBhdGggPSAnL2FjY291bnQvbWZhL2ZhY3RvcnMnO1xuICAgICAgICBsZXQgcGF5bG9hZCA9IHt9O1xuXG4gICAgICAgIHJldHVybiBhd2FpdCB0aGlzLmNsaWVudC5jYWxsKCdnZXQnLCBhcGlQYXRoLCB7XG4gICAgICAgICAgICAnY29udGVudC10eXBlJzogJ2FwcGxpY2F0aW9uL2pzb24nLFxuICAgICAgICB9LCBwYXlsb2FkKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZXQgTUZBIFJlY292ZXJ5IENvZGVzXG4gICAgICpcbiAgICAgKiBHZXQgcmVjb3ZlcnkgY29kZXMgdGhhdCBjYW4gYmUgdXNlZCBhcyBiYWNrdXAgZm9yIE1GQSBmbG93LiBCZWZvcmUgZ2V0dGluZ1xuICAgICAqIGNvZGVzLCB0aGV5IG11c3QgYmUgZ2VuZXJhdGVkIHVzaW5nXG4gICAgICogW2NyZWF0ZU1mYVJlY292ZXJ5Q29kZXNdKC9kb2NzL3JlZmVyZW5jZXMvY2xvdWQvY2xpZW50LXdlYi9hY2NvdW50I2NyZWF0ZU1mYVJlY292ZXJ5Q29kZXMpXG4gICAgICogbWV0aG9kLiBBbiBPVFAgY2hhbGxlbmdlIGlzIHJlcXVpcmVkIHRvIHJlYWQgcmVjb3ZlcnkgY29kZXMuXG4gICAgICpcbiAgICAgKiBAdGhyb3dzIHtBcHB3cml0ZUV4Y2VwdGlvbn1cbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZX1cbiAgICAgKi9cbiAgICBhc3luYyBnZXRNZmFSZWNvdmVyeUNvZGVzKCkge1xuICAgICAgICBjb25zdCBhcGlQYXRoID0gJy9hY2NvdW50L21mYS9yZWNvdmVyeS1jb2Rlcyc7XG4gICAgICAgIGxldCBwYXlsb2FkID0ge307XG5cbiAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMuY2xpZW50LmNhbGwoJ2dldCcsIGFwaVBhdGgsIHtcbiAgICAgICAgICAgICdjb250ZW50LXR5cGUnOiAnYXBwbGljYXRpb24vanNvbicsXG4gICAgICAgIH0sIHBheWxvYWQpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZSBNRkEgUmVjb3ZlcnkgQ29kZXNcbiAgICAgKlxuICAgICAqIEdlbmVyYXRlIHJlY292ZXJ5IGNvZGVzIGFzIGJhY2t1cCBmb3IgTUZBIGZsb3cuIEl0J3MgcmVjb21tZW5kZWQgdG9cbiAgICAgKiBnZW5lcmF0ZSBhbmQgc2hvdyB0aGVuIGltbWVkaWF0ZWx5IGFmdGVyIHVzZXIgc3VjY2Vzc2Z1bGx5IGFkZHMgdGhlaXJcbiAgICAgKiBhdXRoZWh0aWNhdG9yLiBSZWNvdmVyeSBjb2RlcyBjYW4gYmUgdXNlZCBhcyBhIE1GQSB2ZXJpZmljYXRpb24gdHlwZSBpblxuICAgICAqIFtjcmVhdGVNZmFDaGFsbGVuZ2VdKC9kb2NzL3JlZmVyZW5jZXMvY2xvdWQvY2xpZW50LXdlYi9hY2NvdW50I2NyZWF0ZU1mYUNoYWxsZW5nZSlcbiAgICAgKiBtZXRob2QuXG4gICAgICpcbiAgICAgKiBAdGhyb3dzIHtBcHB3cml0ZUV4Y2VwdGlvbn1cbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZX1cbiAgICAgKi9cbiAgICBhc3luYyBjcmVhdGVNZmFSZWNvdmVyeUNvZGVzKCkge1xuICAgICAgICBjb25zdCBhcGlQYXRoID0gJy9hY2NvdW50L21mYS9yZWNvdmVyeS1jb2Rlcyc7XG4gICAgICAgIGxldCBwYXlsb2FkID0ge307XG5cbiAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMuY2xpZW50LmNhbGwoJ3Bvc3QnLCBhcGlQYXRoLCB7XG4gICAgICAgICAgICAnY29udGVudC10eXBlJzogJ2FwcGxpY2F0aW9uL2pzb24nLFxuICAgICAgICB9LCBwYXlsb2FkKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZWdlbmVyYXRlIE1GQSBSZWNvdmVyeSBDb2Rlc1xuICAgICAqXG4gICAgICogUmVnZW5lcmF0ZSByZWNvdmVyeSBjb2RlcyB0aGF0IGNhbiBiZSB1c2VkIGFzIGJhY2t1cCBmb3IgTUZBIGZsb3cuIEJlZm9yZVxuICAgICAqIHJlZ2VuZXJhdGluZyBjb2RlcywgdGhleSBtdXN0IGJlIGZpcnN0IGdlbmVyYXRlZCB1c2luZ1xuICAgICAqIFtjcmVhdGVNZmFSZWNvdmVyeUNvZGVzXSgvZG9jcy9yZWZlcmVuY2VzL2Nsb3VkL2NsaWVudC13ZWIvYWNjb3VudCNjcmVhdGVNZmFSZWNvdmVyeUNvZGVzKVxuICAgICAqIG1ldGhvZC4gQW4gT1RQIGNoYWxsZW5nZSBpcyByZXF1aXJlZCB0byByZWdlbnJlYXRlIHJlY292ZXJ5IGNvZGVzLlxuICAgICAqXG4gICAgICogQHRocm93cyB7QXBwd3JpdGVFeGNlcHRpb259XG4gICAgICogQHJldHVybnMge1Byb21pc2V9XG4gICAgICovXG4gICAgYXN5bmMgdXBkYXRlTWZhUmVjb3ZlcnlDb2RlcygpIHtcbiAgICAgICAgY29uc3QgYXBpUGF0aCA9ICcvYWNjb3VudC9tZmEvcmVjb3ZlcnktY29kZXMnO1xuICAgICAgICBsZXQgcGF5bG9hZCA9IHt9O1xuXG4gICAgICAgIHJldHVybiBhd2FpdCB0aGlzLmNsaWVudC5jYWxsKCdwYXRjaCcsIGFwaVBhdGgsIHtcbiAgICAgICAgICAgICdjb250ZW50LXR5cGUnOiAnYXBwbGljYXRpb24vanNvbicsXG4gICAgICAgIH0sIHBheWxvYWQpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFVwZGF0ZSBuYW1lXG4gICAgICpcbiAgICAgKiBVcGRhdGUgY3VycmVudGx5IGxvZ2dlZCBpbiB1c2VyIGFjY291bnQgbmFtZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lXG4gICAgICogQHRocm93cyB7QXBwd3JpdGVFeGNlcHRpb259XG4gICAgICogQHJldHVybnMge1Byb21pc2V9XG4gICAgICovXG4gICAgYXN5bmMgdXBkYXRlTmFtZShuYW1lKSB7XG4gICAgICAgIGNvbnN0IGFwaVBhdGggPSAnL2FjY291bnQvbmFtZSc7XG4gICAgICAgIGxldCBwYXlsb2FkID0ge307XG4gICAgICAgIGlmICh0eXBlb2YgbmFtZSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBBcHB3cml0ZUV4Y2VwdGlvbignTWlzc2luZyByZXF1aXJlZCBwYXJhbWV0ZXI6IFwibmFtZVwiJyk7XG4gICAgICAgIH1cblxuXG4gICAgICAgIGlmICh0eXBlb2YgbmFtZSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHBheWxvYWRbJ25hbWUnXSA9IG5hbWU7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy5jbGllbnQuY2FsbCgncGF0Y2gnLCBhcGlQYXRoLCB7XG4gICAgICAgICAgICAnY29udGVudC10eXBlJzogJ2FwcGxpY2F0aW9uL2pzb24nLFxuICAgICAgICB9LCBwYXlsb2FkKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBVcGRhdGUgcGFzc3dvcmRcbiAgICAgKlxuICAgICAqIFVwZGF0ZSBjdXJyZW50bHkgbG9nZ2VkIGluIHVzZXIgcGFzc3dvcmQuIEZvciB2YWxpZGF0aW9uLCB1c2VyIGlzIHJlcXVpcmVkXG4gICAgICogdG8gcGFzcyBpbiB0aGUgbmV3IHBhc3N3b3JkLCBhbmQgdGhlIG9sZCBwYXNzd29yZC4gRm9yIHVzZXJzIGNyZWF0ZWQgd2l0aFxuICAgICAqIE9BdXRoLCBUZWFtIEludml0ZXMgYW5kIE1hZ2ljIFVSTCwgb2xkUGFzc3dvcmQgaXMgb3B0aW9uYWwuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gcGFzc3dvcmRcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gb2xkUGFzc3dvcmRcbiAgICAgKiBAdGhyb3dzIHtBcHB3cml0ZUV4Y2VwdGlvbn1cbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZX1cbiAgICAgKi9cbiAgICBhc3luYyB1cGRhdGVQYXNzd29yZChwYXNzd29yZCwgb2xkUGFzc3dvcmQpIHtcbiAgICAgICAgY29uc3QgYXBpUGF0aCA9ICcvYWNjb3VudC9wYXNzd29yZCc7XG4gICAgICAgIGxldCBwYXlsb2FkID0ge307XG4gICAgICAgIGlmICh0eXBlb2YgcGFzc3dvcmQgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgQXBwd3JpdGVFeGNlcHRpb24oJ01pc3NpbmcgcmVxdWlyZWQgcGFyYW1ldGVyOiBcInBhc3N3b3JkXCInKTtcbiAgICAgICAgfVxuXG5cbiAgICAgICAgaWYgKHR5cGVvZiBwYXNzd29yZCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHBheWxvYWRbJ3Bhc3N3b3JkJ10gPSBwYXNzd29yZDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0eXBlb2Ygb2xkUGFzc3dvcmQgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICBwYXlsb2FkWydvbGRQYXNzd29yZCddID0gb2xkUGFzc3dvcmQ7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy5jbGllbnQuY2FsbCgncGF0Y2gnLCBhcGlQYXRoLCB7XG4gICAgICAgICAgICAnY29udGVudC10eXBlJzogJ2FwcGxpY2F0aW9uL2pzb24nLFxuICAgICAgICB9LCBwYXlsb2FkKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBVcGRhdGUgcGhvbmVcbiAgICAgKlxuICAgICAqIFVwZGF0ZSB0aGUgY3VycmVudGx5IGxvZ2dlZCBpbiB1c2VyJ3MgcGhvbmUgbnVtYmVyLiBBZnRlciB1cGRhdGluZyB0aGVcbiAgICAgKiBwaG9uZSBudW1iZXIsIHRoZSBwaG9uZSB2ZXJpZmljYXRpb24gc3RhdHVzIHdpbGwgYmUgcmVzZXQuIEEgY29uZmlybWF0aW9uXG4gICAgICogU01TIGlzIG5vdCBzZW50IGF1dG9tYXRpY2FsbHksIGhvd2V2ZXIgeW91IGNhbiB1c2UgdGhlIFtQT1NUXG4gICAgICogL2FjY291bnQvdmVyaWZpY2F0aW9uL3Bob25lXShodHRwczovL2FwcHdyaXRlLmlvL2RvY3MvcmVmZXJlbmNlcy9jbG91ZC9jbGllbnQtd2ViL2FjY291bnQjY3JlYXRlUGhvbmVWZXJpZmljYXRpb24pXG4gICAgICogZW5kcG9pbnQgdG8gc2VuZCBhIGNvbmZpcm1hdGlvbiBTTVMuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gcGhvbmVcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gcGFzc3dvcmRcbiAgICAgKiBAdGhyb3dzIHtBcHB3cml0ZUV4Y2VwdGlvbn1cbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZX1cbiAgICAgKi9cbiAgICBhc3luYyB1cGRhdGVQaG9uZShwaG9uZSwgcGFzc3dvcmQpIHtcbiAgICAgICAgY29uc3QgYXBpUGF0aCA9ICcvYWNjb3VudC9waG9uZSc7XG4gICAgICAgIGxldCBwYXlsb2FkID0ge307XG4gICAgICAgIGlmICh0eXBlb2YgcGhvbmUgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgQXBwd3JpdGVFeGNlcHRpb24oJ01pc3NpbmcgcmVxdWlyZWQgcGFyYW1ldGVyOiBcInBob25lXCInKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0eXBlb2YgcGFzc3dvcmQgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgQXBwd3JpdGVFeGNlcHRpb24oJ01pc3NpbmcgcmVxdWlyZWQgcGFyYW1ldGVyOiBcInBhc3N3b3JkXCInKTtcbiAgICAgICAgfVxuXG5cbiAgICAgICAgaWYgKHR5cGVvZiBwaG9uZSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHBheWxvYWRbJ3Bob25lJ10gPSBwaG9uZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0eXBlb2YgcGFzc3dvcmQgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICBwYXlsb2FkWydwYXNzd29yZCddID0gcGFzc3dvcmQ7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy5jbGllbnQuY2FsbCgncGF0Y2gnLCBhcGlQYXRoLCB7XG4gICAgICAgICAgICAnY29udGVudC10eXBlJzogJ2FwcGxpY2F0aW9uL2pzb24nLFxuICAgICAgICB9LCBwYXlsb2FkKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZXQgYWNjb3VudCBwcmVmZXJlbmNlc1xuICAgICAqXG4gICAgICogR2V0IHRoZSBwcmVmZXJlbmNlcyBhcyBhIGtleS12YWx1ZSBvYmplY3QgZm9yIHRoZSBjdXJyZW50bHkgbG9nZ2VkIGluIHVzZXIuXG4gICAgICpcbiAgICAgKiBAdGhyb3dzIHtBcHB3cml0ZUV4Y2VwdGlvbn1cbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZX1cbiAgICAgKi9cbiAgICBhc3luYyBnZXRQcmVmcygpIHtcbiAgICAgICAgY29uc3QgYXBpUGF0aCA9ICcvYWNjb3VudC9wcmVmcyc7XG4gICAgICAgIGxldCBwYXlsb2FkID0ge307XG5cbiAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMuY2xpZW50LmNhbGwoJ2dldCcsIGFwaVBhdGgsIHtcbiAgICAgICAgICAgICdjb250ZW50LXR5cGUnOiAnYXBwbGljYXRpb24vanNvbicsXG4gICAgICAgIH0sIHBheWxvYWQpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFVwZGF0ZSBwcmVmZXJlbmNlc1xuICAgICAqXG4gICAgICogVXBkYXRlIGN1cnJlbnRseSBsb2dnZWQgaW4gdXNlciBhY2NvdW50IHByZWZlcmVuY2VzLiBUaGUgb2JqZWN0IHlvdSBwYXNzIGlzXG4gICAgICogc3RvcmVkIGFzIGlzLCBhbmQgcmVwbGFjZXMgYW55IHByZXZpb3VzIHZhbHVlLiBUaGUgbWF4aW11bSBhbGxvd2VkIHByZWZzXG4gICAgICogc2l6ZSBpcyA2NGtCIGFuZCB0aHJvd3MgZXJyb3IgaWYgZXhjZWVkZWQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gcHJlZnNcbiAgICAgKiBAdGhyb3dzIHtBcHB3cml0ZUV4Y2VwdGlvbn1cbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZX1cbiAgICAgKi9cbiAgICBhc3luYyB1cGRhdGVQcmVmcyhwcmVmcykge1xuICAgICAgICBjb25zdCBhcGlQYXRoID0gJy9hY2NvdW50L3ByZWZzJztcbiAgICAgICAgbGV0IHBheWxvYWQgPSB7fTtcbiAgICAgICAgaWYgKHR5cGVvZiBwcmVmcyA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBBcHB3cml0ZUV4Y2VwdGlvbignTWlzc2luZyByZXF1aXJlZCBwYXJhbWV0ZXI6IFwicHJlZnNcIicpO1xuICAgICAgICB9XG5cblxuICAgICAgICBpZiAodHlwZW9mIHByZWZzICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgcGF5bG9hZFsncHJlZnMnXSA9IHByZWZzO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMuY2xpZW50LmNhbGwoJ3BhdGNoJywgYXBpUGF0aCwge1xuICAgICAgICAgICAgJ2NvbnRlbnQtdHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJyxcbiAgICAgICAgfSwgcGF5bG9hZCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlIHBhc3N3b3JkIHJlY292ZXJ5XG4gICAgICpcbiAgICAgKiBTZW5kcyB0aGUgdXNlciBhbiBlbWFpbCB3aXRoIGEgdGVtcG9yYXJ5IHNlY3JldCBrZXkgZm9yIHBhc3N3b3JkIHJlc2V0LlxuICAgICAqIFdoZW4gdGhlIHVzZXIgY2xpY2tzIHRoZSBjb25maXJtYXRpb24gbGluayBoZSBpcyByZWRpcmVjdGVkIGJhY2sgdG8geW91clxuICAgICAqIGFwcCBwYXNzd29yZCByZXNldCBVUkwgd2l0aCB0aGUgc2VjcmV0IGtleSBhbmQgZW1haWwgYWRkcmVzcyB2YWx1ZXNcbiAgICAgKiBhdHRhY2hlZCB0byB0aGUgVVJMIHF1ZXJ5IHN0cmluZy4gVXNlIHRoZSBxdWVyeSBzdHJpbmcgcGFyYW1zIHRvIHN1Ym1pdCBhXG4gICAgICogcmVxdWVzdCB0byB0aGUgW1BVVFxuICAgICAqIC9hY2NvdW50L3JlY292ZXJ5XShodHRwczovL2FwcHdyaXRlLmlvL2RvY3MvcmVmZXJlbmNlcy9jbG91ZC9jbGllbnQtd2ViL2FjY291bnQjdXBkYXRlUmVjb3ZlcnkpXG4gICAgICogZW5kcG9pbnQgdG8gY29tcGxldGUgdGhlIHByb2Nlc3MuIFRoZSB2ZXJpZmljYXRpb24gbGluayBzZW50IHRvIHRoZSB1c2VyJ3NcbiAgICAgKiBlbWFpbCBhZGRyZXNzIGlzIHZhbGlkIGZvciAxIGhvdXIuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gZW1haWxcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gdXJsXG4gICAgICogQHRocm93cyB7QXBwd3JpdGVFeGNlcHRpb259XG4gICAgICogQHJldHVybnMge1Byb21pc2V9XG4gICAgICovXG4gICAgYXN5bmMgY3JlYXRlUmVjb3ZlcnkoZW1haWwsIHVybCkge1xuICAgICAgICBjb25zdCBhcGlQYXRoID0gJy9hY2NvdW50L3JlY292ZXJ5JztcbiAgICAgICAgbGV0IHBheWxvYWQgPSB7fTtcbiAgICAgICAgaWYgKHR5cGVvZiBlbWFpbCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBBcHB3cml0ZUV4Y2VwdGlvbignTWlzc2luZyByZXF1aXJlZCBwYXJhbWV0ZXI6IFwiZW1haWxcIicpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHR5cGVvZiB1cmwgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgQXBwd3JpdGVFeGNlcHRpb24oJ01pc3NpbmcgcmVxdWlyZWQgcGFyYW1ldGVyOiBcInVybFwiJyk7XG4gICAgICAgIH1cblxuXG4gICAgICAgIGlmICh0eXBlb2YgZW1haWwgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICBwYXlsb2FkWydlbWFpbCddID0gZW1haWw7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodHlwZW9mIHVybCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHBheWxvYWRbJ3VybCddID0gdXJsO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMuY2xpZW50LmNhbGwoJ3Bvc3QnLCBhcGlQYXRoLCB7XG4gICAgICAgICAgICAnY29udGVudC10eXBlJzogJ2FwcGxpY2F0aW9uL2pzb24nLFxuICAgICAgICB9LCBwYXlsb2FkKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGUgcGFzc3dvcmQgcmVjb3ZlcnkgKGNvbmZpcm1hdGlvbilcbiAgICAgKlxuICAgICAqIFVzZSB0aGlzIGVuZHBvaW50IHRvIGNvbXBsZXRlIHRoZSB1c2VyIGFjY291bnQgcGFzc3dvcmQgcmVzZXQuIEJvdGggdGhlXG4gICAgICogKip1c2VySWQqKiBhbmQgKipzZWNyZXQqKiBhcmd1bWVudHMgd2lsbCBiZSBwYXNzZWQgYXMgcXVlcnkgcGFyYW1ldGVycyB0b1xuICAgICAqIHRoZSByZWRpcmVjdCBVUkwgeW91IGhhdmUgcHJvdmlkZWQgd2hlbiBzZW5kaW5nIHlvdXIgcmVxdWVzdCB0byB0aGUgW1BPU1RcbiAgICAgKiAvYWNjb3VudC9yZWNvdmVyeV0oaHR0cHM6Ly9hcHB3cml0ZS5pby9kb2NzL3JlZmVyZW5jZXMvY2xvdWQvY2xpZW50LXdlYi9hY2NvdW50I2NyZWF0ZVJlY292ZXJ5KVxuICAgICAqIGVuZHBvaW50LlxuICAgICAqIFxuICAgICAqIFBsZWFzZSBub3RlIHRoYXQgaW4gb3JkZXIgdG8gYXZvaWQgYSBbUmVkaXJlY3RcbiAgICAgKiBBdHRhY2tdKGh0dHBzOi8vZ2l0aHViLmNvbS9PV0FTUC9DaGVhdFNoZWV0U2VyaWVzL2Jsb2IvbWFzdGVyL2NoZWF0c2hlZXRzL1VudmFsaWRhdGVkX1JlZGlyZWN0c19hbmRfRm9yd2FyZHNfQ2hlYXRfU2hlZXQubWQpXG4gICAgICogdGhlIG9ubHkgdmFsaWQgcmVkaXJlY3QgVVJMcyBhcmUgdGhlIG9uZXMgZnJvbSBkb21haW5zIHlvdSBoYXZlIHNldCB3aGVuXG4gICAgICogYWRkaW5nIHlvdXIgcGxhdGZvcm1zIGluIHRoZSBjb25zb2xlIGludGVyZmFjZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSB1c2VySWRcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gc2VjcmV0XG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHBhc3N3b3JkXG4gICAgICogQHRocm93cyB7QXBwd3JpdGVFeGNlcHRpb259XG4gICAgICogQHJldHVybnMge1Byb21pc2V9XG4gICAgICovXG4gICAgYXN5bmMgdXBkYXRlUmVjb3ZlcnkodXNlcklkLCBzZWNyZXQsIHBhc3N3b3JkKSB7XG4gICAgICAgIGNvbnN0IGFwaVBhdGggPSAnL2FjY291bnQvcmVjb3ZlcnknO1xuICAgICAgICBsZXQgcGF5bG9hZCA9IHt9O1xuICAgICAgICBpZiAodHlwZW9mIHVzZXJJZCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBBcHB3cml0ZUV4Y2VwdGlvbignTWlzc2luZyByZXF1aXJlZCBwYXJhbWV0ZXI6IFwidXNlcklkXCInKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0eXBlb2Ygc2VjcmV0ID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEFwcHdyaXRlRXhjZXB0aW9uKCdNaXNzaW5nIHJlcXVpcmVkIHBhcmFtZXRlcjogXCJzZWNyZXRcIicpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHR5cGVvZiBwYXNzd29yZCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBBcHB3cml0ZUV4Y2VwdGlvbignTWlzc2luZyByZXF1aXJlZCBwYXJhbWV0ZXI6IFwicGFzc3dvcmRcIicpO1xuICAgICAgICB9XG5cblxuICAgICAgICBpZiAodHlwZW9mIHVzZXJJZCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHBheWxvYWRbJ3VzZXJJZCddID0gdXNlcklkO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHR5cGVvZiBzZWNyZXQgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICBwYXlsb2FkWydzZWNyZXQnXSA9IHNlY3JldDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0eXBlb2YgcGFzc3dvcmQgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICBwYXlsb2FkWydwYXNzd29yZCddID0gcGFzc3dvcmQ7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy5jbGllbnQuY2FsbCgncHV0JywgYXBpUGF0aCwge1xuICAgICAgICAgICAgJ2NvbnRlbnQtdHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJyxcbiAgICAgICAgfSwgcGF5bG9hZCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogTGlzdCBzZXNzaW9uc1xuICAgICAqXG4gICAgICogR2V0IHRoZSBsaXN0IG9mIGFjdGl2ZSBzZXNzaW9ucyBhY3Jvc3MgZGlmZmVyZW50IGRldmljZXMgZm9yIHRoZSBjdXJyZW50bHlcbiAgICAgKiBsb2dnZWQgaW4gdXNlci5cbiAgICAgKlxuICAgICAqIEB0aHJvd3Mge0FwcHdyaXRlRXhjZXB0aW9ufVxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlfVxuICAgICAqL1xuICAgIGFzeW5jIGxpc3RTZXNzaW9ucygpIHtcbiAgICAgICAgY29uc3QgYXBpUGF0aCA9ICcvYWNjb3VudC9zZXNzaW9ucyc7XG4gICAgICAgIGxldCBwYXlsb2FkID0ge307XG5cbiAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMuY2xpZW50LmNhbGwoJ2dldCcsIGFwaVBhdGgsIHtcbiAgICAgICAgICAgICdjb250ZW50LXR5cGUnOiAnYXBwbGljYXRpb24vanNvbicsXG4gICAgICAgIH0sIHBheWxvYWQpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIERlbGV0ZSBzZXNzaW9uc1xuICAgICAqXG4gICAgICogRGVsZXRlIGFsbCBzZXNzaW9ucyBmcm9tIHRoZSB1c2VyIGFjY291bnQgYW5kIHJlbW92ZSBhbnkgc2Vzc2lvbnMgY29va2llc1xuICAgICAqIGZyb20gdGhlIGVuZCBjbGllbnQuXG4gICAgICpcbiAgICAgKiBAdGhyb3dzIHtBcHB3cml0ZUV4Y2VwdGlvbn1cbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZX1cbiAgICAgKi9cbiAgICBhc3luYyBkZWxldGVTZXNzaW9ucygpIHtcbiAgICAgICAgY29uc3QgYXBpUGF0aCA9ICcvYWNjb3VudC9zZXNzaW9ucyc7XG4gICAgICAgIGxldCBwYXlsb2FkID0ge307XG5cbiAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMuY2xpZW50LmNhbGwoJ2RlbGV0ZScsIGFwaVBhdGgsIHtcbiAgICAgICAgICAgICdjb250ZW50LXR5cGUnOiAnYXBwbGljYXRpb24vanNvbicsXG4gICAgICAgIH0sIHBheWxvYWQpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZSBhbm9ueW1vdXMgc2Vzc2lvblxuICAgICAqXG4gICAgICogVXNlIHRoaXMgZW5kcG9pbnQgdG8gYWxsb3cgYSBuZXcgdXNlciB0byByZWdpc3RlciBhbiBhbm9ueW1vdXMgYWNjb3VudCBpblxuICAgICAqIHlvdXIgcHJvamVjdC4gVGhpcyByb3V0ZSB3aWxsIGFsc28gY3JlYXRlIGEgbmV3IHNlc3Npb24gZm9yIHRoZSB1c2VyLiBUb1xuICAgICAqIGFsbG93IHRoZSBuZXcgdXNlciB0byBjb252ZXJ0IGFuIGFub255bW91cyBhY2NvdW50IHRvIGEgbm9ybWFsIGFjY291bnQsIHlvdVxuICAgICAqIG5lZWQgdG8gdXBkYXRlIGl0cyBbZW1haWwgYW5kXG4gICAgICogcGFzc3dvcmRdKGh0dHBzOi8vYXBwd3JpdGUuaW8vZG9jcy9yZWZlcmVuY2VzL2Nsb3VkL2NsaWVudC13ZWIvYWNjb3VudCN1cGRhdGVFbWFpbClcbiAgICAgKiBvciBjcmVhdGUgYW4gW09BdXRoMlxuICAgICAqIHNlc3Npb25dKGh0dHBzOi8vYXBwd3JpdGUuaW8vZG9jcy9yZWZlcmVuY2VzL2Nsb3VkL2NsaWVudC13ZWIvYWNjb3VudCNDcmVhdGVPQXV0aDJTZXNzaW9uKS5cbiAgICAgKlxuICAgICAqIEB0aHJvd3Mge0FwcHdyaXRlRXhjZXB0aW9ufVxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlfVxuICAgICAqL1xuICAgIGFzeW5jIGNyZWF0ZUFub255bW91c1Nlc3Npb24oKSB7XG4gICAgICAgIGNvbnN0IGFwaVBhdGggPSAnL2FjY291bnQvc2Vzc2lvbnMvYW5vbnltb3VzJztcbiAgICAgICAgbGV0IHBheWxvYWQgPSB7fTtcblxuICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy5jbGllbnQuY2FsbCgncG9zdCcsIGFwaVBhdGgsIHtcbiAgICAgICAgICAgICdjb250ZW50LXR5cGUnOiAnYXBwbGljYXRpb24vanNvbicsXG4gICAgICAgIH0sIHBheWxvYWQpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZSBlbWFpbCBwYXNzd29yZCBzZXNzaW9uXG4gICAgICpcbiAgICAgKiBBbGxvdyB0aGUgdXNlciB0byBsb2dpbiBpbnRvIHRoZWlyIGFjY291bnQgYnkgcHJvdmlkaW5nIGEgdmFsaWQgZW1haWwgYW5kXG4gICAgICogcGFzc3dvcmQgY29tYmluYXRpb24uIFRoaXMgcm91dGUgd2lsbCBjcmVhdGUgYSBuZXcgc2Vzc2lvbiBmb3IgdGhlIHVzZXIuXG4gICAgICogXG4gICAgICogQSB1c2VyIGlzIGxpbWl0ZWQgdG8gMTAgYWN0aXZlIHNlc3Npb25zIGF0IGEgdGltZSBieSBkZWZhdWx0LiBbTGVhcm4gbW9yZVxuICAgICAqIGFib3V0IHNlc3Npb25cbiAgICAgKiBsaW1pdHNdKGh0dHBzOi8vYXBwd3JpdGUuaW8vZG9jcy9hdXRoZW50aWNhdGlvbi1zZWN1cml0eSNsaW1pdHMpLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGVtYWlsXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHBhc3N3b3JkXG4gICAgICogQHRocm93cyB7QXBwd3JpdGVFeGNlcHRpb259XG4gICAgICogQHJldHVybnMge1Byb21pc2V9XG4gICAgICovXG4gICAgYXN5bmMgY3JlYXRlRW1haWxQYXNzd29yZFNlc3Npb24oZW1haWwsIHBhc3N3b3JkKSB7XG4gICAgICAgIGNvbnN0IGFwaVBhdGggPSAnL2FjY291bnQvc2Vzc2lvbnMvZW1haWwnO1xuICAgICAgICBsZXQgcGF5bG9hZCA9IHt9O1xuICAgICAgICBpZiAodHlwZW9mIGVtYWlsID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEFwcHdyaXRlRXhjZXB0aW9uKCdNaXNzaW5nIHJlcXVpcmVkIHBhcmFtZXRlcjogXCJlbWFpbFwiJyk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodHlwZW9mIHBhc3N3b3JkID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEFwcHdyaXRlRXhjZXB0aW9uKCdNaXNzaW5nIHJlcXVpcmVkIHBhcmFtZXRlcjogXCJwYXNzd29yZFwiJyk7XG4gICAgICAgIH1cblxuXG4gICAgICAgIGlmICh0eXBlb2YgZW1haWwgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICBwYXlsb2FkWydlbWFpbCddID0gZW1haWw7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodHlwZW9mIHBhc3N3b3JkICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgcGF5bG9hZFsncGFzc3dvcmQnXSA9IHBhc3N3b3JkO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMuY2xpZW50LmNhbGwoJ3Bvc3QnLCBhcGlQYXRoLCB7XG4gICAgICAgICAgICAnY29udGVudC10eXBlJzogJ2FwcGxpY2F0aW9uL2pzb24nLFxuICAgICAgICB9LCBwYXlsb2FkKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBVcGRhdGUgbWFnaWMgVVJMIHNlc3Npb25cbiAgICAgKlxuICAgICAqIFVzZSB0aGlzIGVuZHBvaW50IHRvIGNyZWF0ZSBhIHNlc3Npb24gZnJvbSB0b2tlbi4gUHJvdmlkZSB0aGUgKip1c2VySWQqKlxuICAgICAqIGFuZCAqKnNlY3JldCoqIHBhcmFtZXRlcnMgZnJvbSB0aGUgc3VjY2Vzc2Z1bCByZXNwb25zZSBvZiBhdXRoZW50aWNhdGlvblxuICAgICAqIGZsb3dzIGluaXRpYXRlZCBieSB0b2tlbiBjcmVhdGlvbi4gRm9yIGV4YW1wbGUsIG1hZ2ljIFVSTCBhbmQgcGhvbmUgbG9naW4uXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gdXNlcklkXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHNlY3JldFxuICAgICAqIEB0aHJvd3Mge0FwcHdyaXRlRXhjZXB0aW9ufVxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlfVxuICAgICAqL1xuICAgIGFzeW5jIHVwZGF0ZU1hZ2ljVVJMU2Vzc2lvbih1c2VySWQsIHNlY3JldCkge1xuICAgICAgICBjb25zdCBhcGlQYXRoID0gJy9hY2NvdW50L3Nlc3Npb25zL21hZ2ljLXVybCc7XG4gICAgICAgIGxldCBwYXlsb2FkID0ge307XG4gICAgICAgIGlmICh0eXBlb2YgdXNlcklkID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEFwcHdyaXRlRXhjZXB0aW9uKCdNaXNzaW5nIHJlcXVpcmVkIHBhcmFtZXRlcjogXCJ1c2VySWRcIicpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHR5cGVvZiBzZWNyZXQgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgQXBwd3JpdGVFeGNlcHRpb24oJ01pc3NpbmcgcmVxdWlyZWQgcGFyYW1ldGVyOiBcInNlY3JldFwiJyk7XG4gICAgICAgIH1cblxuXG4gICAgICAgIGlmICh0eXBlb2YgdXNlcklkICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgcGF5bG9hZFsndXNlcklkJ10gPSB1c2VySWQ7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodHlwZW9mIHNlY3JldCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHBheWxvYWRbJ3NlY3JldCddID0gc2VjcmV0O1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMuY2xpZW50LmNhbGwoJ3B1dCcsIGFwaVBhdGgsIHtcbiAgICAgICAgICAgICdjb250ZW50LXR5cGUnOiAnYXBwbGljYXRpb24vanNvbicsXG4gICAgICAgIH0sIHBheWxvYWQpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFVwZGF0ZSBwaG9uZSBzZXNzaW9uXG4gICAgICpcbiAgICAgKiBVc2UgdGhpcyBlbmRwb2ludCB0byBjcmVhdGUgYSBzZXNzaW9uIGZyb20gdG9rZW4uIFByb3ZpZGUgdGhlICoqdXNlcklkKipcbiAgICAgKiBhbmQgKipzZWNyZXQqKiBwYXJhbWV0ZXJzIGZyb20gdGhlIHN1Y2Nlc3NmdWwgcmVzcG9uc2Ugb2YgYXV0aGVudGljYXRpb25cbiAgICAgKiBmbG93cyBpbml0aWF0ZWQgYnkgdG9rZW4gY3JlYXRpb24uIEZvciBleGFtcGxlLCBtYWdpYyBVUkwgYW5kIHBob25lIGxvZ2luLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHVzZXJJZFxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBzZWNyZXRcbiAgICAgKiBAdGhyb3dzIHtBcHB3cml0ZUV4Y2VwdGlvbn1cbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZX1cbiAgICAgKi9cbiAgICBhc3luYyB1cGRhdGVQaG9uZVNlc3Npb24odXNlcklkLCBzZWNyZXQpIHtcbiAgICAgICAgY29uc3QgYXBpUGF0aCA9ICcvYWNjb3VudC9zZXNzaW9ucy9waG9uZSc7XG4gICAgICAgIGxldCBwYXlsb2FkID0ge307XG4gICAgICAgIGlmICh0eXBlb2YgdXNlcklkID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEFwcHdyaXRlRXhjZXB0aW9uKCdNaXNzaW5nIHJlcXVpcmVkIHBhcmFtZXRlcjogXCJ1c2VySWRcIicpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHR5cGVvZiBzZWNyZXQgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgQXBwd3JpdGVFeGNlcHRpb24oJ01pc3NpbmcgcmVxdWlyZWQgcGFyYW1ldGVyOiBcInNlY3JldFwiJyk7XG4gICAgICAgIH1cblxuXG4gICAgICAgIGlmICh0eXBlb2YgdXNlcklkICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgcGF5bG9hZFsndXNlcklkJ10gPSB1c2VySWQ7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodHlwZW9mIHNlY3JldCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHBheWxvYWRbJ3NlY3JldCddID0gc2VjcmV0O1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMuY2xpZW50LmNhbGwoJ3B1dCcsIGFwaVBhdGgsIHtcbiAgICAgICAgICAgICdjb250ZW50LXR5cGUnOiAnYXBwbGljYXRpb24vanNvbicsXG4gICAgICAgIH0sIHBheWxvYWQpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZSBzZXNzaW9uXG4gICAgICpcbiAgICAgKiBVc2UgdGhpcyBlbmRwb2ludCB0byBjcmVhdGUgYSBzZXNzaW9uIGZyb20gdG9rZW4uIFByb3ZpZGUgdGhlICoqdXNlcklkKipcbiAgICAgKiBhbmQgKipzZWNyZXQqKiBwYXJhbWV0ZXJzIGZyb20gdGhlIHN1Y2Nlc3NmdWwgcmVzcG9uc2Ugb2YgYXV0aGVudGljYXRpb25cbiAgICAgKiBmbG93cyBpbml0aWF0ZWQgYnkgdG9rZW4gY3JlYXRpb24uIEZvciBleGFtcGxlLCBtYWdpYyBVUkwgYW5kIHBob25lIGxvZ2luLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHVzZXJJZFxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBzZWNyZXRcbiAgICAgKiBAdGhyb3dzIHtBcHB3cml0ZUV4Y2VwdGlvbn1cbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZX1cbiAgICAgKi9cbiAgICBhc3luYyBjcmVhdGVTZXNzaW9uKHVzZXJJZCwgc2VjcmV0KSB7XG4gICAgICAgIGNvbnN0IGFwaVBhdGggPSAnL2FjY291bnQvc2Vzc2lvbnMvdG9rZW4nO1xuICAgICAgICBsZXQgcGF5bG9hZCA9IHt9O1xuICAgICAgICBpZiAodHlwZW9mIHVzZXJJZCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBBcHB3cml0ZUV4Y2VwdGlvbignTWlzc2luZyByZXF1aXJlZCBwYXJhbWV0ZXI6IFwidXNlcklkXCInKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0eXBlb2Ygc2VjcmV0ID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEFwcHdyaXRlRXhjZXB0aW9uKCdNaXNzaW5nIHJlcXVpcmVkIHBhcmFtZXRlcjogXCJzZWNyZXRcIicpO1xuICAgICAgICB9XG5cblxuICAgICAgICBpZiAodHlwZW9mIHVzZXJJZCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHBheWxvYWRbJ3VzZXJJZCddID0gdXNlcklkO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHR5cGVvZiBzZWNyZXQgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICBwYXlsb2FkWydzZWNyZXQnXSA9IHNlY3JldDtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBhd2FpdCB0aGlzLmNsaWVudC5jYWxsKCdwb3N0JywgYXBpUGF0aCwge1xuICAgICAgICAgICAgJ2NvbnRlbnQtdHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJyxcbiAgICAgICAgfSwgcGF5bG9hZCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2V0IHNlc3Npb25cbiAgICAgKlxuICAgICAqIFVzZSB0aGlzIGVuZHBvaW50IHRvIGdldCBhIGxvZ2dlZCBpbiB1c2VyJ3Mgc2Vzc2lvbiB1c2luZyBhIFNlc3Npb24gSUQuXG4gICAgICogSW5wdXR0aW5nICdjdXJyZW50JyB3aWxsIHJldHVybiB0aGUgY3VycmVudCBzZXNzaW9uIGJlaW5nIHVzZWQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gc2Vzc2lvbklkXG4gICAgICogQHRocm93cyB7QXBwd3JpdGVFeGNlcHRpb259XG4gICAgICogQHJldHVybnMge1Byb21pc2V9XG4gICAgICovXG4gICAgYXN5bmMgZ2V0U2Vzc2lvbihzZXNzaW9uSWQpIHtcbiAgICAgICAgY29uc3QgYXBpUGF0aCA9ICcvYWNjb3VudC9zZXNzaW9ucy97c2Vzc2lvbklkfScucmVwbGFjZSgne3Nlc3Npb25JZH0nLCBzZXNzaW9uSWQpO1xuICAgICAgICBsZXQgcGF5bG9hZCA9IHt9O1xuICAgICAgICBpZiAodHlwZW9mIHNlc3Npb25JZCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBBcHB3cml0ZUV4Y2VwdGlvbignTWlzc2luZyByZXF1aXJlZCBwYXJhbWV0ZXI6IFwic2Vzc2lvbklkXCInKTtcbiAgICAgICAgfVxuXG5cbiAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMuY2xpZW50LmNhbGwoJ2dldCcsIGFwaVBhdGgsIHtcbiAgICAgICAgICAgICdjb250ZW50LXR5cGUnOiAnYXBwbGljYXRpb24vanNvbicsXG4gICAgICAgIH0sIHBheWxvYWQpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFVwZGF0ZSBzZXNzaW9uXG4gICAgICpcbiAgICAgKiBVc2UgdGhpcyBlbmRwb2ludCB0byBleHRlbmQgYSBzZXNzaW9uJ3MgbGVuZ3RoLiBFeHRlbmRpbmcgYSBzZXNzaW9uIGlzXG4gICAgICogdXNlZnVsIHdoZW4gc2Vzc2lvbiBleHBpcnkgaXMgc2hvcnQuIElmIHRoZSBzZXNzaW9uIHdhcyBjcmVhdGVkIHVzaW5nIGFuXG4gICAgICogT0F1dGggcHJvdmlkZXIsIHRoaXMgZW5kcG9pbnQgcmVmcmVzaGVzIHRoZSBhY2Nlc3MgdG9rZW4gZnJvbSB0aGUgcHJvdmlkZXIuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gc2Vzc2lvbklkXG4gICAgICogQHRocm93cyB7QXBwd3JpdGVFeGNlcHRpb259XG4gICAgICogQHJldHVybnMge1Byb21pc2V9XG4gICAgICovXG4gICAgYXN5bmMgdXBkYXRlU2Vzc2lvbihzZXNzaW9uSWQpIHtcbiAgICAgICAgY29uc3QgYXBpUGF0aCA9ICcvYWNjb3VudC9zZXNzaW9ucy97c2Vzc2lvbklkfScucmVwbGFjZSgne3Nlc3Npb25JZH0nLCBzZXNzaW9uSWQpO1xuICAgICAgICBsZXQgcGF5bG9hZCA9IHt9O1xuICAgICAgICBpZiAodHlwZW9mIHNlc3Npb25JZCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBBcHB3cml0ZUV4Y2VwdGlvbignTWlzc2luZyByZXF1aXJlZCBwYXJhbWV0ZXI6IFwic2Vzc2lvbklkXCInKTtcbiAgICAgICAgfVxuXG5cbiAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMuY2xpZW50LmNhbGwoJ3BhdGNoJywgYXBpUGF0aCwge1xuICAgICAgICAgICAgJ2NvbnRlbnQtdHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJyxcbiAgICAgICAgfSwgcGF5bG9hZCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRGVsZXRlIHNlc3Npb25cbiAgICAgKlxuICAgICAqIExvZ291dCB0aGUgdXNlci4gVXNlICdjdXJyZW50JyBhcyB0aGUgc2Vzc2lvbiBJRCB0byBsb2dvdXQgb24gdGhpcyBkZXZpY2UsXG4gICAgICogdXNlIGEgc2Vzc2lvbiBJRCB0byBsb2dvdXQgb24gYW5vdGhlciBkZXZpY2UuIElmIHlvdSdyZSBsb29raW5nIHRvIGxvZ291dFxuICAgICAqIHRoZSB1c2VyIG9uIGFsbCBkZXZpY2VzLCB1c2UgW0RlbGV0ZVxuICAgICAqIFNlc3Npb25zXShodHRwczovL2FwcHdyaXRlLmlvL2RvY3MvcmVmZXJlbmNlcy9jbG91ZC9jbGllbnQtd2ViL2FjY291bnQjZGVsZXRlU2Vzc2lvbnMpXG4gICAgICogaW5zdGVhZC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBzZXNzaW9uSWRcbiAgICAgKiBAdGhyb3dzIHtBcHB3cml0ZUV4Y2VwdGlvbn1cbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZX1cbiAgICAgKi9cbiAgICBhc3luYyBkZWxldGVTZXNzaW9uKHNlc3Npb25JZCkge1xuICAgICAgICBjb25zdCBhcGlQYXRoID0gJy9hY2NvdW50L3Nlc3Npb25zL3tzZXNzaW9uSWR9Jy5yZXBsYWNlKCd7c2Vzc2lvbklkfScsIHNlc3Npb25JZCk7XG4gICAgICAgIGxldCBwYXlsb2FkID0ge307XG4gICAgICAgIGlmICh0eXBlb2Ygc2Vzc2lvbklkID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEFwcHdyaXRlRXhjZXB0aW9uKCdNaXNzaW5nIHJlcXVpcmVkIHBhcmFtZXRlcjogXCJzZXNzaW9uSWRcIicpO1xuICAgICAgICB9XG5cblxuICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy5jbGllbnQuY2FsbCgnZGVsZXRlJywgYXBpUGF0aCwge1xuICAgICAgICAgICAgJ2NvbnRlbnQtdHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJyxcbiAgICAgICAgfSwgcGF5bG9hZCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVXBkYXRlIHN0YXR1c1xuICAgICAqXG4gICAgICogQmxvY2sgdGhlIGN1cnJlbnRseSBsb2dnZWQgaW4gdXNlciBhY2NvdW50LiBCZWhpbmQgdGhlIHNjZW5lLCB0aGUgdXNlclxuICAgICAqIHJlY29yZCBpcyBub3QgZGVsZXRlZCBidXQgcGVybWFuZW50bHkgYmxvY2tlZCBmcm9tIGFueSBhY2Nlc3MuIFRvXG4gICAgICogY29tcGxldGVseSBkZWxldGUgYSB1c2VyLCB1c2UgdGhlIFVzZXJzIEFQSSBpbnN0ZWFkLlxuICAgICAqXG4gICAgICogQHRocm93cyB7QXBwd3JpdGVFeGNlcHRpb259XG4gICAgICogQHJldHVybnMge1Byb21pc2V9XG4gICAgICovXG4gICAgYXN5bmMgdXBkYXRlU3RhdHVzKCkge1xuICAgICAgICBjb25zdCBhcGlQYXRoID0gJy9hY2NvdW50L3N0YXR1cyc7XG4gICAgICAgIGxldCBwYXlsb2FkID0ge307XG5cbiAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMuY2xpZW50LmNhbGwoJ3BhdGNoJywgYXBpUGF0aCwge1xuICAgICAgICAgICAgJ2NvbnRlbnQtdHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJyxcbiAgICAgICAgfSwgcGF5bG9hZCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlIGVtYWlsIHRva2VuIChPVFApXG4gICAgICpcbiAgICAgKiBTZW5kcyB0aGUgdXNlciBhbiBlbWFpbCB3aXRoIGEgc2VjcmV0IGtleSBmb3IgY3JlYXRpbmcgYSBzZXNzaW9uLiBJZiB0aGVcbiAgICAgKiBwcm92aWRlZCB1c2VyIElEIGhhcyBub3QgYmUgcmVnaXN0ZXJlZCwgYSBuZXcgdXNlciB3aWxsIGJlIGNyZWF0ZWQuIFVzZSB0aGVcbiAgICAgKiByZXR1cm5lZCB1c2VyIElEIGFuZCBzZWNyZXQgYW5kIHN1Ym1pdCBhIHJlcXVlc3QgdG8gdGhlIFtQT1NUXG4gICAgICogL3YxL2FjY291bnQvc2Vzc2lvbnMvdG9rZW5dKGh0dHBzOi8vYXBwd3JpdGUuaW8vZG9jcy9yZWZlcmVuY2VzL2Nsb3VkL2NsaWVudC13ZWIvYWNjb3VudCNjcmVhdGVTZXNzaW9uKVxuICAgICAqIGVuZHBvaW50IHRvIGNvbXBsZXRlIHRoZSBsb2dpbiBwcm9jZXNzLiBUaGUgc2VjcmV0IHNlbnQgdG8gdGhlIHVzZXIncyBlbWFpbFxuICAgICAqIGlzIHZhbGlkIGZvciAxNSBtaW51dGVzLlxuICAgICAqIFxuICAgICAqIEEgdXNlciBpcyBsaW1pdGVkIHRvIDEwIGFjdGl2ZSBzZXNzaW9ucyBhdCBhIHRpbWUgYnkgZGVmYXVsdC4gW0xlYXJuIG1vcmVcbiAgICAgKiBhYm91dCBzZXNzaW9uXG4gICAgICogbGltaXRzXShodHRwczovL2FwcHdyaXRlLmlvL2RvY3MvYXV0aGVudGljYXRpb24tc2VjdXJpdHkjbGltaXRzKS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSB1c2VySWRcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gZW1haWxcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IHBocmFzZVxuICAgICAqIEB0aHJvd3Mge0FwcHdyaXRlRXhjZXB0aW9ufVxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlfVxuICAgICAqL1xuICAgIGFzeW5jIGNyZWF0ZUVtYWlsVG9rZW4odXNlcklkLCBlbWFpbCwgcGhyYXNlKSB7XG4gICAgICAgIGNvbnN0IGFwaVBhdGggPSAnL2FjY291bnQvdG9rZW5zL2VtYWlsJztcbiAgICAgICAgbGV0IHBheWxvYWQgPSB7fTtcbiAgICAgICAgaWYgKHR5cGVvZiB1c2VySWQgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgQXBwd3JpdGVFeGNlcHRpb24oJ01pc3NpbmcgcmVxdWlyZWQgcGFyYW1ldGVyOiBcInVzZXJJZFwiJyk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodHlwZW9mIGVtYWlsID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEFwcHdyaXRlRXhjZXB0aW9uKCdNaXNzaW5nIHJlcXVpcmVkIHBhcmFtZXRlcjogXCJlbWFpbFwiJyk7XG4gICAgICAgIH1cblxuXG4gICAgICAgIGlmICh0eXBlb2YgdXNlcklkICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgcGF5bG9hZFsndXNlcklkJ10gPSB1c2VySWQ7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodHlwZW9mIGVtYWlsICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgcGF5bG9hZFsnZW1haWwnXSA9IGVtYWlsO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHR5cGVvZiBwaHJhc2UgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICBwYXlsb2FkWydwaHJhc2UnXSA9IHBocmFzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBhd2FpdCB0aGlzLmNsaWVudC5jYWxsKCdwb3N0JywgYXBpUGF0aCwge1xuICAgICAgICAgICAgJ2NvbnRlbnQtdHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJyxcbiAgICAgICAgfSwgcGF5bG9hZCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlIG1hZ2ljIFVSTCB0b2tlblxuICAgICAqXG4gICAgICogU2VuZHMgdGhlIHVzZXIgYW4gZW1haWwgd2l0aCBhIHNlY3JldCBrZXkgZm9yIGNyZWF0aW5nIGEgc2Vzc2lvbi4gSWYgdGhlXG4gICAgICogcHJvdmlkZWQgdXNlciBJRCBoYXMgbm90IGJlZW4gcmVnaXN0ZXJlZCwgYSBuZXcgdXNlciB3aWxsIGJlIGNyZWF0ZWQuIFdoZW5cbiAgICAgKiB0aGUgdXNlciBjbGlja3MgdGhlIGxpbmsgaW4gdGhlIGVtYWlsLCB0aGUgdXNlciBpcyByZWRpcmVjdGVkIGJhY2sgdG8gdGhlXG4gICAgICogVVJMIHlvdSBwcm92aWRlZCB3aXRoIHRoZSBzZWNyZXQga2V5IGFuZCB1c2VySWQgdmFsdWVzIGF0dGFjaGVkIHRvIHRoZSBVUkxcbiAgICAgKiBxdWVyeSBzdHJpbmcuIFVzZSB0aGUgcXVlcnkgc3RyaW5nIHBhcmFtZXRlcnMgdG8gc3VibWl0IGEgcmVxdWVzdCB0byB0aGVcbiAgICAgKiBbUE9TVFxuICAgICAqIC92MS9hY2NvdW50L3Nlc3Npb25zL3Rva2VuXShodHRwczovL2FwcHdyaXRlLmlvL2RvY3MvcmVmZXJlbmNlcy9jbG91ZC9jbGllbnQtd2ViL2FjY291bnQjY3JlYXRlU2Vzc2lvbilcbiAgICAgKiBlbmRwb2ludCB0byBjb21wbGV0ZSB0aGUgbG9naW4gcHJvY2Vzcy4gVGhlIGxpbmsgc2VudCB0byB0aGUgdXNlcidzIGVtYWlsXG4gICAgICogYWRkcmVzcyBpcyB2YWxpZCBmb3IgMSBob3VyLiBJZiB5b3UgYXJlIG9uIGEgbW9iaWxlIGRldmljZSB5b3UgY2FuIGxlYXZlXG4gICAgICogdGhlIFVSTCBwYXJhbWV0ZXIgZW1wdHksIHNvIHRoYXQgdGhlIGxvZ2luIGNvbXBsZXRpb24gd2lsbCBiZSBoYW5kbGVkIGJ5XG4gICAgICogeW91ciBBcHB3cml0ZSBpbnN0YW5jZSBieSBkZWZhdWx0LlxuICAgICAqIFxuICAgICAqIEEgdXNlciBpcyBsaW1pdGVkIHRvIDEwIGFjdGl2ZSBzZXNzaW9ucyBhdCBhIHRpbWUgYnkgZGVmYXVsdC4gW0xlYXJuIG1vcmVcbiAgICAgKiBhYm91dCBzZXNzaW9uXG4gICAgICogbGltaXRzXShodHRwczovL2FwcHdyaXRlLmlvL2RvY3MvYXV0aGVudGljYXRpb24tc2VjdXJpdHkjbGltaXRzKS5cbiAgICAgKiBcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSB1c2VySWRcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gZW1haWxcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gdXJsXG4gICAgICogQHBhcmFtIHtib29sZWFufSBwaHJhc2VcbiAgICAgKiBAdGhyb3dzIHtBcHB3cml0ZUV4Y2VwdGlvbn1cbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZX1cbiAgICAgKi9cbiAgICBhc3luYyBjcmVhdGVNYWdpY1VSTFRva2VuKHVzZXJJZCwgZW1haWwsIHVybCwgcGhyYXNlKSB7XG4gICAgICAgIGNvbnN0IGFwaVBhdGggPSAnL2FjY291bnQvdG9rZW5zL21hZ2ljLXVybCc7XG4gICAgICAgIGxldCBwYXlsb2FkID0ge307XG4gICAgICAgIGlmICh0eXBlb2YgdXNlcklkID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEFwcHdyaXRlRXhjZXB0aW9uKCdNaXNzaW5nIHJlcXVpcmVkIHBhcmFtZXRlcjogXCJ1c2VySWRcIicpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHR5cGVvZiBlbWFpbCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBBcHB3cml0ZUV4Y2VwdGlvbignTWlzc2luZyByZXF1aXJlZCBwYXJhbWV0ZXI6IFwiZW1haWxcIicpO1xuICAgICAgICB9XG5cblxuICAgICAgICBpZiAodHlwZW9mIHVzZXJJZCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHBheWxvYWRbJ3VzZXJJZCddID0gdXNlcklkO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHR5cGVvZiBlbWFpbCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHBheWxvYWRbJ2VtYWlsJ10gPSBlbWFpbDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0eXBlb2YgdXJsICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgcGF5bG9hZFsndXJsJ10gPSB1cmw7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodHlwZW9mIHBocmFzZSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHBheWxvYWRbJ3BocmFzZSddID0gcGhyYXNlO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMuY2xpZW50LmNhbGwoJ3Bvc3QnLCBhcGlQYXRoLCB7XG4gICAgICAgICAgICAnY29udGVudC10eXBlJzogJ2FwcGxpY2F0aW9uL2pzb24nLFxuICAgICAgICB9LCBwYXlsb2FkKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGUgT0F1dGgyIHRva2VuXG4gICAgICpcbiAgICAgKiBBbGxvdyB0aGUgdXNlciB0byBsb2dpbiB0byB0aGVpciBhY2NvdW50IHVzaW5nIHRoZSBPQXV0aDIgcHJvdmlkZXIgb2YgdGhlaXJcbiAgICAgKiBjaG9pY2UuIEVhY2ggT0F1dGgyIHByb3ZpZGVyIHNob3VsZCBiZSBlbmFibGVkIGZyb20gdGhlIEFwcHdyaXRlIGNvbnNvbGVcbiAgICAgKiBmaXJzdC4gVXNlIHRoZSBzdWNjZXNzIGFuZCBmYWlsdXJlIGFyZ3VtZW50cyB0byBwcm92aWRlIGEgcmVkaXJlY3QgVVJMJ3NcbiAgICAgKiBiYWNrIHRvIHlvdXIgYXBwIHdoZW4gbG9naW4gaXMgY29tcGxldGVkLiBcbiAgICAgKiBcbiAgICAgKiBJZiBhdXRoZW50aWNhdGlvbiBzdWNjZWVkcywgYHVzZXJJZGAgYW5kIGBzZWNyZXRgIG9mIGEgdG9rZW4gd2lsbCBiZVxuICAgICAqIGFwcGVuZGVkIHRvIHRoZSBzdWNjZXNzIFVSTCBhcyBxdWVyeSBwYXJhbWV0ZXJzLiBUaGVzZSBjYW4gYmUgdXNlZCB0b1xuICAgICAqIGNyZWF0ZSBhIG5ldyBzZXNzaW9uIHVzaW5nIHRoZSBbQ3JlYXRlXG4gICAgICogc2Vzc2lvbl0oaHR0cHM6Ly9hcHB3cml0ZS5pby9kb2NzL3JlZmVyZW5jZXMvY2xvdWQvY2xpZW50LXdlYi9hY2NvdW50I2NyZWF0ZVNlc3Npb24pXG4gICAgICogZW5kcG9pbnQuXG4gICAgICogXG4gICAgICogQSB1c2VyIGlzIGxpbWl0ZWQgdG8gMTAgYWN0aXZlIHNlc3Npb25zIGF0IGEgdGltZSBieSBkZWZhdWx0LiBbTGVhcm4gbW9yZVxuICAgICAqIGFib3V0IHNlc3Npb25cbiAgICAgKiBsaW1pdHNdKGh0dHBzOi8vYXBwd3JpdGUuaW8vZG9jcy9hdXRoZW50aWNhdGlvbi1zZWN1cml0eSNsaW1pdHMpLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtPQXV0aFByb3ZpZGVyfSBwcm92aWRlclxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBzdWNjZXNzXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGZhaWx1cmVcbiAgICAgKiBAcGFyYW0ge3N0cmluZ1tdfSBzY29wZXNcbiAgICAgKiBAdGhyb3dzIHtBcHB3cml0ZUV4Y2VwdGlvbn1cbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZX1cbiAgICAgKi9cbiAgICBhc3luYyBjcmVhdGVPQXV0aDJUb2tlbihwcm92aWRlciwgc3VjY2VzcywgZmFpbHVyZSwgc2NvcGVzKSB7XG4gICAgICAgIGNvbnN0IGFwaVBhdGggPSAnL2FjY291bnQvdG9rZW5zL29hdXRoMi97cHJvdmlkZXJ9Jy5yZXBsYWNlKCd7cHJvdmlkZXJ9JywgcHJvdmlkZXIpO1xuICAgICAgICBsZXQgcGF5bG9hZCA9IHt9O1xuICAgICAgICBpZiAodHlwZW9mIHByb3ZpZGVyID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEFwcHdyaXRlRXhjZXB0aW9uKCdNaXNzaW5nIHJlcXVpcmVkIHBhcmFtZXRlcjogXCJwcm92aWRlclwiJyk7XG4gICAgICAgIH1cblxuXG4gICAgICAgIGlmICh0eXBlb2Ygc3VjY2VzcyAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHBheWxvYWRbJ3N1Y2Nlc3MnXSA9IHN1Y2Nlc3M7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodHlwZW9mIGZhaWx1cmUgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICBwYXlsb2FkWydmYWlsdXJlJ10gPSBmYWlsdXJlO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHR5cGVvZiBzY29wZXMgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICBwYXlsb2FkWydzY29wZXMnXSA9IHNjb3BlcztcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBhd2FpdCB0aGlzLmNsaWVudC5jYWxsKCdnZXQnLCBhcGlQYXRoLCB7XG4gICAgICAgICAgICAnY29udGVudC10eXBlJzogJ2FwcGxpY2F0aW9uL2pzb24nLFxuICAgICAgICB9LCBwYXlsb2FkLCAnbG9jYXRpb24nKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGUgcGhvbmUgdG9rZW5cbiAgICAgKlxuICAgICAqIFNlbmRzIHRoZSB1c2VyIGFuIFNNUyB3aXRoIGEgc2VjcmV0IGtleSBmb3IgY3JlYXRpbmcgYSBzZXNzaW9uLiBJZiB0aGVcbiAgICAgKiBwcm92aWRlZCB1c2VyIElEIGhhcyBub3QgYmUgcmVnaXN0ZXJlZCwgYSBuZXcgdXNlciB3aWxsIGJlIGNyZWF0ZWQuIFVzZSB0aGVcbiAgICAgKiByZXR1cm5lZCB1c2VyIElEIGFuZCBzZWNyZXQgYW5kIHN1Ym1pdCBhIHJlcXVlc3QgdG8gdGhlIFtQT1NUXG4gICAgICogL3YxL2FjY291bnQvc2Vzc2lvbnMvdG9rZW5dKGh0dHBzOi8vYXBwd3JpdGUuaW8vZG9jcy9yZWZlcmVuY2VzL2Nsb3VkL2NsaWVudC13ZWIvYWNjb3VudCNjcmVhdGVTZXNzaW9uKVxuICAgICAqIGVuZHBvaW50IHRvIGNvbXBsZXRlIHRoZSBsb2dpbiBwcm9jZXNzLiBUaGUgc2VjcmV0IHNlbnQgdG8gdGhlIHVzZXIncyBwaG9uZVxuICAgICAqIGlzIHZhbGlkIGZvciAxNSBtaW51dGVzLlxuICAgICAqIFxuICAgICAqIEEgdXNlciBpcyBsaW1pdGVkIHRvIDEwIGFjdGl2ZSBzZXNzaW9ucyBhdCBhIHRpbWUgYnkgZGVmYXVsdC4gW0xlYXJuIG1vcmVcbiAgICAgKiBhYm91dCBzZXNzaW9uXG4gICAgICogbGltaXRzXShodHRwczovL2FwcHdyaXRlLmlvL2RvY3MvYXV0aGVudGljYXRpb24tc2VjdXJpdHkjbGltaXRzKS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSB1c2VySWRcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gcGhvbmVcbiAgICAgKiBAdGhyb3dzIHtBcHB3cml0ZUV4Y2VwdGlvbn1cbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZX1cbiAgICAgKi9cbiAgICBhc3luYyBjcmVhdGVQaG9uZVRva2VuKHVzZXJJZCwgcGhvbmUpIHtcbiAgICAgICAgY29uc3QgYXBpUGF0aCA9ICcvYWNjb3VudC90b2tlbnMvcGhvbmUnO1xuICAgICAgICBsZXQgcGF5bG9hZCA9IHt9O1xuICAgICAgICBpZiAodHlwZW9mIHVzZXJJZCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBBcHB3cml0ZUV4Y2VwdGlvbignTWlzc2luZyByZXF1aXJlZCBwYXJhbWV0ZXI6IFwidXNlcklkXCInKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0eXBlb2YgcGhvbmUgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgQXBwd3JpdGVFeGNlcHRpb24oJ01pc3NpbmcgcmVxdWlyZWQgcGFyYW1ldGVyOiBcInBob25lXCInKTtcbiAgICAgICAgfVxuXG5cbiAgICAgICAgaWYgKHR5cGVvZiB1c2VySWQgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICBwYXlsb2FkWyd1c2VySWQnXSA9IHVzZXJJZDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0eXBlb2YgcGhvbmUgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICBwYXlsb2FkWydwaG9uZSddID0gcGhvbmU7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy5jbGllbnQuY2FsbCgncG9zdCcsIGFwaVBhdGgsIHtcbiAgICAgICAgICAgICdjb250ZW50LXR5cGUnOiAnYXBwbGljYXRpb24vanNvbicsXG4gICAgICAgIH0sIHBheWxvYWQpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZSBlbWFpbCB2ZXJpZmljYXRpb25cbiAgICAgKlxuICAgICAqIFVzZSB0aGlzIGVuZHBvaW50IHRvIHNlbmQgYSB2ZXJpZmljYXRpb24gbWVzc2FnZSB0byB5b3VyIHVzZXIgZW1haWwgYWRkcmVzc1xuICAgICAqIHRvIGNvbmZpcm0gdGhleSBhcmUgdGhlIHZhbGlkIG93bmVycyBvZiB0aGF0IGFkZHJlc3MuIEJvdGggdGhlICoqdXNlcklkKipcbiAgICAgKiBhbmQgKipzZWNyZXQqKiBhcmd1bWVudHMgd2lsbCBiZSBwYXNzZWQgYXMgcXVlcnkgcGFyYW1ldGVycyB0byB0aGUgVVJMIHlvdVxuICAgICAqIGhhdmUgcHJvdmlkZWQgdG8gYmUgYXR0YWNoZWQgdG8gdGhlIHZlcmlmaWNhdGlvbiBlbWFpbC4gVGhlIHByb3ZpZGVkIFVSTFxuICAgICAqIHNob3VsZCByZWRpcmVjdCB0aGUgdXNlciBiYWNrIHRvIHlvdXIgYXBwIGFuZCBhbGxvdyB5b3UgdG8gY29tcGxldGUgdGhlXG4gICAgICogdmVyaWZpY2F0aW9uIHByb2Nlc3MgYnkgdmVyaWZ5aW5nIGJvdGggdGhlICoqdXNlcklkKiogYW5kICoqc2VjcmV0KipcbiAgICAgKiBwYXJhbWV0ZXJzLiBMZWFybiBtb3JlIGFib3V0IGhvdyB0byBbY29tcGxldGUgdGhlIHZlcmlmaWNhdGlvblxuICAgICAqIHByb2Nlc3NdKGh0dHBzOi8vYXBwd3JpdGUuaW8vZG9jcy9yZWZlcmVuY2VzL2Nsb3VkL2NsaWVudC13ZWIvYWNjb3VudCN1cGRhdGVWZXJpZmljYXRpb24pLlxuICAgICAqIFRoZSB2ZXJpZmljYXRpb24gbGluayBzZW50IHRvIHRoZSB1c2VyJ3MgZW1haWwgYWRkcmVzcyBpcyB2YWxpZCBmb3IgNyBkYXlzLlxuICAgICAqIFxuICAgICAqIFBsZWFzZSBub3RlIHRoYXQgaW4gb3JkZXIgdG8gYXZvaWQgYSBbUmVkaXJlY3RcbiAgICAgKiBBdHRhY2tdKGh0dHBzOi8vZ2l0aHViLmNvbS9PV0FTUC9DaGVhdFNoZWV0U2VyaWVzL2Jsb2IvbWFzdGVyL2NoZWF0c2hlZXRzL1VudmFsaWRhdGVkX1JlZGlyZWN0c19hbmRfRm9yd2FyZHNfQ2hlYXRfU2hlZXQubWQpLFxuICAgICAqIHRoZSBvbmx5IHZhbGlkIHJlZGlyZWN0IFVSTHMgYXJlIHRoZSBvbmVzIGZyb20gZG9tYWlucyB5b3UgaGF2ZSBzZXQgd2hlblxuICAgICAqIGFkZGluZyB5b3VyIHBsYXRmb3JtcyBpbiB0aGUgY29uc29sZSBpbnRlcmZhY2UuXG4gICAgICogXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gdXJsXG4gICAgICogQHRocm93cyB7QXBwd3JpdGVFeGNlcHRpb259XG4gICAgICogQHJldHVybnMge1Byb21pc2V9XG4gICAgICovXG4gICAgYXN5bmMgY3JlYXRlVmVyaWZpY2F0aW9uKHVybCkge1xuICAgICAgICBjb25zdCBhcGlQYXRoID0gJy9hY2NvdW50L3ZlcmlmaWNhdGlvbic7XG4gICAgICAgIGxldCBwYXlsb2FkID0ge307XG4gICAgICAgIGlmICh0eXBlb2YgdXJsID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEFwcHdyaXRlRXhjZXB0aW9uKCdNaXNzaW5nIHJlcXVpcmVkIHBhcmFtZXRlcjogXCJ1cmxcIicpO1xuICAgICAgICB9XG5cblxuICAgICAgICBpZiAodHlwZW9mIHVybCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHBheWxvYWRbJ3VybCddID0gdXJsO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMuY2xpZW50LmNhbGwoJ3Bvc3QnLCBhcGlQYXRoLCB7XG4gICAgICAgICAgICAnY29udGVudC10eXBlJzogJ2FwcGxpY2F0aW9uL2pzb24nLFxuICAgICAgICB9LCBwYXlsb2FkKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGUgZW1haWwgdmVyaWZpY2F0aW9uIChjb25maXJtYXRpb24pXG4gICAgICpcbiAgICAgKiBVc2UgdGhpcyBlbmRwb2ludCB0byBjb21wbGV0ZSB0aGUgdXNlciBlbWFpbCB2ZXJpZmljYXRpb24gcHJvY2Vzcy4gVXNlIGJvdGhcbiAgICAgKiB0aGUgKip1c2VySWQqKiBhbmQgKipzZWNyZXQqKiBwYXJhbWV0ZXJzIHRoYXQgd2VyZSBhdHRhY2hlZCB0byB5b3VyIGFwcCBVUkxcbiAgICAgKiB0byB2ZXJpZnkgdGhlIHVzZXIgZW1haWwgb3duZXJzaGlwLiBJZiBjb25maXJtZWQgdGhpcyByb3V0ZSB3aWxsIHJldHVybiBhXG4gICAgICogMjAwIHN0YXR1cyBjb2RlLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHVzZXJJZFxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBzZWNyZXRcbiAgICAgKiBAdGhyb3dzIHtBcHB3cml0ZUV4Y2VwdGlvbn1cbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZX1cbiAgICAgKi9cbiAgICBhc3luYyB1cGRhdGVWZXJpZmljYXRpb24odXNlcklkLCBzZWNyZXQpIHtcbiAgICAgICAgY29uc3QgYXBpUGF0aCA9ICcvYWNjb3VudC92ZXJpZmljYXRpb24nO1xuICAgICAgICBsZXQgcGF5bG9hZCA9IHt9O1xuICAgICAgICBpZiAodHlwZW9mIHVzZXJJZCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBBcHB3cml0ZUV4Y2VwdGlvbignTWlzc2luZyByZXF1aXJlZCBwYXJhbWV0ZXI6IFwidXNlcklkXCInKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0eXBlb2Ygc2VjcmV0ID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEFwcHdyaXRlRXhjZXB0aW9uKCdNaXNzaW5nIHJlcXVpcmVkIHBhcmFtZXRlcjogXCJzZWNyZXRcIicpO1xuICAgICAgICB9XG5cblxuICAgICAgICBpZiAodHlwZW9mIHVzZXJJZCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHBheWxvYWRbJ3VzZXJJZCddID0gdXNlcklkO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHR5cGVvZiBzZWNyZXQgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICBwYXlsb2FkWydzZWNyZXQnXSA9IHNlY3JldDtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBhd2FpdCB0aGlzLmNsaWVudC5jYWxsKCdwdXQnLCBhcGlQYXRoLCB7XG4gICAgICAgICAgICAnY29udGVudC10eXBlJzogJ2FwcGxpY2F0aW9uL2pzb24nLFxuICAgICAgICB9LCBwYXlsb2FkKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGUgcGhvbmUgdmVyaWZpY2F0aW9uXG4gICAgICpcbiAgICAgKiBVc2UgdGhpcyBlbmRwb2ludCB0byBzZW5kIGEgdmVyaWZpY2F0aW9uIFNNUyB0byB0aGUgY3VycmVudGx5IGxvZ2dlZCBpblxuICAgICAqIHVzZXIuIFRoaXMgZW5kcG9pbnQgaXMgbWVhbnQgZm9yIHVzZSBhZnRlciB1cGRhdGluZyBhIHVzZXIncyBwaG9uZSBudW1iZXJcbiAgICAgKiB1c2luZyB0aGVcbiAgICAgKiBbYWNjb3VudFVwZGF0ZVBob25lXShodHRwczovL2FwcHdyaXRlLmlvL2RvY3MvcmVmZXJlbmNlcy9jbG91ZC9jbGllbnQtd2ViL2FjY291bnQjdXBkYXRlUGhvbmUpXG4gICAgICogZW5kcG9pbnQuIExlYXJuIG1vcmUgYWJvdXQgaG93IHRvIFtjb21wbGV0ZSB0aGUgdmVyaWZpY2F0aW9uXG4gICAgICogcHJvY2Vzc10oaHR0cHM6Ly9hcHB3cml0ZS5pby9kb2NzL3JlZmVyZW5jZXMvY2xvdWQvY2xpZW50LXdlYi9hY2NvdW50I3VwZGF0ZVBob25lVmVyaWZpY2F0aW9uKS5cbiAgICAgKiBUaGUgdmVyaWZpY2F0aW9uIGNvZGUgc2VudCB0byB0aGUgdXNlcidzIHBob25lIG51bWJlciBpcyB2YWxpZCBmb3IgMTVcbiAgICAgKiBtaW51dGVzLlxuICAgICAqXG4gICAgICogQHRocm93cyB7QXBwd3JpdGVFeGNlcHRpb259XG4gICAgICogQHJldHVybnMge1Byb21pc2V9XG4gICAgICovXG4gICAgYXN5bmMgY3JlYXRlUGhvbmVWZXJpZmljYXRpb24oKSB7XG4gICAgICAgIGNvbnN0IGFwaVBhdGggPSAnL2FjY291bnQvdmVyaWZpY2F0aW9uL3Bob25lJztcbiAgICAgICAgbGV0IHBheWxvYWQgPSB7fTtcblxuICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy5jbGllbnQuY2FsbCgncG9zdCcsIGFwaVBhdGgsIHtcbiAgICAgICAgICAgICdjb250ZW50LXR5cGUnOiAnYXBwbGljYXRpb24vanNvbicsXG4gICAgICAgIH0sIHBheWxvYWQpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZSBwaG9uZSB2ZXJpZmljYXRpb24gKGNvbmZpcm1hdGlvbilcbiAgICAgKlxuICAgICAqIFVzZSB0aGlzIGVuZHBvaW50IHRvIGNvbXBsZXRlIHRoZSB1c2VyIHBob25lIHZlcmlmaWNhdGlvbiBwcm9jZXNzLiBVc2UgdGhlXG4gICAgICogKip1c2VySWQqKiBhbmQgKipzZWNyZXQqKiB0aGF0IHdlcmUgc2VudCB0byB5b3VyIHVzZXIncyBwaG9uZSBudW1iZXIgdG9cbiAgICAgKiB2ZXJpZnkgdGhlIHVzZXIgZW1haWwgb3duZXJzaGlwLiBJZiBjb25maXJtZWQgdGhpcyByb3V0ZSB3aWxsIHJldHVybiBhIDIwMFxuICAgICAqIHN0YXR1cyBjb2RlLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHVzZXJJZFxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBzZWNyZXRcbiAgICAgKiBAdGhyb3dzIHtBcHB3cml0ZUV4Y2VwdGlvbn1cbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZX1cbiAgICAgKi9cbiAgICBhc3luYyB1cGRhdGVQaG9uZVZlcmlmaWNhdGlvbih1c2VySWQsIHNlY3JldCkge1xuICAgICAgICBjb25zdCBhcGlQYXRoID0gJy9hY2NvdW50L3ZlcmlmaWNhdGlvbi9waG9uZSc7XG4gICAgICAgIGxldCBwYXlsb2FkID0ge307XG4gICAgICAgIGlmICh0eXBlb2YgdXNlcklkID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEFwcHdyaXRlRXhjZXB0aW9uKCdNaXNzaW5nIHJlcXVpcmVkIHBhcmFtZXRlcjogXCJ1c2VySWRcIicpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHR5cGVvZiBzZWNyZXQgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgQXBwd3JpdGVFeGNlcHRpb24oJ01pc3NpbmcgcmVxdWlyZWQgcGFyYW1ldGVyOiBcInNlY3JldFwiJyk7XG4gICAgICAgIH1cblxuXG4gICAgICAgIGlmICh0eXBlb2YgdXNlcklkICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgcGF5bG9hZFsndXNlcklkJ10gPSB1c2VySWQ7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodHlwZW9mIHNlY3JldCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHBheWxvYWRbJ3NlY3JldCddID0gc2VjcmV0O1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMuY2xpZW50LmNhbGwoJ3B1dCcsIGFwaVBhdGgsIHtcbiAgICAgICAgICAgICdjb250ZW50LXR5cGUnOiAnYXBwbGljYXRpb24vanNvbicsXG4gICAgICAgIH0sIHBheWxvYWQpO1xuICAgIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBBY2NvdW50O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(action-browser)/./node_modules/node-appwrite/lib/services/account.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/node-appwrite/lib/services/account.js":
/*!************************************************************!*\
  !*** ./node_modules/node-appwrite/lib/services/account.js ***!
  \************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("const Service = __webpack_require__(/*! ../service.js */ \"(rsc)/./node_modules/node-appwrite/lib/service.js\");\nconst AppwriteException = __webpack_require__(/*! ../exception.js */ \"(rsc)/./node_modules/node-appwrite/lib/exception.js\");\nconst InputFile = __webpack_require__(/*! ../inputFile.js */ \"(rsc)/./node_modules/node-appwrite/lib/inputFile.js\");\nconst client = __webpack_require__(/*! ../client.js */ \"(rsc)/./node_modules/node-appwrite/lib/client.js\");\nconst Stream = __webpack_require__(/*! stream */ \"stream\");\nconst { promisify } = __webpack_require__(/*! util */ \"util\");\nconst fs = __webpack_require__(/*! fs */ \"fs\");\nconst { File } = __webpack_require__(/*! undici */ \"undici\");\nconst Query = __webpack_require__(/*! ../query.js */ \"(rsc)/./node_modules/node-appwrite/lib/query.js\");\n\nclass Account extends Service {\n\n     constructor(client)\n     {\n        super(client);\n     }\n\n\n    /**\n     * Get account\n     *\n     * Get the currently logged in user.\n     *\n     * @throws {AppwriteException}\n     * @returns {Promise}\n     */\n    async get() {\n        const apiPath = '/account';\n        let payload = {};\n\n        return await this.client.call('get', apiPath, {\n            'content-type': 'application/json',\n        }, payload);\n    }\n\n    /**\n     * Create account\n     *\n     * Use this endpoint to allow a new user to register a new account in your\n     * project. After the user registration completes successfully, you can use\n     * the\n     * [/account/verfication](https://appwrite.io/docs/references/cloud/client-web/account#createVerification)\n     * route to start verifying the user email address. To allow the new user to\n     * login to their new account, you need to create a new [account\n     * session](https://appwrite.io/docs/references/cloud/client-web/account#createEmailSession).\n     *\n     * @param {string} userId\n     * @param {string} email\n     * @param {string} password\n     * @param {string} name\n     * @throws {AppwriteException}\n     * @returns {Promise}\n     */\n    async create(userId, email, password, name) {\n        const apiPath = '/account';\n        let payload = {};\n        if (typeof userId === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"userId\"');\n        }\n\n        if (typeof email === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"email\"');\n        }\n\n        if (typeof password === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"password\"');\n        }\n\n\n        if (typeof userId !== 'undefined') {\n            payload['userId'] = userId;\n        }\n\n        if (typeof email !== 'undefined') {\n            payload['email'] = email;\n        }\n\n        if (typeof password !== 'undefined') {\n            payload['password'] = password;\n        }\n\n        if (typeof name !== 'undefined') {\n            payload['name'] = name;\n        }\n\n        return await this.client.call('post', apiPath, {\n            'content-type': 'application/json',\n        }, payload);\n    }\n\n    /**\n     * Update email\n     *\n     * Update currently logged in user account email address. After changing user\n     * address, the user confirmation status will get reset. A new confirmation\n     * email is not sent automatically however you can use the send confirmation\n     * email endpoint again to send the confirmation email. For security measures,\n     * user password is required to complete this request.\n     * This endpoint can also be used to convert an anonymous account to a normal\n     * one, by passing an email address and a new password.\n     * \n     *\n     * @param {string} email\n     * @param {string} password\n     * @throws {AppwriteException}\n     * @returns {Promise}\n     */\n    async updateEmail(email, password) {\n        const apiPath = '/account/email';\n        let payload = {};\n        if (typeof email === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"email\"');\n        }\n\n        if (typeof password === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"password\"');\n        }\n\n\n        if (typeof email !== 'undefined') {\n            payload['email'] = email;\n        }\n\n        if (typeof password !== 'undefined') {\n            payload['password'] = password;\n        }\n\n        return await this.client.call('patch', apiPath, {\n            'content-type': 'application/json',\n        }, payload);\n    }\n\n    /**\n     * List Identities\n     *\n     * Get the list of identities for the currently logged in user.\n     *\n     * @param {string[]} queries\n     * @throws {AppwriteException}\n     * @returns {Promise}\n     */\n    async listIdentities(queries) {\n        const apiPath = '/account/identities';\n        let payload = {};\n\n        if (typeof queries !== 'undefined') {\n            payload['queries'] = queries;\n        }\n\n        return await this.client.call('get', apiPath, {\n            'content-type': 'application/json',\n        }, payload);\n    }\n\n    /**\n     * Delete identity\n     *\n     * Delete an identity by its unique ID.\n     *\n     * @param {string} identityId\n     * @throws {AppwriteException}\n     * @returns {Promise}\n     */\n    async deleteIdentity(identityId) {\n        const apiPath = '/account/identities/{identityId}'.replace('{identityId}', identityId);\n        let payload = {};\n        if (typeof identityId === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"identityId\"');\n        }\n\n\n        return await this.client.call('delete', apiPath, {\n            'content-type': 'application/json',\n        }, payload);\n    }\n\n    /**\n     * Create JWT\n     *\n     * Use this endpoint to create a JSON Web Token. You can use the resulting JWT\n     * to authenticate on behalf of the current user when working with the\n     * Appwrite server-side API and SDKs. The JWT secret is valid for 15 minutes\n     * from its creation and will be invalid if the user will logout in that time\n     * frame.\n     *\n     * @throws {AppwriteException}\n     * @returns {Promise}\n     */\n    async createJWT() {\n        const apiPath = '/account/jwt';\n        let payload = {};\n\n        return await this.client.call('post', apiPath, {\n            'content-type': 'application/json',\n        }, payload);\n    }\n\n    /**\n     * List logs\n     *\n     * Get the list of latest security activity logs for the currently logged in\n     * user. Each log returns user IP address, location and date and time of log.\n     *\n     * @param {string[]} queries\n     * @throws {AppwriteException}\n     * @returns {Promise}\n     */\n    async listLogs(queries) {\n        const apiPath = '/account/logs';\n        let payload = {};\n\n        if (typeof queries !== 'undefined') {\n            payload['queries'] = queries;\n        }\n\n        return await this.client.call('get', apiPath, {\n            'content-type': 'application/json',\n        }, payload);\n    }\n\n    /**\n     * Update MFA\n     *\n     * Enable or disable MFA on an account.\n     *\n     * @param {boolean} mfa\n     * @throws {AppwriteException}\n     * @returns {Promise}\n     */\n    async updateMFA(mfa) {\n        const apiPath = '/account/mfa';\n        let payload = {};\n        if (typeof mfa === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"mfa\"');\n        }\n\n\n        if (typeof mfa !== 'undefined') {\n            payload['mfa'] = mfa;\n        }\n\n        return await this.client.call('patch', apiPath, {\n            'content-type': 'application/json',\n        }, payload);\n    }\n\n    /**\n     * Add Authenticator\n     *\n     * Add an authenticator app to be used as an MFA factor. Verify the\n     * authenticator using the [verify\n     * authenticator](/docs/references/cloud/client-web/account#verifyAuthenticator)\n     * method.\n     *\n     * @param {AuthenticatorType} type\n     * @throws {AppwriteException}\n     * @returns {Promise}\n     */\n    async createMfaAuthenticator(type) {\n        const apiPath = '/account/mfa/authenticators/{type}'.replace('{type}', type);\n        let payload = {};\n        if (typeof type === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"type\"');\n        }\n\n\n        return await this.client.call('post', apiPath, {\n            'content-type': 'application/json',\n        }, payload);\n    }\n\n    /**\n     * Verify Authenticator\n     *\n     * Verify an authenticator app after adding it using the [add\n     * authenticator](/docs/references/cloud/client-web/account#addAuthenticator)\n     * method.\n     *\n     * @param {AuthenticatorType} type\n     * @param {string} otp\n     * @throws {AppwriteException}\n     * @returns {Promise}\n     */\n    async updateMfaAuthenticator(type, otp) {\n        const apiPath = '/account/mfa/authenticators/{type}'.replace('{type}', type);\n        let payload = {};\n        if (typeof type === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"type\"');\n        }\n\n        if (typeof otp === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"otp\"');\n        }\n\n\n        if (typeof otp !== 'undefined') {\n            payload['otp'] = otp;\n        }\n\n        return await this.client.call('put', apiPath, {\n            'content-type': 'application/json',\n        }, payload);\n    }\n\n    /**\n     * Delete Authenticator\n     *\n     * Delete an authenticator for a user by ID.\n     *\n     * @param {AuthenticatorType} type\n     * @param {string} otp\n     * @throws {AppwriteException}\n     * @returns {Promise}\n     */\n    async deleteMfaAuthenticator(type, otp) {\n        const apiPath = '/account/mfa/authenticators/{type}'.replace('{type}', type);\n        let payload = {};\n        if (typeof type === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"type\"');\n        }\n\n        if (typeof otp === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"otp\"');\n        }\n\n\n        if (typeof otp !== 'undefined') {\n            payload['otp'] = otp;\n        }\n\n        return await this.client.call('delete', apiPath, {\n            'content-type': 'application/json',\n        }, payload);\n    }\n\n    /**\n     * Create 2FA Challenge\n     *\n     * Begin the process of MFA verification after sign-in. Finish the flow with\n     * [updateMfaChallenge](/docs/references/cloud/client-web/account#updateMfaChallenge)\n     * method.\n     *\n     * @param {AuthenticationFactor} factor\n     * @throws {AppwriteException}\n     * @returns {Promise}\n     */\n    async createMfaChallenge(factor) {\n        const apiPath = '/account/mfa/challenge';\n        let payload = {};\n        if (typeof factor === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"factor\"');\n        }\n\n\n        if (typeof factor !== 'undefined') {\n            payload['factor'] = factor;\n        }\n\n        return await this.client.call('post', apiPath, {\n            'content-type': 'application/json',\n        }, payload);\n    }\n\n    /**\n     * Create MFA Challenge (confirmation)\n     *\n     * Complete the MFA challenge by providing the one-time password. Finish the\n     * process of MFA verification by providing the one-time password. To begin\n     * the flow, use\n     * [createMfaChallenge](/docs/references/cloud/client-web/account#createMfaChallenge)\n     * method.\n     *\n     * @param {string} challengeId\n     * @param {string} otp\n     * @throws {AppwriteException}\n     * @returns {Promise}\n     */\n    async updateMfaChallenge(challengeId, otp) {\n        const apiPath = '/account/mfa/challenge';\n        let payload = {};\n        if (typeof challengeId === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"challengeId\"');\n        }\n\n        if (typeof otp === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"otp\"');\n        }\n\n\n        if (typeof challengeId !== 'undefined') {\n            payload['challengeId'] = challengeId;\n        }\n\n        if (typeof otp !== 'undefined') {\n            payload['otp'] = otp;\n        }\n\n        return await this.client.call('put', apiPath, {\n            'content-type': 'application/json',\n        }, payload);\n    }\n\n    /**\n     * List Factors\n     *\n     * List the factors available on the account to be used as a MFA challange.\n     *\n     * @throws {AppwriteException}\n     * @returns {Promise}\n     */\n    async listMfaFactors() {\n        const apiPath = '/account/mfa/factors';\n        let payload = {};\n\n        return await this.client.call('get', apiPath, {\n            'content-type': 'application/json',\n        }, payload);\n    }\n\n    /**\n     * Get MFA Recovery Codes\n     *\n     * Get recovery codes that can be used as backup for MFA flow. Before getting\n     * codes, they must be generated using\n     * [createMfaRecoveryCodes](/docs/references/cloud/client-web/account#createMfaRecoveryCodes)\n     * method. An OTP challenge is required to read recovery codes.\n     *\n     * @throws {AppwriteException}\n     * @returns {Promise}\n     */\n    async getMfaRecoveryCodes() {\n        const apiPath = '/account/mfa/recovery-codes';\n        let payload = {};\n\n        return await this.client.call('get', apiPath, {\n            'content-type': 'application/json',\n        }, payload);\n    }\n\n    /**\n     * Create MFA Recovery Codes\n     *\n     * Generate recovery codes as backup for MFA flow. It's recommended to\n     * generate and show then immediately after user successfully adds their\n     * authehticator. Recovery codes can be used as a MFA verification type in\n     * [createMfaChallenge](/docs/references/cloud/client-web/account#createMfaChallenge)\n     * method.\n     *\n     * @throws {AppwriteException}\n     * @returns {Promise}\n     */\n    async createMfaRecoveryCodes() {\n        const apiPath = '/account/mfa/recovery-codes';\n        let payload = {};\n\n        return await this.client.call('post', apiPath, {\n            'content-type': 'application/json',\n        }, payload);\n    }\n\n    /**\n     * Regenerate MFA Recovery Codes\n     *\n     * Regenerate recovery codes that can be used as backup for MFA flow. Before\n     * regenerating codes, they must be first generated using\n     * [createMfaRecoveryCodes](/docs/references/cloud/client-web/account#createMfaRecoveryCodes)\n     * method. An OTP challenge is required to regenreate recovery codes.\n     *\n     * @throws {AppwriteException}\n     * @returns {Promise}\n     */\n    async updateMfaRecoveryCodes() {\n        const apiPath = '/account/mfa/recovery-codes';\n        let payload = {};\n\n        return await this.client.call('patch', apiPath, {\n            'content-type': 'application/json',\n        }, payload);\n    }\n\n    /**\n     * Update name\n     *\n     * Update currently logged in user account name.\n     *\n     * @param {string} name\n     * @throws {AppwriteException}\n     * @returns {Promise}\n     */\n    async updateName(name) {\n        const apiPath = '/account/name';\n        let payload = {};\n        if (typeof name === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"name\"');\n        }\n\n\n        if (typeof name !== 'undefined') {\n            payload['name'] = name;\n        }\n\n        return await this.client.call('patch', apiPath, {\n            'content-type': 'application/json',\n        }, payload);\n    }\n\n    /**\n     * Update password\n     *\n     * Update currently logged in user password. For validation, user is required\n     * to pass in the new password, and the old password. For users created with\n     * OAuth, Team Invites and Magic URL, oldPassword is optional.\n     *\n     * @param {string} password\n     * @param {string} oldPassword\n     * @throws {AppwriteException}\n     * @returns {Promise}\n     */\n    async updatePassword(password, oldPassword) {\n        const apiPath = '/account/password';\n        let payload = {};\n        if (typeof password === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"password\"');\n        }\n\n\n        if (typeof password !== 'undefined') {\n            payload['password'] = password;\n        }\n\n        if (typeof oldPassword !== 'undefined') {\n            payload['oldPassword'] = oldPassword;\n        }\n\n        return await this.client.call('patch', apiPath, {\n            'content-type': 'application/json',\n        }, payload);\n    }\n\n    /**\n     * Update phone\n     *\n     * Update the currently logged in user's phone number. After updating the\n     * phone number, the phone verification status will be reset. A confirmation\n     * SMS is not sent automatically, however you can use the [POST\n     * /account/verification/phone](https://appwrite.io/docs/references/cloud/client-web/account#createPhoneVerification)\n     * endpoint to send a confirmation SMS.\n     *\n     * @param {string} phone\n     * @param {string} password\n     * @throws {AppwriteException}\n     * @returns {Promise}\n     */\n    async updatePhone(phone, password) {\n        const apiPath = '/account/phone';\n        let payload = {};\n        if (typeof phone === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"phone\"');\n        }\n\n        if (typeof password === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"password\"');\n        }\n\n\n        if (typeof phone !== 'undefined') {\n            payload['phone'] = phone;\n        }\n\n        if (typeof password !== 'undefined') {\n            payload['password'] = password;\n        }\n\n        return await this.client.call('patch', apiPath, {\n            'content-type': 'application/json',\n        }, payload);\n    }\n\n    /**\n     * Get account preferences\n     *\n     * Get the preferences as a key-value object for the currently logged in user.\n     *\n     * @throws {AppwriteException}\n     * @returns {Promise}\n     */\n    async getPrefs() {\n        const apiPath = '/account/prefs';\n        let payload = {};\n\n        return await this.client.call('get', apiPath, {\n            'content-type': 'application/json',\n        }, payload);\n    }\n\n    /**\n     * Update preferences\n     *\n     * Update currently logged in user account preferences. The object you pass is\n     * stored as is, and replaces any previous value. The maximum allowed prefs\n     * size is 64kB and throws error if exceeded.\n     *\n     * @param {object} prefs\n     * @throws {AppwriteException}\n     * @returns {Promise}\n     */\n    async updatePrefs(prefs) {\n        const apiPath = '/account/prefs';\n        let payload = {};\n        if (typeof prefs === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"prefs\"');\n        }\n\n\n        if (typeof prefs !== 'undefined') {\n            payload['prefs'] = prefs;\n        }\n\n        return await this.client.call('patch', apiPath, {\n            'content-type': 'application/json',\n        }, payload);\n    }\n\n    /**\n     * Create password recovery\n     *\n     * Sends the user an email with a temporary secret key for password reset.\n     * When the user clicks the confirmation link he is redirected back to your\n     * app password reset URL with the secret key and email address values\n     * attached to the URL query string. Use the query string params to submit a\n     * request to the [PUT\n     * /account/recovery](https://appwrite.io/docs/references/cloud/client-web/account#updateRecovery)\n     * endpoint to complete the process. The verification link sent to the user's\n     * email address is valid for 1 hour.\n     *\n     * @param {string} email\n     * @param {string} url\n     * @throws {AppwriteException}\n     * @returns {Promise}\n     */\n    async createRecovery(email, url) {\n        const apiPath = '/account/recovery';\n        let payload = {};\n        if (typeof email === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"email\"');\n        }\n\n        if (typeof url === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"url\"');\n        }\n\n\n        if (typeof email !== 'undefined') {\n            payload['email'] = email;\n        }\n\n        if (typeof url !== 'undefined') {\n            payload['url'] = url;\n        }\n\n        return await this.client.call('post', apiPath, {\n            'content-type': 'application/json',\n        }, payload);\n    }\n\n    /**\n     * Create password recovery (confirmation)\n     *\n     * Use this endpoint to complete the user account password reset. Both the\n     * **userId** and **secret** arguments will be passed as query parameters to\n     * the redirect URL you have provided when sending your request to the [POST\n     * /account/recovery](https://appwrite.io/docs/references/cloud/client-web/account#createRecovery)\n     * endpoint.\n     * \n     * Please note that in order to avoid a [Redirect\n     * Attack](https://github.com/OWASP/CheatSheetSeries/blob/master/cheatsheets/Unvalidated_Redirects_and_Forwards_Cheat_Sheet.md)\n     * the only valid redirect URLs are the ones from domains you have set when\n     * adding your platforms in the console interface.\n     *\n     * @param {string} userId\n     * @param {string} secret\n     * @param {string} password\n     * @throws {AppwriteException}\n     * @returns {Promise}\n     */\n    async updateRecovery(userId, secret, password) {\n        const apiPath = '/account/recovery';\n        let payload = {};\n        if (typeof userId === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"userId\"');\n        }\n\n        if (typeof secret === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"secret\"');\n        }\n\n        if (typeof password === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"password\"');\n        }\n\n\n        if (typeof userId !== 'undefined') {\n            payload['userId'] = userId;\n        }\n\n        if (typeof secret !== 'undefined') {\n            payload['secret'] = secret;\n        }\n\n        if (typeof password !== 'undefined') {\n            payload['password'] = password;\n        }\n\n        return await this.client.call('put', apiPath, {\n            'content-type': 'application/json',\n        }, payload);\n    }\n\n    /**\n     * List sessions\n     *\n     * Get the list of active sessions across different devices for the currently\n     * logged in user.\n     *\n     * @throws {AppwriteException}\n     * @returns {Promise}\n     */\n    async listSessions() {\n        const apiPath = '/account/sessions';\n        let payload = {};\n\n        return await this.client.call('get', apiPath, {\n            'content-type': 'application/json',\n        }, payload);\n    }\n\n    /**\n     * Delete sessions\n     *\n     * Delete all sessions from the user account and remove any sessions cookies\n     * from the end client.\n     *\n     * @throws {AppwriteException}\n     * @returns {Promise}\n     */\n    async deleteSessions() {\n        const apiPath = '/account/sessions';\n        let payload = {};\n\n        return await this.client.call('delete', apiPath, {\n            'content-type': 'application/json',\n        }, payload);\n    }\n\n    /**\n     * Create anonymous session\n     *\n     * Use this endpoint to allow a new user to register an anonymous account in\n     * your project. This route will also create a new session for the user. To\n     * allow the new user to convert an anonymous account to a normal account, you\n     * need to update its [email and\n     * password](https://appwrite.io/docs/references/cloud/client-web/account#updateEmail)\n     * or create an [OAuth2\n     * session](https://appwrite.io/docs/references/cloud/client-web/account#CreateOAuth2Session).\n     *\n     * @throws {AppwriteException}\n     * @returns {Promise}\n     */\n    async createAnonymousSession() {\n        const apiPath = '/account/sessions/anonymous';\n        let payload = {};\n\n        return await this.client.call('post', apiPath, {\n            'content-type': 'application/json',\n        }, payload);\n    }\n\n    /**\n     * Create email password session\n     *\n     * Allow the user to login into their account by providing a valid email and\n     * password combination. This route will create a new session for the user.\n     * \n     * A user is limited to 10 active sessions at a time by default. [Learn more\n     * about session\n     * limits](https://appwrite.io/docs/authentication-security#limits).\n     *\n     * @param {string} email\n     * @param {string} password\n     * @throws {AppwriteException}\n     * @returns {Promise}\n     */\n    async createEmailPasswordSession(email, password) {\n        const apiPath = '/account/sessions/email';\n        let payload = {};\n        if (typeof email === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"email\"');\n        }\n\n        if (typeof password === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"password\"');\n        }\n\n\n        if (typeof email !== 'undefined') {\n            payload['email'] = email;\n        }\n\n        if (typeof password !== 'undefined') {\n            payload['password'] = password;\n        }\n\n        return await this.client.call('post', apiPath, {\n            'content-type': 'application/json',\n        }, payload);\n    }\n\n    /**\n     * Update magic URL session\n     *\n     * Use this endpoint to create a session from token. Provide the **userId**\n     * and **secret** parameters from the successful response of authentication\n     * flows initiated by token creation. For example, magic URL and phone login.\n     *\n     * @param {string} userId\n     * @param {string} secret\n     * @throws {AppwriteException}\n     * @returns {Promise}\n     */\n    async updateMagicURLSession(userId, secret) {\n        const apiPath = '/account/sessions/magic-url';\n        let payload = {};\n        if (typeof userId === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"userId\"');\n        }\n\n        if (typeof secret === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"secret\"');\n        }\n\n\n        if (typeof userId !== 'undefined') {\n            payload['userId'] = userId;\n        }\n\n        if (typeof secret !== 'undefined') {\n            payload['secret'] = secret;\n        }\n\n        return await this.client.call('put', apiPath, {\n            'content-type': 'application/json',\n        }, payload);\n    }\n\n    /**\n     * Update phone session\n     *\n     * Use this endpoint to create a session from token. Provide the **userId**\n     * and **secret** parameters from the successful response of authentication\n     * flows initiated by token creation. For example, magic URL and phone login.\n     *\n     * @param {string} userId\n     * @param {string} secret\n     * @throws {AppwriteException}\n     * @returns {Promise}\n     */\n    async updatePhoneSession(userId, secret) {\n        const apiPath = '/account/sessions/phone';\n        let payload = {};\n        if (typeof userId === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"userId\"');\n        }\n\n        if (typeof secret === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"secret\"');\n        }\n\n\n        if (typeof userId !== 'undefined') {\n            payload['userId'] = userId;\n        }\n\n        if (typeof secret !== 'undefined') {\n            payload['secret'] = secret;\n        }\n\n        return await this.client.call('put', apiPath, {\n            'content-type': 'application/json',\n        }, payload);\n    }\n\n    /**\n     * Create session\n     *\n     * Use this endpoint to create a session from token. Provide the **userId**\n     * and **secret** parameters from the successful response of authentication\n     * flows initiated by token creation. For example, magic URL and phone login.\n     *\n     * @param {string} userId\n     * @param {string} secret\n     * @throws {AppwriteException}\n     * @returns {Promise}\n     */\n    async createSession(userId, secret) {\n        const apiPath = '/account/sessions/token';\n        let payload = {};\n        if (typeof userId === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"userId\"');\n        }\n\n        if (typeof secret === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"secret\"');\n        }\n\n\n        if (typeof userId !== 'undefined') {\n            payload['userId'] = userId;\n        }\n\n        if (typeof secret !== 'undefined') {\n            payload['secret'] = secret;\n        }\n\n        return await this.client.call('post', apiPath, {\n            'content-type': 'application/json',\n        }, payload);\n    }\n\n    /**\n     * Get session\n     *\n     * Use this endpoint to get a logged in user's session using a Session ID.\n     * Inputting 'current' will return the current session being used.\n     *\n     * @param {string} sessionId\n     * @throws {AppwriteException}\n     * @returns {Promise}\n     */\n    async getSession(sessionId) {\n        const apiPath = '/account/sessions/{sessionId}'.replace('{sessionId}', sessionId);\n        let payload = {};\n        if (typeof sessionId === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"sessionId\"');\n        }\n\n\n        return await this.client.call('get', apiPath, {\n            'content-type': 'application/json',\n        }, payload);\n    }\n\n    /**\n     * Update session\n     *\n     * Use this endpoint to extend a session's length. Extending a session is\n     * useful when session expiry is short. If the session was created using an\n     * OAuth provider, this endpoint refreshes the access token from the provider.\n     *\n     * @param {string} sessionId\n     * @throws {AppwriteException}\n     * @returns {Promise}\n     */\n    async updateSession(sessionId) {\n        const apiPath = '/account/sessions/{sessionId}'.replace('{sessionId}', sessionId);\n        let payload = {};\n        if (typeof sessionId === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"sessionId\"');\n        }\n\n\n        return await this.client.call('patch', apiPath, {\n            'content-type': 'application/json',\n        }, payload);\n    }\n\n    /**\n     * Delete session\n     *\n     * Logout the user. Use 'current' as the session ID to logout on this device,\n     * use a session ID to logout on another device. If you're looking to logout\n     * the user on all devices, use [Delete\n     * Sessions](https://appwrite.io/docs/references/cloud/client-web/account#deleteSessions)\n     * instead.\n     *\n     * @param {string} sessionId\n     * @throws {AppwriteException}\n     * @returns {Promise}\n     */\n    async deleteSession(sessionId) {\n        const apiPath = '/account/sessions/{sessionId}'.replace('{sessionId}', sessionId);\n        let payload = {};\n        if (typeof sessionId === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"sessionId\"');\n        }\n\n\n        return await this.client.call('delete', apiPath, {\n            'content-type': 'application/json',\n        }, payload);\n    }\n\n    /**\n     * Update status\n     *\n     * Block the currently logged in user account. Behind the scene, the user\n     * record is not deleted but permanently blocked from any access. To\n     * completely delete a user, use the Users API instead.\n     *\n     * @throws {AppwriteException}\n     * @returns {Promise}\n     */\n    async updateStatus() {\n        const apiPath = '/account/status';\n        let payload = {};\n\n        return await this.client.call('patch', apiPath, {\n            'content-type': 'application/json',\n        }, payload);\n    }\n\n    /**\n     * Create email token (OTP)\n     *\n     * Sends the user an email with a secret key for creating a session. If the\n     * provided user ID has not be registered, a new user will be created. Use the\n     * returned user ID and secret and submit a request to the [POST\n     * /v1/account/sessions/token](https://appwrite.io/docs/references/cloud/client-web/account#createSession)\n     * endpoint to complete the login process. The secret sent to the user's email\n     * is valid for 15 minutes.\n     * \n     * A user is limited to 10 active sessions at a time by default. [Learn more\n     * about session\n     * limits](https://appwrite.io/docs/authentication-security#limits).\n     *\n     * @param {string} userId\n     * @param {string} email\n     * @param {boolean} phrase\n     * @throws {AppwriteException}\n     * @returns {Promise}\n     */\n    async createEmailToken(userId, email, phrase) {\n        const apiPath = '/account/tokens/email';\n        let payload = {};\n        if (typeof userId === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"userId\"');\n        }\n\n        if (typeof email === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"email\"');\n        }\n\n\n        if (typeof userId !== 'undefined') {\n            payload['userId'] = userId;\n        }\n\n        if (typeof email !== 'undefined') {\n            payload['email'] = email;\n        }\n\n        if (typeof phrase !== 'undefined') {\n            payload['phrase'] = phrase;\n        }\n\n        return await this.client.call('post', apiPath, {\n            'content-type': 'application/json',\n        }, payload);\n    }\n\n    /**\n     * Create magic URL token\n     *\n     * Sends the user an email with a secret key for creating a session. If the\n     * provided user ID has not been registered, a new user will be created. When\n     * the user clicks the link in the email, the user is redirected back to the\n     * URL you provided with the secret key and userId values attached to the URL\n     * query string. Use the query string parameters to submit a request to the\n     * [POST\n     * /v1/account/sessions/token](https://appwrite.io/docs/references/cloud/client-web/account#createSession)\n     * endpoint to complete the login process. The link sent to the user's email\n     * address is valid for 1 hour. If you are on a mobile device you can leave\n     * the URL parameter empty, so that the login completion will be handled by\n     * your Appwrite instance by default.\n     * \n     * A user is limited to 10 active sessions at a time by default. [Learn more\n     * about session\n     * limits](https://appwrite.io/docs/authentication-security#limits).\n     * \n     *\n     * @param {string} userId\n     * @param {string} email\n     * @param {string} url\n     * @param {boolean} phrase\n     * @throws {AppwriteException}\n     * @returns {Promise}\n     */\n    async createMagicURLToken(userId, email, url, phrase) {\n        const apiPath = '/account/tokens/magic-url';\n        let payload = {};\n        if (typeof userId === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"userId\"');\n        }\n\n        if (typeof email === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"email\"');\n        }\n\n\n        if (typeof userId !== 'undefined') {\n            payload['userId'] = userId;\n        }\n\n        if (typeof email !== 'undefined') {\n            payload['email'] = email;\n        }\n\n        if (typeof url !== 'undefined') {\n            payload['url'] = url;\n        }\n\n        if (typeof phrase !== 'undefined') {\n            payload['phrase'] = phrase;\n        }\n\n        return await this.client.call('post', apiPath, {\n            'content-type': 'application/json',\n        }, payload);\n    }\n\n    /**\n     * Create OAuth2 token\n     *\n     * Allow the user to login to their account using the OAuth2 provider of their\n     * choice. Each OAuth2 provider should be enabled from the Appwrite console\n     * first. Use the success and failure arguments to provide a redirect URL's\n     * back to your app when login is completed. \n     * \n     * If authentication succeeds, `userId` and `secret` of a token will be\n     * appended to the success URL as query parameters. These can be used to\n     * create a new session using the [Create\n     * session](https://appwrite.io/docs/references/cloud/client-web/account#createSession)\n     * endpoint.\n     * \n     * A user is limited to 10 active sessions at a time by default. [Learn more\n     * about session\n     * limits](https://appwrite.io/docs/authentication-security#limits).\n     *\n     * @param {OAuthProvider} provider\n     * @param {string} success\n     * @param {string} failure\n     * @param {string[]} scopes\n     * @throws {AppwriteException}\n     * @returns {Promise}\n     */\n    async createOAuth2Token(provider, success, failure, scopes) {\n        const apiPath = '/account/tokens/oauth2/{provider}'.replace('{provider}', provider);\n        let payload = {};\n        if (typeof provider === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"provider\"');\n        }\n\n\n        if (typeof success !== 'undefined') {\n            payload['success'] = success;\n        }\n\n        if (typeof failure !== 'undefined') {\n            payload['failure'] = failure;\n        }\n\n        if (typeof scopes !== 'undefined') {\n            payload['scopes'] = scopes;\n        }\n\n        return await this.client.call('get', apiPath, {\n            'content-type': 'application/json',\n        }, payload, 'location');\n    }\n\n    /**\n     * Create phone token\n     *\n     * Sends the user an SMS with a secret key for creating a session. If the\n     * provided user ID has not be registered, a new user will be created. Use the\n     * returned user ID and secret and submit a request to the [POST\n     * /v1/account/sessions/token](https://appwrite.io/docs/references/cloud/client-web/account#createSession)\n     * endpoint to complete the login process. The secret sent to the user's phone\n     * is valid for 15 minutes.\n     * \n     * A user is limited to 10 active sessions at a time by default. [Learn more\n     * about session\n     * limits](https://appwrite.io/docs/authentication-security#limits).\n     *\n     * @param {string} userId\n     * @param {string} phone\n     * @throws {AppwriteException}\n     * @returns {Promise}\n     */\n    async createPhoneToken(userId, phone) {\n        const apiPath = '/account/tokens/phone';\n        let payload = {};\n        if (typeof userId === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"userId\"');\n        }\n\n        if (typeof phone === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"phone\"');\n        }\n\n\n        if (typeof userId !== 'undefined') {\n            payload['userId'] = userId;\n        }\n\n        if (typeof phone !== 'undefined') {\n            payload['phone'] = phone;\n        }\n\n        return await this.client.call('post', apiPath, {\n            'content-type': 'application/json',\n        }, payload);\n    }\n\n    /**\n     * Create email verification\n     *\n     * Use this endpoint to send a verification message to your user email address\n     * to confirm they are the valid owners of that address. Both the **userId**\n     * and **secret** arguments will be passed as query parameters to the URL you\n     * have provided to be attached to the verification email. The provided URL\n     * should redirect the user back to your app and allow you to complete the\n     * verification process by verifying both the **userId** and **secret**\n     * parameters. Learn more about how to [complete the verification\n     * process](https://appwrite.io/docs/references/cloud/client-web/account#updateVerification).\n     * The verification link sent to the user's email address is valid for 7 days.\n     * \n     * Please note that in order to avoid a [Redirect\n     * Attack](https://github.com/OWASP/CheatSheetSeries/blob/master/cheatsheets/Unvalidated_Redirects_and_Forwards_Cheat_Sheet.md),\n     * the only valid redirect URLs are the ones from domains you have set when\n     * adding your platforms in the console interface.\n     * \n     *\n     * @param {string} url\n     * @throws {AppwriteException}\n     * @returns {Promise}\n     */\n    async createVerification(url) {\n        const apiPath = '/account/verification';\n        let payload = {};\n        if (typeof url === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"url\"');\n        }\n\n\n        if (typeof url !== 'undefined') {\n            payload['url'] = url;\n        }\n\n        return await this.client.call('post', apiPath, {\n            'content-type': 'application/json',\n        }, payload);\n    }\n\n    /**\n     * Create email verification (confirmation)\n     *\n     * Use this endpoint to complete the user email verification process. Use both\n     * the **userId** and **secret** parameters that were attached to your app URL\n     * to verify the user email ownership. If confirmed this route will return a\n     * 200 status code.\n     *\n     * @param {string} userId\n     * @param {string} secret\n     * @throws {AppwriteException}\n     * @returns {Promise}\n     */\n    async updateVerification(userId, secret) {\n        const apiPath = '/account/verification';\n        let payload = {};\n        if (typeof userId === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"userId\"');\n        }\n\n        if (typeof secret === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"secret\"');\n        }\n\n\n        if (typeof userId !== 'undefined') {\n            payload['userId'] = userId;\n        }\n\n        if (typeof secret !== 'undefined') {\n            payload['secret'] = secret;\n        }\n\n        return await this.client.call('put', apiPath, {\n            'content-type': 'application/json',\n        }, payload);\n    }\n\n    /**\n     * Create phone verification\n     *\n     * Use this endpoint to send a verification SMS to the currently logged in\n     * user. This endpoint is meant for use after updating a user's phone number\n     * using the\n     * [accountUpdatePhone](https://appwrite.io/docs/references/cloud/client-web/account#updatePhone)\n     * endpoint. Learn more about how to [complete the verification\n     * process](https://appwrite.io/docs/references/cloud/client-web/account#updatePhoneVerification).\n     * The verification code sent to the user's phone number is valid for 15\n     * minutes.\n     *\n     * @throws {AppwriteException}\n     * @returns {Promise}\n     */\n    async createPhoneVerification() {\n        const apiPath = '/account/verification/phone';\n        let payload = {};\n\n        return await this.client.call('post', apiPath, {\n            'content-type': 'application/json',\n        }, payload);\n    }\n\n    /**\n     * Create phone verification (confirmation)\n     *\n     * Use this endpoint to complete the user phone verification process. Use the\n     * **userId** and **secret** that were sent to your user's phone number to\n     * verify the user email ownership. If confirmed this route will return a 200\n     * status code.\n     *\n     * @param {string} userId\n     * @param {string} secret\n     * @throws {AppwriteException}\n     * @returns {Promise}\n     */\n    async updatePhoneVerification(userId, secret) {\n        const apiPath = '/account/verification/phone';\n        let payload = {};\n        if (typeof userId === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"userId\"');\n        }\n\n        if (typeof secret === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"secret\"');\n        }\n\n\n        if (typeof userId !== 'undefined') {\n            payload['userId'] = userId;\n        }\n\n        if (typeof secret !== 'undefined') {\n            payload['secret'] = secret;\n        }\n\n        return await this.client.call('put', apiPath, {\n            'content-type': 'application/json',\n        }, payload);\n    }\n}\n\nmodule.exports = Account;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvbm9kZS1hcHB3cml0ZS9saWIvc2VydmljZXMvYWNjb3VudC5qcyIsIm1hcHBpbmdzIjoiQUFBQSxnQkFBZ0IsbUJBQU8sQ0FBQyx3RUFBZTtBQUN2QywwQkFBMEIsbUJBQU8sQ0FBQyw0RUFBaUI7QUFDbkQsa0JBQWtCLG1CQUFPLENBQUMsNEVBQWlCO0FBQzNDLGVBQWUsbUJBQU8sQ0FBQyxzRUFBYztBQUNyQyxlQUFlLG1CQUFPLENBQUMsc0JBQVE7QUFDL0IsUUFBUSxZQUFZLEVBQUUsbUJBQU8sQ0FBQyxrQkFBTTtBQUNwQyxXQUFXLG1CQUFPLENBQUMsY0FBSTtBQUN2QixRQUFRLE9BQU8sRUFBRSxtQkFBTyxDQUFDLHNCQUFRO0FBQ2pDLGNBQWMsbUJBQU8sQ0FBQyxvRUFBYTs7QUFFbkM7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEIsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QixlQUFlLFFBQVE7QUFDdkIsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsUUFBUTtBQUN2QixnQkFBZ0I7QUFDaEIsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsU0FBUztBQUNUOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QixlQUFlLFFBQVE7QUFDdkIs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QSxnQkFBZ0I7QUFDaEIsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQixpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFNBQVM7QUFDVDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEIsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQixpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFNBQVM7QUFDVDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCLGdCQUFnQjtBQUNoQixpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsU0FBUztBQUNUOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsUUFBUTtBQUN2QixnQkFBZ0I7QUFDaEIsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsUUFBUTtBQUN2QixnQkFBZ0I7QUFDaEIsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsU0FBUztBQUNUOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEIsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkIsZ0JBQWdCO0FBQ2hCLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsUUFBUTtBQUN2QixnQkFBZ0I7QUFDaEIsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsU0FBUztBQUNUOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkIsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsUUFBUTtBQUN2QixnQkFBZ0I7QUFDaEIsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsU0FBUztBQUNUOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQixpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFNBQVM7QUFDVDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsU0FBUztBQUNUOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsUUFBUTtBQUN2QixnQkFBZ0I7QUFDaEIsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsU0FBUztBQUNUOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsUUFBUTtBQUN2QixnQkFBZ0I7QUFDaEIsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsU0FBUztBQUNUOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsUUFBUTtBQUN2QixnQkFBZ0I7QUFDaEIsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsU0FBUztBQUNUOztBQUVBO0FB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QTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7O0FBRUEiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9qc21fYmFua2luZy8uL25vZGVfbW9kdWxlcy9ub2RlLWFwcHdyaXRlL2xpYi9zZXJ2aWNlcy9hY2NvdW50LmpzPzE0OTYiXSwic291cmNlc0NvbnRlbnQiOlsiY29uc3QgU2VydmljZSA9IHJlcXVpcmUoJy4uL3NlcnZpY2UuanMnKTtcbmNvbnN0IEFwcHdyaXRlRXhjZXB0aW9uID0gcmVxdWlyZSgnLi4vZXhjZXB0aW9uLmpzJyk7XG5jb25zdCBJbnB1dEZpbGUgPSByZXF1aXJlKCcuLi9pbnB1dEZpbGUuanMnKTtcbmNvbnN0IGNsaWVudCA9IHJlcXVpcmUoJy4uL2NsaWVudC5qcycpO1xuY29uc3QgU3RyZWFtID0gcmVxdWlyZSgnc3RyZWFtJyk7XG5jb25zdCB7IHByb21pc2lmeSB9ID0gcmVxdWlyZSgndXRpbCcpO1xuY29uc3QgZnMgPSByZXF1aXJlKCdmcycpO1xuY29uc3QgeyBGaWxlIH0gPSByZXF1aXJlKCd1bmRpY2knKTtcbmNvbnN0IFF1ZXJ5ID0gcmVxdWlyZSgnLi4vcXVlcnkuanMnKTtcblxuY2xhc3MgQWNjb3VudCBleHRlbmRzIFNlcnZpY2Uge1xuXG4gICAgIGNvbnN0cnVjdG9yKGNsaWVudClcbiAgICAge1xuICAgICAgICBzdXBlcihjbGllbnQpO1xuICAgICB9XG5cblxuICAgIC8qKlxuICAgICAqIEdldCBhY2NvdW50XG4gICAgICpcbiAgICAgKiBHZXQgdGhlIGN1cnJlbnRseSBsb2dnZWQgaW4gdXNlci5cbiAgICAgKlxuICAgICAqIEB0aHJvd3Mge0FwcHdyaXRlRXhjZXB0aW9ufVxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlfVxuICAgICAqL1xuICAgIGFzeW5jIGdldCgpIHtcbiAgICAgICAgY29uc3QgYXBpUGF0aCA9ICcvYWNjb3VudCc7XG4gICAgICAgIGxldCBwYXlsb2FkID0ge307XG5cbiAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMuY2xpZW50LmNhbGwoJ2dldCcsIGFwaVBhdGgsIHtcbiAgICAgICAgICAgICdjb250ZW50LXR5cGUnOiAnYXBwbGljYXRpb24vanNvbicsXG4gICAgICAgIH0sIHBheWxvYWQpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZSBhY2NvdW50XG4gICAgICpcbiAgICAgKiBVc2UgdGhpcyBlbmRwb2ludCB0byBhbGxvdyBhIG5ldyB1c2VyIHRvIHJlZ2lzdGVyIGEgbmV3IGFjY291bnQgaW4geW91clxuICAgICAqIHByb2plY3QuIEFmdGVyIHRoZSB1c2VyIHJlZ2lzdHJhdGlvbiBjb21wbGV0ZXMgc3VjY2Vzc2Z1bGx5LCB5b3UgY2FuIHVzZVxuICAgICAqIHRoZVxuICAgICAqIFsvYWNjb3VudC92ZXJmaWNhdGlvbl0oaHR0cHM6Ly9hcHB3cml0ZS5pby9kb2NzL3JlZmVyZW5jZXMvY2xvdWQvY2xpZW50LXdlYi9hY2NvdW50I2NyZWF0ZVZlcmlmaWNhdGlvbilcbiAgICAgKiByb3V0ZSB0byBzdGFydCB2ZXJpZnlpbmcgdGhlIHVzZXIgZW1haWwgYWRkcmVzcy4gVG8gYWxsb3cgdGhlIG5ldyB1c2VyIHRvXG4gICAgICogbG9naW4gdG8gdGhlaXIgbmV3IGFjY291bnQsIHlvdSBuZWVkIHRvIGNyZWF0ZSBhIG5ldyBbYWNjb3VudFxuICAgICAqIHNlc3Npb25dKGh0dHBzOi8vYXBwd3JpdGUuaW8vZG9jcy9yZWZlcmVuY2VzL2Nsb3VkL2NsaWVudC13ZWIvYWNjb3VudCNjcmVhdGVFbWFpbFNlc3Npb24pLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHVzZXJJZFxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBlbWFpbFxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBwYXNzd29yZFxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lXG4gICAgICogQHRocm93cyB7QXBwd3JpdGVFeGNlcHRpb259XG4gICAgICogQHJldHVybnMge1Byb21pc2V9XG4gICAgICovXG4gICAgYXN5bmMgY3JlYXRlKHVzZXJJZCwgZW1haWwsIHBhc3N3b3JkLCBuYW1lKSB7XG4gICAgICAgIGNvbnN0IGFwaVBhdGggPSAnL2FjY291bnQnO1xuICAgICAgICBsZXQgcGF5bG9hZCA9IHt9O1xuICAgICAgICBpZiAodHlwZW9mIHVzZXJJZCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBBcHB3cml0ZUV4Y2VwdGlvbignTWlzc2luZyByZXF1aXJlZCBwYXJhbWV0ZXI6IFwidXNlcklkXCInKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0eXBlb2YgZW1haWwgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgQXBwd3JpdGVFeGNlcHRpb24oJ01pc3NpbmcgcmVxdWlyZWQgcGFyYW1ldGVyOiBcImVtYWlsXCInKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0eXBlb2YgcGFzc3dvcmQgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgQXBwd3JpdGVFeGNlcHRpb24oJ01pc3NpbmcgcmVxdWlyZWQgcGFyYW1ldGVyOiBcInBhc3N3b3JkXCInKTtcbiAgICAgICAgfVxuXG5cbiAgICAgICAgaWYgKHR5cGVvZiB1c2VySWQgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICBwYXlsb2FkWyd1c2VySWQnXSA9IHVzZXJJZDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0eXBlb2YgZW1haWwgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICBwYXlsb2FkWydlbWFpbCddID0gZW1haWw7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodHlwZW9mIHBhc3N3b3JkICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgcGF5bG9hZFsncGFzc3dvcmQnXSA9IHBhc3N3b3JkO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHR5cGVvZiBuYW1lICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgcGF5bG9hZFsnbmFtZSddID0gbmFtZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBhd2FpdCB0aGlzLmNsaWVudC5jYWxsKCdwb3N0JywgYXBpUGF0aCwge1xuICAgICAgICAgICAgJ2NvbnRlbnQtdHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJyxcbiAgICAgICAgfSwgcGF5bG9hZCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVXBkYXRlIGVtYWlsXG4gICAgICpcbiAgICAgKiBVcGRhdGUgY3VycmVudGx5IGxvZ2dlZCBpbiB1c2VyIGFjY291bnQgZW1haWwgYWRkcmVzcy4gQWZ0ZXIgY2hhbmdpbmcgdXNlclxuICAgICAqIGFkZHJlc3MsIHRoZSB1c2VyIGNvbmZpcm1hdGlvbiBzdGF0dXMgd2lsbCBnZXQgcmVzZXQuIEEgbmV3IGNvbmZpcm1hdGlvblxuICAgICAqIGVtYWlsIGlzIG5vdCBzZW50IGF1dG9tYXRpY2FsbHkgaG93ZXZlciB5b3UgY2FuIHVzZSB0aGUgc2VuZCBjb25maXJtYXRpb25cbiAgICAgKiBlbWFpbCBlbmRwb2ludCBhZ2FpbiB0byBzZW5kIHRoZSBjb25maXJtYXRpb24gZW1haWwuIEZvciBzZWN1cml0eSBtZWFzdXJlcyxcbiAgICAgKiB1c2VyIHBhc3N3b3JkIGlzIHJlcXVpcmVkIHRvIGNvbXBsZXRlIHRoaXMgcmVxdWVzdC5cbiAgICAgKiBUaGlzIGVuZHBvaW50IGNhbiBhbHNvIGJlIHVzZWQgdG8gY29udmVydCBhbiBhbm9ueW1vdXMgYWNjb3VudCB0byBhIG5vcm1hbFxuICAgICAqIG9uZSwgYnkgcGFzc2luZyBhbiBlbWFpbCBhZGRyZXNzIGFuZCBhIG5ldyBwYXNzd29yZC5cbiAgICAgKiBcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBlbWFpbFxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBwYXNzd29yZFxuICAgICAqIEB0aHJvd3Mge0FwcHdyaXRlRXhjZXB0aW9ufVxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlfVxuICAgICAqL1xuICAgIGFzeW5jIHVwZGF0ZUVtYWlsKGVtYWlsLCBwYXNzd29yZCkge1xuICAgICAgICBjb25zdCBhcGlQYXRoID0gJy9hY2NvdW50L2VtYWlsJztcbiAgICAgICAgbGV0IHBheWxvYWQgPSB7fTtcbiAgICAgICAgaWYgKHR5cGVvZiBlbWFpbCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBBcHB3cml0ZUV4Y2VwdGlvbignTWlzc2luZyByZXF1aXJlZCBwYXJhbWV0ZXI6IFwiZW1haWxcIicpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHR5cGVvZiBwYXNzd29yZCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBBcHB3cml0ZUV4Y2VwdGlvbignTWlzc2luZyByZXF1aXJlZCBwYXJhbWV0ZXI6IFwicGFzc3dvcmRcIicpO1xuICAgICAgICB9XG5cblxuICAgICAgICBpZiAodHlwZW9mIGVtYWlsICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgcGF5bG9hZFsnZW1haWwnXSA9IGVtYWlsO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHR5cGVvZiBwYXNzd29yZCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHBheWxvYWRbJ3Bhc3N3b3JkJ10gPSBwYXNzd29yZDtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBhd2FpdCB0aGlzLmNsaWVudC5jYWxsKCdwYXRjaCcsIGFwaVBhdGgsIHtcbiAgICAgICAgICAgICdjb250ZW50LXR5cGUnOiAnYXBwbGljYXRpb24vanNvbicsXG4gICAgICAgIH0sIHBheWxvYWQpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIExpc3QgSWRlbnRpdGllc1xuICAgICAqXG4gICAgICogR2V0IHRoZSBsaXN0IG9mIGlkZW50aXRpZXMgZm9yIHRoZSBjdXJyZW50bHkgbG9nZ2VkIGluIHVzZXIuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZ1tdfSBxdWVyaWVzXG4gICAgICogQHRocm93cyB7QXBwd3JpdGVFeGNlcHRpb259XG4gICAgICogQHJldHVybnMge1Byb21pc2V9XG4gICAgICovXG4gICAgYXN5bmMgbGlzdElkZW50aXRpZXMocXVlcmllcykge1xuICAgICAgICBjb25zdCBhcGlQYXRoID0gJy9hY2NvdW50L2lkZW50aXRpZXMnO1xuICAgICAgICBsZXQgcGF5bG9hZCA9IHt9O1xuXG4gICAgICAgIGlmICh0eXBlb2YgcXVlcmllcyAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHBheWxvYWRbJ3F1ZXJpZXMnXSA9IHF1ZXJpZXM7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy5jbGllbnQuY2FsbCgnZ2V0JywgYXBpUGF0aCwge1xuICAgICAgICAgICAgJ2NvbnRlbnQtdHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJyxcbiAgICAgICAgfSwgcGF5bG9hZCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRGVsZXRlIGlkZW50aXR5XG4gICAgICpcbiAgICAgKiBEZWxldGUgYW4gaWRlbnRpdHkgYnkgaXRzIHVuaXF1ZSBJRC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBpZGVudGl0eUlkXG4gICAgICogQHRocm93cyB7QXBwd3JpdGVFeGNlcHRpb259XG4gICAgICogQHJldHVybnMge1Byb21pc2V9XG4gICAgICovXG4gICAgYXN5bmMgZGVsZXRlSWRlbnRpdHkoaWRlbnRpdHlJZCkge1xuICAgICAgICBjb25zdCBhcGlQYXRoID0gJy9hY2NvdW50L2lkZW50aXRpZXMve2lkZW50aXR5SWR9Jy5yZXBsYWNlKCd7aWRlbnRpdHlJZH0nLCBpZGVudGl0eUlkKTtcbiAgICAgICAgbGV0IHBheWxvYWQgPSB7fTtcbiAgICAgICAgaWYgKHR5cGVvZiBpZGVudGl0eUlkID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEFwcHdyaXRlRXhjZXB0aW9uKCdNaXNzaW5nIHJlcXVpcmVkIHBhcmFtZXRlcjogXCJpZGVudGl0eUlkXCInKTtcbiAgICAgICAgfVxuXG5cbiAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMuY2xpZW50LmNhbGwoJ2RlbGV0ZScsIGFwaVBhdGgsIHtcbiAgICAgICAgICAgICdjb250ZW50LXR5cGUnOiAnYXBwbGljYXRpb24vanNvbicsXG4gICAgICAgIH0sIHBheWxvYWQpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZSBKV1RcbiAgICAgKlxuICAgICAqIFVzZSB0aGlzIGVuZHBvaW50IHRvIGNyZWF0ZSBhIEpTT04gV2ViIFRva2VuLiBZb3UgY2FuIHVzZSB0aGUgcmVzdWx0aW5nIEpXVFxuICAgICAqIHRvIGF1dGhlbnRpY2F0ZSBvbiBiZWhhbGYgb2YgdGhlIGN1cnJlbnQgdXNlciB3aGVuIHdvcmtpbmcgd2l0aCB0aGVcbiAgICAgKiBBcHB3cml0ZSBzZXJ2ZXItc2lkZSBBUEkgYW5kIFNES3MuIFRoZSBKV1Qgc2VjcmV0IGlzIHZhbGlkIGZvciAxNSBtaW51dGVzXG4gICAgICogZnJvbSBpdHMgY3JlYXRpb24gYW5kIHdpbGwgYmUgaW52YWxpZCBpZiB0aGUgdXNlciB3aWxsIGxvZ291dCBpbiB0aGF0IHRpbWVcbiAgICAgKiBmcmFtZS5cbiAgICAgKlxuICAgICAqIEB0aHJvd3Mge0FwcHdyaXRlRXhjZXB0aW9ufVxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlfVxuICAgICAqL1xuICAgIGFzeW5jIGNyZWF0ZUpXVCgpIHtcbiAgICAgICAgY29uc3QgYXBpUGF0aCA9ICcvYWNjb3VudC9qd3QnO1xuICAgICAgICBsZXQgcGF5bG9hZCA9IHt9O1xuXG4gICAgICAgIHJldHVybiBhd2FpdCB0aGlzLmNsaWVudC5jYWxsKCdwb3N0JywgYXBpUGF0aCwge1xuICAgICAgICAgICAgJ2NvbnRlbnQtdHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJyxcbiAgICAgICAgfSwgcGF5bG9hZCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogTGlzdCBsb2dzXG4gICAgICpcbiAgICAgKiBHZXQgdGhlIGxpc3Qgb2YgbGF0ZXN0IHNlY3VyaXR5IGFjdGl2aXR5IGxvZ3MgZm9yIHRoZSBjdXJyZW50bHkgbG9nZ2VkIGluXG4gICAgICogdXNlci4gRWFjaCBsb2cgcmV0dXJucyB1c2VyIElQIGFkZHJlc3MsIGxvY2F0aW9uIGFuZCBkYXRlIGFuZCB0aW1lIG9mIGxvZy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nW119IHF1ZXJpZXNcbiAgICAgKiBAdGhyb3dzIHtBcHB3cml0ZUV4Y2VwdGlvbn1cbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZX1cbiAgICAgKi9cbiAgICBhc3luYyBsaXN0TG9ncyhxdWVyaWVzKSB7XG4gICAgICAgIGNvbnN0IGFwaVBhdGggPSAnL2FjY291bnQvbG9ncyc7XG4gICAgICAgIGxldCBwYXlsb2FkID0ge307XG5cbiAgICAgICAgaWYgKHR5cGVvZiBxdWVyaWVzICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgcGF5bG9hZFsncXVlcmllcyddID0gcXVlcmllcztcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBhd2FpdCB0aGlzLmNsaWVudC5jYWxsKCdnZXQnLCBhcGlQYXRoLCB7XG4gICAgICAgICAgICAnY29udGVudC10eXBlJzogJ2FwcGxpY2F0aW9uL2pzb24nLFxuICAgICAgICB9LCBwYXlsb2FkKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBVcGRhdGUgTUZBXG4gICAgICpcbiAgICAgKiBFbmFibGUgb3IgZGlzYWJsZSBNRkEgb24gYW4gYWNjb3VudC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gbWZhXG4gICAgICogQHRocm93cyB7QXBwd3JpdGVFeGNlcHRpb259XG4gICAgICogQHJldHVybnMge1Byb21pc2V9XG4gICAgICovXG4gICAgYXN5bmMgdXBkYXRlTUZBKG1mYSkge1xuICAgICAgICBjb25zdCBhcGlQYXRoID0gJy9hY2NvdW50L21mYSc7XG4gICAgICAgIGxldCBwYXlsb2FkID0ge307XG4gICAgICAgIGlmICh0eXBlb2YgbWZhID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEFwcHdyaXRlRXhjZXB0aW9uKCdNaXNzaW5nIHJlcXVpcmVkIHBhcmFtZXRlcjogXCJtZmFcIicpO1xuICAgICAgICB9XG5cblxuICAgICAgICBpZiAodHlwZW9mIG1mYSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHBheWxvYWRbJ21mYSddID0gbWZhO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMuY2xpZW50LmNhbGwoJ3BhdGNoJywgYXBpUGF0aCwge1xuICAgICAgICAgICAgJ2NvbnRlbnQtdHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJyxcbiAgICAgICAgfSwgcGF5bG9hZCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQWRkIEF1dGhlbnRpY2F0b3JcbiAgICAgKlxuICAgICAqIEFkZCBhbiBhdXRoZW50aWNhdG9yIGFwcCB0byBiZSB1c2VkIGFzIGFuIE1GQSBmYWN0b3IuIFZlcmlmeSB0aGVcbiAgICAgKiBhdXRoZW50aWNhdG9yIHVzaW5nIHRoZSBbdmVyaWZ5XG4gICAgICogYXV0aGVudGljYXRvcl0oL2RvY3MvcmVmZXJlbmNlcy9jbG91ZC9jbGllbnQtd2ViL2FjY291bnQjdmVyaWZ5QXV0aGVudGljYXRvcilcbiAgICAgKiBtZXRob2QuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0F1dGhlbnRpY2F0b3JUeXBlfSB0eXBlXG4gICAgICogQHRocm93cyB7QXBwd3JpdGVFeGNlcHRpb259XG4gICAgICogQHJldHVybnMge1Byb21pc2V9XG4gICAgICovXG4gICAgYXN5bmMgY3JlYXRlTWZhQXV0aGVudGljYXRvcih0eXBlKSB7XG4gICAgICAgIGNvbnN0IGFwaVBhdGggPSAnL2FjY291bnQvbWZhL2F1dGhlbnRpY2F0b3JzL3t0eXBlfScucmVwbGFjZSgne3R5cGV9JywgdHlwZSk7XG4gICAgICAgIGxldCBwYXlsb2FkID0ge307XG4gICAgICAgIGlmICh0eXBlb2YgdHlwZSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBBcHB3cml0ZUV4Y2VwdGlvbignTWlzc2luZyByZXF1aXJlZCBwYXJhbWV0ZXI6IFwidHlwZVwiJyk7XG4gICAgICAgIH1cblxuXG4gICAgICAgIHJldHVybiBhd2FpdCB0aGlzLmNsaWVudC5jYWxsKCdwb3N0JywgYXBpUGF0aCwge1xuICAgICAgICAgICAgJ2NvbnRlbnQtdHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJyxcbiAgICAgICAgfSwgcGF5bG9hZCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVmVyaWZ5IEF1dGhlbnRpY2F0b3JcbiAgICAgKlxuICAgICAqIFZlcmlmeSBhbiBhdXRoZW50aWNhdG9yIGFwcCBhZnRlciBhZGRpbmcgaXQgdXNpbmcgdGhlIFthZGRcbiAgICAgKiBhdXRoZW50aWNhdG9yXSgvZG9jcy9yZWZlcmVuY2VzL2Nsb3VkL2NsaWVudC13ZWIvYWNjb3VudCNhZGRBdXRoZW50aWNhdG9yKVxuICAgICAqIG1ldGhvZC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7QXV0aGVudGljYXRvclR5cGV9IHR5cGVcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gb3RwXG4gICAgICogQHRocm93cyB7QXBwd3JpdGVFeGNlcHRpb259XG4gICAgICogQHJldHVybnMge1Byb21pc2V9XG4gICAgICovXG4gICAgYXN5bmMgdXBkYXRlTWZhQXV0aGVudGljYXRvcih0eXBlLCBvdHApIHtcbiAgICAgICAgY29uc3QgYXBpUGF0aCA9ICcvYWNjb3VudC9tZmEvYXV0aGVudGljYXRvcnMve3R5cGV9Jy5yZXBsYWNlKCd7dHlwZX0nLCB0eXBlKTtcbiAgICAgICAgbGV0IHBheWxvYWQgPSB7fTtcbiAgICAgICAgaWYgKHR5cGVvZiB0eXBlID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEFwcHdyaXRlRXhjZXB0aW9uKCdNaXNzaW5nIHJlcXVpcmVkIHBhcmFtZXRlcjogXCJ0eXBlXCInKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0eXBlb2Ygb3RwID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEFwcHdyaXRlRXhjZXB0aW9uKCdNaXNzaW5nIHJlcXVpcmVkIHBhcmFtZXRlcjogXCJvdHBcIicpO1xuICAgICAgICB9XG5cblxuICAgICAgICBpZiAodHlwZW9mIG90cCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHBheWxvYWRbJ290cCddID0gb3RwO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMuY2xpZW50LmNhbGwoJ3B1dCcsIGFwaVBhdGgsIHtcbiAgICAgICAgICAgICdjb250ZW50LXR5cGUnOiAnYXBwbGljYXRpb24vanNvbicsXG4gICAgICAgIH0sIHBheWxvYWQpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIERlbGV0ZSBBdXRoZW50aWNhdG9yXG4gICAgICpcbiAgICAgKiBEZWxldGUgYW4gYXV0aGVudGljYXRvciBmb3IgYSB1c2VyIGJ5IElELlxuICAgICAqXG4gICAgICogQHBhcmFtIHtBdXRoZW50aWNhdG9yVHlwZX0gdHlwZVxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBvdHBcbiAgICAgKiBAdGhyb3dzIHtBcHB3cml0ZUV4Y2VwdGlvbn1cbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZX1cbiAgICAgKi9cbiAgICBhc3luYyBkZWxldGVNZmFBdXRoZW50aWNhdG9yKHR5cGUsIG90cCkge1xuICAgICAgICBjb25zdCBhcGlQYXRoID0gJy9hY2NvdW50L21mYS9hdXRoZW50aWNhdG9ycy97dHlwZX0nLnJlcGxhY2UoJ3t0eXBlfScsIHR5cGUpO1xuICAgICAgICBsZXQgcGF5bG9hZCA9IHt9O1xuICAgICAgICBpZiAodHlwZW9mIHR5cGUgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgQXBwd3JpdGVFeGNlcHRpb24oJ01pc3NpbmcgcmVxdWlyZWQgcGFyYW1ldGVyOiBcInR5cGVcIicpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHR5cGVvZiBvdHAgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgQXBwd3JpdGVFeGNlcHRpb24oJ01pc3NpbmcgcmVxdWlyZWQgcGFyYW1ldGVyOiBcIm90cFwiJyk7XG4gICAgICAgIH1cblxuXG4gICAgICAgIGlmICh0eXBlb2Ygb3RwICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgcGF5bG9hZFsnb3RwJ10gPSBvdHA7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy5jbGllbnQuY2FsbCgnZGVsZXRlJywgYXBpUGF0aCwge1xuICAgICAgICAgICAgJ2NvbnRlbnQtdHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJyxcbiAgICAgICAgfSwgcGF5bG9hZCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlIDJGQSBDaGFsbGVuZ2VcbiAgICAgKlxuICAgICAqIEJlZ2luIHRoZSBwcm9jZXNzIG9mIE1GQSB2ZXJpZmljYXRpb24gYWZ0ZXIgc2lnbi1pbi4gRmluaXNoIHRoZSBmbG93IHdpdGhcbiAgICAgKiBbdXBkYXRlTWZhQ2hhbGxlbmdlXSgvZG9jcy9yZWZlcmVuY2VzL2Nsb3VkL2NsaWVudC13ZWIvYWNjb3VudCN1cGRhdGVNZmFDaGFsbGVuZ2UpXG4gICAgICogbWV0aG9kLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtBdXRoZW50aWNhdGlvbkZhY3Rvcn0gZmFjdG9yXG4gICAgICogQHRocm93cyB7QXBwd3JpdGVFeGNlcHRpb259XG4gICAgICogQHJldHVybnMge1Byb21pc2V9XG4gICAgICovXG4gICAgYXN5bmMgY3JlYXRlTWZhQ2hhbGxlbmdlKGZhY3Rvcikge1xuICAgICAgICBjb25zdCBhcGlQYXRoID0gJy9hY2NvdW50L21mYS9jaGFsbGVuZ2UnO1xuICAgICAgICBsZXQgcGF5bG9hZCA9IHt9O1xuICAgICAgICBpZiAodHlwZW9mIGZhY3RvciA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBBcHB3cml0ZUV4Y2VwdGlvbignTWlzc2luZyByZXF1aXJlZCBwYXJhbWV0ZXI6IFwiZmFjdG9yXCInKTtcbiAgICAgICAgfVxuXG5cbiAgICAgICAgaWYgKHR5cGVvZiBmYWN0b3IgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICBwYXlsb2FkWydmYWN0b3InXSA9IGZhY3RvcjtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBhd2FpdCB0aGlzLmNsaWVudC5jYWxsKCdwb3N0JywgYXBpUGF0aCwge1xuICAgICAgICAgICAgJ2NvbnRlbnQtdHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJyxcbiAgICAgICAgfSwgcGF5bG9hZCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlIE1GQSBDaGFsbGVuZ2UgKGNvbmZpcm1hdGlvbilcbiAgICAgKlxuICAgICAqIENvbXBsZXRlIHRoZSBNRkEgY2hhbGxlbmdlIGJ5IHByb3ZpZGluZyB0aGUgb25lLXRpbWUgcGFzc3dvcmQuIEZpbmlzaCB0aGVcbiAgICAgKiBwcm9jZXNzIG9mIE1GQSB2ZXJpZmljYXRpb24gYnkgcHJvdmlkaW5nIHRoZSBvbmUtdGltZSBwYXNzd29yZC4gVG8gYmVnaW5cbiAgICAgKiB0aGUgZmxvdywgdXNlXG4gICAgICogW2NyZWF0ZU1mYUNoYWxsZW5nZV0oL2RvY3MvcmVmZXJlbmNlcy9jbG91ZC9jbGllbnQtd2ViL2FjY291bnQjY3JlYXRlTWZhQ2hhbGxlbmdlKVxuICAgICAqIG1ldGhvZC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBjaGFsbGVuZ2VJZFxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBvdHBcbiAgICAgKiBAdGhyb3dzIHtBcHB3cml0ZUV4Y2VwdGlvbn1cbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZX1cbiAgICAgKi9cbiAgICBhc3luYyB1cGRhdGVNZmFDaGFsbGVuZ2UoY2hhbGxlbmdlSWQsIG90cCkge1xuICAgICAgICBjb25zdCBhcGlQYXRoID0gJy9hY2NvdW50L21mYS9jaGFsbGVuZ2UnO1xuICAgICAgICBsZXQgcGF5bG9hZCA9IHt9O1xuICAgICAgICBpZiAodHlwZW9mIGNoYWxsZW5nZUlkID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEFwcHdyaXRlRXhjZXB0aW9uKCdNaXNzaW5nIHJlcXVpcmVkIHBhcmFtZXRlcjogXCJjaGFsbGVuZ2VJZFwiJyk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodHlwZW9mIG90cCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBBcHB3cml0ZUV4Y2VwdGlvbignTWlzc2luZyByZXF1aXJlZCBwYXJhbWV0ZXI6IFwib3RwXCInKTtcbiAgICAgICAgfVxuXG5cbiAgICAgICAgaWYgKHR5cGVvZiBjaGFsbGVuZ2VJZCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHBheWxvYWRbJ2NoYWxsZW5nZUlkJ10gPSBjaGFsbGVuZ2VJZDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0eXBlb2Ygb3RwICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgcGF5bG9hZFsnb3RwJ10gPSBvdHA7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy5jbGllbnQuY2FsbCgncHV0JywgYXBpUGF0aCwge1xuICAgICAgICAgICAgJ2NvbnRlbnQtdHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJyxcbiAgICAgICAgfSwgcGF5bG9hZCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogTGlzdCBGYWN0b3JzXG4gICAgICpcbiAgICAgKiBMaXN0IHRoZSBmYWN0b3JzIGF2YWlsYWJsZSBvbiB0aGUgYWNjb3VudCB0byBiZSB1c2VkIGFzIGEgTUZBIGNoYWxsYW5nZS5cbiAgICAgKlxuICAgICAqIEB0aHJvd3Mge0FwcHdyaXRlRXhjZXB0aW9ufVxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlfVxuICAgICAqL1xuICAgIGFzeW5jIGxpc3RNZmFGYWN0b3JzKCkge1xuICAgICAgICBjb25zdCBhcGlQYXRoID0gJy9hY2NvdW50L21mYS9mYWN0b3JzJztcbiAgICAgICAgbGV0IHBheWxvYWQgPSB7fTtcblxuICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy5jbGllbnQuY2FsbCgnZ2V0JywgYXBpUGF0aCwge1xuICAgICAgICAgICAgJ2NvbnRlbnQtdHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJyxcbiAgICAgICAgfSwgcGF5bG9hZCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2V0IE1GQSBSZWNvdmVyeSBDb2Rlc1xuICAgICAqXG4gICAgICogR2V0IHJlY292ZXJ5IGNvZGVzIHRoYXQgY2FuIGJlIHVzZWQgYXMgYmFja3VwIGZvciBNRkEgZmxvdy4gQmVmb3JlIGdldHRpbmdcbiAgICAgKiBjb2RlcywgdGhleSBtdXN0IGJlIGdlbmVyYXRlZCB1c2luZ1xuICAgICAqIFtjcmVhdGVNZmFSZWNvdmVyeUNvZGVzXSgvZG9jcy9yZWZlcmVuY2VzL2Nsb3VkL2NsaWVudC13ZWIvYWNjb3VudCNjcmVhdGVNZmFSZWNvdmVyeUNvZGVzKVxuICAgICAqIG1ldGhvZC4gQW4gT1RQIGNoYWxsZW5nZSBpcyByZXF1aXJlZCB0byByZWFkIHJlY292ZXJ5IGNvZGVzLlxuICAgICAqXG4gICAgICogQHRocm93cyB7QXBwd3JpdGVFeGNlcHRpb259XG4gICAgICogQHJldHVybnMge1Byb21pc2V9XG4gICAgICovXG4gICAgYXN5bmMgZ2V0TWZhUmVjb3ZlcnlDb2RlcygpIHtcbiAgICAgICAgY29uc3QgYXBpUGF0aCA9ICcvYWNjb3VudC9tZmEvcmVjb3ZlcnktY29kZXMnO1xuICAgICAgICBsZXQgcGF5bG9hZCA9IHt9O1xuXG4gICAgICAgIHJldHVybiBhd2FpdCB0aGlzLmNsaWVudC5jYWxsKCdnZXQnLCBhcGlQYXRoLCB7XG4gICAgICAgICAgICAnY29udGVudC10eXBlJzogJ2FwcGxpY2F0aW9uL2pzb24nLFxuICAgICAgICB9LCBwYXlsb2FkKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGUgTUZBIFJlY292ZXJ5IENvZGVzXG4gICAgICpcbiAgICAgKiBHZW5lcmF0ZSByZWNvdmVyeSBjb2RlcyBhcyBiYWNrdXAgZm9yIE1GQSBmbG93LiBJdCdzIHJlY29tbWVuZGVkIHRvXG4gICAgICogZ2VuZXJhdGUgYW5kIHNob3cgdGhlbiBpbW1lZGlhdGVseSBhZnRlciB1c2VyIHN1Y2Nlc3NmdWxseSBhZGRzIHRoZWlyXG4gICAgICogYXV0aGVodGljYXRvci4gUmVjb3ZlcnkgY29kZXMgY2FuIGJlIHVzZWQgYXMgYSBNRkEgdmVyaWZpY2F0aW9uIHR5cGUgaW5cbiAgICAgKiBbY3JlYXRlTWZhQ2hhbGxlbmdlXSgvZG9jcy9yZWZlcmVuY2VzL2Nsb3VkL2NsaWVudC13ZWIvYWNjb3VudCNjcmVhdGVNZmFDaGFsbGVuZ2UpXG4gICAgICogbWV0aG9kLlxuICAgICAqXG4gICAgICogQHRocm93cyB7QXBwd3JpdGVFeGNlcHRpb259XG4gICAgICogQHJldHVybnMge1Byb21pc2V9XG4gICAgICovXG4gICAgYXN5bmMgY3JlYXRlTWZhUmVjb3ZlcnlDb2RlcygpIHtcbiAgICAgICAgY29uc3QgYXBpUGF0aCA9ICcvYWNjb3VudC9tZmEvcmVjb3ZlcnktY29kZXMnO1xuICAgICAgICBsZXQgcGF5bG9hZCA9IHt9O1xuXG4gICAgICAgIHJldHVybiBhd2FpdCB0aGlzLmNsaWVudC5jYWxsKCdwb3N0JywgYXBpUGF0aCwge1xuICAgICAgICAgICAgJ2NvbnRlbnQtdHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJyxcbiAgICAgICAgfSwgcGF5bG9hZCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmVnZW5lcmF0ZSBNRkEgUmVjb3ZlcnkgQ29kZXNcbiAgICAgKlxuICAgICAqIFJlZ2VuZXJhdGUgcmVjb3ZlcnkgY29kZXMgdGhhdCBjYW4gYmUgdXNlZCBhcyBiYWNrdXAgZm9yIE1GQSBmbG93LiBCZWZvcmVcbiAgICAgKiByZWdlbmVyYXRpbmcgY29kZXMsIHRoZXkgbXVzdCBiZSBmaXJzdCBnZW5lcmF0ZWQgdXNpbmdcbiAgICAgKiBbY3JlYXRlTWZhUmVjb3ZlcnlDb2Rlc10oL2RvY3MvcmVmZXJlbmNlcy9jbG91ZC9jbGllbnQtd2ViL2FjY291bnQjY3JlYXRlTWZhUmVjb3ZlcnlDb2RlcylcbiAgICAgKiBtZXRob2QuIEFuIE9UUCBjaGFsbGVuZ2UgaXMgcmVxdWlyZWQgdG8gcmVnZW5yZWF0ZSByZWNvdmVyeSBjb2Rlcy5cbiAgICAgKlxuICAgICAqIEB0aHJvd3Mge0FwcHdyaXRlRXhjZXB0aW9ufVxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlfVxuICAgICAqL1xuICAgIGFzeW5jIHVwZGF0ZU1mYVJlY292ZXJ5Q29kZXMoKSB7XG4gICAgICAgIGNvbnN0IGFwaVBhdGggPSAnL2FjY291bnQvbWZhL3JlY292ZXJ5LWNvZGVzJztcbiAgICAgICAgbGV0IHBheWxvYWQgPSB7fTtcblxuICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy5jbGllbnQuY2FsbCgncGF0Y2gnLCBhcGlQYXRoLCB7XG4gICAgICAgICAgICAnY29udGVudC10eXBlJzogJ2FwcGxpY2F0aW9uL2pzb24nLFxuICAgICAgICB9LCBwYXlsb2FkKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBVcGRhdGUgbmFtZVxuICAgICAqXG4gICAgICogVXBkYXRlIGN1cnJlbnRseSBsb2dnZWQgaW4gdXNlciBhY2NvdW50IG5hbWUuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gbmFtZVxuICAgICAqIEB0aHJvd3Mge0FwcHdyaXRlRXhjZXB0aW9ufVxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlfVxuICAgICAqL1xuICAgIGFzeW5jIHVwZGF0ZU5hbWUobmFtZSkge1xuICAgICAgICBjb25zdCBhcGlQYXRoID0gJy9hY2NvdW50L25hbWUnO1xuICAgICAgICBsZXQgcGF5bG9hZCA9IHt9O1xuICAgICAgICBpZiAodHlwZW9mIG5hbWUgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgQXBwd3JpdGVFeGNlcHRpb24oJ01pc3NpbmcgcmVxdWlyZWQgcGFyYW1ldGVyOiBcIm5hbWVcIicpO1xuICAgICAgICB9XG5cblxuICAgICAgICBpZiAodHlwZW9mIG5hbWUgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICBwYXlsb2FkWyduYW1lJ10gPSBuYW1lO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMuY2xpZW50LmNhbGwoJ3BhdGNoJywgYXBpUGF0aCwge1xuICAgICAgICAgICAgJ2NvbnRlbnQtdHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJyxcbiAgICAgICAgfSwgcGF5bG9hZCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVXBkYXRlIHBhc3N3b3JkXG4gICAgICpcbiAgICAgKiBVcGRhdGUgY3VycmVudGx5IGxvZ2dlZCBpbiB1c2VyIHBhc3N3b3JkLiBGb3IgdmFsaWRhdGlvbiwgdXNlciBpcyByZXF1aXJlZFxuICAgICAqIHRvIHBhc3MgaW4gdGhlIG5ldyBwYXNzd29yZCwgYW5kIHRoZSBvbGQgcGFzc3dvcmQuIEZvciB1c2VycyBjcmVhdGVkIHdpdGhcbiAgICAgKiBPQXV0aCwgVGVhbSBJbnZpdGVzIGFuZCBNYWdpYyBVUkwsIG9sZFBhc3N3b3JkIGlzIG9wdGlvbmFsLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHBhc3N3b3JkXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IG9sZFBhc3N3b3JkXG4gICAgICogQHRocm93cyB7QXBwd3JpdGVFeGNlcHRpb259XG4gICAgICogQHJldHVybnMge1Byb21pc2V9XG4gICAgICovXG4gICAgYXN5bmMgdXBkYXRlUGFzc3dvcmQocGFzc3dvcmQsIG9sZFBhc3N3b3JkKSB7XG4gICAgICAgIGNvbnN0IGFwaVBhdGggPSAnL2FjY291bnQvcGFzc3dvcmQnO1xuICAgICAgICBsZXQgcGF5bG9hZCA9IHt9O1xuICAgICAgICBpZiAodHlwZW9mIHBhc3N3b3JkID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEFwcHdyaXRlRXhjZXB0aW9uKCdNaXNzaW5nIHJlcXVpcmVkIHBhcmFtZXRlcjogXCJwYXNzd29yZFwiJyk7XG4gICAgICAgIH1cblxuXG4gICAgICAgIGlmICh0eXBlb2YgcGFzc3dvcmQgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICBwYXlsb2FkWydwYXNzd29yZCddID0gcGFzc3dvcmQ7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodHlwZW9mIG9sZFBhc3N3b3JkICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgcGF5bG9hZFsnb2xkUGFzc3dvcmQnXSA9IG9sZFBhc3N3b3JkO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMuY2xpZW50LmNhbGwoJ3BhdGNoJywgYXBpUGF0aCwge1xuICAgICAgICAgICAgJ2NvbnRlbnQtdHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJyxcbiAgICAgICAgfSwgcGF5bG9hZCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVXBkYXRlIHBob25lXG4gICAgICpcbiAgICAgKiBVcGRhdGUgdGhlIGN1cnJlbnRseSBsb2dnZWQgaW4gdXNlcidzIHBob25lIG51bWJlci4gQWZ0ZXIgdXBkYXRpbmcgdGhlXG4gICAgICogcGhvbmUgbnVtYmVyLCB0aGUgcGhvbmUgdmVyaWZpY2F0aW9uIHN0YXR1cyB3aWxsIGJlIHJlc2V0LiBBIGNvbmZpcm1hdGlvblxuICAgICAqIFNNUyBpcyBub3Qgc2VudCBhdXRvbWF0aWNhbGx5LCBob3dldmVyIHlvdSBjYW4gdXNlIHRoZSBbUE9TVFxuICAgICAqIC9hY2NvdW50L3ZlcmlmaWNhdGlvbi9waG9uZV0oaHR0cHM6Ly9hcHB3cml0ZS5pby9kb2NzL3JlZmVyZW5jZXMvY2xvdWQvY2xpZW50LXdlYi9hY2NvdW50I2NyZWF0ZVBob25lVmVyaWZpY2F0aW9uKVxuICAgICAqIGVuZHBvaW50IHRvIHNlbmQgYSBjb25maXJtYXRpb24gU01TLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHBob25lXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHBhc3N3b3JkXG4gICAgICogQHRocm93cyB7QXBwd3JpdGVFeGNlcHRpb259XG4gICAgICogQHJldHVybnMge1Byb21pc2V9XG4gICAgICovXG4gICAgYXN5bmMgdXBkYXRlUGhvbmUocGhvbmUsIHBhc3N3b3JkKSB7XG4gICAgICAgIGNvbnN0IGFwaVBhdGggPSAnL2FjY291bnQvcGhvbmUnO1xuICAgICAgICBsZXQgcGF5bG9hZCA9IHt9O1xuICAgICAgICBpZiAodHlwZW9mIHBob25lID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEFwcHdyaXRlRXhjZXB0aW9uKCdNaXNzaW5nIHJlcXVpcmVkIHBhcmFtZXRlcjogXCJwaG9uZVwiJyk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodHlwZW9mIHBhc3N3b3JkID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEFwcHdyaXRlRXhjZXB0aW9uKCdNaXNzaW5nIHJlcXVpcmVkIHBhcmFtZXRlcjogXCJwYXNzd29yZFwiJyk7XG4gICAgICAgIH1cblxuXG4gICAgICAgIGlmICh0eXBlb2YgcGhvbmUgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICBwYXlsb2FkWydwaG9uZSddID0gcGhvbmU7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodHlwZW9mIHBhc3N3b3JkICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgcGF5bG9hZFsncGFzc3dvcmQnXSA9IHBhc3N3b3JkO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMuY2xpZW50LmNhbGwoJ3BhdGNoJywgYXBpUGF0aCwge1xuICAgICAgICAgICAgJ2NvbnRlbnQtdHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJyxcbiAgICAgICAgfSwgcGF5bG9hZCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2V0IGFjY291bnQgcHJlZmVyZW5jZXNcbiAgICAgKlxuICAgICAqIEdldCB0aGUgcHJlZmVyZW5jZXMgYXMgYSBrZXktdmFsdWUgb2JqZWN0IGZvciB0aGUgY3VycmVudGx5IGxvZ2dlZCBpbiB1c2VyLlxuICAgICAqXG4gICAgICogQHRocm93cyB7QXBwd3JpdGVFeGNlcHRpb259XG4gICAgICogQHJldHVybnMge1Byb21pc2V9XG4gICAgICovXG4gICAgYXN5bmMgZ2V0UHJlZnMoKSB7XG4gICAgICAgIGNvbnN0IGFwaVBhdGggPSAnL2FjY291bnQvcHJlZnMnO1xuICAgICAgICBsZXQgcGF5bG9hZCA9IHt9O1xuXG4gICAgICAgIHJldHVybiBhd2FpdCB0aGlzLmNsaWVudC5jYWxsKCdnZXQnLCBhcGlQYXRoLCB7XG4gICAgICAgICAgICAnY29udGVudC10eXBlJzogJ2FwcGxpY2F0aW9uL2pzb24nLFxuICAgICAgICB9LCBwYXlsb2FkKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBVcGRhdGUgcHJlZmVyZW5jZXNcbiAgICAgKlxuICAgICAqIFVwZGF0ZSBjdXJyZW50bHkgbG9nZ2VkIGluIHVzZXIgYWNjb3VudCBwcmVmZXJlbmNlcy4gVGhlIG9iamVjdCB5b3UgcGFzcyBpc1xuICAgICAqIHN0b3JlZCBhcyBpcywgYW5kIHJlcGxhY2VzIGFueSBwcmV2aW91cyB2YWx1ZS4gVGhlIG1heGltdW0gYWxsb3dlZCBwcmVmc1xuICAgICAqIHNpemUgaXMgNjRrQiBhbmQgdGhyb3dzIGVycm9yIGlmIGV4Y2VlZGVkLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtvYmplY3R9IHByZWZzXG4gICAgICogQHRocm93cyB7QXBwd3JpdGVFeGNlcHRpb259XG4gICAgICogQHJldHVybnMge1Byb21pc2V9XG4gICAgICovXG4gICAgYXN5bmMgdXBkYXRlUHJlZnMocHJlZnMpIHtcbiAgICAgICAgY29uc3QgYXBpUGF0aCA9ICcvYWNjb3VudC9wcmVmcyc7XG4gICAgICAgIGxldCBwYXlsb2FkID0ge307XG4gICAgICAgIGlmICh0eXBlb2YgcHJlZnMgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgQXBwd3JpdGVFeGNlcHRpb24oJ01pc3NpbmcgcmVxdWlyZWQgcGFyYW1ldGVyOiBcInByZWZzXCInKTtcbiAgICAgICAgfVxuXG5cbiAgICAgICAgaWYgKHR5cGVvZiBwcmVmcyAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHBheWxvYWRbJ3ByZWZzJ10gPSBwcmVmcztcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBhd2FpdCB0aGlzLmNsaWVudC5jYWxsKCdwYXRjaCcsIGFwaVBhdGgsIHtcbiAgICAgICAgICAgICdjb250ZW50LXR5cGUnOiAnYXBwbGljYXRpb24vanNvbicsXG4gICAgICAgIH0sIHBheWxvYWQpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZSBwYXNzd29yZCByZWNvdmVyeVxuICAgICAqXG4gICAgICogU2VuZHMgdGhlIHVzZXIgYW4gZW1haWwgd2l0aCBhIHRlbXBvcmFyeSBzZWNyZXQga2V5IGZvciBwYXNzd29yZCByZXNldC5cbiAgICAgKiBXaGVuIHRoZSB1c2VyIGNsaWNrcyB0aGUgY29uZmlybWF0aW9uIGxpbmsgaGUgaXMgcmVkaXJlY3RlZCBiYWNrIHRvIHlvdXJcbiAgICAgKiBhcHAgcGFzc3dvcmQgcmVzZXQgVVJMIHdpdGggdGhlIHNlY3JldCBrZXkgYW5kIGVtYWlsIGFkZHJlc3MgdmFsdWVzXG4gICAgICogYXR0YWNoZWQgdG8gdGhlIFVSTCBxdWVyeSBzdHJpbmcuIFVzZSB0aGUgcXVlcnkgc3RyaW5nIHBhcmFtcyB0byBzdWJtaXQgYVxuICAgICAqIHJlcXVlc3QgdG8gdGhlIFtQVVRcbiAgICAgKiAvYWNjb3VudC9yZWNvdmVyeV0oaHR0cHM6Ly9hcHB3cml0ZS5pby9kb2NzL3JlZmVyZW5jZXMvY2xvdWQvY2xpZW50LXdlYi9hY2NvdW50I3VwZGF0ZVJlY292ZXJ5KVxuICAgICAqIGVuZHBvaW50IHRvIGNvbXBsZXRlIHRoZSBwcm9jZXNzLiBUaGUgdmVyaWZpY2F0aW9uIGxpbmsgc2VudCB0byB0aGUgdXNlcidzXG4gICAgICogZW1haWwgYWRkcmVzcyBpcyB2YWxpZCBmb3IgMSBob3VyLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGVtYWlsXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHVybFxuICAgICAqIEB0aHJvd3Mge0FwcHdyaXRlRXhjZXB0aW9ufVxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlfVxuICAgICAqL1xuICAgIGFzeW5jIGNyZWF0ZVJlY292ZXJ5KGVtYWlsLCB1cmwpIHtcbiAgICAgICAgY29uc3QgYXBpUGF0aCA9ICcvYWNjb3VudC9yZWNvdmVyeSc7XG4gICAgICAgIGxldCBwYXlsb2FkID0ge307XG4gICAgICAgIGlmICh0eXBlb2YgZW1haWwgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgQXBwd3JpdGVFeGNlcHRpb24oJ01pc3NpbmcgcmVxdWlyZWQgcGFyYW1ldGVyOiBcImVtYWlsXCInKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0eXBlb2YgdXJsID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEFwcHdyaXRlRXhjZXB0aW9uKCdNaXNzaW5nIHJlcXVpcmVkIHBhcmFtZXRlcjogXCJ1cmxcIicpO1xuICAgICAgICB9XG5cblxuICAgICAgICBpZiAodHlwZW9mIGVtYWlsICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgcGF5bG9hZFsnZW1haWwnXSA9IGVtYWlsO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHR5cGVvZiB1cmwgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICBwYXlsb2FkWyd1cmwnXSA9IHVybDtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBhd2FpdCB0aGlzLmNsaWVudC5jYWxsKCdwb3N0JywgYXBpUGF0aCwge1xuICAgICAgICAgICAgJ2NvbnRlbnQtdHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJyxcbiAgICAgICAgfSwgcGF5bG9hZCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlIHBhc3N3b3JkIHJlY292ZXJ5IChjb25maXJtYXRpb24pXG4gICAgICpcbiAgICAgKiBVc2UgdGhpcyBlbmRwb2ludCB0byBjb21wbGV0ZSB0aGUgdXNlciBhY2NvdW50IHBhc3N3b3JkIHJlc2V0LiBCb3RoIHRoZVxuICAgICAqICoqdXNlcklkKiogYW5kICoqc2VjcmV0KiogYXJndW1lbnRzIHdpbGwgYmUgcGFzc2VkIGFzIHF1ZXJ5IHBhcmFtZXRlcnMgdG9cbiAgICAgKiB0aGUgcmVkaXJlY3QgVVJMIHlvdSBoYXZlIHByb3ZpZGVkIHdoZW4gc2VuZGluZyB5b3VyIHJlcXVlc3QgdG8gdGhlIFtQT1NUXG4gICAgICogL2FjY291bnQvcmVjb3ZlcnldKGh0dHBzOi8vYXBwd3JpdGUuaW8vZG9jcy9yZWZlcmVuY2VzL2Nsb3VkL2NsaWVudC13ZWIvYWNjb3VudCNjcmVhdGVSZWNvdmVyeSlcbiAgICAgKiBlbmRwb2ludC5cbiAgICAgKiBcbiAgICAgKiBQbGVhc2Ugbm90ZSB0aGF0IGluIG9yZGVyIHRvIGF2b2lkIGEgW1JlZGlyZWN0XG4gICAgICogQXR0YWNrXShodHRwczovL2dpdGh1Yi5jb20vT1dBU1AvQ2hlYXRTaGVldFNlcmllcy9ibG9iL21hc3Rlci9jaGVhdHNoZWV0cy9VbnZhbGlkYXRlZF9SZWRpcmVjdHNfYW5kX0ZvcndhcmRzX0NoZWF0X1NoZWV0Lm1kKVxuICAgICAqIHRoZSBvbmx5IHZhbGlkIHJlZGlyZWN0IFVSTHMgYXJlIHRoZSBvbmVzIGZyb20gZG9tYWlucyB5b3UgaGF2ZSBzZXQgd2hlblxuICAgICAqIGFkZGluZyB5b3VyIHBsYXRmb3JtcyBpbiB0aGUgY29uc29sZSBpbnRlcmZhY2UuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gdXNlcklkXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHNlY3JldFxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBwYXNzd29yZFxuICAgICAqIEB0aHJvd3Mge0FwcHdyaXRlRXhjZXB0aW9ufVxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlfVxuICAgICAqL1xuICAgIGFzeW5jIHVwZGF0ZVJlY292ZXJ5KHVzZXJJZCwgc2VjcmV0LCBwYXNzd29yZCkge1xuICAgICAgICBjb25zdCBhcGlQYXRoID0gJy9hY2NvdW50L3JlY292ZXJ5JztcbiAgICAgICAgbGV0IHBheWxvYWQgPSB7fTtcbiAgICAgICAgaWYgKHR5cGVvZiB1c2VySWQgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgQXBwd3JpdGVFeGNlcHRpb24oJ01pc3NpbmcgcmVxdWlyZWQgcGFyYW1ldGVyOiBcInVzZXJJZFwiJyk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodHlwZW9mIHNlY3JldCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBBcHB3cml0ZUV4Y2VwdGlvbignTWlzc2luZyByZXF1aXJlZCBwYXJhbWV0ZXI6IFwic2VjcmV0XCInKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0eXBlb2YgcGFzc3dvcmQgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgQXBwd3JpdGVFeGNlcHRpb24oJ01pc3NpbmcgcmVxdWlyZWQgcGFyYW1ldGVyOiBcInBhc3N3b3JkXCInKTtcbiAgICAgICAgfVxuXG5cbiAgICAgICAgaWYgKHR5cGVvZiB1c2VySWQgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICBwYXlsb2FkWyd1c2VySWQnXSA9IHVzZXJJZDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0eXBlb2Ygc2VjcmV0ICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgcGF5bG9hZFsnc2VjcmV0J10gPSBzZWNyZXQ7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodHlwZW9mIHBhc3N3b3JkICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgcGF5bG9hZFsncGFzc3dvcmQnXSA9IHBhc3N3b3JkO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMuY2xpZW50LmNhbGwoJ3B1dCcsIGFwaVBhdGgsIHtcbiAgICAgICAgICAgICdjb250ZW50LXR5cGUnOiAnYXBwbGljYXRpb24vanNvbicsXG4gICAgICAgIH0sIHBheWxvYWQpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIExpc3Qgc2Vzc2lvbnNcbiAgICAgKlxuICAgICAqIEdldCB0aGUgbGlzdCBvZiBhY3RpdmUgc2Vzc2lvbnMgYWNyb3NzIGRpZmZlcmVudCBkZXZpY2VzIGZvciB0aGUgY3VycmVudGx5XG4gICAgICogbG9nZ2VkIGluIHVzZXIuXG4gICAgICpcbiAgICAgKiBAdGhyb3dzIHtBcHB3cml0ZUV4Y2VwdGlvbn1cbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZX1cbiAgICAgKi9cbiAgICBhc3luYyBsaXN0U2Vzc2lvbnMoKSB7XG4gICAgICAgIGNvbnN0IGFwaVBhdGggPSAnL2FjY291bnQvc2Vzc2lvbnMnO1xuICAgICAgICBsZXQgcGF5bG9hZCA9IHt9O1xuXG4gICAgICAgIHJldHVybiBhd2FpdCB0aGlzLmNsaWVudC5jYWxsKCdnZXQnLCBhcGlQYXRoLCB7XG4gICAgICAgICAgICAnY29udGVudC10eXBlJzogJ2FwcGxpY2F0aW9uL2pzb24nLFxuICAgICAgICB9LCBwYXlsb2FkKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBEZWxldGUgc2Vzc2lvbnNcbiAgICAgKlxuICAgICAqIERlbGV0ZSBhbGwgc2Vzc2lvbnMgZnJvbSB0aGUgdXNlciBhY2NvdW50IGFuZCByZW1vdmUgYW55IHNlc3Npb25zIGNvb2tpZXNcbiAgICAgKiBmcm9tIHRoZSBlbmQgY2xpZW50LlxuICAgICAqXG4gICAgICogQHRocm93cyB7QXBwd3JpdGVFeGNlcHRpb259XG4gICAgICogQHJldHVybnMge1Byb21pc2V9XG4gICAgICovXG4gICAgYXN5bmMgZGVsZXRlU2Vzc2lvbnMoKSB7XG4gICAgICAgIGNvbnN0IGFwaVBhdGggPSAnL2FjY291bnQvc2Vzc2lvbnMnO1xuICAgICAgICBsZXQgcGF5bG9hZCA9IHt9O1xuXG4gICAgICAgIHJldHVybiBhd2FpdCB0aGlzLmNsaWVudC5jYWxsKCdkZWxldGUnLCBhcGlQYXRoLCB7XG4gICAgICAgICAgICAnY29udGVudC10eXBlJzogJ2FwcGxpY2F0aW9uL2pzb24nLFxuICAgICAgICB9LCBwYXlsb2FkKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGUgYW5vbnltb3VzIHNlc3Npb25cbiAgICAgKlxuICAgICAqIFVzZSB0aGlzIGVuZHBvaW50IHRvIGFsbG93IGEgbmV3IHVzZXIgdG8gcmVnaXN0ZXIgYW4gYW5vbnltb3VzIGFjY291bnQgaW5cbiAgICAgKiB5b3VyIHByb2plY3QuIFRoaXMgcm91dGUgd2lsbCBhbHNvIGNyZWF0ZSBhIG5ldyBzZXNzaW9uIGZvciB0aGUgdXNlci4gVG9cbiAgICAgKiBhbGxvdyB0aGUgbmV3IHVzZXIgdG8gY29udmVydCBhbiBhbm9ueW1vdXMgYWNjb3VudCB0byBhIG5vcm1hbCBhY2NvdW50LCB5b3VcbiAgICAgKiBuZWVkIHRvIHVwZGF0ZSBpdHMgW2VtYWlsIGFuZFxuICAgICAqIHBhc3N3b3JkXShodHRwczovL2FwcHdyaXRlLmlvL2RvY3MvcmVmZXJlbmNlcy9jbG91ZC9jbGllbnQtd2ViL2FjY291bnQjdXBkYXRlRW1haWwpXG4gICAgICogb3IgY3JlYXRlIGFuIFtPQXV0aDJcbiAgICAgKiBzZXNzaW9uXShodHRwczovL2FwcHdyaXRlLmlvL2RvY3MvcmVmZXJlbmNlcy9jbG91ZC9jbGllbnQtd2ViL2FjY291bnQjQ3JlYXRlT0F1dGgyU2Vzc2lvbikuXG4gICAgICpcbiAgICAgKiBAdGhyb3dzIHtBcHB3cml0ZUV4Y2VwdGlvbn1cbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZX1cbiAgICAgKi9cbiAgICBhc3luYyBjcmVhdGVBbm9ueW1vdXNTZXNzaW9uKCkge1xuICAgICAgICBjb25zdCBhcGlQYXRoID0gJy9hY2NvdW50L3Nlc3Npb25zL2Fub255bW91cyc7XG4gICAgICAgIGxldCBwYXlsb2FkID0ge307XG5cbiAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMuY2xpZW50LmNhbGwoJ3Bvc3QnLCBhcGlQYXRoLCB7XG4gICAgICAgICAgICAnY29udGVudC10eXBlJzogJ2FwcGxpY2F0aW9uL2pzb24nLFxuICAgICAgICB9LCBwYXlsb2FkKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGUgZW1haWwgcGFzc3dvcmQgc2Vzc2lvblxuICAgICAqXG4gICAgICogQWxsb3cgdGhlIHVzZXIgdG8gbG9naW4gaW50byB0aGVpciBhY2NvdW50IGJ5IHByb3ZpZGluZyBhIHZhbGlkIGVtYWlsIGFuZFxuICAgICAqIHBhc3N3b3JkIGNvbWJpbmF0aW9uLiBUaGlzIHJvdXRlIHdpbGwgY3JlYXRlIGEgbmV3IHNlc3Npb24gZm9yIHRoZSB1c2VyLlxuICAgICAqIFxuICAgICAqIEEgdXNlciBpcyBsaW1pdGVkIHRvIDEwIGFjdGl2ZSBzZXNzaW9ucyBhdCBhIHRpbWUgYnkgZGVmYXVsdC4gW0xlYXJuIG1vcmVcbiAgICAgKiBhYm91dCBzZXNzaW9uXG4gICAgICogbGltaXRzXShodHRwczovL2FwcHdyaXRlLmlvL2RvY3MvYXV0aGVudGljYXRpb24tc2VjdXJpdHkjbGltaXRzKS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBlbWFpbFxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBwYXNzd29yZFxuICAgICAqIEB0aHJvd3Mge0FwcHdyaXRlRXhjZXB0aW9ufVxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlfVxuICAgICAqL1xuICAgIGFzeW5jIGNyZWF0ZUVtYWlsUGFzc3dvcmRTZXNzaW9uKGVtYWlsLCBwYXNzd29yZCkge1xuICAgICAgICBjb25zdCBhcGlQYXRoID0gJy9hY2NvdW50L3Nlc3Npb25zL2VtYWlsJztcbiAgICAgICAgbGV0IHBheWxvYWQgPSB7fTtcbiAgICAgICAgaWYgKHR5cGVvZiBlbWFpbCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBBcHB3cml0ZUV4Y2VwdGlvbignTWlzc2luZyByZXF1aXJlZCBwYXJhbWV0ZXI6IFwiZW1haWxcIicpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHR5cGVvZiBwYXNzd29yZCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBBcHB3cml0ZUV4Y2VwdGlvbignTWlzc2luZyByZXF1aXJlZCBwYXJhbWV0ZXI6IFwicGFzc3dvcmRcIicpO1xuICAgICAgICB9XG5cblxuICAgICAgICBpZiAodHlwZW9mIGVtYWlsICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgcGF5bG9hZFsnZW1haWwnXSA9IGVtYWlsO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHR5cGVvZiBwYXNzd29yZCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHBheWxvYWRbJ3Bhc3N3b3JkJ10gPSBwYXNzd29yZDtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBhd2FpdCB0aGlzLmNsaWVudC5jYWxsKCdwb3N0JywgYXBpUGF0aCwge1xuICAgICAgICAgICAgJ2NvbnRlbnQtdHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJyxcbiAgICAgICAgfSwgcGF5bG9hZCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVXBkYXRlIG1hZ2ljIFVSTCBzZXNzaW9uXG4gICAgICpcbiAgICAgKiBVc2UgdGhpcyBlbmRwb2ludCB0byBjcmVhdGUgYSBzZXNzaW9uIGZyb20gdG9rZW4uIFByb3ZpZGUgdGhlICoqdXNlcklkKipcbiAgICAgKiBhbmQgKipzZWNyZXQqKiBwYXJhbWV0ZXJzIGZyb20gdGhlIHN1Y2Nlc3NmdWwgcmVzcG9uc2Ugb2YgYXV0aGVudGljYXRpb25cbiAgICAgKiBmbG93cyBpbml0aWF0ZWQgYnkgdG9rZW4gY3JlYXRpb24uIEZvciBleGFtcGxlLCBtYWdpYyBVUkwgYW5kIHBob25lIGxvZ2luLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHVzZXJJZFxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBzZWNyZXRcbiAgICAgKiBAdGhyb3dzIHtBcHB3cml0ZUV4Y2VwdGlvbn1cbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZX1cbiAgICAgKi9cbiAgICBhc3luYyB1cGRhdGVNYWdpY1VSTFNlc3Npb24odXNlcklkLCBzZWNyZXQpIHtcbiAgICAgICAgY29uc3QgYXBpUGF0aCA9ICcvYWNjb3VudC9zZXNzaW9ucy9tYWdpYy11cmwnO1xuICAgICAgICBsZXQgcGF5bG9hZCA9IHt9O1xuICAgICAgICBpZiAodHlwZW9mIHVzZXJJZCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBBcHB3cml0ZUV4Y2VwdGlvbignTWlzc2luZyByZXF1aXJlZCBwYXJhbWV0ZXI6IFwidXNlcklkXCInKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0eXBlb2Ygc2VjcmV0ID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEFwcHdyaXRlRXhjZXB0aW9uKCdNaXNzaW5nIHJlcXVpcmVkIHBhcmFtZXRlcjogXCJzZWNyZXRcIicpO1xuICAgICAgICB9XG5cblxuICAgICAgICBpZiAodHlwZW9mIHVzZXJJZCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHBheWxvYWRbJ3VzZXJJZCddID0gdXNlcklkO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHR5cGVvZiBzZWNyZXQgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICBwYXlsb2FkWydzZWNyZXQnXSA9IHNlY3JldDtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBhd2FpdCB0aGlzLmNsaWVudC5jYWxsKCdwdXQnLCBhcGlQYXRoLCB7XG4gICAgICAgICAgICAnY29udGVudC10eXBlJzogJ2FwcGxpY2F0aW9uL2pzb24nLFxuICAgICAgICB9LCBwYXlsb2FkKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBVcGRhdGUgcGhvbmUgc2Vzc2lvblxuICAgICAqXG4gICAgICogVXNlIHRoaXMgZW5kcG9pbnQgdG8gY3JlYXRlIGEgc2Vzc2lvbiBmcm9tIHRva2VuLiBQcm92aWRlIHRoZSAqKnVzZXJJZCoqXG4gICAgICogYW5kICoqc2VjcmV0KiogcGFyYW1ldGVycyBmcm9tIHRoZSBzdWNjZXNzZnVsIHJlc3BvbnNlIG9mIGF1dGhlbnRpY2F0aW9uXG4gICAgICogZmxvd3MgaW5pdGlhdGVkIGJ5IHRva2VuIGNyZWF0aW9uLiBGb3IgZXhhbXBsZSwgbWFnaWMgVVJMIGFuZCBwaG9uZSBsb2dpbi5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSB1c2VySWRcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gc2VjcmV0XG4gICAgICogQHRocm93cyB7QXBwd3JpdGVFeGNlcHRpb259XG4gICAgICogQHJldHVybnMge1Byb21pc2V9XG4gICAgICovXG4gICAgYXN5bmMgdXBkYXRlUGhvbmVTZXNzaW9uKHVzZXJJZCwgc2VjcmV0KSB7XG4gICAgICAgIGNvbnN0IGFwaVBhdGggPSAnL2FjY291bnQvc2Vzc2lvbnMvcGhvbmUnO1xuICAgICAgICBsZXQgcGF5bG9hZCA9IHt9O1xuICAgICAgICBpZiAodHlwZW9mIHVzZXJJZCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBBcHB3cml0ZUV4Y2VwdGlvbignTWlzc2luZyByZXF1aXJlZCBwYXJhbWV0ZXI6IFwidXNlcklkXCInKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0eXBlb2Ygc2VjcmV0ID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEFwcHdyaXRlRXhjZXB0aW9uKCdNaXNzaW5nIHJlcXVpcmVkIHBhcmFtZXRlcjogXCJzZWNyZXRcIicpO1xuICAgICAgICB9XG5cblxuICAgICAgICBpZiAodHlwZW9mIHVzZXJJZCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHBheWxvYWRbJ3VzZXJJZCddID0gdXNlcklkO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHR5cGVvZiBzZWNyZXQgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICBwYXlsb2FkWydzZWNyZXQnXSA9IHNlY3JldDtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBhd2FpdCB0aGlzLmNsaWVudC5jYWxsKCdwdXQnLCBhcGlQYXRoLCB7XG4gICAgICAgICAgICAnY29udGVudC10eXBlJzogJ2FwcGxpY2F0aW9uL2pzb24nLFxuICAgICAgICB9LCBwYXlsb2FkKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGUgc2Vzc2lvblxuICAgICAqXG4gICAgICogVXNlIHRoaXMgZW5kcG9pbnQgdG8gY3JlYXRlIGEgc2Vzc2lvbiBmcm9tIHRva2VuLiBQcm92aWRlIHRoZSAqKnVzZXJJZCoqXG4gICAgICogYW5kICoqc2VjcmV0KiogcGFyYW1ldGVycyBmcm9tIHRoZSBzdWNjZXNzZnVsIHJlc3BvbnNlIG9mIGF1dGhlbnRpY2F0aW9uXG4gICAgICogZmxvd3MgaW5pdGlhdGVkIGJ5IHRva2VuIGNyZWF0aW9uLiBGb3IgZXhhbXBsZSwgbWFnaWMgVVJMIGFuZCBwaG9uZSBsb2dpbi5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSB1c2VySWRcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gc2VjcmV0XG4gICAgICogQHRocm93cyB7QXBwd3JpdGVFeGNlcHRpb259XG4gICAgICogQHJldHVybnMge1Byb21pc2V9XG4gICAgICovXG4gICAgYXN5bmMgY3JlYXRlU2Vzc2lvbih1c2VySWQsIHNlY3JldCkge1xuICAgICAgICBjb25zdCBhcGlQYXRoID0gJy9hY2NvdW50L3Nlc3Npb25zL3Rva2VuJztcbiAgICAgICAgbGV0IHBheWxvYWQgPSB7fTtcbiAgICAgICAgaWYgKHR5cGVvZiB1c2VySWQgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgQXBwd3JpdGVFeGNlcHRpb24oJ01pc3NpbmcgcmVxdWlyZWQgcGFyYW1ldGVyOiBcInVzZXJJZFwiJyk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodHlwZW9mIHNlY3JldCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBBcHB3cml0ZUV4Y2VwdGlvbignTWlzc2luZyByZXF1aXJlZCBwYXJhbWV0ZXI6IFwic2VjcmV0XCInKTtcbiAgICAgICAgfVxuXG5cbiAgICAgICAgaWYgKHR5cGVvZiB1c2VySWQgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICBwYXlsb2FkWyd1c2VySWQnXSA9IHVzZXJJZDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0eXBlb2Ygc2VjcmV0ICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgcGF5bG9hZFsnc2VjcmV0J10gPSBzZWNyZXQ7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy5jbGllbnQuY2FsbCgncG9zdCcsIGFwaVBhdGgsIHtcbiAgICAgICAgICAgICdjb250ZW50LXR5cGUnOiAnYXBwbGljYXRpb24vanNvbicsXG4gICAgICAgIH0sIHBheWxvYWQpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdldCBzZXNzaW9uXG4gICAgICpcbiAgICAgKiBVc2UgdGhpcyBlbmRwb2ludCB0byBnZXQgYSBsb2dnZWQgaW4gdXNlcidzIHNlc3Npb24gdXNpbmcgYSBTZXNzaW9uIElELlxuICAgICAqIElucHV0dGluZyAnY3VycmVudCcgd2lsbCByZXR1cm4gdGhlIGN1cnJlbnQgc2Vzc2lvbiBiZWluZyB1c2VkLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHNlc3Npb25JZFxuICAgICAqIEB0aHJvd3Mge0FwcHdyaXRlRXhjZXB0aW9ufVxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlfVxuICAgICAqL1xuICAgIGFzeW5jIGdldFNlc3Npb24oc2Vzc2lvbklkKSB7XG4gICAgICAgIGNvbnN0IGFwaVBhdGggPSAnL2FjY291bnQvc2Vzc2lvbnMve3Nlc3Npb25JZH0nLnJlcGxhY2UoJ3tzZXNzaW9uSWR9Jywgc2Vzc2lvbklkKTtcbiAgICAgICAgbGV0IHBheWxvYWQgPSB7fTtcbiAgICAgICAgaWYgKHR5cGVvZiBzZXNzaW9uSWQgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgQXBwd3JpdGVFeGNlcHRpb24oJ01pc3NpbmcgcmVxdWlyZWQgcGFyYW1ldGVyOiBcInNlc3Npb25JZFwiJyk7XG4gICAgICAgIH1cblxuXG4gICAgICAgIHJldHVybiBhd2FpdCB0aGlzLmNsaWVudC5jYWxsKCdnZXQnLCBhcGlQYXRoLCB7XG4gICAgICAgICAgICAnY29udGVudC10eXBlJzogJ2FwcGxpY2F0aW9uL2pzb24nLFxuICAgICAgICB9LCBwYXlsb2FkKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBVcGRhdGUgc2Vzc2lvblxuICAgICAqXG4gICAgICogVXNlIHRoaXMgZW5kcG9pbnQgdG8gZXh0ZW5kIGEgc2Vzc2lvbidzIGxlbmd0aC4gRXh0ZW5kaW5nIGEgc2Vzc2lvbiBpc1xuICAgICAqIHVzZWZ1bCB3aGVuIHNlc3Npb24gZXhwaXJ5IGlzIHNob3J0LiBJZiB0aGUgc2Vzc2lvbiB3YXMgY3JlYXRlZCB1c2luZyBhblxuICAgICAqIE9BdXRoIHByb3ZpZGVyLCB0aGlzIGVuZHBvaW50IHJlZnJlc2hlcyB0aGUgYWNjZXNzIHRva2VuIGZyb20gdGhlIHByb3ZpZGVyLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHNlc3Npb25JZFxuICAgICAqIEB0aHJvd3Mge0FwcHdyaXRlRXhjZXB0aW9ufVxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlfVxuICAgICAqL1xuICAgIGFzeW5jIHVwZGF0ZVNlc3Npb24oc2Vzc2lvbklkKSB7XG4gICAgICAgIGNvbnN0IGFwaVBhdGggPSAnL2FjY291bnQvc2Vzc2lvbnMve3Nlc3Npb25JZH0nLnJlcGxhY2UoJ3tzZXNzaW9uSWR9Jywgc2Vzc2lvbklkKTtcbiAgICAgICAgbGV0IHBheWxvYWQgPSB7fTtcbiAgICAgICAgaWYgKHR5cGVvZiBzZXNzaW9uSWQgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgQXBwd3JpdGVFeGNlcHRpb24oJ01pc3NpbmcgcmVxdWlyZWQgcGFyYW1ldGVyOiBcInNlc3Npb25JZFwiJyk7XG4gICAgICAgIH1cblxuXG4gICAgICAgIHJldHVybiBhd2FpdCB0aGlzLmNsaWVudC5jYWxsKCdwYXRjaCcsIGFwaVBhdGgsIHtcbiAgICAgICAgICAgICdjb250ZW50LXR5cGUnOiAnYXBwbGljYXRpb24vanNvbicsXG4gICAgICAgIH0sIHBheWxvYWQpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIERlbGV0ZSBzZXNzaW9uXG4gICAgICpcbiAgICAgKiBMb2dvdXQgdGhlIHVzZXIuIFVzZSAnY3VycmVudCcgYXMgdGhlIHNlc3Npb24gSUQgdG8gbG9nb3V0IG9uIHRoaXMgZGV2aWNlLFxuICAgICAqIHVzZSBhIHNlc3Npb24gSUQgdG8gbG9nb3V0IG9uIGFub3RoZXIgZGV2aWNlLiBJZiB5b3UncmUgbG9va2luZyB0byBsb2dvdXRcbiAgICAgKiB0aGUgdXNlciBvbiBhbGwgZGV2aWNlcywgdXNlIFtEZWxldGVcbiAgICAgKiBTZXNzaW9uc10oaHR0cHM6Ly9hcHB3cml0ZS5pby9kb2NzL3JlZmVyZW5jZXMvY2xvdWQvY2xpZW50LXdlYi9hY2NvdW50I2RlbGV0ZVNlc3Npb25zKVxuICAgICAqIGluc3RlYWQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gc2Vzc2lvbklkXG4gICAgICogQHRocm93cyB7QXBwd3JpdGVFeGNlcHRpb259XG4gICAgICogQHJldHVybnMge1Byb21pc2V9XG4gICAgICovXG4gICAgYXN5bmMgZGVsZXRlU2Vzc2lvbihzZXNzaW9uSWQpIHtcbiAgICAgICAgY29uc3QgYXBpUGF0aCA9ICcvYWNjb3VudC9zZXNzaW9ucy97c2Vzc2lvbklkfScucmVwbGFjZSgne3Nlc3Npb25JZH0nLCBzZXNzaW9uSWQpO1xuICAgICAgICBsZXQgcGF5bG9hZCA9IHt9O1xuICAgICAgICBpZiAodHlwZW9mIHNlc3Npb25JZCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBBcHB3cml0ZUV4Y2VwdGlvbignTWlzc2luZyByZXF1aXJlZCBwYXJhbWV0ZXI6IFwic2Vzc2lvbklkXCInKTtcbiAgICAgICAgfVxuXG5cbiAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMuY2xpZW50LmNhbGwoJ2RlbGV0ZScsIGFwaVBhdGgsIHtcbiAgICAgICAgICAgICdjb250ZW50LXR5cGUnOiAnYXBwbGljYXRpb24vanNvbicsXG4gICAgICAgIH0sIHBheWxvYWQpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFVwZGF0ZSBzdGF0dXNcbiAgICAgKlxuICAgICAqIEJsb2NrIHRoZSBjdXJyZW50bHkgbG9nZ2VkIGluIHVzZXIgYWNjb3VudC4gQmVoaW5kIHRoZSBzY2VuZSwgdGhlIHVzZXJcbiAgICAgKiByZWNvcmQgaXMgbm90IGRlbGV0ZWQgYnV0IHBlcm1hbmVudGx5IGJsb2NrZWQgZnJvbSBhbnkgYWNjZXNzLiBUb1xuICAgICAqIGNvbXBsZXRlbHkgZGVsZXRlIGEgdXNlciwgdXNlIHRoZSBVc2VycyBBUEkgaW5zdGVhZC5cbiAgICAgKlxuICAgICAqIEB0aHJvd3Mge0FwcHdyaXRlRXhjZXB0aW9ufVxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlfVxuICAgICAqL1xuICAgIGFzeW5jIHVwZGF0ZVN0YXR1cygpIHtcbiAgICAgICAgY29uc3QgYXBpUGF0aCA9ICcvYWNjb3VudC9zdGF0dXMnO1xuICAgICAgICBsZXQgcGF5bG9hZCA9IHt9O1xuXG4gICAgICAgIHJldHVybiBhd2FpdCB0aGlzLmNsaWVudC5jYWxsKCdwYXRjaCcsIGFwaVBhdGgsIHtcbiAgICAgICAgICAgICdjb250ZW50LXR5cGUnOiAnYXBwbGljYXRpb24vanNvbicsXG4gICAgICAgIH0sIHBheWxvYWQpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZSBlbWFpbCB0b2tlbiAoT1RQKVxuICAgICAqXG4gICAgICogU2VuZHMgdGhlIHVzZXIgYW4gZW1haWwgd2l0aCBhIHNlY3JldCBrZXkgZm9yIGNyZWF0aW5nIGEgc2Vzc2lvbi4gSWYgdGhlXG4gICAgICogcHJvdmlkZWQgdXNlciBJRCBoYXMgbm90IGJlIHJlZ2lzdGVyZWQsIGEgbmV3IHVzZXIgd2lsbCBiZSBjcmVhdGVkLiBVc2UgdGhlXG4gICAgICogcmV0dXJuZWQgdXNlciBJRCBhbmQgc2VjcmV0IGFuZCBzdWJtaXQgYSByZXF1ZXN0IHRvIHRoZSBbUE9TVFxuICAgICAqIC92MS9hY2NvdW50L3Nlc3Npb25zL3Rva2VuXShodHRwczovL2FwcHdyaXRlLmlvL2RvY3MvcmVmZXJlbmNlcy9jbG91ZC9jbGllbnQtd2ViL2FjY291bnQjY3JlYXRlU2Vzc2lvbilcbiAgICAgKiBlbmRwb2ludCB0byBjb21wbGV0ZSB0aGUgbG9naW4gcHJvY2Vzcy4gVGhlIHNlY3JldCBzZW50IHRvIHRoZSB1c2VyJ3MgZW1haWxcbiAgICAgKiBpcyB2YWxpZCBmb3IgMTUgbWludXRlcy5cbiAgICAgKiBcbiAgICAgKiBBIHVzZXIgaXMgbGltaXRlZCB0byAxMCBhY3RpdmUgc2Vzc2lvbnMgYXQgYSB0aW1lIGJ5IGRlZmF1bHQuIFtMZWFybiBtb3JlXG4gICAgICogYWJvdXQgc2Vzc2lvblxuICAgICAqIGxpbWl0c10oaHR0cHM6Ly9hcHB3cml0ZS5pby9kb2NzL2F1dGhlbnRpY2F0aW9uLXNlY3VyaXR5I2xpbWl0cykuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gdXNlcklkXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGVtYWlsXG4gICAgICogQHBhcmFtIHtib29sZWFufSBwaHJhc2VcbiAgICAgKiBAdGhyb3dzIHtBcHB3cml0ZUV4Y2VwdGlvbn1cbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZX1cbiAgICAgKi9cbiAgICBhc3luYyBjcmVhdGVFbWFpbFRva2VuKHVzZXJJZCwgZW1haWwsIHBocmFzZSkge1xuICAgICAgICBjb25zdCBhcGlQYXRoID0gJy9hY2NvdW50L3Rva2Vucy9lbWFpbCc7XG4gICAgICAgIGxldCBwYXlsb2FkID0ge307XG4gICAgICAgIGlmICh0eXBlb2YgdXNlcklkID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEFwcHdyaXRlRXhjZXB0aW9uKCdNaXNzaW5nIHJlcXVpcmVkIHBhcmFtZXRlcjogXCJ1c2VySWRcIicpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHR5cGVvZiBlbWFpbCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBBcHB3cml0ZUV4Y2VwdGlvbignTWlzc2luZyByZXF1aXJlZCBwYXJhbWV0ZXI6IFwiZW1haWxcIicpO1xuICAgICAgICB9XG5cblxuICAgICAgICBpZiAodHlwZW9mIHVzZXJJZCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHBheWxvYWRbJ3VzZXJJZCddID0gdXNlcklkO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHR5cGVvZiBlbWFpbCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHBheWxvYWRbJ2VtYWlsJ10gPSBlbWFpbDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0eXBlb2YgcGhyYXNlICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgcGF5bG9hZFsncGhyYXNlJ10gPSBwaHJhc2U7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy5jbGllbnQuY2FsbCgncG9zdCcsIGFwaVBhdGgsIHtcbiAgICAgICAgICAgICdjb250ZW50LXR5cGUnOiAnYXBwbGljYXRpb24vanNvbicsXG4gICAgICAgIH0sIHBheWxvYWQpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZSBtYWdpYyBVUkwgdG9rZW5cbiAgICAgKlxuICAgICAqIFNlbmRzIHRoZSB1c2VyIGFuIGVtYWlsIHdpdGggYSBzZWNyZXQga2V5IGZvciBjcmVhdGluZyBhIHNlc3Npb24uIElmIHRoZVxuICAgICAqIHByb3ZpZGVkIHVzZXIgSUQgaGFzIG5vdCBiZWVuIHJlZ2lzdGVyZWQsIGEgbmV3IHVzZXIgd2lsbCBiZSBjcmVhdGVkLiBXaGVuXG4gICAgICogdGhlIHVzZXIgY2xpY2tzIHRoZSBsaW5rIGluIHRoZSBlbWFpbCwgdGhlIHVzZXIgaXMgcmVkaXJlY3RlZCBiYWNrIHRvIHRoZVxuICAgICAqIFVSTCB5b3UgcHJvdmlkZWQgd2l0aCB0aGUgc2VjcmV0IGtleSBhbmQgdXNlcklkIHZhbHVlcyBhdHRhY2hlZCB0byB0aGUgVVJMXG4gICAgICogcXVlcnkgc3RyaW5nLiBVc2UgdGhlIHF1ZXJ5IHN0cmluZyBwYXJhbWV0ZXJzIHRvIHN1Ym1pdCBhIHJlcXVlc3QgdG8gdGhlXG4gICAgICogW1BPU1RcbiAgICAgKiAvdjEvYWNjb3VudC9zZXNzaW9ucy90b2tlbl0oaHR0cHM6Ly9hcHB3cml0ZS5pby9kb2NzL3JlZmVyZW5jZXMvY2xvdWQvY2xpZW50LXdlYi9hY2NvdW50I2NyZWF0ZVNlc3Npb24pXG4gICAgICogZW5kcG9pbnQgdG8gY29tcGxldGUgdGhlIGxvZ2luIHByb2Nlc3MuIFRoZSBsaW5rIHNlbnQgdG8gdGhlIHVzZXIncyBlbWFpbFxuICAgICAqIGFkZHJlc3MgaXMgdmFsaWQgZm9yIDEgaG91ci4gSWYgeW91IGFyZSBvbiBhIG1vYmlsZSBkZXZpY2UgeW91IGNhbiBsZWF2ZVxuICAgICAqIHRoZSBVUkwgcGFyYW1ldGVyIGVtcHR5LCBzbyB0aGF0IHRoZSBsb2dpbiBjb21wbGV0aW9uIHdpbGwgYmUgaGFuZGxlZCBieVxuICAgICAqIHlvdXIgQXBwd3JpdGUgaW5zdGFuY2UgYnkgZGVmYXVsdC5cbiAgICAgKiBcbiAgICAgKiBBIHVzZXIgaXMgbGltaXRlZCB0byAxMCBhY3RpdmUgc2Vzc2lvbnMgYXQgYSB0aW1lIGJ5IGRlZmF1bHQuIFtMZWFybiBtb3JlXG4gICAgICogYWJvdXQgc2Vzc2lvblxuICAgICAqIGxpbWl0c10oaHR0cHM6Ly9hcHB3cml0ZS5pby9kb2NzL2F1dGhlbnRpY2F0aW9uLXNlY3VyaXR5I2xpbWl0cykuXG4gICAgICogXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gdXNlcklkXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGVtYWlsXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHVybFxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gcGhyYXNlXG4gICAgICogQHRocm93cyB7QXBwd3JpdGVFeGNlcHRpb259XG4gICAgICogQHJldHVybnMge1Byb21pc2V9XG4gICAgICovXG4gICAgYXN5bmMgY3JlYXRlTWFnaWNVUkxUb2tlbih1c2VySWQsIGVtYWlsLCB1cmwsIHBocmFzZSkge1xuICAgICAgICBjb25zdCBhcGlQYXRoID0gJy9hY2NvdW50L3Rva2Vucy9tYWdpYy11cmwnO1xuICAgICAgICBsZXQgcGF5bG9hZCA9IHt9O1xuICAgICAgICBpZiAodHlwZW9mIHVzZXJJZCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBBcHB3cml0ZUV4Y2VwdGlvbignTWlzc2luZyByZXF1aXJlZCBwYXJhbWV0ZXI6IFwidXNlcklkXCInKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0eXBlb2YgZW1haWwgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgQXBwd3JpdGVFeGNlcHRpb24oJ01pc3NpbmcgcmVxdWlyZWQgcGFyYW1ldGVyOiBcImVtYWlsXCInKTtcbiAgICAgICAgfVxuXG5cbiAgICAgICAgaWYgKHR5cGVvZiB1c2VySWQgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICBwYXlsb2FkWyd1c2VySWQnXSA9IHVzZXJJZDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0eXBlb2YgZW1haWwgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICBwYXlsb2FkWydlbWFpbCddID0gZW1haWw7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodHlwZW9mIHVybCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHBheWxvYWRbJ3VybCddID0gdXJsO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHR5cGVvZiBwaHJhc2UgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICBwYXlsb2FkWydwaHJhc2UnXSA9IHBocmFzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBhd2FpdCB0aGlzLmNsaWVudC5jYWxsKCdwb3N0JywgYXBpUGF0aCwge1xuICAgICAgICAgICAgJ2NvbnRlbnQtdHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJyxcbiAgICAgICAgfSwgcGF5bG9hZCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlIE9BdXRoMiB0b2tlblxuICAgICAqXG4gICAgICogQWxsb3cgdGhlIHVzZXIgdG8gbG9naW4gdG8gdGhlaXIgYWNjb3VudCB1c2luZyB0aGUgT0F1dGgyIHByb3ZpZGVyIG9mIHRoZWlyXG4gICAgICogY2hvaWNlLiBFYWNoIE9BdXRoMiBwcm92aWRlciBzaG91bGQgYmUgZW5hYmxlZCBmcm9tIHRoZSBBcHB3cml0ZSBjb25zb2xlXG4gICAgICogZmlyc3QuIFVzZSB0aGUgc3VjY2VzcyBhbmQgZmFpbHVyZSBhcmd1bWVudHMgdG8gcHJvdmlkZSBhIHJlZGlyZWN0IFVSTCdzXG4gICAgICogYmFjayB0byB5b3VyIGFwcCB3aGVuIGxvZ2luIGlzIGNvbXBsZXRlZC4gXG4gICAgICogXG4gICAgICogSWYgYXV0aGVudGljYXRpb24gc3VjY2VlZHMsIGB1c2VySWRgIGFuZCBgc2VjcmV0YCBvZiBhIHRva2VuIHdpbGwgYmVcbiAgICAgKiBhcHBlbmRlZCB0byB0aGUgc3VjY2VzcyBVUkwgYXMgcXVlcnkgcGFyYW1ldGVycy4gVGhlc2UgY2FuIGJlIHVzZWQgdG9cbiAgICAgKiBjcmVhdGUgYSBuZXcgc2Vzc2lvbiB1c2luZyB0aGUgW0NyZWF0ZVxuICAgICAqIHNlc3Npb25dKGh0dHBzOi8vYXBwd3JpdGUuaW8vZG9jcy9yZWZlcmVuY2VzL2Nsb3VkL2NsaWVudC13ZWIvYWNjb3VudCNjcmVhdGVTZXNzaW9uKVxuICAgICAqIGVuZHBvaW50LlxuICAgICAqIFxuICAgICAqIEEgdXNlciBpcyBsaW1pdGVkIHRvIDEwIGFjdGl2ZSBzZXNzaW9ucyBhdCBhIHRpbWUgYnkgZGVmYXVsdC4gW0xlYXJuIG1vcmVcbiAgICAgKiBhYm91dCBzZXNzaW9uXG4gICAgICogbGltaXRzXShodHRwczovL2FwcHdyaXRlLmlvL2RvY3MvYXV0aGVudGljYXRpb24tc2VjdXJpdHkjbGltaXRzKS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7T0F1dGhQcm92aWRlcn0gcHJvdmlkZXJcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gc3VjY2Vzc1xuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBmYWlsdXJlXG4gICAgICogQHBhcmFtIHtzdHJpbmdbXX0gc2NvcGVzXG4gICAgICogQHRocm93cyB7QXBwd3JpdGVFeGNlcHRpb259XG4gICAgICogQHJldHVybnMge1Byb21pc2V9XG4gICAgICovXG4gICAgYXN5bmMgY3JlYXRlT0F1dGgyVG9rZW4ocHJvdmlkZXIsIHN1Y2Nlc3MsIGZhaWx1cmUsIHNjb3Blcykge1xuICAgICAgICBjb25zdCBhcGlQYXRoID0gJy9hY2NvdW50L3Rva2Vucy9vYXV0aDIve3Byb3ZpZGVyfScucmVwbGFjZSgne3Byb3ZpZGVyfScsIHByb3ZpZGVyKTtcbiAgICAgICAgbGV0IHBheWxvYWQgPSB7fTtcbiAgICAgICAgaWYgKHR5cGVvZiBwcm92aWRlciA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBBcHB3cml0ZUV4Y2VwdGlvbignTWlzc2luZyByZXF1aXJlZCBwYXJhbWV0ZXI6IFwicHJvdmlkZXJcIicpO1xuICAgICAgICB9XG5cblxuICAgICAgICBpZiAodHlwZW9mIHN1Y2Nlc3MgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICBwYXlsb2FkWydzdWNjZXNzJ10gPSBzdWNjZXNzO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHR5cGVvZiBmYWlsdXJlICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgcGF5bG9hZFsnZmFpbHVyZSddID0gZmFpbHVyZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0eXBlb2Ygc2NvcGVzICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgcGF5bG9hZFsnc2NvcGVzJ10gPSBzY29wZXM7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy5jbGllbnQuY2FsbCgnZ2V0JywgYXBpUGF0aCwge1xuICAgICAgICAgICAgJ2NvbnRlbnQtdHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJyxcbiAgICAgICAgfSwgcGF5bG9hZCwgJ2xvY2F0aW9uJyk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlIHBob25lIHRva2VuXG4gICAgICpcbiAgICAgKiBTZW5kcyB0aGUgdXNlciBhbiBTTVMgd2l0aCBhIHNlY3JldCBrZXkgZm9yIGNyZWF0aW5nIGEgc2Vzc2lvbi4gSWYgdGhlXG4gICAgICogcHJvdmlkZWQgdXNlciBJRCBoYXMgbm90IGJlIHJlZ2lzdGVyZWQsIGEgbmV3IHVzZXIgd2lsbCBiZSBjcmVhdGVkLiBVc2UgdGhlXG4gICAgICogcmV0dXJuZWQgdXNlciBJRCBhbmQgc2VjcmV0IGFuZCBzdWJtaXQgYSByZXF1ZXN0IHRvIHRoZSBbUE9TVFxuICAgICAqIC92MS9hY2NvdW50L3Nlc3Npb25zL3Rva2VuXShodHRwczovL2FwcHdyaXRlLmlvL2RvY3MvcmVmZXJlbmNlcy9jbG91ZC9jbGllbnQtd2ViL2FjY291bnQjY3JlYXRlU2Vzc2lvbilcbiAgICAgKiBlbmRwb2ludCB0byBjb21wbGV0ZSB0aGUgbG9naW4gcHJvY2Vzcy4gVGhlIHNlY3JldCBzZW50IHRvIHRoZSB1c2VyJ3MgcGhvbmVcbiAgICAgKiBpcyB2YWxpZCBmb3IgMTUgbWludXRlcy5cbiAgICAgKiBcbiAgICAgKiBBIHVzZXIgaXMgbGltaXRlZCB0byAxMCBhY3RpdmUgc2Vzc2lvbnMgYXQgYSB0aW1lIGJ5IGRlZmF1bHQuIFtMZWFybiBtb3JlXG4gICAgICogYWJvdXQgc2Vzc2lvblxuICAgICAqIGxpbWl0c10oaHR0cHM6Ly9hcHB3cml0ZS5pby9kb2NzL2F1dGhlbnRpY2F0aW9uLXNlY3VyaXR5I2xpbWl0cykuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gdXNlcklkXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHBob25lXG4gICAgICogQHRocm93cyB7QXBwd3JpdGVFeGNlcHRpb259XG4gICAgICogQHJldHVybnMge1Byb21pc2V9XG4gICAgICovXG4gICAgYXN5bmMgY3JlYXRlUGhvbmVUb2tlbih1c2VySWQsIHBob25lKSB7XG4gICAgICAgIGNvbnN0IGFwaVBhdGggPSAnL2FjY291bnQvdG9rZW5zL3Bob25lJztcbiAgICAgICAgbGV0IHBheWxvYWQgPSB7fTtcbiAgICAgICAgaWYgKHR5cGVvZiB1c2VySWQgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgQXBwd3JpdGVFeGNlcHRpb24oJ01pc3NpbmcgcmVxdWlyZWQgcGFyYW1ldGVyOiBcInVzZXJJZFwiJyk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodHlwZW9mIHBob25lID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEFwcHdyaXRlRXhjZXB0aW9uKCdNaXNzaW5nIHJlcXVpcmVkIHBhcmFtZXRlcjogXCJwaG9uZVwiJyk7XG4gICAgICAgIH1cblxuXG4gICAgICAgIGlmICh0eXBlb2YgdXNlcklkICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgcGF5bG9hZFsndXNlcklkJ10gPSB1c2VySWQ7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodHlwZW9mIHBob25lICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgcGF5bG9hZFsncGhvbmUnXSA9IHBob25lO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMuY2xpZW50LmNhbGwoJ3Bvc3QnLCBhcGlQYXRoLCB7XG4gICAgICAgICAgICAnY29udGVudC10eXBlJzogJ2FwcGxpY2F0aW9uL2pzb24nLFxuICAgICAgICB9LCBwYXlsb2FkKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGUgZW1haWwgdmVyaWZpY2F0aW9uXG4gICAgICpcbiAgICAgKiBVc2UgdGhpcyBlbmRwb2ludCB0byBzZW5kIGEgdmVyaWZpY2F0aW9uIG1lc3NhZ2UgdG8geW91ciB1c2VyIGVtYWlsIGFkZHJlc3NcbiAgICAgKiB0byBjb25maXJtIHRoZXkgYXJlIHRoZSB2YWxpZCBvd25lcnMgb2YgdGhhdCBhZGRyZXNzLiBCb3RoIHRoZSAqKnVzZXJJZCoqXG4gICAgICogYW5kICoqc2VjcmV0KiogYXJndW1lbnRzIHdpbGwgYmUgcGFzc2VkIGFzIHF1ZXJ5IHBhcmFtZXRlcnMgdG8gdGhlIFVSTCB5b3VcbiAgICAgKiBoYXZlIHByb3ZpZGVkIHRvIGJlIGF0dGFjaGVkIHRvIHRoZSB2ZXJpZmljYXRpb24gZW1haWwuIFRoZSBwcm92aWRlZCBVUkxcbiAgICAgKiBzaG91bGQgcmVkaXJlY3QgdGhlIHVzZXIgYmFjayB0byB5b3VyIGFwcCBhbmQgYWxsb3cgeW91IHRvIGNvbXBsZXRlIHRoZVxuICAgICAqIHZlcmlmaWNhdGlvbiBwcm9jZXNzIGJ5IHZlcmlmeWluZyBib3RoIHRoZSAqKnVzZXJJZCoqIGFuZCAqKnNlY3JldCoqXG4gICAgICogcGFyYW1ldGVycy4gTGVhcm4gbW9yZSBhYm91dCBob3cgdG8gW2NvbXBsZXRlIHRoZSB2ZXJpZmljYXRpb25cbiAgICAgKiBwcm9jZXNzXShodHRwczovL2FwcHdyaXRlLmlvL2RvY3MvcmVmZXJlbmNlcy9jbG91ZC9jbGllbnQtd2ViL2FjY291bnQjdXBkYXRlVmVyaWZpY2F0aW9uKS5cbiAgICAgKiBUaGUgdmVyaWZpY2F0aW9uIGxpbmsgc2VudCB0byB0aGUgdXNlcidzIGVtYWlsIGFkZHJlc3MgaXMgdmFsaWQgZm9yIDcgZGF5cy5cbiAgICAgKiBcbiAgICAgKiBQbGVhc2Ugbm90ZSB0aGF0IGluIG9yZGVyIHRvIGF2b2lkIGEgW1JlZGlyZWN0XG4gICAgICogQXR0YWNrXShodHRwczovL2dpdGh1Yi5jb20vT1dBU1AvQ2hlYXRTaGVldFNlcmllcy9ibG9iL21hc3Rlci9jaGVhdHNoZWV0cy9VbnZhbGlkYXRlZF9SZWRpcmVjdHNfYW5kX0ZvcndhcmRzX0NoZWF0X1NoZWV0Lm1kKSxcbiAgICAgKiB0aGUgb25seSB2YWxpZCByZWRpcmVjdCBVUkxzIGFyZSB0aGUgb25lcyBmcm9tIGRvbWFpbnMgeW91IGhhdmUgc2V0IHdoZW5cbiAgICAgKiBhZGRpbmcgeW91ciBwbGF0Zm9ybXMgaW4gdGhlIGNvbnNvbGUgaW50ZXJmYWNlLlxuICAgICAqIFxuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHVybFxuICAgICAqIEB0aHJvd3Mge0FwcHdyaXRlRXhjZXB0aW9ufVxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlfVxuICAgICAqL1xuICAgIGFzeW5jIGNyZWF0ZVZlcmlmaWNhdGlvbih1cmwpIHtcbiAgICAgICAgY29uc3QgYXBpUGF0aCA9ICcvYWNjb3VudC92ZXJpZmljYXRpb24nO1xuICAgICAgICBsZXQgcGF5bG9hZCA9IHt9O1xuICAgICAgICBpZiAodHlwZW9mIHVybCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBBcHB3cml0ZUV4Y2VwdGlvbignTWlzc2luZyByZXF1aXJlZCBwYXJhbWV0ZXI6IFwidXJsXCInKTtcbiAgICAgICAgfVxuXG5cbiAgICAgICAgaWYgKHR5cGVvZiB1cmwgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICBwYXlsb2FkWyd1cmwnXSA9IHVybDtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBhd2FpdCB0aGlzLmNsaWVudC5jYWxsKCdwb3N0JywgYXBpUGF0aCwge1xuICAgICAgICAgICAgJ2NvbnRlbnQtdHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJyxcbiAgICAgICAgfSwgcGF5bG9hZCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlIGVtYWlsIHZlcmlmaWNhdGlvbiAoY29uZmlybWF0aW9uKVxuICAgICAqXG4gICAgICogVXNlIHRoaXMgZW5kcG9pbnQgdG8gY29tcGxldGUgdGhlIHVzZXIgZW1haWwgdmVyaWZpY2F0aW9uIHByb2Nlc3MuIFVzZSBib3RoXG4gICAgICogdGhlICoqdXNlcklkKiogYW5kICoqc2VjcmV0KiogcGFyYW1ldGVycyB0aGF0IHdlcmUgYXR0YWNoZWQgdG8geW91ciBhcHAgVVJMXG4gICAgICogdG8gdmVyaWZ5IHRoZSB1c2VyIGVtYWlsIG93bmVyc2hpcC4gSWYgY29uZmlybWVkIHRoaXMgcm91dGUgd2lsbCByZXR1cm4gYVxuICAgICAqIDIwMCBzdGF0dXMgY29kZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSB1c2VySWRcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gc2VjcmV0XG4gICAgICogQHRocm93cyB7QXBwd3JpdGVFeGNlcHRpb259XG4gICAgICogQHJldHVybnMge1Byb21pc2V9XG4gICAgICovXG4gICAgYXN5bmMgdXBkYXRlVmVyaWZpY2F0aW9uKHVzZXJJZCwgc2VjcmV0KSB7XG4gICAgICAgIGNvbnN0IGFwaVBhdGggPSAnL2FjY291bnQvdmVyaWZpY2F0aW9uJztcbiAgICAgICAgbGV0IHBheWxvYWQgPSB7fTtcbiAgICAgICAgaWYgKHR5cGVvZiB1c2VySWQgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgQXBwd3JpdGVFeGNlcHRpb24oJ01pc3NpbmcgcmVxdWlyZWQgcGFyYW1ldGVyOiBcInVzZXJJZFwiJyk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodHlwZW9mIHNlY3JldCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBBcHB3cml0ZUV4Y2VwdGlvbignTWlzc2luZyByZXF1aXJlZCBwYXJhbWV0ZXI6IFwic2VjcmV0XCInKTtcbiAgICAgICAgfVxuXG5cbiAgICAgICAgaWYgKHR5cGVvZiB1c2VySWQgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICBwYXlsb2FkWyd1c2VySWQnXSA9IHVzZXJJZDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0eXBlb2Ygc2VjcmV0ICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgcGF5bG9hZFsnc2VjcmV0J10gPSBzZWNyZXQ7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy5jbGllbnQuY2FsbCgncHV0JywgYXBpUGF0aCwge1xuICAgICAgICAgICAgJ2NvbnRlbnQtdHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJyxcbiAgICAgICAgfSwgcGF5bG9hZCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlIHBob25lIHZlcmlmaWNhdGlvblxuICAgICAqXG4gICAgICogVXNlIHRoaXMgZW5kcG9pbnQgdG8gc2VuZCBhIHZlcmlmaWNhdGlvbiBTTVMgdG8gdGhlIGN1cnJlbnRseSBsb2dnZWQgaW5cbiAgICAgKiB1c2VyLiBUaGlzIGVuZHBvaW50IGlzIG1lYW50IGZvciB1c2UgYWZ0ZXIgdXBkYXRpbmcgYSB1c2VyJ3MgcGhvbmUgbnVtYmVyXG4gICAgICogdXNpbmcgdGhlXG4gICAgICogW2FjY291bnRVcGRhdGVQaG9uZV0oaHR0cHM6Ly9hcHB3cml0ZS5pby9kb2NzL3JlZmVyZW5jZXMvY2xvdWQvY2xpZW50LXdlYi9hY2NvdW50I3VwZGF0ZVBob25lKVxuICAgICAqIGVuZHBvaW50LiBMZWFybiBtb3JlIGFib3V0IGhvdyB0byBbY29tcGxldGUgdGhlIHZlcmlmaWNhdGlvblxuICAgICAqIHByb2Nlc3NdKGh0dHBzOi8vYXBwd3JpdGUuaW8vZG9jcy9yZWZlcmVuY2VzL2Nsb3VkL2NsaWVudC13ZWIvYWNjb3VudCN1cGRhdGVQaG9uZVZlcmlmaWNhdGlvbikuXG4gICAgICogVGhlIHZlcmlmaWNhdGlvbiBjb2RlIHNlbnQgdG8gdGhlIHVzZXIncyBwaG9uZSBudW1iZXIgaXMgdmFsaWQgZm9yIDE1XG4gICAgICogbWludXRlcy5cbiAgICAgKlxuICAgICAqIEB0aHJvd3Mge0FwcHdyaXRlRXhjZXB0aW9ufVxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlfVxuICAgICAqL1xuICAgIGFzeW5jIGNyZWF0ZVBob25lVmVyaWZpY2F0aW9uKCkge1xuICAgICAgICBjb25zdCBhcGlQYXRoID0gJy9hY2NvdW50L3ZlcmlmaWNhdGlvbi9waG9uZSc7XG4gICAgICAgIGxldCBwYXlsb2FkID0ge307XG5cbiAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMuY2xpZW50LmNhbGwoJ3Bvc3QnLCBhcGlQYXRoLCB7XG4gICAgICAgICAgICAnY29udGVudC10eXBlJzogJ2FwcGxpY2F0aW9uL2pzb24nLFxuICAgICAgICB9LCBwYXlsb2FkKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGUgcGhvbmUgdmVyaWZpY2F0aW9uIChjb25maXJtYXRpb24pXG4gICAgICpcbiAgICAgKiBVc2UgdGhpcyBlbmRwb2ludCB0byBjb21wbGV0ZSB0aGUgdXNlciBwaG9uZSB2ZXJpZmljYXRpb24gcHJvY2Vzcy4gVXNlIHRoZVxuICAgICAqICoqdXNlcklkKiogYW5kICoqc2VjcmV0KiogdGhhdCB3ZXJlIHNlbnQgdG8geW91ciB1c2VyJ3MgcGhvbmUgbnVtYmVyIHRvXG4gICAgICogdmVyaWZ5IHRoZSB1c2VyIGVtYWlsIG93bmVyc2hpcC4gSWYgY29uZmlybWVkIHRoaXMgcm91dGUgd2lsbCByZXR1cm4gYSAyMDBcbiAgICAgKiBzdGF0dXMgY29kZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSB1c2VySWRcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gc2VjcmV0XG4gICAgICogQHRocm93cyB7QXBwd3JpdGVFeGNlcHRpb259XG4gICAgICogQHJldHVybnMge1Byb21pc2V9XG4gICAgICovXG4gICAgYXN5bmMgdXBkYXRlUGhvbmVWZXJpZmljYXRpb24odXNlcklkLCBzZWNyZXQpIHtcbiAgICAgICAgY29uc3QgYXBpUGF0aCA9ICcvYWNjb3VudC92ZXJpZmljYXRpb24vcGhvbmUnO1xuICAgICAgICBsZXQgcGF5bG9hZCA9IHt9O1xuICAgICAgICBpZiAodHlwZW9mIHVzZXJJZCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBBcHB3cml0ZUV4Y2VwdGlvbignTWlzc2luZyByZXF1aXJlZCBwYXJhbWV0ZXI6IFwidXNlcklkXCInKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0eXBlb2Ygc2VjcmV0ID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEFwcHdyaXRlRXhjZXB0aW9uKCdNaXNzaW5nIHJlcXVpcmVkIHBhcmFtZXRlcjogXCJzZWNyZXRcIicpO1xuICAgICAgICB9XG5cblxuICAgICAgICBpZiAodHlwZW9mIHVzZXJJZCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHBheWxvYWRbJ3VzZXJJZCddID0gdXNlcklkO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHR5cGVvZiBzZWNyZXQgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICBwYXlsb2FkWydzZWNyZXQnXSA9IHNlY3JldDtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBhd2FpdCB0aGlzLmNsaWVudC5jYWxsKCdwdXQnLCBhcGlQYXRoLCB7XG4gICAgICAgICAgICAnY29udGVudC10eXBlJzogJ2FwcGxpY2F0aW9uL2pzb24nLFxuICAgICAgICB9LCBwYXlsb2FkKTtcbiAgICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gQWNjb3VudDtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/node-appwrite/lib/services/account.js\n");

/***/ }),

/***/ "(action-browser)/./node_modules/node-appwrite/lib/services/avatars.js":
/*!************************************************************!*\
  !*** ./node_modules/node-appwrite/lib/services/avatars.js ***!
  \************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("const Service = __webpack_require__(/*! ../service.js */ \"(action-browser)/./node_modules/node-appwrite/lib/service.js\");\nconst AppwriteException = __webpack_require__(/*! ../exception.js */ \"(action-browser)/./node_modules/node-appwrite/lib/exception.js\");\nconst InputFile = __webpack_require__(/*! ../inputFile.js */ \"(action-browser)/./node_modules/node-appwrite/lib/inputFile.js\");\nconst client = __webpack_require__(/*! ../client.js */ \"(action-browser)/./node_modules/node-appwrite/lib/client.js\");\nconst Stream = __webpack_require__(/*! stream */ \"stream\");\nconst { promisify } = __webpack_require__(/*! util */ \"util\");\nconst fs = __webpack_require__(/*! fs */ \"fs\");\nconst { File } = __webpack_require__(/*! undici */ \"undici\");\nconst Query = __webpack_require__(/*! ../query.js */ \"(action-browser)/./node_modules/node-appwrite/lib/query.js\");\n\nclass Avatars extends Service {\n\n     constructor(client)\n     {\n        super(client);\n     }\n\n\n    /**\n     * Get browser icon\n     *\n     * You can use this endpoint to show different browser icons to your users.\n     * The code argument receives the browser code as it appears in your user [GET\n     * /account/sessions](https://appwrite.io/docs/references/cloud/client-web/account#getSessions)\n     * endpoint. Use width, height and quality arguments to change the output\n     * settings.\n     * \n     * When one dimension is specified and the other is 0, the image is scaled\n     * with preserved aspect ratio. If both dimensions are 0, the API provides an\n     * image at source quality. If dimensions are not specified, the default size\n     * of image returned is 100x100px.\n     *\n     * @param {Browser} code\n     * @param {number} width\n     * @param {number} height\n     * @param {number} quality\n     * @throws {AppwriteException}\n     * @returns {Promise}\n     */\n    async getBrowser(code, width, height, quality) {\n        const apiPath = '/avatars/browsers/{code}'.replace('{code}', code);\n        let payload = {};\n        if (typeof code === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"code\"');\n        }\n\n\n        if (typeof width !== 'undefined') {\n            payload['width'] = width;\n        }\n\n        if (typeof height !== 'undefined') {\n            payload['height'] = height;\n        }\n\n        if (typeof quality !== 'undefined') {\n            payload['quality'] = quality;\n        }\n\n        return await this.client.call('get', apiPath, {\n            'content-type': 'application/json',\n        }, payload, 'arraybuffer');\n    }\n\n    /**\n     * Get credit card icon\n     *\n     * The credit card endpoint will return you the icon of the credit card\n     * provider you need. Use width, height and quality arguments to change the\n     * output settings.\n     * \n     * When one dimension is specified and the other is 0, the image is scaled\n     * with preserved aspect ratio. If both dimensions are 0, the API provides an\n     * image at source quality. If dimensions are not specified, the default size\n     * of image returned is 100x100px.\n     * \n     *\n     * @param {CreditCard} code\n     * @param {number} width\n     * @param {number} height\n     * @param {number} quality\n     * @throws {AppwriteException}\n     * @returns {Promise}\n     */\n    async getCreditCard(code, width, height, quality) {\n        const apiPath = '/avatars/credit-cards/{code}'.replace('{code}', code);\n        let payload = {};\n        if (typeof code === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"code\"');\n        }\n\n\n        if (typeof width !== 'undefined') {\n            payload['width'] = width;\n        }\n\n        if (typeof height !== 'undefined') {\n            payload['height'] = height;\n        }\n\n        if (typeof quality !== 'undefined') {\n            payload['quality'] = quality;\n        }\n\n        return await this.client.call('get', apiPath, {\n            'content-type': 'application/json',\n        }, payload, 'arraybuffer');\n    }\n\n    /**\n     * Get favicon\n     *\n     * Use this endpoint to fetch the favorite icon (AKA favicon) of any remote\n     * website URL.\n     * \n     *\n     * @param {string} url\n     * @throws {AppwriteException}\n     * @returns {Promise}\n     */\n    async getFavicon(url) {\n        const apiPath = '/avatars/favicon';\n        let payload = {};\n        if (typeof url === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"url\"');\n        }\n\n\n        if (typeof url !== 'undefined') {\n            payload['url'] = url;\n        }\n\n        return await this.client.call('get', apiPath, {\n            'content-type': 'application/json',\n        }, payload, 'arraybuffer');\n    }\n\n    /**\n     * Get country flag\n     *\n     * You can use this endpoint to show different country flags icons to your\n     * users. The code argument receives the 2 letter country code. Use width,\n     * height and quality arguments to change the output settings. Country codes\n     * follow the [ISO 3166-1](https://en.wikipedia.org/wiki/ISO_3166-1) standard.\n     * \n     * When one dimension is specified and the other is 0, the image is scaled\n     * with preserved aspect ratio. If both dimensions are 0, the API provides an\n     * image at source quality. If dimensions are not specified, the default size\n     * of image returned is 100x100px.\n     * \n     *\n     * @param {Flag} code\n     * @param {number} width\n     * @param {number} height\n     * @param {number} quality\n     * @throws {AppwriteException}\n     * @returns {Promise}\n     */\n    async getFlag(code, width, height, quality) {\n        const apiPath = '/avatars/flags/{code}'.replace('{code}', code);\n        let payload = {};\n        if (typeof code === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"code\"');\n        }\n\n\n        if (typeof width !== 'undefined') {\n            payload['width'] = width;\n        }\n\n        if (typeof height !== 'undefined') {\n            payload['height'] = height;\n        }\n\n        if (typeof quality !== 'undefined') {\n            payload['quality'] = quality;\n        }\n\n        return await this.client.call('get', apiPath, {\n            'content-type': 'application/json',\n        }, payload, 'arraybuffer');\n    }\n\n    /**\n     * Get image from URL\n     *\n     * Use this endpoint to fetch a remote image URL and crop it to any image size\n     * you want. This endpoint is very useful if you need to crop and display\n     * remote images in your app or in case you want to make sure a 3rd party\n     * image is properly served using a TLS protocol.\n     * \n     * When one dimension is specified and the other is 0, the image is scaled\n     * with preserved aspect ratio. If both dimensions are 0, the API provides an\n     * image at source quality. If dimensions are not specified, the default size\n     * of image returned is 400x400px.\n     * \n     *\n     * @param {string} url\n     * @param {number} width\n     * @param {number} height\n     * @throws {AppwriteException}\n     * @returns {Promise}\n     */\n    async getImage(url, width, height) {\n        const apiPath = '/avatars/image';\n        let payload = {};\n        if (typeof url === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"url\"');\n        }\n\n\n        if (typeof url !== 'undefined') {\n            payload['url'] = url;\n        }\n\n        if (typeof width !== 'undefined') {\n            payload['width'] = width;\n        }\n\n        if (typeof height !== 'undefined') {\n            payload['height'] = height;\n        }\n\n        return await this.client.call('get', apiPath, {\n            'content-type': 'application/json',\n        }, payload, 'arraybuffer');\n    }\n\n    /**\n     * Get user initials\n     *\n     * Use this endpoint to show your user initials avatar icon on your website or\n     * app. By default, this route will try to print your logged-in user name or\n     * email initials. You can also overwrite the user name if you pass the 'name'\n     * parameter. If no name is given and no user is logged, an empty avatar will\n     * be returned.\n     * \n     * You can use the color and background params to change the avatar colors. By\n     * default, a random theme will be selected. The random theme will persist for\n     * the user's initials when reloading the same theme will always return for\n     * the same initials.\n     * \n     * When one dimension is specified and the other is 0, the image is scaled\n     * with preserved aspect ratio. If both dimensions are 0, the API provides an\n     * image at source quality. If dimensions are not specified, the default size\n     * of image returned is 100x100px.\n     * \n     *\n     * @param {string} name\n     * @param {number} width\n     * @param {number} height\n     * @param {string} background\n     * @throws {AppwriteException}\n     * @returns {Promise}\n     */\n    async getInitials(name, width, height, background) {\n        const apiPath = '/avatars/initials';\n        let payload = {};\n\n        if (typeof name !== 'undefined') {\n            payload['name'] = name;\n        }\n\n        if (typeof width !== 'undefined') {\n            payload['width'] = width;\n        }\n\n        if (typeof height !== 'undefined') {\n            payload['height'] = height;\n        }\n\n        if (typeof background !== 'undefined') {\n            payload['background'] = background;\n        }\n\n        return await this.client.call('get', apiPath, {\n            'content-type': 'application/json',\n        }, payload, 'arraybuffer');\n    }\n\n    /**\n     * Get QR code\n     *\n     * Converts a given plain text to a QR code image. You can use the query\n     * parameters to change the size and style of the resulting image.\n     * \n     *\n     * @param {string} text\n     * @param {number} size\n     * @param {number} margin\n     * @param {boolean} download\n     * @throws {AppwriteException}\n     * @returns {Promise}\n     */\n    async getQR(text, size, margin, download) {\n        const apiPath = '/avatars/qr';\n        let payload = {};\n        if (typeof text === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"text\"');\n        }\n\n\n        if (typeof text !== 'undefined') {\n            payload['text'] = text;\n        }\n\n        if (typeof size !== 'undefined') {\n            payload['size'] = size;\n        }\n\n        if (typeof margin !== 'undefined') {\n            payload['margin'] = margin;\n        }\n\n        if (typeof download !== 'undefined') {\n            payload['download'] = download;\n        }\n\n        return await this.client.call('get', apiPath, {\n            'content-type': 'application/json',\n        }, payload, 'arraybuffer');\n    }\n}\n\nmodule.exports = Avatars;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFjdGlvbi1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9ub2RlLWFwcHdyaXRlL2xpYi9zZXJ2aWNlcy9hdmF0YXJzLmpzIiwibWFwcGluZ3MiOiJBQUFBLGdCQUFnQixtQkFBTyxDQUFDLG1GQUFlO0FBQ3ZDLDBCQUEwQixtQkFBTyxDQUFDLHVGQUFpQjtBQUNuRCxrQkFBa0IsbUJBQU8sQ0FBQyx1RkFBaUI7QUFDM0MsZUFBZSxtQkFBTyxDQUFDLGlGQUFjO0FBQ3JDLGVBQWUsbUJBQU8sQ0FBQyxzQkFBUTtBQUMvQixRQUFRLFlBQVksRUFBRSxtQkFBTyxDQUFDLGtCQUFNO0FBQ3BDLFdBQVcsbUJBQU8sQ0FBQyxjQUFJO0FBQ3ZCLFFBQVEsT0FBTyxFQUFFLG1CQUFPLENBQUMsc0JBQVE7QUFDakMsY0FBYyxtQkFBTyxDQUFDLCtFQUFhOztBQUVuQzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsU0FBUztBQUN4QixlQUFlLFFBQVE7QUFDdkIsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsUUFBUTtBQUN2QixnQkFBZ0I7QUFDaEIsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQSw0Q0FBNEMsS0FBSyxZQUFZLEtBQUs7QUFDbEU7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFlBQVk7QUFDM0IsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsUUFBUTtBQUN2QixlQUFlLFFBQVE7QUFDdkIsZ0JBQWdCO0FBQ2hCLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0EsZ0RBQWdELEtBQUssWUFBWSxLQUFLO0FBQ3RFO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsU0FBUztBQUNUOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCLGdCQUFnQjtBQUNoQixpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsU0FBUztBQUNUOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLE1BQU07QUFDckIsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsUUFBUTtBQUN2QixlQUFlLFFBQVE7QUFDdkIsZ0JBQWdCO0FBQ2hCLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0EseUNBQXlDLEtBQUssWUFBWSxLQUFLO0FBQy9EO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsU0FBUztBQUNUOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkIsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsUUFBUTtBQUN2QixnQkFBZ0I7QUFDaEIsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsU0FBUztBQUNUOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkIsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsUUFBUTtBQUN2QixlQUFlLFFBQVE7QUFDdkIsZ0JBQWdCO0FBQ2hCLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFNBQVM7QUFDVDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QixlQUFlLFFBQVE7QUFDdkIsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsU0FBUztBQUN4QixnQkFBZ0I7QUFDaEIsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBOztBQUVBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vanNtX2JhbmtpbmcvLi9ub2RlX21vZHVsZXMvbm9kZS1hcHB3cml0ZS9saWIvc2VydmljZXMvYXZhdGFycy5qcz9lMzliIl0sInNvdXJjZXNDb250ZW50IjpbImNvbnN0IFNlcnZpY2UgPSByZXF1aXJlKCcuLi9zZXJ2aWNlLmpzJyk7XG5jb25zdCBBcHB3cml0ZUV4Y2VwdGlvbiA9IHJlcXVpcmUoJy4uL2V4Y2VwdGlvbi5qcycpO1xuY29uc3QgSW5wdXRGaWxlID0gcmVxdWlyZSgnLi4vaW5wdXRGaWxlLmpzJyk7XG5jb25zdCBjbGllbnQgPSByZXF1aXJlKCcuLi9jbGllbnQuanMnKTtcbmNvbnN0IFN0cmVhbSA9IHJlcXVpcmUoJ3N0cmVhbScpO1xuY29uc3QgeyBwcm9taXNpZnkgfSA9IHJlcXVpcmUoJ3V0aWwnKTtcbmNvbnN0IGZzID0gcmVxdWlyZSgnZnMnKTtcbmNvbnN0IHsgRmlsZSB9ID0gcmVxdWlyZSgndW5kaWNpJyk7XG5jb25zdCBRdWVyeSA9IHJlcXVpcmUoJy4uL3F1ZXJ5LmpzJyk7XG5cbmNsYXNzIEF2YXRhcnMgZXh0ZW5kcyBTZXJ2aWNlIHtcblxuICAgICBjb25zdHJ1Y3RvcihjbGllbnQpXG4gICAgIHtcbiAgICAgICAgc3VwZXIoY2xpZW50KTtcbiAgICAgfVxuXG5cbiAgICAvKipcbiAgICAgKiBHZXQgYnJvd3NlciBpY29uXG4gICAgICpcbiAgICAgKiBZb3UgY2FuIHVzZSB0aGlzIGVuZHBvaW50IHRvIHNob3cgZGlmZmVyZW50IGJyb3dzZXIgaWNvbnMgdG8geW91ciB1c2Vycy5cbiAgICAgKiBUaGUgY29kZSBhcmd1bWVudCByZWNlaXZlcyB0aGUgYnJvd3NlciBjb2RlIGFzIGl0IGFwcGVhcnMgaW4geW91ciB1c2VyIFtHRVRcbiAgICAgKiAvYWNjb3VudC9zZXNzaW9uc10oaHR0cHM6Ly9hcHB3cml0ZS5pby9kb2NzL3JlZmVyZW5jZXMvY2xvdWQvY2xpZW50LXdlYi9hY2NvdW50I2dldFNlc3Npb25zKVxuICAgICAqIGVuZHBvaW50LiBVc2Ugd2lkdGgsIGhlaWdodCBhbmQgcXVhbGl0eSBhcmd1bWVudHMgdG8gY2hhbmdlIHRoZSBvdXRwdXRcbiAgICAgKiBzZXR0aW5ncy5cbiAgICAgKiBcbiAgICAgKiBXaGVuIG9uZSBkaW1lbnNpb24gaXMgc3BlY2lmaWVkIGFuZCB0aGUgb3RoZXIgaXMgMCwgdGhlIGltYWdlIGlzIHNjYWxlZFxuICAgICAqIHdpdGggcHJlc2VydmVkIGFzcGVjdCByYXRpby4gSWYgYm90aCBkaW1lbnNpb25zIGFyZSAwLCB0aGUgQVBJIHByb3ZpZGVzIGFuXG4gICAgICogaW1hZ2UgYXQgc291cmNlIHF1YWxpdHkuIElmIGRpbWVuc2lvbnMgYXJlIG5vdCBzcGVjaWZpZWQsIHRoZSBkZWZhdWx0IHNpemVcbiAgICAgKiBvZiBpbWFnZSByZXR1cm5lZCBpcyAxMDB4MTAwcHguXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0Jyb3dzZXJ9IGNvZGVcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gd2lkdGhcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gaGVpZ2h0XG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHF1YWxpdHlcbiAgICAgKiBAdGhyb3dzIHtBcHB3cml0ZUV4Y2VwdGlvbn1cbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZX1cbiAgICAgKi9cbiAgICBhc3luYyBnZXRCcm93c2VyKGNvZGUsIHdpZHRoLCBoZWlnaHQsIHF1YWxpdHkpIHtcbiAgICAgICAgY29uc3QgYXBpUGF0aCA9ICcvYXZhdGFycy9icm93c2Vycy97Y29kZX0nLnJlcGxhY2UoJ3tjb2RlfScsIGNvZGUpO1xuICAgICAgICBsZXQgcGF5bG9hZCA9IHt9O1xuICAgICAgICBpZiAodHlwZW9mIGNvZGUgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgQXBwd3JpdGVFeGNlcHRpb24oJ01pc3NpbmcgcmVxdWlyZWQgcGFyYW1ldGVyOiBcImNvZGVcIicpO1xuICAgICAgICB9XG5cblxuICAgICAgICBpZiAodHlwZW9mIHdpZHRoICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgcGF5bG9hZFsnd2lkdGgnXSA9IHdpZHRoO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHR5cGVvZiBoZWlnaHQgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICBwYXlsb2FkWydoZWlnaHQnXSA9IGhlaWdodDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0eXBlb2YgcXVhbGl0eSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHBheWxvYWRbJ3F1YWxpdHknXSA9IHF1YWxpdHk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy5jbGllbnQuY2FsbCgnZ2V0JywgYXBpUGF0aCwge1xuICAgICAgICAgICAgJ2NvbnRlbnQtdHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJyxcbiAgICAgICAgfSwgcGF5bG9hZCwgJ2FycmF5YnVmZmVyJyk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2V0IGNyZWRpdCBjYXJkIGljb25cbiAgICAgKlxuICAgICAqIFRoZSBjcmVkaXQgY2FyZCBlbmRwb2ludCB3aWxsIHJldHVybiB5b3UgdGhlIGljb24gb2YgdGhlIGNyZWRpdCBjYXJkXG4gICAgICogcHJvdmlkZXIgeW91IG5lZWQuIFVzZSB3aWR0aCwgaGVpZ2h0IGFuZCBxdWFsaXR5IGFyZ3VtZW50cyB0byBjaGFuZ2UgdGhlXG4gICAgICogb3V0cHV0IHNldHRpbmdzLlxuICAgICAqIFxuICAgICAqIFdoZW4gb25lIGRpbWVuc2lvbiBpcyBzcGVjaWZpZWQgYW5kIHRoZSBvdGhlciBpcyAwLCB0aGUgaW1hZ2UgaXMgc2NhbGVkXG4gICAgICogd2l0aCBwcmVzZXJ2ZWQgYXNwZWN0IHJhdGlvLiBJZiBib3RoIGRpbWVuc2lvbnMgYXJlIDAsIHRoZSBBUEkgcHJvdmlkZXMgYW5cbiAgICAgKiBpbWFnZSBhdCBzb3VyY2UgcXVhbGl0eS4gSWYgZGltZW5zaW9ucyBhcmUgbm90IHNwZWNpZmllZCwgdGhlIGRlZmF1bHQgc2l6ZVxuICAgICAqIG9mIGltYWdlIHJldHVybmVkIGlzIDEwMHgxMDBweC5cbiAgICAgKiBcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7Q3JlZGl0Q2FyZH0gY29kZVxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB3aWR0aFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBoZWlnaHRcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gcXVhbGl0eVxuICAgICAqIEB0aHJvd3Mge0FwcHdyaXRlRXhjZXB0aW9ufVxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlfVxuICAgICAqL1xuICAgIGFzeW5jIGdldENyZWRpdENhcmQoY29kZSwgd2lkdGgsIGhlaWdodCwgcXVhbGl0eSkge1xuICAgICAgICBjb25zdCBhcGlQYXRoID0gJy9hdmF0YXJzL2NyZWRpdC1jYXJkcy97Y29kZX0nLnJlcGxhY2UoJ3tjb2RlfScsIGNvZGUpO1xuICAgICAgICBsZXQgcGF5bG9hZCA9IHt9O1xuICAgICAgICBpZiAodHlwZW9mIGNvZGUgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgQXBwd3JpdGVFeGNlcHRpb24oJ01pc3NpbmcgcmVxdWlyZWQgcGFyYW1ldGVyOiBcImNvZGVcIicpO1xuICAgICAgICB9XG5cblxuICAgICAgICBpZiAodHlwZW9mIHdpZHRoICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgcGF5bG9hZFsnd2lkdGgnXSA9IHdpZHRoO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHR5cGVvZiBoZWlnaHQgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICBwYXlsb2FkWydoZWlnaHQnXSA9IGhlaWdodDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0eXBlb2YgcXVhbGl0eSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHBheWxvYWRbJ3F1YWxpdHknXSA9IHF1YWxpdHk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy5jbGllbnQuY2FsbCgnZ2V0JywgYXBpUGF0aCwge1xuICAgICAgICAgICAgJ2NvbnRlbnQtdHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJyxcbiAgICAgICAgfSwgcGF5bG9hZCwgJ2FycmF5YnVmZmVyJyk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2V0IGZhdmljb25cbiAgICAgKlxuICAgICAqIFVzZSB0aGlzIGVuZHBvaW50IHRvIGZldGNoIHRoZSBmYXZvcml0ZSBpY29uIChBS0EgZmF2aWNvbikgb2YgYW55IHJlbW90ZVxuICAgICAqIHdlYnNpdGUgVVJMLlxuICAgICAqIFxuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHVybFxuICAgICAqIEB0aHJvd3Mge0FwcHdyaXRlRXhjZXB0aW9ufVxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlfVxuICAgICAqL1xuICAgIGFzeW5jIGdldEZhdmljb24odXJsKSB7XG4gICAgICAgIGNvbnN0IGFwaVBhdGggPSAnL2F2YXRhcnMvZmF2aWNvbic7XG4gICAgICAgIGxldCBwYXlsb2FkID0ge307XG4gICAgICAgIGlmICh0eXBlb2YgdXJsID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEFwcHdyaXRlRXhjZXB0aW9uKCdNaXNzaW5nIHJlcXVpcmVkIHBhcmFtZXRlcjogXCJ1cmxcIicpO1xuICAgICAgICB9XG5cblxuICAgICAgICBpZiAodHlwZW9mIHVybCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHBheWxvYWRbJ3VybCddID0gdXJsO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMuY2xpZW50LmNhbGwoJ2dldCcsIGFwaVBhdGgsIHtcbiAgICAgICAgICAgICdjb250ZW50LXR5cGUnOiAnYXBwbGljYXRpb24vanNvbicsXG4gICAgICAgIH0sIHBheWxvYWQsICdhcnJheWJ1ZmZlcicpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdldCBjb3VudHJ5IGZsYWdcbiAgICAgKlxuICAgICAqIFlvdSBjYW4gdXNlIHRoaXMgZW5kcG9pbnQgdG8gc2hvdyBkaWZmZXJlbnQgY291bnRyeSBmbGFncyBpY29ucyB0byB5b3VyXG4gICAgICogdXNlcnMuIFRoZSBjb2RlIGFyZ3VtZW50IHJlY2VpdmVzIHRoZSAyIGxldHRlciBjb3VudHJ5IGNvZGUuIFVzZSB3aWR0aCxcbiAgICAgKiBoZWlnaHQgYW5kIHF1YWxpdHkgYXJndW1lbnRzIHRvIGNoYW5nZSB0aGUgb3V0cHV0IHNldHRpbmdzLiBDb3VudHJ5IGNvZGVzXG4gICAgICogZm9sbG93IHRoZSBbSVNPIDMxNjYtMV0oaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvSVNPXzMxNjYtMSkgc3RhbmRhcmQuXG4gICAgICogXG4gICAgICogV2hlbiBvbmUgZGltZW5zaW9uIGlzIHNwZWNpZmllZCBhbmQgdGhlIG90aGVyIGlzIDAsIHRoZSBpbWFnZSBpcyBzY2FsZWRcbiAgICAgKiB3aXRoIHByZXNlcnZlZCBhc3BlY3QgcmF0aW8uIElmIGJvdGggZGltZW5zaW9ucyBhcmUgMCwgdGhlIEFQSSBwcm92aWRlcyBhblxuICAgICAqIGltYWdlIGF0IHNvdXJjZSBxdWFsaXR5LiBJZiBkaW1lbnNpb25zIGFyZSBub3Qgc3BlY2lmaWVkLCB0aGUgZGVmYXVsdCBzaXplXG4gICAgICogb2YgaW1hZ2UgcmV0dXJuZWQgaXMgMTAweDEwMHB4LlxuICAgICAqIFxuICAgICAqXG4gICAgICogQHBhcmFtIHtGbGFnfSBjb2RlXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHdpZHRoXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGhlaWdodFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBxdWFsaXR5XG4gICAgICogQHRocm93cyB7QXBwd3JpdGVFeGNlcHRpb259XG4gICAgICogQHJldHVybnMge1Byb21pc2V9XG4gICAgICovXG4gICAgYXN5bmMgZ2V0RmxhZyhjb2RlLCB3aWR0aCwgaGVpZ2h0LCBxdWFsaXR5KSB7XG4gICAgICAgIGNvbnN0IGFwaVBhdGggPSAnL2F2YXRhcnMvZmxhZ3Mve2NvZGV9Jy5yZXBsYWNlKCd7Y29kZX0nLCBjb2RlKTtcbiAgICAgICAgbGV0IHBheWxvYWQgPSB7fTtcbiAgICAgICAgaWYgKHR5cGVvZiBjb2RlID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEFwcHdyaXRlRXhjZXB0aW9uKCdNaXNzaW5nIHJlcXVpcmVkIHBhcmFtZXRlcjogXCJjb2RlXCInKTtcbiAgICAgICAgfVxuXG5cbiAgICAgICAgaWYgKHR5cGVvZiB3aWR0aCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHBheWxvYWRbJ3dpZHRoJ10gPSB3aWR0aDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0eXBlb2YgaGVpZ2h0ICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgcGF5bG9hZFsnaGVpZ2h0J10gPSBoZWlnaHQ7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodHlwZW9mIHF1YWxpdHkgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICBwYXlsb2FkWydxdWFsaXR5J10gPSBxdWFsaXR5O1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMuY2xpZW50LmNhbGwoJ2dldCcsIGFwaVBhdGgsIHtcbiAgICAgICAgICAgICdjb250ZW50LXR5cGUnOiAnYXBwbGljYXRpb24vanNvbicsXG4gICAgICAgIH0sIHBheWxvYWQsICdhcnJheWJ1ZmZlcicpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdldCBpbWFnZSBmcm9tIFVSTFxuICAgICAqXG4gICAgICogVXNlIHRoaXMgZW5kcG9pbnQgdG8gZmV0Y2ggYSByZW1vdGUgaW1hZ2UgVVJMIGFuZCBjcm9wIGl0IHRvIGFueSBpbWFnZSBzaXplXG4gICAgICogeW91IHdhbnQuIFRoaXMgZW5kcG9pbnQgaXMgdmVyeSB1c2VmdWwgaWYgeW91IG5lZWQgdG8gY3JvcCBhbmQgZGlzcGxheVxuICAgICAqIHJlbW90ZSBpbWFnZXMgaW4geW91ciBhcHAgb3IgaW4gY2FzZSB5b3Ugd2FudCB0byBtYWtlIHN1cmUgYSAzcmQgcGFydHlcbiAgICAgKiBpbWFnZSBpcyBwcm9wZXJseSBzZXJ2ZWQgdXNpbmcgYSBUTFMgcHJvdG9jb2wuXG4gICAgICogXG4gICAgICogV2hlbiBvbmUgZGltZW5zaW9uIGlzIHNwZWNpZmllZCBhbmQgdGhlIG90aGVyIGlzIDAsIHRoZSBpbWFnZSBpcyBzY2FsZWRcbiAgICAgKiB3aXRoIHByZXNlcnZlZCBhc3BlY3QgcmF0aW8uIElmIGJvdGggZGltZW5zaW9ucyBhcmUgMCwgdGhlIEFQSSBwcm92aWRlcyBhblxuICAgICAqIGltYWdlIGF0IHNvdXJjZSBxdWFsaXR5LiBJZiBkaW1lbnNpb25zIGFyZSBub3Qgc3BlY2lmaWVkLCB0aGUgZGVmYXVsdCBzaXplXG4gICAgICogb2YgaW1hZ2UgcmV0dXJuZWQgaXMgNDAweDQwMHB4LlxuICAgICAqIFxuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHVybFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB3aWR0aFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBoZWlnaHRcbiAgICAgKiBAdGhyb3dzIHtBcHB3cml0ZUV4Y2VwdGlvbn1cbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZX1cbiAgICAgKi9cbiAgICBhc3luYyBnZXRJbWFnZSh1cmwsIHdpZHRoLCBoZWlnaHQpIHtcbiAgICAgICAgY29uc3QgYXBpUGF0aCA9ICcvYXZhdGFycy9pbWFnZSc7XG4gICAgICAgIGxldCBwYXlsb2FkID0ge307XG4gICAgICAgIGlmICh0eXBlb2YgdXJsID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEFwcHdyaXRlRXhjZXB0aW9uKCdNaXNzaW5nIHJlcXVpcmVkIHBhcmFtZXRlcjogXCJ1cmxcIicpO1xuICAgICAgICB9XG5cblxuICAgICAgICBpZiAodHlwZW9mIHVybCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHBheWxvYWRbJ3VybCddID0gdXJsO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHR5cGVvZiB3aWR0aCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHBheWxvYWRbJ3dpZHRoJ10gPSB3aWR0aDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0eXBlb2YgaGVpZ2h0ICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgcGF5bG9hZFsnaGVpZ2h0J10gPSBoZWlnaHQ7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy5jbGllbnQuY2FsbCgnZ2V0JywgYXBpUGF0aCwge1xuICAgICAgICAgICAgJ2NvbnRlbnQtdHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJyxcbiAgICAgICAgfSwgcGF5bG9hZCwgJ2FycmF5YnVmZmVyJyk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2V0IHVzZXIgaW5pdGlhbHNcbiAgICAgKlxuICAgICAqIFVzZSB0aGlzIGVuZHBvaW50IHRvIHNob3cgeW91ciB1c2VyIGluaXRpYWxzIGF2YXRhciBpY29uIG9uIHlvdXIgd2Vic2l0ZSBvclxuICAgICAqIGFwcC4gQnkgZGVmYXVsdCwgdGhpcyByb3V0ZSB3aWxsIHRyeSB0byBwcmludCB5b3VyIGxvZ2dlZC1pbiB1c2VyIG5hbWUgb3JcbiAgICAgKiBlbWFpbCBpbml0aWFscy4gWW91IGNhbiBhbHNvIG92ZXJ3cml0ZSB0aGUgdXNlciBuYW1lIGlmIHlvdSBwYXNzIHRoZSAnbmFtZSdcbiAgICAgKiBwYXJhbWV0ZXIuIElmIG5vIG5hbWUgaXMgZ2l2ZW4gYW5kIG5vIHVzZXIgaXMgbG9nZ2VkLCBhbiBlbXB0eSBhdmF0YXIgd2lsbFxuICAgICAqIGJlIHJldHVybmVkLlxuICAgICAqIFxuICAgICAqIFlvdSBjYW4gdXNlIHRoZSBjb2xvciBhbmQgYmFja2dyb3VuZCBwYXJhbXMgdG8gY2hhbmdlIHRoZSBhdmF0YXIgY29sb3JzLiBCeVxuICAgICAqIGRlZmF1bHQsIGEgcmFuZG9tIHRoZW1lIHdpbGwgYmUgc2VsZWN0ZWQuIFRoZSByYW5kb20gdGhlbWUgd2lsbCBwZXJzaXN0IGZvclxuICAgICAqIHRoZSB1c2VyJ3MgaW5pdGlhbHMgd2hlbiByZWxvYWRpbmcgdGhlIHNhbWUgdGhlbWUgd2lsbCBhbHdheXMgcmV0dXJuIGZvclxuICAgICAqIHRoZSBzYW1lIGluaXRpYWxzLlxuICAgICAqIFxuICAgICAqIFdoZW4gb25lIGRpbWVuc2lvbiBpcyBzcGVjaWZpZWQgYW5kIHRoZSBvdGhlciBpcyAwLCB0aGUgaW1hZ2UgaXMgc2NhbGVkXG4gICAgICogd2l0aCBwcmVzZXJ2ZWQgYXNwZWN0IHJhdGlvLiBJZiBib3RoIGRpbWVuc2lvbnMgYXJlIDAsIHRoZSBBUEkgcHJvdmlkZXMgYW5cbiAgICAgKiBpbWFnZSBhdCBzb3VyY2UgcXVhbGl0eS4gSWYgZGltZW5zaW9ucyBhcmUgbm90IHNwZWNpZmllZCwgdGhlIGRlZmF1bHQgc2l6ZVxuICAgICAqIG9mIGltYWdlIHJldHVybmVkIGlzIDEwMHgxMDBweC5cbiAgICAgKiBcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHdpZHRoXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGhlaWdodFxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBiYWNrZ3JvdW5kXG4gICAgICogQHRocm93cyB7QXBwd3JpdGVFeGNlcHRpb259XG4gICAgICogQHJldHVybnMge1Byb21pc2V9XG4gICAgICovXG4gICAgYXN5bmMgZ2V0SW5pdGlhbHMobmFtZSwgd2lkdGgsIGhlaWdodCwgYmFja2dyb3VuZCkge1xuICAgICAgICBjb25zdCBhcGlQYXRoID0gJy9hdmF0YXJzL2luaXRpYWxzJztcbiAgICAgICAgbGV0IHBheWxvYWQgPSB7fTtcblxuICAgICAgICBpZiAodHlwZW9mIG5hbWUgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICBwYXlsb2FkWyduYW1lJ10gPSBuYW1lO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHR5cGVvZiB3aWR0aCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHBheWxvYWRbJ3dpZHRoJ10gPSB3aWR0aDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0eXBlb2YgaGVpZ2h0ICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgcGF5bG9hZFsnaGVpZ2h0J10gPSBoZWlnaHQ7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodHlwZW9mIGJhY2tncm91bmQgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICBwYXlsb2FkWydiYWNrZ3JvdW5kJ10gPSBiYWNrZ3JvdW5kO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMuY2xpZW50LmNhbGwoJ2dldCcsIGFwaVBhdGgsIHtcbiAgICAgICAgICAgICdjb250ZW50LXR5cGUnOiAnYXBwbGljYXRpb24vanNvbicsXG4gICAgICAgIH0sIHBheWxvYWQsICdhcnJheWJ1ZmZlcicpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdldCBRUiBjb2RlXG4gICAgICpcbiAgICAgKiBDb252ZXJ0cyBhIGdpdmVuIHBsYWluIHRleHQgdG8gYSBRUiBjb2RlIGltYWdlLiBZb3UgY2FuIHVzZSB0aGUgcXVlcnlcbiAgICAgKiBwYXJhbWV0ZXJzIHRvIGNoYW5nZSB0aGUgc2l6ZSBhbmQgc3R5bGUgb2YgdGhlIHJlc3VsdGluZyBpbWFnZS5cbiAgICAgKiBcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSB0ZXh0XG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHNpemVcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gbWFyZ2luXG4gICAgICogQHBhcmFtIHtib29sZWFufSBkb3dubG9hZFxuICAgICAqIEB0aHJvd3Mge0FwcHdyaXRlRXhjZXB0aW9ufVxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlfVxuICAgICAqL1xuICAgIGFzeW5jIGdldFFSKHRleHQsIHNpemUsIG1hcmdpbiwgZG93bmxvYWQpIHtcbiAgICAgICAgY29uc3QgYXBpUGF0aCA9ICcvYXZhdGFycy9xcic7XG4gICAgICAgIGxldCBwYXlsb2FkID0ge307XG4gICAgICAgIGlmICh0eXBlb2YgdGV4dCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBBcHB3cml0ZUV4Y2VwdGlvbignTWlzc2luZyByZXF1aXJlZCBwYXJhbWV0ZXI6IFwidGV4dFwiJyk7XG4gICAgICAgIH1cblxuXG4gICAgICAgIGlmICh0eXBlb2YgdGV4dCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHBheWxvYWRbJ3RleHQnXSA9IHRleHQ7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodHlwZW9mIHNpemUgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICBwYXlsb2FkWydzaXplJ10gPSBzaXplO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHR5cGVvZiBtYXJnaW4gIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICBwYXlsb2FkWydtYXJnaW4nXSA9IG1hcmdpbjtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0eXBlb2YgZG93bmxvYWQgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICBwYXlsb2FkWydkb3dubG9hZCddID0gZG93bmxvYWQ7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy5jbGllbnQuY2FsbCgnZ2V0JywgYXBpUGF0aCwge1xuICAgICAgICAgICAgJ2NvbnRlbnQtdHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJyxcbiAgICAgICAgfSwgcGF5bG9hZCwgJ2FycmF5YnVmZmVyJyk7XG4gICAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IEF2YXRhcnM7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(action-browser)/./node_modules/node-appwrite/lib/services/avatars.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/node-appwrite/lib/services/avatars.js":
/*!************************************************************!*\
  !*** ./node_modules/node-appwrite/lib/services/avatars.js ***!
  \************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("const Service = __webpack_require__(/*! ../service.js */ \"(rsc)/./node_modules/node-appwrite/lib/service.js\");\nconst AppwriteException = __webpack_require__(/*! ../exception.js */ \"(rsc)/./node_modules/node-appwrite/lib/exception.js\");\nconst InputFile = __webpack_require__(/*! ../inputFile.js */ \"(rsc)/./node_modules/node-appwrite/lib/inputFile.js\");\nconst client = __webpack_require__(/*! ../client.js */ \"(rsc)/./node_modules/node-appwrite/lib/client.js\");\nconst Stream = __webpack_require__(/*! stream */ \"stream\");\nconst { promisify } = __webpack_require__(/*! util */ \"util\");\nconst fs = __webpack_require__(/*! fs */ \"fs\");\nconst { File } = __webpack_require__(/*! undici */ \"undici\");\nconst Query = __webpack_require__(/*! ../query.js */ \"(rsc)/./node_modules/node-appwrite/lib/query.js\");\n\nclass Avatars extends Service {\n\n     constructor(client)\n     {\n        super(client);\n     }\n\n\n    /**\n     * Get browser icon\n     *\n     * You can use this endpoint to show different browser icons to your users.\n     * The code argument receives the browser code as it appears in your user [GET\n     * /account/sessions](https://appwrite.io/docs/references/cloud/client-web/account#getSessions)\n     * endpoint. Use width, height and quality arguments to change the output\n     * settings.\n     * \n     * When one dimension is specified and the other is 0, the image is scaled\n     * with preserved aspect ratio. If both dimensions are 0, the API provides an\n     * image at source quality. If dimensions are not specified, the default size\n     * of image returned is 100x100px.\n     *\n     * @param {Browser} code\n     * @param {number} width\n     * @param {number} height\n     * @param {number} quality\n     * @throws {AppwriteException}\n     * @returns {Promise}\n     */\n    async getBrowser(code, width, height, quality) {\n        const apiPath = '/avatars/browsers/{code}'.replace('{code}', code);\n        let payload = {};\n        if (typeof code === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"code\"');\n        }\n\n\n        if (typeof width !== 'undefined') {\n            payload['width'] = width;\n        }\n\n        if (typeof height !== 'undefined') {\n            payload['height'] = height;\n        }\n\n        if (typeof quality !== 'undefined') {\n            payload['quality'] = quality;\n        }\n\n        return await this.client.call('get', apiPath, {\n            'content-type': 'application/json',\n        }, payload, 'arraybuffer');\n    }\n\n    /**\n     * Get credit card icon\n     *\n     * The credit card endpoint will return you the icon of the credit card\n     * provider you need. Use width, height and quality arguments to change the\n     * output settings.\n     * \n     * When one dimension is specified and the other is 0, the image is scaled\n     * with preserved aspect ratio. If both dimensions are 0, the API provides an\n     * image at source quality. If dimensions are not specified, the default size\n     * of image returned is 100x100px.\n     * \n     *\n     * @param {CreditCard} code\n     * @param {number} width\n     * @param {number} height\n     * @param {number} quality\n     * @throws {AppwriteException}\n     * @returns {Promise}\n     */\n    async getCreditCard(code, width, height, quality) {\n        const apiPath = '/avatars/credit-cards/{code}'.replace('{code}', code);\n        let payload = {};\n        if (typeof code === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"code\"');\n        }\n\n\n        if (typeof width !== 'undefined') {\n            payload['width'] = width;\n        }\n\n        if (typeof height !== 'undefined') {\n            payload['height'] = height;\n        }\n\n        if (typeof quality !== 'undefined') {\n            payload['quality'] = quality;\n        }\n\n        return await this.client.call('get', apiPath, {\n            'content-type': 'application/json',\n        }, payload, 'arraybuffer');\n    }\n\n    /**\n     * Get favicon\n     *\n     * Use this endpoint to fetch the favorite icon (AKA favicon) of any remote\n     * website URL.\n     * \n     *\n     * @param {string} url\n     * @throws {AppwriteException}\n     * @returns {Promise}\n     */\n    async getFavicon(url) {\n        const apiPath = '/avatars/favicon';\n        let payload = {};\n        if (typeof url === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"url\"');\n        }\n\n\n        if (typeof url !== 'undefined') {\n            payload['url'] = url;\n        }\n\n        return await this.client.call('get', apiPath, {\n            'content-type': 'application/json',\n        }, payload, 'arraybuffer');\n    }\n\n    /**\n     * Get country flag\n     *\n     * You can use this endpoint to show different country flags icons to your\n     * users. The code argument receives the 2 letter country code. Use width,\n     * height and quality arguments to change the output settings. Country codes\n     * follow the [ISO 3166-1](https://en.wikipedia.org/wiki/ISO_3166-1) standard.\n     * \n     * When one dimension is specified and the other is 0, the image is scaled\n     * with preserved aspect ratio. If both dimensions are 0, the API provides an\n     * image at source quality. If dimensions are not specified, the default size\n     * of image returned is 100x100px.\n     * \n     *\n     * @param {Flag} code\n     * @param {number} width\n     * @param {number} height\n     * @param {number} quality\n     * @throws {AppwriteException}\n     * @returns {Promise}\n     */\n    async getFlag(code, width, height, quality) {\n        const apiPath = '/avatars/flags/{code}'.replace('{code}', code);\n        let payload = {};\n        if (typeof code === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"code\"');\n        }\n\n\n        if (typeof width !== 'undefined') {\n            payload['width'] = width;\n        }\n\n        if (typeof height !== 'undefined') {\n            payload['height'] = height;\n        }\n\n        if (typeof quality !== 'undefined') {\n            payload['quality'] = quality;\n        }\n\n        return await this.client.call('get', apiPath, {\n            'content-type': 'application/json',\n        }, payload, 'arraybuffer');\n    }\n\n    /**\n     * Get image from URL\n     *\n     * Use this endpoint to fetch a remote image URL and crop it to any image size\n     * you want. This endpoint is very useful if you need to crop and display\n     * remote images in your app or in case you want to make sure a 3rd party\n     * image is properly served using a TLS protocol.\n     * \n     * When one dimension is specified and the other is 0, the image is scaled\n     * with preserved aspect ratio. If both dimensions are 0, the API provides an\n     * image at source quality. If dimensions are not specified, the default size\n     * of image returned is 400x400px.\n     * \n     *\n     * @param {string} url\n     * @param {number} width\n     * @param {number} height\n     * @throws {AppwriteException}\n     * @returns {Promise}\n     */\n    async getImage(url, width, height) {\n        const apiPath = '/avatars/image';\n        let payload = {};\n        if (typeof url === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"url\"');\n        }\n\n\n        if (typeof url !== 'undefined') {\n            payload['url'] = url;\n        }\n\n        if (typeof width !== 'undefined') {\n            payload['width'] = width;\n        }\n\n        if (typeof height !== 'undefined') {\n            payload['height'] = height;\n        }\n\n        return await this.client.call('get', apiPath, {\n            'content-type': 'application/json',\n        }, payload, 'arraybuffer');\n    }\n\n    /**\n     * Get user initials\n     *\n     * Use this endpoint to show your user initials avatar icon on your website or\n     * app. By default, this route will try to print your logged-in user name or\n     * email initials. You can also overwrite the user name if you pass the 'name'\n     * parameter. If no name is given and no user is logged, an empty avatar will\n     * be returned.\n     * \n     * You can use the color and background params to change the avatar colors. By\n     * default, a random theme will be selected. The random theme will persist for\n     * the user's initials when reloading the same theme will always return for\n     * the same initials.\n     * \n     * When one dimension is specified and the other is 0, the image is scaled\n     * with preserved aspect ratio. If both dimensions are 0, the API provides an\n     * image at source quality. If dimensions are not specified, the default size\n     * of image returned is 100x100px.\n     * \n     *\n     * @param {string} name\n     * @param {number} width\n     * @param {number} height\n     * @param {string} background\n     * @throws {AppwriteException}\n     * @returns {Promise}\n     */\n    async getInitials(name, width, height, background) {\n        const apiPath = '/avatars/initials';\n        let payload = {};\n\n        if (typeof name !== 'undefined') {\n            payload['name'] = name;\n        }\n\n        if (typeof width !== 'undefined') {\n            payload['width'] = width;\n        }\n\n        if (typeof height !== 'undefined') {\n            payload['height'] = height;\n        }\n\n        if (typeof background !== 'undefined') {\n            payload['background'] = background;\n        }\n\n        return await this.client.call('get', apiPath, {\n            'content-type': 'application/json',\n        }, payload, 'arraybuffer');\n    }\n\n    /**\n     * Get QR code\n     *\n     * Converts a given plain text to a QR code image. You can use the query\n     * parameters to change the size and style of the resulting image.\n     * \n     *\n     * @param {string} text\n     * @param {number} size\n     * @param {number} margin\n     * @param {boolean} download\n     * @throws {AppwriteException}\n     * @returns {Promise}\n     */\n    async getQR(text, size, margin, download) {\n        const apiPath = '/avatars/qr';\n        let payload = {};\n        if (typeof text === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"text\"');\n        }\n\n\n        if (typeof text !== 'undefined') {\n            payload['text'] = text;\n        }\n\n        if (typeof size !== 'undefined') {\n            payload['size'] = size;\n        }\n\n        if (typeof margin !== 'undefined') {\n            payload['margin'] = margin;\n        }\n\n        if (typeof download !== 'undefined') {\n            payload['download'] = download;\n        }\n\n        return await this.client.call('get', apiPath, {\n            'content-type': 'application/json',\n        }, payload, 'arraybuffer');\n    }\n}\n\nmodule.exports = Avatars;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvbm9kZS1hcHB3cml0ZS9saWIvc2VydmljZXMvYXZhdGFycy5qcyIsIm1hcHBpbmdzIjoiQUFBQSxnQkFBZ0IsbUJBQU8sQ0FBQyx3RUFBZTtBQUN2QywwQkFBMEIsbUJBQU8sQ0FBQyw0RUFBaUI7QUFDbkQsa0JBQWtCLG1CQUFPLENBQUMsNEVBQWlCO0FBQzNDLGVBQWUsbUJBQU8sQ0FBQyxzRUFBYztBQUNyQyxlQUFlLG1CQUFPLENBQUMsc0JBQVE7QUFDL0IsUUFBUSxZQUFZLEVBQUUsbUJBQU8sQ0FBQyxrQkFBTTtBQUNwQyxXQUFXLG1CQUFPLENBQUMsY0FBSTtBQUN2QixRQUFRLE9BQU8sRUFBRSxtQkFBTyxDQUFDLHNCQUFRO0FBQ2pDLGNBQWMsbUJBQU8sQ0FBQyxvRUFBYTs7QUFFbkM7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFNBQVM7QUFDeEIsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsUUFBUTtBQUN2QixlQUFlLFFBQVE7QUFDdkIsZ0JBQWdCO0FBQ2hCLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0EsNENBQTRDLEtBQUssWUFBWSxLQUFLO0FBQ2xFO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsU0FBUztBQUNUOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxZQUFZO0FBQzNCLGVBQWUsUUFBUTtBQUN2QixlQUFlLFFBQVE7QUFDdkIsZUFBZSxRQUFRO0FBQ3ZCLGdCQUFnQjtBQUNoQixpQkFBaUI7QUFDakI7QUFDQTtBQUNBLGdEQUFnRCxLQUFLLFlBQVksS0FBSztBQUN0RTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFNBQVM7QUFDVDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QixnQkFBZ0I7QUFDaEIsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFNBQVM7QUFDVDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxNQUFNO0FBQ3JCLGVBQWUsUUFBUTtBQUN2QixlQUFlLFFBQVE7QUFDdkIsZUFBZSxRQUFRO0FBQ3ZCLGdCQUFnQjtBQUNoQixpQkFBaUI7QUFDakI7QUFDQTtBQUNBLHlDQUF5QyxLQUFLLFlBQVksS0FBSztBQUMvRDtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFNBQVM7QUFDVDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsUUFBUTtBQUN2QixlQUFlLFFBQVE7QUFDdkIsZ0JBQWdCO0FBQ2hCLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFNBQVM7QUFDVDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsUUFBUTtBQUN2QixlQUFlLFFBQVE7QUFDdkIsZUFBZSxRQUFRO0FBQ3ZCLGdCQUFnQjtBQUNoQixpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkIsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsUUFBUTtBQUN2QixlQUFlLFNBQVM7QUFDeEIsZ0JBQWdCO0FBQ2hCLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTs7QUFFQSIsInNvdXJjZXMiOlsid2VicGFjazovL2pzbV9iYW5raW5nLy4vbm9kZV9tb2R1bGVzL25vZGUtYXBwd3JpdGUvbGliL3NlcnZpY2VzL2F2YXRhcnMuanM/MDEyMCJdLCJzb3VyY2VzQ29udGVudCI6WyJjb25zdCBTZXJ2aWNlID0gcmVxdWlyZSgnLi4vc2VydmljZS5qcycpO1xuY29uc3QgQXBwd3JpdGVFeGNlcHRpb24gPSByZXF1aXJlKCcuLi9leGNlcHRpb24uanMnKTtcbmNvbnN0IElucHV0RmlsZSA9IHJlcXVpcmUoJy4uL2lucHV0RmlsZS5qcycpO1xuY29uc3QgY2xpZW50ID0gcmVxdWlyZSgnLi4vY2xpZW50LmpzJyk7XG5jb25zdCBTdHJlYW0gPSByZXF1aXJlKCdzdHJlYW0nKTtcbmNvbnN0IHsgcHJvbWlzaWZ5IH0gPSByZXF1aXJlKCd1dGlsJyk7XG5jb25zdCBmcyA9IHJlcXVpcmUoJ2ZzJyk7XG5jb25zdCB7IEZpbGUgfSA9IHJlcXVpcmUoJ3VuZGljaScpO1xuY29uc3QgUXVlcnkgPSByZXF1aXJlKCcuLi9xdWVyeS5qcycpO1xuXG5jbGFzcyBBdmF0YXJzIGV4dGVuZHMgU2VydmljZSB7XG5cbiAgICAgY29uc3RydWN0b3IoY2xpZW50KVxuICAgICB7XG4gICAgICAgIHN1cGVyKGNsaWVudCk7XG4gICAgIH1cblxuXG4gICAgLyoqXG4gICAgICogR2V0IGJyb3dzZXIgaWNvblxuICAgICAqXG4gICAgICogWW91IGNhbiB1c2UgdGhpcyBlbmRwb2ludCB0byBzaG93IGRpZmZlcmVudCBicm93c2VyIGljb25zIHRvIHlvdXIgdXNlcnMuXG4gICAgICogVGhlIGNvZGUgYXJndW1lbnQgcmVjZWl2ZXMgdGhlIGJyb3dzZXIgY29kZSBhcyBpdCBhcHBlYXJzIGluIHlvdXIgdXNlciBbR0VUXG4gICAgICogL2FjY291bnQvc2Vzc2lvbnNdKGh0dHBzOi8vYXBwd3JpdGUuaW8vZG9jcy9yZWZlcmVuY2VzL2Nsb3VkL2NsaWVudC13ZWIvYWNjb3VudCNnZXRTZXNzaW9ucylcbiAgICAgKiBlbmRwb2ludC4gVXNlIHdpZHRoLCBoZWlnaHQgYW5kIHF1YWxpdHkgYXJndW1lbnRzIHRvIGNoYW5nZSB0aGUgb3V0cHV0XG4gICAgICogc2V0dGluZ3MuXG4gICAgICogXG4gICAgICogV2hlbiBvbmUgZGltZW5zaW9uIGlzIHNwZWNpZmllZCBhbmQgdGhlIG90aGVyIGlzIDAsIHRoZSBpbWFnZSBpcyBzY2FsZWRcbiAgICAgKiB3aXRoIHByZXNlcnZlZCBhc3BlY3QgcmF0aW8uIElmIGJvdGggZGltZW5zaW9ucyBhcmUgMCwgdGhlIEFQSSBwcm92aWRlcyBhblxuICAgICAqIGltYWdlIGF0IHNvdXJjZSBxdWFsaXR5LiBJZiBkaW1lbnNpb25zIGFyZSBub3Qgc3BlY2lmaWVkLCB0aGUgZGVmYXVsdCBzaXplXG4gICAgICogb2YgaW1hZ2UgcmV0dXJuZWQgaXMgMTAweDEwMHB4LlxuICAgICAqXG4gICAgICogQHBhcmFtIHtCcm93c2VyfSBjb2RlXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHdpZHRoXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGhlaWdodFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBxdWFsaXR5XG4gICAgICogQHRocm93cyB7QXBwd3JpdGVFeGNlcHRpb259XG4gICAgICogQHJldHVybnMge1Byb21pc2V9XG4gICAgICovXG4gICAgYXN5bmMgZ2V0QnJvd3Nlcihjb2RlLCB3aWR0aCwgaGVpZ2h0LCBxdWFsaXR5KSB7XG4gICAgICAgIGNvbnN0IGFwaVBhdGggPSAnL2F2YXRhcnMvYnJvd3NlcnMve2NvZGV9Jy5yZXBsYWNlKCd7Y29kZX0nLCBjb2RlKTtcbiAgICAgICAgbGV0IHBheWxvYWQgPSB7fTtcbiAgICAgICAgaWYgKHR5cGVvZiBjb2RlID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEFwcHdyaXRlRXhjZXB0aW9uKCdNaXNzaW5nIHJlcXVpcmVkIHBhcmFtZXRlcjogXCJjb2RlXCInKTtcbiAgICAgICAgfVxuXG5cbiAgICAgICAgaWYgKHR5cGVvZiB3aWR0aCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHBheWxvYWRbJ3dpZHRoJ10gPSB3aWR0aDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0eXBlb2YgaGVpZ2h0ICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgcGF5bG9hZFsnaGVpZ2h0J10gPSBoZWlnaHQ7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodHlwZW9mIHF1YWxpdHkgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICBwYXlsb2FkWydxdWFsaXR5J10gPSBxdWFsaXR5O1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMuY2xpZW50LmNhbGwoJ2dldCcsIGFwaVBhdGgsIHtcbiAgICAgICAgICAgICdjb250ZW50LXR5cGUnOiAnYXBwbGljYXRpb24vanNvbicsXG4gICAgICAgIH0sIHBheWxvYWQsICdhcnJheWJ1ZmZlcicpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdldCBjcmVkaXQgY2FyZCBpY29uXG4gICAgICpcbiAgICAgKiBUaGUgY3JlZGl0IGNhcmQgZW5kcG9pbnQgd2lsbCByZXR1cm4geW91IHRoZSBpY29uIG9mIHRoZSBjcmVkaXQgY2FyZFxuICAgICAqIHByb3ZpZGVyIHlvdSBuZWVkLiBVc2Ugd2lkdGgsIGhlaWdodCBhbmQgcXVhbGl0eSBhcmd1bWVudHMgdG8gY2hhbmdlIHRoZVxuICAgICAqIG91dHB1dCBzZXR0aW5ncy5cbiAgICAgKiBcbiAgICAgKiBXaGVuIG9uZSBkaW1lbnNpb24gaXMgc3BlY2lmaWVkIGFuZCB0aGUgb3RoZXIgaXMgMCwgdGhlIGltYWdlIGlzIHNjYWxlZFxuICAgICAqIHdpdGggcHJlc2VydmVkIGFzcGVjdCByYXRpby4gSWYgYm90aCBkaW1lbnNpb25zIGFyZSAwLCB0aGUgQVBJIHByb3ZpZGVzIGFuXG4gICAgICogaW1hZ2UgYXQgc291cmNlIHF1YWxpdHkuIElmIGRpbWVuc2lvbnMgYXJlIG5vdCBzcGVjaWZpZWQsIHRoZSBkZWZhdWx0IHNpemVcbiAgICAgKiBvZiBpbWFnZSByZXR1cm5lZCBpcyAxMDB4MTAwcHguXG4gICAgICogXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0NyZWRpdENhcmR9IGNvZGVcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gd2lkdGhcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gaGVpZ2h0XG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHF1YWxpdHlcbiAgICAgKiBAdGhyb3dzIHtBcHB3cml0ZUV4Y2VwdGlvbn1cbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZX1cbiAgICAgKi9cbiAgICBhc3luYyBnZXRDcmVkaXRDYXJkKGNvZGUsIHdpZHRoLCBoZWlnaHQsIHF1YWxpdHkpIHtcbiAgICAgICAgY29uc3QgYXBpUGF0aCA9ICcvYXZhdGFycy9jcmVkaXQtY2FyZHMve2NvZGV9Jy5yZXBsYWNlKCd7Y29kZX0nLCBjb2RlKTtcbiAgICAgICAgbGV0IHBheWxvYWQgPSB7fTtcbiAgICAgICAgaWYgKHR5cGVvZiBjb2RlID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEFwcHdyaXRlRXhjZXB0aW9uKCdNaXNzaW5nIHJlcXVpcmVkIHBhcmFtZXRlcjogXCJjb2RlXCInKTtcbiAgICAgICAgfVxuXG5cbiAgICAgICAgaWYgKHR5cGVvZiB3aWR0aCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHBheWxvYWRbJ3dpZHRoJ10gPSB3aWR0aDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0eXBlb2YgaGVpZ2h0ICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgcGF5bG9hZFsnaGVpZ2h0J10gPSBoZWlnaHQ7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodHlwZW9mIHF1YWxpdHkgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICBwYXlsb2FkWydxdWFsaXR5J10gPSBxdWFsaXR5O1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMuY2xpZW50LmNhbGwoJ2dldCcsIGFwaVBhdGgsIHtcbiAgICAgICAgICAgICdjb250ZW50LXR5cGUnOiAnYXBwbGljYXRpb24vanNvbicsXG4gICAgICAgIH0sIHBheWxvYWQsICdhcnJheWJ1ZmZlcicpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdldCBmYXZpY29uXG4gICAgICpcbiAgICAgKiBVc2UgdGhpcyBlbmRwb2ludCB0byBmZXRjaCB0aGUgZmF2b3JpdGUgaWNvbiAoQUtBIGZhdmljb24pIG9mIGFueSByZW1vdGVcbiAgICAgKiB3ZWJzaXRlIFVSTC5cbiAgICAgKiBcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSB1cmxcbiAgICAgKiBAdGhyb3dzIHtBcHB3cml0ZUV4Y2VwdGlvbn1cbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZX1cbiAgICAgKi9cbiAgICBhc3luYyBnZXRGYXZpY29uKHVybCkge1xuICAgICAgICBjb25zdCBhcGlQYXRoID0gJy9hdmF0YXJzL2Zhdmljb24nO1xuICAgICAgICBsZXQgcGF5bG9hZCA9IHt9O1xuICAgICAgICBpZiAodHlwZW9mIHVybCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBBcHB3cml0ZUV4Y2VwdGlvbignTWlzc2luZyByZXF1aXJlZCBwYXJhbWV0ZXI6IFwidXJsXCInKTtcbiAgICAgICAgfVxuXG5cbiAgICAgICAgaWYgKHR5cGVvZiB1cmwgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICBwYXlsb2FkWyd1cmwnXSA9IHVybDtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBhd2FpdCB0aGlzLmNsaWVudC5jYWxsKCdnZXQnLCBhcGlQYXRoLCB7XG4gICAgICAgICAgICAnY29udGVudC10eXBlJzogJ2FwcGxpY2F0aW9uL2pzb24nLFxuICAgICAgICB9LCBwYXlsb2FkLCAnYXJyYXlidWZmZXInKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZXQgY291bnRyeSBmbGFnXG4gICAgICpcbiAgICAgKiBZb3UgY2FuIHVzZSB0aGlzIGVuZHBvaW50IHRvIHNob3cgZGlmZmVyZW50IGNvdW50cnkgZmxhZ3MgaWNvbnMgdG8geW91clxuICAgICAqIHVzZXJzLiBUaGUgY29kZSBhcmd1bWVudCByZWNlaXZlcyB0aGUgMiBsZXR0ZXIgY291bnRyeSBjb2RlLiBVc2Ugd2lkdGgsXG4gICAgICogaGVpZ2h0IGFuZCBxdWFsaXR5IGFyZ3VtZW50cyB0byBjaGFuZ2UgdGhlIG91dHB1dCBzZXR0aW5ncy4gQ291bnRyeSBjb2Rlc1xuICAgICAqIGZvbGxvdyB0aGUgW0lTTyAzMTY2LTFdKGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0lTT18zMTY2LTEpIHN0YW5kYXJkLlxuICAgICAqIFxuICAgICAqIFdoZW4gb25lIGRpbWVuc2lvbiBpcyBzcGVjaWZpZWQgYW5kIHRoZSBvdGhlciBpcyAwLCB0aGUgaW1hZ2UgaXMgc2NhbGVkXG4gICAgICogd2l0aCBwcmVzZXJ2ZWQgYXNwZWN0IHJhdGlvLiBJZiBib3RoIGRpbWVuc2lvbnMgYXJlIDAsIHRoZSBBUEkgcHJvdmlkZXMgYW5cbiAgICAgKiBpbWFnZSBhdCBzb3VyY2UgcXVhbGl0eS4gSWYgZGltZW5zaW9ucyBhcmUgbm90IHNwZWNpZmllZCwgdGhlIGRlZmF1bHQgc2l6ZVxuICAgICAqIG9mIGltYWdlIHJldHVybmVkIGlzIDEwMHgxMDBweC5cbiAgICAgKiBcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7RmxhZ30gY29kZVxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB3aWR0aFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBoZWlnaHRcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gcXVhbGl0eVxuICAgICAqIEB0aHJvd3Mge0FwcHdyaXRlRXhjZXB0aW9ufVxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlfVxuICAgICAqL1xuICAgIGFzeW5jIGdldEZsYWcoY29kZSwgd2lkdGgsIGhlaWdodCwgcXVhbGl0eSkge1xuICAgICAgICBjb25zdCBhcGlQYXRoID0gJy9hdmF0YXJzL2ZsYWdzL3tjb2RlfScucmVwbGFjZSgne2NvZGV9JywgY29kZSk7XG4gICAgICAgIGxldCBwYXlsb2FkID0ge307XG4gICAgICAgIGlmICh0eXBlb2YgY29kZSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBBcHB3cml0ZUV4Y2VwdGlvbignTWlzc2luZyByZXF1aXJlZCBwYXJhbWV0ZXI6IFwiY29kZVwiJyk7XG4gICAgICAgIH1cblxuXG4gICAgICAgIGlmICh0eXBlb2Ygd2lkdGggIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICBwYXlsb2FkWyd3aWR0aCddID0gd2lkdGg7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodHlwZW9mIGhlaWdodCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHBheWxvYWRbJ2hlaWdodCddID0gaGVpZ2h0O1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHR5cGVvZiBxdWFsaXR5ICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgcGF5bG9hZFsncXVhbGl0eSddID0gcXVhbGl0eTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBhd2FpdCB0aGlzLmNsaWVudC5jYWxsKCdnZXQnLCBhcGlQYXRoLCB7XG4gICAgICAgICAgICAnY29udGVudC10eXBlJzogJ2FwcGxpY2F0aW9uL2pzb24nLFxuICAgICAgICB9LCBwYXlsb2FkLCAnYXJyYXlidWZmZXInKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZXQgaW1hZ2UgZnJvbSBVUkxcbiAgICAgKlxuICAgICAqIFVzZSB0aGlzIGVuZHBvaW50IHRvIGZldGNoIGEgcmVtb3RlIGltYWdlIFVSTCBhbmQgY3JvcCBpdCB0byBhbnkgaW1hZ2Ugc2l6ZVxuICAgICAqIHlvdSB3YW50LiBUaGlzIGVuZHBvaW50IGlzIHZlcnkgdXNlZnVsIGlmIHlvdSBuZWVkIHRvIGNyb3AgYW5kIGRpc3BsYXlcbiAgICAgKiByZW1vdGUgaW1hZ2VzIGluIHlvdXIgYXBwIG9yIGluIGNhc2UgeW91IHdhbnQgdG8gbWFrZSBzdXJlIGEgM3JkIHBhcnR5XG4gICAgICogaW1hZ2UgaXMgcHJvcGVybHkgc2VydmVkIHVzaW5nIGEgVExTIHByb3RvY29sLlxuICAgICAqIFxuICAgICAqIFdoZW4gb25lIGRpbWVuc2lvbiBpcyBzcGVjaWZpZWQgYW5kIHRoZSBvdGhlciBpcyAwLCB0aGUgaW1hZ2UgaXMgc2NhbGVkXG4gICAgICogd2l0aCBwcmVzZXJ2ZWQgYXNwZWN0IHJhdGlvLiBJZiBib3RoIGRpbWVuc2lvbnMgYXJlIDAsIHRoZSBBUEkgcHJvdmlkZXMgYW5cbiAgICAgKiBpbWFnZSBhdCBzb3VyY2UgcXVhbGl0eS4gSWYgZGltZW5zaW9ucyBhcmUgbm90IHNwZWNpZmllZCwgdGhlIGRlZmF1bHQgc2l6ZVxuICAgICAqIG9mIGltYWdlIHJldHVybmVkIGlzIDQwMHg0MDBweC5cbiAgICAgKiBcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSB1cmxcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gd2lkdGhcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gaGVpZ2h0XG4gICAgICogQHRocm93cyB7QXBwd3JpdGVFeGNlcHRpb259XG4gICAgICogQHJldHVybnMge1Byb21pc2V9XG4gICAgICovXG4gICAgYXN5bmMgZ2V0SW1hZ2UodXJsLCB3aWR0aCwgaGVpZ2h0KSB7XG4gICAgICAgIGNvbnN0IGFwaVBhdGggPSAnL2F2YXRhcnMvaW1hZ2UnO1xuICAgICAgICBsZXQgcGF5bG9hZCA9IHt9O1xuICAgICAgICBpZiAodHlwZW9mIHVybCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBBcHB3cml0ZUV4Y2VwdGlvbignTWlzc2luZyByZXF1aXJlZCBwYXJhbWV0ZXI6IFwidXJsXCInKTtcbiAgICAgICAgfVxuXG5cbiAgICAgICAgaWYgKHR5cGVvZiB1cmwgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICBwYXlsb2FkWyd1cmwnXSA9IHVybDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0eXBlb2Ygd2lkdGggIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICBwYXlsb2FkWyd3aWR0aCddID0gd2lkdGg7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodHlwZW9mIGhlaWdodCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHBheWxvYWRbJ2hlaWdodCddID0gaGVpZ2h0O1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMuY2xpZW50LmNhbGwoJ2dldCcsIGFwaVBhdGgsIHtcbiAgICAgICAgICAgICdjb250ZW50LXR5cGUnOiAnYXBwbGljYXRpb24vanNvbicsXG4gICAgICAgIH0sIHBheWxvYWQsICdhcnJheWJ1ZmZlcicpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdldCB1c2VyIGluaXRpYWxzXG4gICAgICpcbiAgICAgKiBVc2UgdGhpcyBlbmRwb2ludCB0byBzaG93IHlvdXIgdXNlciBpbml0aWFscyBhdmF0YXIgaWNvbiBvbiB5b3VyIHdlYnNpdGUgb3JcbiAgICAgKiBhcHAuIEJ5IGRlZmF1bHQsIHRoaXMgcm91dGUgd2lsbCB0cnkgdG8gcHJpbnQgeW91ciBsb2dnZWQtaW4gdXNlciBuYW1lIG9yXG4gICAgICogZW1haWwgaW5pdGlhbHMuIFlvdSBjYW4gYWxzbyBvdmVyd3JpdGUgdGhlIHVzZXIgbmFtZSBpZiB5b3UgcGFzcyB0aGUgJ25hbWUnXG4gICAgICogcGFyYW1ldGVyLiBJZiBubyBuYW1lIGlzIGdpdmVuIGFuZCBubyB1c2VyIGlzIGxvZ2dlZCwgYW4gZW1wdHkgYXZhdGFyIHdpbGxcbiAgICAgKiBiZSByZXR1cm5lZC5cbiAgICAgKiBcbiAgICAgKiBZb3UgY2FuIHVzZSB0aGUgY29sb3IgYW5kIGJhY2tncm91bmQgcGFyYW1zIHRvIGNoYW5nZSB0aGUgYXZhdGFyIGNvbG9ycy4gQnlcbiAgICAgKiBkZWZhdWx0LCBhIHJhbmRvbSB0aGVtZSB3aWxsIGJlIHNlbGVjdGVkLiBUaGUgcmFuZG9tIHRoZW1lIHdpbGwgcGVyc2lzdCBmb3JcbiAgICAgKiB0aGUgdXNlcidzIGluaXRpYWxzIHdoZW4gcmVsb2FkaW5nIHRoZSBzYW1lIHRoZW1lIHdpbGwgYWx3YXlzIHJldHVybiBmb3JcbiAgICAgKiB0aGUgc2FtZSBpbml0aWFscy5cbiAgICAgKiBcbiAgICAgKiBXaGVuIG9uZSBkaW1lbnNpb24gaXMgc3BlY2lmaWVkIGFuZCB0aGUgb3RoZXIgaXMgMCwgdGhlIGltYWdlIGlzIHNjYWxlZFxuICAgICAqIHdpdGggcHJlc2VydmVkIGFzcGVjdCByYXRpby4gSWYgYm90aCBkaW1lbnNpb25zIGFyZSAwLCB0aGUgQVBJIHByb3ZpZGVzIGFuXG4gICAgICogaW1hZ2UgYXQgc291cmNlIHF1YWxpdHkuIElmIGRpbWVuc2lvbnMgYXJlIG5vdCBzcGVjaWZpZWQsIHRoZSBkZWZhdWx0IHNpemVcbiAgICAgKiBvZiBpbWFnZSByZXR1cm5lZCBpcyAxMDB4MTAwcHguXG4gICAgICogXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gbmFtZVxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB3aWR0aFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBoZWlnaHRcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gYmFja2dyb3VuZFxuICAgICAqIEB0aHJvd3Mge0FwcHdyaXRlRXhjZXB0aW9ufVxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlfVxuICAgICAqL1xuICAgIGFzeW5jIGdldEluaXRpYWxzKG5hbWUsIHdpZHRoLCBoZWlnaHQsIGJhY2tncm91bmQpIHtcbiAgICAgICAgY29uc3QgYXBpUGF0aCA9ICcvYXZhdGFycy9pbml0aWFscyc7XG4gICAgICAgIGxldCBwYXlsb2FkID0ge307XG5cbiAgICAgICAgaWYgKHR5cGVvZiBuYW1lICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgcGF5bG9hZFsnbmFtZSddID0gbmFtZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0eXBlb2Ygd2lkdGggIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICBwYXlsb2FkWyd3aWR0aCddID0gd2lkdGg7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodHlwZW9mIGhlaWdodCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHBheWxvYWRbJ2hlaWdodCddID0gaGVpZ2h0O1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHR5cGVvZiBiYWNrZ3JvdW5kICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgcGF5bG9hZFsnYmFja2dyb3VuZCddID0gYmFja2dyb3VuZDtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBhd2FpdCB0aGlzLmNsaWVudC5jYWxsKCdnZXQnLCBhcGlQYXRoLCB7XG4gICAgICAgICAgICAnY29udGVudC10eXBlJzogJ2FwcGxpY2F0aW9uL2pzb24nLFxuICAgICAgICB9LCBwYXlsb2FkLCAnYXJyYXlidWZmZXInKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZXQgUVIgY29kZVxuICAgICAqXG4gICAgICogQ29udmVydHMgYSBnaXZlbiBwbGFpbiB0ZXh0IHRvIGEgUVIgY29kZSBpbWFnZS4gWW91IGNhbiB1c2UgdGhlIHF1ZXJ5XG4gICAgICogcGFyYW1ldGVycyB0byBjaGFuZ2UgdGhlIHNpemUgYW5kIHN0eWxlIG9mIHRoZSByZXN1bHRpbmcgaW1hZ2UuXG4gICAgICogXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gdGV4dFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBzaXplXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IG1hcmdpblxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gZG93bmxvYWRcbiAgICAgKiBAdGhyb3dzIHtBcHB3cml0ZUV4Y2VwdGlvbn1cbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZX1cbiAgICAgKi9cbiAgICBhc3luYyBnZXRRUih0ZXh0LCBzaXplLCBtYXJnaW4sIGRvd25sb2FkKSB7XG4gICAgICAgIGNvbnN0IGFwaVBhdGggPSAnL2F2YXRhcnMvcXInO1xuICAgICAgICBsZXQgcGF5bG9hZCA9IHt9O1xuICAgICAgICBpZiAodHlwZW9mIHRleHQgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgQXBwd3JpdGVFeGNlcHRpb24oJ01pc3NpbmcgcmVxdWlyZWQgcGFyYW1ldGVyOiBcInRleHRcIicpO1xuICAgICAgICB9XG5cblxuICAgICAgICBpZiAodHlwZW9mIHRleHQgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICBwYXlsb2FkWyd0ZXh0J10gPSB0ZXh0O1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHR5cGVvZiBzaXplICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgcGF5bG9hZFsnc2l6ZSddID0gc2l6ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0eXBlb2YgbWFyZ2luICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgcGF5bG9hZFsnbWFyZ2luJ10gPSBtYXJnaW47XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodHlwZW9mIGRvd25sb2FkICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgcGF5bG9hZFsnZG93bmxvYWQnXSA9IGRvd25sb2FkO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMuY2xpZW50LmNhbGwoJ2dldCcsIGFwaVBhdGgsIHtcbiAgICAgICAgICAgICdjb250ZW50LXR5cGUnOiAnYXBwbGljYXRpb24vanNvbicsXG4gICAgICAgIH0sIHBheWxvYWQsICdhcnJheWJ1ZmZlcicpO1xuICAgIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBBdmF0YXJzO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/node-appwrite/lib/services/avatars.js\n");

/***/ }),

/***/ "(action-browser)/./node_modules/node-appwrite/lib/services/databases.js":
/*!**************************************************************!*\
  !*** ./node_modules/node-appwrite/lib/services/databases.js ***!
  \**************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("const Service = __webpack_require__(/*! ../service.js */ \"(action-browser)/./node_modules/node-appwrite/lib/service.js\");\nconst AppwriteException = __webpack_require__(/*! ../exception.js */ \"(action-browser)/./node_modules/node-appwrite/lib/exception.js\");\nconst InputFile = __webpack_require__(/*! ../inputFile.js */ \"(action-browser)/./node_modules/node-appwrite/lib/inputFile.js\");\nconst client = __webpack_require__(/*! ../client.js */ \"(action-browser)/./node_modules/node-appwrite/lib/client.js\");\nconst Stream = __webpack_require__(/*! stream */ \"stream\");\nconst { promisify } = __webpack_require__(/*! util */ \"util\");\nconst fs = __webpack_require__(/*! fs */ \"fs\");\nconst { File } = __webpack_require__(/*! undici */ \"undici\");\nconst Query = __webpack_require__(/*! ../query.js */ \"(action-browser)/./node_modules/node-appwrite/lib/query.js\");\n\nclass Databases extends Service {\n\n     constructor(client)\n     {\n        super(client);\n     }\n\n\n    /**\n     * List databases\n     *\n     * Get a list of all databases from the current Appwrite project. You can use\n     * the search parameter to filter your results.\n     *\n     * @param {string[]} queries\n     * @param {string} search\n     * @throws {AppwriteException}\n     * @returns {Promise}\n     */\n    async list(queries, search) {\n        const apiPath = '/databases';\n        let payload = {};\n\n        if (typeof queries !== 'undefined') {\n            payload['queries'] = queries;\n        }\n\n        if (typeof search !== 'undefined') {\n            payload['search'] = search;\n        }\n\n        return await this.client.call('get', apiPath, {\n            'content-type': 'application/json',\n        }, payload);\n    }\n\n    /**\n     * Create database\n     *\n     * Create a new Database.\n     * \n     *\n     * @param {string} databaseId\n     * @param {string} name\n     * @param {boolean} enabled\n     * @throws {AppwriteException}\n     * @returns {Promise}\n     */\n    async create(databaseId, name, enabled) {\n        const apiPath = '/databases';\n        let payload = {};\n        if (typeof databaseId === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"databaseId\"');\n        }\n\n        if (typeof name === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"name\"');\n        }\n\n\n        if (typeof databaseId !== 'undefined') {\n            payload['databaseId'] = databaseId;\n        }\n\n        if (typeof name !== 'undefined') {\n            payload['name'] = name;\n        }\n\n        if (typeof enabled !== 'undefined') {\n            payload['enabled'] = enabled;\n        }\n\n        return await this.client.call('post', apiPath, {\n            'content-type': 'application/json',\n        }, payload);\n    }\n\n    /**\n     * Get database\n     *\n     * Get a database by its unique ID. This endpoint response returns a JSON\n     * object with the database metadata.\n     *\n     * @param {string} databaseId\n     * @throws {AppwriteException}\n     * @returns {Promise}\n     */\n    async get(databaseId) {\n        const apiPath = '/databases/{databaseId}'.replace('{databaseId}', databaseId);\n        let payload = {};\n        if (typeof databaseId === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"databaseId\"');\n        }\n\n\n        return await this.client.call('get', apiPath, {\n            'content-type': 'application/json',\n        }, payload);\n    }\n\n    /**\n     * Update database\n     *\n     * Update a database by its unique ID.\n     *\n     * @param {string} databaseId\n     * @param {string} name\n     * @param {boolean} enabled\n     * @throws {AppwriteException}\n     * @returns {Promise}\n     */\n    async update(databaseId, name, enabled) {\n        const apiPath = '/databases/{databaseId}'.replace('{databaseId}', databaseId);\n        let payload = {};\n        if (typeof databaseId === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"databaseId\"');\n        }\n\n        if (typeof name === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"name\"');\n        }\n\n\n        if (typeof name !== 'undefined') {\n            payload['name'] = name;\n        }\n\n        if (typeof enabled !== 'undefined') {\n            payload['enabled'] = enabled;\n        }\n\n        return await this.client.call('put', apiPath, {\n            'content-type': 'application/json',\n        }, payload);\n    }\n\n    /**\n     * Delete database\n     *\n     * Delete a database by its unique ID. Only API keys with with databases.write\n     * scope can delete a database.\n     *\n     * @param {string} databaseId\n     * @throws {AppwriteException}\n     * @returns {Promise}\n     */\n    async delete(databaseId) {\n        const apiPath = '/databases/{databaseId}'.replace('{databaseId}', databaseId);\n        let payload = {};\n        if (typeof databaseId === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"databaseId\"');\n        }\n\n\n        return await this.client.call('delete', apiPath, {\n            'content-type': 'application/json',\n        }, payload);\n    }\n\n    /**\n     * List collections\n     *\n     * Get a list of all collections that belong to the provided databaseId. You\n     * can use the search parameter to filter your results.\n     *\n     * @param {string} databaseId\n     * @param {string[]} queries\n     * @param {string} search\n     * @throws {AppwriteException}\n     * @returns {Promise}\n     */\n    async listCollections(databaseId, queries, search) {\n        const apiPath = '/databases/{databaseId}/collections'.replace('{databaseId}', databaseId);\n        let payload = {};\n        if (typeof databaseId === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"databaseId\"');\n        }\n\n\n        if (typeof queries !== 'undefined') {\n            payload['queries'] = queries;\n        }\n\n        if (typeof search !== 'undefined') {\n            payload['search'] = search;\n        }\n\n        return await this.client.call('get', apiPath, {\n            'content-type': 'application/json',\n        }, payload);\n    }\n\n    /**\n     * Create collection\n     *\n     * Create a new Collection. Before using this route, you should create a new\n     * database resource using either a [server\n     * integration](https://appwrite.io/docs/server/databases#databasesCreateCollection)\n     * API or directly from your database console.\n     *\n     * @param {string} databaseId\n     * @param {string} collectionId\n     * @param {string} name\n     * @param {string[]} permissions\n     * @param {boolean} documentSecurity\n     * @param {boolean} enabled\n     * @throws {AppwriteException}\n     * @returns {Promise}\n     */\n    async createCollection(databaseId, collectionId, name, permissions, documentSecurity, enabled) {\n        const apiPath = '/databases/{databaseId}/collections'.replace('{databaseId}', databaseId);\n        let payload = {};\n        if (typeof databaseId === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"databaseId\"');\n        }\n\n        if (typeof collectionId === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"collectionId\"');\n        }\n\n        if (typeof name === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"name\"');\n        }\n\n\n        if (typeof collectionId !== 'undefined') {\n            payload['collectionId'] = collectionId;\n        }\n\n        if (typeof name !== 'undefined') {\n            payload['name'] = name;\n        }\n\n        if (typeof permissions !== 'undefined') {\n            payload['permissions'] = permissions;\n        }\n\n        if (typeof documentSecurity !== 'undefined') {\n            payload['documentSecurity'] = documentSecurity;\n        }\n\n        if (typeof enabled !== 'undefined') {\n            payload['enabled'] = enabled;\n        }\n\n        return await this.client.call('post', apiPath, {\n            'content-type': 'application/json',\n        }, payload);\n    }\n\n    /**\n     * Get collection\n     *\n     * Get a collection by its unique ID. This endpoint response returns a JSON\n     * object with the collection metadata.\n     *\n     * @param {string} databaseId\n     * @param {string} collectionId\n     * @throws {AppwriteException}\n     * @returns {Promise}\n     */\n    async getCollection(databaseId, collectionId) {\n        const apiPath = '/databases/{databaseId}/collections/{collectionId}'.replace('{databaseId}', databaseId).replace('{collectionId}', collectionId);\n        let payload = {};\n        if (typeof databaseId === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"databaseId\"');\n        }\n\n        if (typeof collectionId === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"collectionId\"');\n        }\n\n\n        return await this.client.call('get', apiPath, {\n            'content-type': 'application/json',\n        }, payload);\n    }\n\n    /**\n     * Update collection\n     *\n     * Update a collection by its unique ID.\n     *\n     * @param {string} databaseId\n     * @param {string} collectionId\n     * @param {string} name\n     * @param {string[]} permissions\n     * @param {boolean} documentSecurity\n     * @param {boolean} enabled\n     * @throws {AppwriteException}\n     * @returns {Promise}\n     */\n    async updateCollection(databaseId, collectionId, name, permissions, documentSecurity, enabled) {\n        const apiPath = '/databases/{databaseId}/collections/{collectionId}'.replace('{databaseId}', databaseId).replace('{collectionId}', collectionId);\n        let payload = {};\n        if (typeof databaseId === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"databaseId\"');\n        }\n\n        if (typeof collectionId === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"collectionId\"');\n        }\n\n        if (typeof name === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"name\"');\n        }\n\n\n        if (typeof name !== 'undefined') {\n            payload['name'] = name;\n        }\n\n        if (typeof permissions !== 'undefined') {\n            payload['permissions'] = permissions;\n        }\n\n        if (typeof documentSecurity !== 'undefined') {\n            payload['documentSecurity'] = documentSecurity;\n        }\n\n        if (typeof enabled !== 'undefined') {\n            payload['enabled'] = enabled;\n        }\n\n        return await this.client.call('put', apiPath, {\n            'content-type': 'application/json',\n        }, payload);\n    }\n\n    /**\n     * Delete collection\n     *\n     * Delete a collection by its unique ID. Only users with write permissions\n     * have access to delete this resource.\n     *\n     * @param {string} databaseId\n     * @param {string} collectionId\n     * @throws {AppwriteException}\n     * @returns {Promise}\n     */\n    async deleteCollection(databaseId, collectionId) {\n        const apiPath = '/databases/{databaseId}/collections/{collectionId}'.replace('{databaseId}', databaseId).replace('{collectionId}', collectionId);\n        let payload = {};\n        if (typeof databaseId === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"databaseId\"');\n        }\n\n        if (typeof collectionId === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"collectionId\"');\n        }\n\n\n        return await this.client.call('delete', apiPath, {\n            'content-type': 'application/json',\n        }, payload);\n    }\n\n    /**\n     * List attributes\n     *\n     * List attributes in the collection.\n     *\n     * @param {string} databaseId\n     * @param {string} collectionId\n     * @param {string[]} queries\n     * @throws {AppwriteException}\n     * @returns {Promise}\n     */\n    async listAttributes(databaseId, collectionId, queries) {\n        const apiPath = '/databases/{databaseId}/collections/{collectionId}/attributes'.replace('{databaseId}', databaseId).replace('{collectionId}', collectionId);\n        let payload = {};\n        if (typeof databaseId === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"databaseId\"');\n        }\n\n        if (typeof collectionId === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"collectionId\"');\n        }\n\n\n        if (typeof queries !== 'undefined') {\n            payload['queries'] = queries;\n        }\n\n        return await this.client.call('get', apiPath, {\n            'content-type': 'application/json',\n        }, payload);\n    }\n\n    /**\n     * Create boolean attribute\n     *\n     * Create a boolean attribute.\n     * \n     *\n     * @param {string} databaseId\n     * @param {string} collectionId\n     * @param {string} key\n     * @param {boolean} required\n     * @param {boolean} xdefault\n     * @param {boolean} array\n     * @throws {AppwriteException}\n     * @returns {Promise}\n     */\n    async createBooleanAttribute(databaseId, collectionId, key, required, xdefault, array) {\n        const apiPath = '/databases/{databaseId}/collections/{collectionId}/attributes/boolean'.replace('{databaseId}', databaseId).replace('{collectionId}', collectionId);\n        let payload = {};\n        if (typeof databaseId === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"databaseId\"');\n        }\n\n        if (typeof collectionId === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"collectionId\"');\n        }\n\n        if (typeof key === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"key\"');\n        }\n\n        if (typeof required === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"required\"');\n        }\n\n\n        if (typeof key !== 'undefined') {\n            payload['key'] = key;\n        }\n\n        if (typeof required !== 'undefined') {\n            payload['required'] = required;\n        }\n\n        if (typeof xdefault !== 'undefined') {\n            payload['default'] = xdefault;\n        }\n\n        if (typeof array !== 'undefined') {\n            payload['array'] = array;\n        }\n\n        return await this.client.call('post', apiPath, {\n            'content-type': 'application/json',\n        }, payload);\n    }\n\n    /**\n     * Update boolean attribute\n     *\n     * Update a boolean attribute. Changing the `default` value will not update\n     * already existing documents.\n     *\n     * @param {string} databaseId\n     * @param {string} collectionId\n     * @param {string} key\n     * @param {boolean} required\n     * @param {boolean} xdefault\n     * @throws {AppwriteException}\n     * @returns {Promise}\n     */\n    async updateBooleanAttribute(databaseId, collectionId, key, required, xdefault) {\n        const apiPath = '/databases/{databaseId}/collections/{collectionId}/attributes/boolean/{key}'.replace('{databaseId}', databaseId).replace('{collectionId}', collectionId).replace('{key}', key);\n        let payload = {};\n        if (typeof databaseId === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"databaseId\"');\n        }\n\n        if (typeof collectionId === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"collectionId\"');\n        }\n\n        if (typeof key === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"key\"');\n        }\n\n        if (typeof required === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"required\"');\n        }\n\n        if (typeof xdefault === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"xdefault\"');\n        }\n\n\n        if (typeof required !== 'undefined') {\n            payload['required'] = required;\n        }\n\n        if (typeof xdefault !== 'undefined') {\n            payload['default'] = xdefault;\n        }\n\n        return await this.client.call('patch', apiPath, {\n            'content-type': 'application/json',\n        }, payload);\n    }\n\n    /**\n     * Create datetime attribute\n     *\n     * Create a date time attribute according to the ISO 8601 standard.\n     *\n     * @param {string} databaseId\n     * @param {string} collectionId\n     * @param {string} key\n     * @param {boolean} required\n     * @param {string} xdefault\n     * @param {boolean} array\n     * @throws {AppwriteException}\n     * @returns {Promise}\n     */\n    async createDatetimeAttribute(databaseId, collectionId, key, required, xdefault, array) {\n        const apiPath = '/databases/{databaseId}/collections/{collectionId}/attributes/datetime'.replace('{databaseId}', databaseId).replace('{collectionId}', collectionId);\n        let payload = {};\n        if (typeof databaseId === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"databaseId\"');\n        }\n\n        if (typeof collectionId === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"collectionId\"');\n        }\n\n        if (typeof key === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"key\"');\n        }\n\n        if (typeof required === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"required\"');\n        }\n\n\n        if (typeof key !== 'undefined') {\n            payload['key'] = key;\n        }\n\n        if (typeof required !== 'undefined') {\n            payload['required'] = required;\n        }\n\n        if (typeof xdefault !== 'undefined') {\n            payload['default'] = xdefault;\n        }\n\n        if (typeof array !== 'undefined') {\n            payload['array'] = array;\n        }\n\n        return await this.client.call('post', apiPath, {\n            'content-type': 'application/json',\n        }, payload);\n    }\n\n    /**\n     * Update dateTime attribute\n     *\n     * Update a date time attribute. Changing the `default` value will not update\n     * already existing documents.\n     *\n     * @param {string} databaseId\n     * @param {string} collectionId\n     * @param {string} key\n     * @param {boolean} required\n     * @param {string} xdefault\n     * @throws {AppwriteException}\n     * @returns {Promise}\n     */\n    async updateDatetimeAttribute(databaseId, collectionId, key, required, xdefault) {\n        const apiPath = '/databases/{databaseId}/collections/{collectionId}/attributes/datetime/{key}'.replace('{databaseId}', databaseId).replace('{collectionId}', collectionId).replace('{key}', key);\n        let payload = {};\n        if (typeof databaseId === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"databaseId\"');\n        }\n\n        if (typeof collectionId === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"collectionId\"');\n        }\n\n        if (typeof key === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"key\"');\n        }\n\n        if (typeof required === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"required\"');\n        }\n\n        if (typeof xdefault === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"xdefault\"');\n        }\n\n\n        if (typeof required !== 'undefined') {\n            payload['required'] = required;\n        }\n\n        if (typeof xdefault !== 'undefined') {\n            payload['default'] = xdefault;\n        }\n\n        return await this.client.call('patch', apiPath, {\n            'content-type': 'application/json',\n        }, payload);\n    }\n\n    /**\n     * Create email attribute\n     *\n     * Create an email attribute.\n     * \n     *\n     * @param {string} databaseId\n     * @param {string} collectionId\n     * @param {string} key\n     * @param {boolean} required\n     * @param {string} xdefault\n     * @param {boolean} array\n     * @throws {AppwriteException}\n     * @returns {Promise}\n     */\n    async createEmailAttribute(databaseId, collectionId, key, required, xdefault, array) {\n        const apiPath = '/databases/{databaseId}/collections/{collectionId}/attributes/email'.replace('{databaseId}', databaseId).replace('{collectionId}', collectionId);\n        let payload = {};\n        if (typeof databaseId === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"databaseId\"');\n        }\n\n        if (typeof collectionId === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"collectionId\"');\n        }\n\n        if (typeof key === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"key\"');\n        }\n\n        if (typeof required === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"required\"');\n        }\n\n\n        if (typeof key !== 'undefined') {\n            payload['key'] = key;\n        }\n\n        if (typeof required !== 'undefined') {\n            payload['required'] = required;\n        }\n\n        if (typeof xdefault !== 'undefined') {\n            payload['default'] = xdefault;\n        }\n\n        if (typeof array !== 'undefined') {\n            payload['array'] = array;\n        }\n\n        return await this.client.call('post', apiPath, {\n            'content-type': 'application/json',\n        }, payload);\n    }\n\n    /**\n     * Update email attribute\n     *\n     * Update an email attribute. Changing the `default` value will not update\n     * already existing documents.\n     * \n     *\n     * @param {string} databaseId\n     * @param {string} collectionId\n     * @param {string} key\n     * @param {boolean} required\n     * @param {string} xdefault\n     * @throws {AppwriteException}\n     * @returns {Promise}\n     */\n    async updateEmailAttribute(databaseId, collectionId, key, required, xdefault) {\n        const apiPath = '/databases/{databaseId}/collections/{collectionId}/attributes/email/{key}'.replace('{databaseId}', databaseId).replace('{collectionId}', collectionId).replace('{key}', key);\n        let payload = {};\n        if (typeof databaseId === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"databaseId\"');\n        }\n\n        if (typeof collectionId === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"collectionId\"');\n        }\n\n        if (typeof key === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"key\"');\n        }\n\n        if (typeof required === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"required\"');\n        }\n\n        if (typeof xdefault === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"xdefault\"');\n        }\n\n\n        if (typeof required !== 'undefined') {\n            payload['required'] = required;\n        }\n\n        if (typeof xdefault !== 'undefined') {\n            payload['default'] = xdefault;\n        }\n\n        return await this.client.call('patch', apiPath, {\n            'content-type': 'application/json',\n        }, payload);\n    }\n\n    /**\n     * Create enum attribute\n     *\n     * Create an enumeration attribute. The `elements` param acts as a white-list\n     * of accepted values for this attribute. \n     * \n     *\n     * @param {string} databaseId\n     * @param {string} collectionId\n     * @param {string} key\n     * @param {string[]} elements\n     * @param {boolean} required\n     * @param {string} xdefault\n     * @param {boolean} array\n     * @throws {AppwriteException}\n     * @returns {Promise}\n     */\n    async createEnumAttribute(databaseId, collectionId, key, elements, required, xdefault, array) {\n        const apiPath = '/databases/{databaseId}/collections/{collectionId}/attributes/enum'.replace('{databaseId}', databaseId).replace('{collectionId}', collectionId);\n        let payload = {};\n        if (typeof databaseId === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"databaseId\"');\n        }\n\n        if (typeof collectionId === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"collectionId\"');\n        }\n\n        if (typeof key === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"key\"');\n        }\n\n        if (typeof elements === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"elements\"');\n        }\n\n        if (typeof required === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"required\"');\n        }\n\n\n        if (typeof key !== 'undefined') {\n            payload['key'] = key;\n        }\n\n        if (typeof elements !== 'undefined') {\n            payload['elements'] = elements;\n        }\n\n        if (typeof required !== 'undefined') {\n            payload['required'] = required;\n        }\n\n        if (typeof xdefault !== 'undefined') {\n            payload['default'] = xdefault;\n        }\n\n        if (typeof array !== 'undefined') {\n            payload['array'] = array;\n        }\n\n        return await this.client.call('post', apiPath, {\n            'content-type': 'application/json',\n        }, payload);\n    }\n\n    /**\n     * Update enum attribute\n     *\n     * Update an enum attribute. Changing the `default` value will not update\n     * already existing documents.\n     * \n     *\n     * @param {string} databaseId\n     * @param {string} collectionId\n     * @param {string} key\n     * @param {string[]} elements\n     * @param {boolean} required\n     * @param {string} xdefault\n     * @throws {AppwriteException}\n     * @returns {Promise}\n     */\n    async updateEnumAttribute(databaseId, collectionId, key, elements, required, xdefault) {\n        const apiPath = '/databases/{databaseId}/collections/{collectionId}/attributes/enum/{key}'.replace('{databaseId}', databaseId).replace('{collectionId}', collectionId).replace('{key}', key);\n        let payload = {};\n        if (typeof databaseId === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"databaseId\"');\n        }\n\n        if (typeof collectionId === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"collectionId\"');\n        }\n\n        if (typeof key === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"key\"');\n        }\n\n        if (typeof elements === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"elements\"');\n        }\n\n        if (typeof required === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"required\"');\n        }\n\n        if (typeof xdefault === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"xdefault\"');\n        }\n\n\n        if (typeof elements !== 'undefined') {\n            payload['elements'] = elements;\n        }\n\n        if (typeof required !== 'undefined') {\n            payload['required'] = required;\n        }\n\n        if (typeof xdefault !== 'undefined') {\n            payload['default'] = xdefault;\n        }\n\n        return await this.client.call('patch', apiPath, {\n            'content-type': 'application/json',\n        }, payload);\n    }\n\n    /**\n     * Create float attribute\n     *\n     * Create a float attribute. Optionally, minimum and maximum values can be\n     * provided.\n     * \n     *\n     * @param {string} databaseId\n     * @param {string} collectionId\n     * @param {string} key\n     * @param {boolean} required\n     * @param {number} min\n     * @param {number} max\n     * @param {number} xdefault\n     * @param {boolean} array\n     * @throws {AppwriteException}\n     * @returns {Promise}\n     */\n    async createFloatAttribute(databaseId, collectionId, key, required, min, max, xdefault, array) {\n        const apiPath = '/databases/{databaseId}/collections/{collectionId}/attributes/float'.replace('{databaseId}', databaseId).replace('{collectionId}', collectionId);\n        let payload = {};\n        if (typeof databaseId === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"databaseId\"');\n        }\n\n        if (typeof collectionId === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"collectionId\"');\n        }\n\n        if (typeof key === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"key\"');\n        }\n\n        if (typeof required === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"required\"');\n        }\n\n\n        if (typeof key !== 'undefined') {\n            payload['key'] = key;\n        }\n\n        if (typeof required !== 'undefined') {\n            payload['required'] = required;\n        }\n\n        if (typeof min !== 'undefined') {\n            payload['min'] = min;\n        }\n\n        if (typeof max !== 'undefined') {\n            payload['max'] = max;\n        }\n\n        if (typeof xdefault !== 'undefined') {\n            payload['default'] = xdefault;\n        }\n\n        if (typeof array !== 'undefined') {\n            payload['array'] = array;\n        }\n\n        return await this.client.call('post', apiPath, {\n            'content-type': 'application/json',\n        }, payload);\n    }\n\n    /**\n     * Update float attribute\n     *\n     * Update a float attribute. Changing the `default` value will not update\n     * already existing documents.\n     * \n     *\n     * @param {string} databaseId\n     * @param {string} collectionId\n     * @param {string} key\n     * @param {boolean} required\n     * @param {number} min\n     * @param {number} max\n     * @param {number} xdefault\n     * @throws {AppwriteException}\n     * @returns {Promise}\n     */\n    async updateFloatAttribute(databaseId, collectionId, key, required, min, max, xdefault) {\n        const apiPath = '/databases/{databaseId}/collections/{collectionId}/attributes/float/{key}'.replace('{databaseId}', databaseId).replace('{collectionId}', collectionId).replace('{key}', key);\n        let payload = {};\n        if (typeof databaseId === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"databaseId\"');\n        }\n\n        if (typeof collectionId === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"collectionId\"');\n        }\n\n        if (typeof key === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"key\"');\n        }\n\n        if (typeof required === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"required\"');\n        }\n\n        if (typeof min === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"min\"');\n        }\n\n        if (typeof max === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"max\"');\n        }\n\n        if (typeof xdefault === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"xdefault\"');\n        }\n\n\n        if (typeof required !== 'undefined') {\n            payload['required'] = required;\n        }\n\n        if (typeof min !== 'undefined') {\n            payload['min'] = min;\n        }\n\n        if (typeof max !== 'undefined') {\n            payload['max'] = max;\n        }\n\n        if (typeof xdefault !== 'undefined') {\n            payload['default'] = xdefault;\n        }\n\n        return await this.client.call('patch', apiPath, {\n            'content-type': 'application/json',\n        }, payload);\n    }\n\n    /**\n     * Create integer attribute\n     *\n     * Create an integer attribute. Optionally, minimum and maximum values can be\n     * provided.\n     * \n     *\n     * @param {string} databaseId\n     * @param {string} collectionId\n     * @param {string} key\n     * @param {boolean} required\n     * @param {number} min\n     * @param {number} max\n     * @param {number} xdefault\n     * @param {boolean} array\n     * @throws {AppwriteException}\n     * @returns {Promise}\n     */\n    async createIntegerAttribute(databaseId, collectionId, key, required, min, max, xdefault, array) {\n        const apiPath = '/databases/{databaseId}/collections/{collectionId}/attributes/integer'.replace('{databaseId}', databaseId).replace('{collectionId}', collectionId);\n        let payload = {};\n        if (typeof databaseId === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"databaseId\"');\n        }\n\n        if (typeof collectionId === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"collectionId\"');\n        }\n\n        if (typeof key === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"key\"');\n        }\n\n        if (typeof required === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"required\"');\n        }\n\n\n        if (typeof key !== 'undefined') {\n            payload['key'] = key;\n        }\n\n        if (typeof required !== 'undefined') {\n            payload['required'] = required;\n        }\n\n        if (typeof min !== 'undefined') {\n            payload['min'] = min;\n        }\n\n        if (typeof max !== 'undefined') {\n            payload['max'] = max;\n        }\n\n        if (typeof xdefault !== 'undefined') {\n            payload['default'] = xdefault;\n        }\n\n        if (typeof array !== 'undefined') {\n            payload['array'] = array;\n        }\n\n        return await this.client.call('post', apiPath, {\n            'content-type': 'application/json',\n        }, payload);\n    }\n\n    /**\n     * Update integer attribute\n     *\n     * Update an integer attribute. Changing the `default` value will not update\n     * already existing documents.\n     * \n     *\n     * @param {string} databaseId\n     * @param {string} collectionId\n     * @param {string} key\n     * @param {boolean} required\n     * @param {number} min\n     * @param {number} max\n     * @param {number} xdefault\n     * @throws {AppwriteException}\n     * @returns {Promise}\n     */\n    async updateIntegerAttribute(databaseId, collectionId, key, required, min, max, xdefault) {\n        const apiPath = '/databases/{databaseId}/collections/{collectionId}/attributes/integer/{key}'.replace('{databaseId}', databaseId).replace('{collectionId}', collectionId).replace('{key}', key);\n        let payload = {};\n        if (typeof databaseId === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"databaseId\"');\n        }\n\n        if (typeof collectionId === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"collectionId\"');\n        }\n\n        if (typeof key === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"key\"');\n        }\n\n        if (typeof required === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"required\"');\n        }\n\n        if (typeof min === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"min\"');\n        }\n\n        if (typeof max === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"max\"');\n        }\n\n        if (typeof xdefault === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"xdefault\"');\n        }\n\n\n        if (typeof required !== 'undefined') {\n            payload['required'] = required;\n        }\n\n        if (typeof min !== 'undefined') {\n            payload['min'] = min;\n        }\n\n        if (typeof max !== 'undefined') {\n            payload['max'] = max;\n        }\n\n        if (typeof xdefault !== 'undefined') {\n            payload['default'] = xdefault;\n        }\n\n        return await this.client.call('patch', apiPath, {\n            'content-type': 'application/json',\n        }, payload);\n    }\n\n    /**\n     * Create IP address attribute\n     *\n     * Create IP address attribute.\n     * \n     *\n     * @param {string} databaseId\n     * @param {string} collectionId\n     * @param {string} key\n     * @param {boolean} required\n     * @param {string} xdefault\n     * @param {boolean} array\n     * @throws {AppwriteException}\n     * @returns {Promise}\n     */\n    async createIpAttribute(databaseId, collectionId, key, required, xdefault, array) {\n        const apiPath = '/databases/{databaseId}/collections/{collectionId}/attributes/ip'.replace('{databaseId}', databaseId).replace('{collectionId}', collectionId);\n        let payload = {};\n        if (typeof databaseId === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"databaseId\"');\n        }\n\n        if (typeof collectionId === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"collectionId\"');\n        }\n\n        if (typeof key === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"key\"');\n        }\n\n        if (typeof required === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"required\"');\n        }\n\n\n        if (typeof key !== 'undefined') {\n            payload['key'] = key;\n        }\n\n        if (typeof required !== 'undefined') {\n            payload['required'] = required;\n        }\n\n        if (typeof xdefault !== 'undefined') {\n            payload['default'] = xdefault;\n        }\n\n        if (typeof array !== 'undefined') {\n            payload['array'] = array;\n        }\n\n        return await this.client.call('post', apiPath, {\n            'content-type': 'application/json',\n        }, payload);\n    }\n\n    /**\n     * Update IP address attribute\n     *\n     * Update an ip attribute. Changing the `default` value will not update\n     * already existing documents.\n     * \n     *\n     * @param {string} databaseId\n     * @param {string} collectionId\n     * @param {string} key\n     * @param {boolean} required\n     * @param {string} xdefault\n     * @throws {AppwriteException}\n     * @returns {Promise}\n     */\n    async updateIpAttribute(databaseId, collectionId, key, required, xdefault) {\n        const apiPath = '/databases/{databaseId}/collections/{collectionId}/attributes/ip/{key}'.replace('{databaseId}', databaseId).replace('{collectionId}', collectionId).replace('{key}', key);\n        let payload = {};\n        if (typeof databaseId === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"databaseId\"');\n        }\n\n        if (typeof collectionId === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"collectionId\"');\n        }\n\n        if (typeof key === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"key\"');\n        }\n\n        if (typeof required === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"required\"');\n        }\n\n        if (typeof xdefault === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"xdefault\"');\n        }\n\n\n        if (typeof required !== 'undefined') {\n            payload['required'] = required;\n        }\n\n        if (typeof xdefault !== 'undefined') {\n            payload['default'] = xdefault;\n        }\n\n        return await this.client.call('patch', apiPath, {\n            'content-type': 'application/json',\n        }, payload);\n    }\n\n    /**\n     * Create relationship attribute\n     *\n     * Create relationship attribute. [Learn more about relationship\n     * attributes](https://appwrite.io/docs/databases-relationships#relationship-attributes).\n     * \n     *\n     * @param {string} databaseId\n     * @param {string} collectionId\n     * @param {string} relatedCollectionId\n     * @param {RelationshipType} type\n     * @param {boolean} twoWay\n     * @param {string} key\n     * @param {string} twoWayKey\n     * @param {RelationMutate} onDelete\n     * @throws {AppwriteException}\n     * @returns {Promise}\n     */\n    async createRelationshipAttribute(databaseId, collectionId, relatedCollectionId, type, twoWay, key, twoWayKey, onDelete) {\n        const apiPath = '/databases/{databaseId}/collections/{collectionId}/attributes/relationship'.replace('{databaseId}', databaseId).replace('{collectionId}', collectionId);\n        let payload = {};\n        if (typeof databaseId === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"databaseId\"');\n        }\n\n        if (typeof collectionId === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"collectionId\"');\n        }\n\n        if (typeof relatedCollectionId === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"relatedCollectionId\"');\n        }\n\n        if (typeof type === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"type\"');\n        }\n\n\n        if (typeof relatedCollectionId !== 'undefined') {\n            payload['relatedCollectionId'] = relatedCollectionId;\n        }\n\n        if (typeof type !== 'undefined') {\n            payload['type'] = type;\n        }\n\n        if (typeof twoWay !== 'undefined') {\n            payload['twoWay'] = twoWay;\n        }\n\n        if (typeof key !== 'undefined') {\n            payload['key'] = key;\n        }\n\n        if (typeof twoWayKey !== 'undefined') {\n            payload['twoWayKey'] = twoWayKey;\n        }\n\n        if (typeof onDelete !== 'undefined') {\n            payload['onDelete'] = onDelete;\n        }\n\n        return await this.client.call('post', apiPath, {\n            'content-type': 'application/json',\n        }, payload);\n    }\n\n    /**\n     * Create string attribute\n     *\n     * Create a string attribute.\n     * \n     *\n     * @param {string} databaseId\n     * @param {string} collectionId\n     * @param {string} key\n     * @param {number} size\n     * @param {boolean} required\n     * @param {string} xdefault\n     * @param {boolean} array\n     * @param {boolean} encrypt\n     * @throws {AppwriteException}\n     * @returns {Promise}\n     */\n    async createStringAttribute(databaseId, collectionId, key, size, required, xdefault, array, encrypt) {\n        const apiPath = '/databases/{databaseId}/collections/{collectionId}/attributes/string'.replace('{databaseId}', databaseId).replace('{collectionId}', collectionId);\n        let payload = {};\n        if (typeof databaseId === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"databaseId\"');\n        }\n\n        if (typeof collectionId === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"collectionId\"');\n        }\n\n        if (typeof key === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"key\"');\n        }\n\n        if (typeof size === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"size\"');\n        }\n\n        if (typeof required === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"required\"');\n        }\n\n\n        if (typeof key !== 'undefined') {\n            payload['key'] = key;\n        }\n\n        if (typeof size !== 'undefined') {\n            payload['size'] = size;\n        }\n\n        if (typeof required !== 'undefined') {\n            payload['required'] = required;\n        }\n\n        if (typeof xdefault !== 'undefined') {\n            payload['default'] = xdefault;\n        }\n\n        if (typeof array !== 'undefined') {\n            payload['array'] = array;\n        }\n\n        if (typeof encrypt !== 'undefined') {\n            payload['encrypt'] = encrypt;\n        }\n\n        return await this.client.call('post', apiPath, {\n            'content-type': 'application/json',\n        }, payload);\n    }\n\n    /**\n     * Update string attribute\n     *\n     * Update a string attribute. Changing the `default` value will not update\n     * already existing documents.\n     * \n     *\n     * @param {string} databaseId\n     * @param {string} collectionId\n     * @param {string} key\n     * @param {boolean} required\n     * @param {string} xdefault\n     * @throws {AppwriteException}\n     * @returns {Promise}\n     */\n    async updateStringAttribute(databaseId, collectionId, key, required, xdefault) {\n        const apiPath = '/databases/{databaseId}/collections/{collectionId}/attributes/string/{key}'.replace('{databaseId}', databaseId).replace('{collectionId}', collectionId).replace('{key}', key);\n        let payload = {};\n        if (typeof databaseId === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"databaseId\"');\n        }\n\n        if (typeof collectionId === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"collectionId\"');\n        }\n\n        if (typeof key === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"key\"');\n        }\n\n        if (typeof required === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"required\"');\n        }\n\n        if (typeof xdefault === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"xdefault\"');\n        }\n\n\n        if (typeof required !== 'undefined') {\n            payload['required'] = required;\n        }\n\n        if (typeof xdefault !== 'undefined') {\n            payload['default'] = xdefault;\n        }\n\n        return await this.client.call('patch', apiPath, {\n            'content-type': 'application/json',\n        }, payload);\n    }\n\n    /**\n     * Create URL attribute\n     *\n     * Create a URL attribute.\n     * \n     *\n     * @param {string} databaseId\n     * @param {string} collectionId\n     * @param {string} key\n     * @param {boolean} required\n     * @param {string} xdefault\n     * @param {boolean} array\n     * @throws {AppwriteException}\n     * @returns {Promise}\n     */\n    async createUrlAttribute(databaseId, collectionId, key, required, xdefault, array) {\n        const apiPath = '/databases/{databaseId}/collections/{collectionId}/attributes/url'.replace('{databaseId}', databaseId).replace('{collectionId}', collectionId);\n        let payload = {};\n        if (typeof databaseId === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"databaseId\"');\n        }\n\n        if (typeof collectionId === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"collectionId\"');\n        }\n\n        if (typeof key === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"key\"');\n        }\n\n        if (typeof required === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"required\"');\n        }\n\n\n        if (typeof key !== 'undefined') {\n            payload['key'] = key;\n        }\n\n        if (typeof required !== 'undefined') {\n            payload['required'] = required;\n        }\n\n        if (typeof xdefault !== 'undefined') {\n            payload['default'] = xdefault;\n        }\n\n        if (typeof array !== 'undefined') {\n            payload['array'] = array;\n        }\n\n        return await this.client.call('post', apiPath, {\n            'content-type': 'application/json',\n        }, payload);\n    }\n\n    /**\n     * Update URL attribute\n     *\n     * Update an url attribute. Changing the `default` value will not update\n     * already existing documents.\n     * \n     *\n     * @param {string} databaseId\n     * @param {string} collectionId\n     * @param {string} key\n     * @param {boolean} required\n     * @param {string} xdefault\n     * @throws {AppwriteException}\n     * @returns {Promise}\n     */\n    async updateUrlAttribute(databaseId, collectionId, key, required, xdefault) {\n        const apiPath = '/databases/{databaseId}/collections/{collectionId}/attributes/url/{key}'.replace('{databaseId}', databaseId).replace('{collectionId}', collectionId).replace('{key}', key);\n        let payload = {};\n        if (typeof databaseId === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"databaseId\"');\n        }\n\n        if (typeof collectionId === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"collectionId\"');\n        }\n\n        if (typeof key === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"key\"');\n        }\n\n        if (typeof required === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"required\"');\n        }\n\n        if (typeof xdefault === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"xdefault\"');\n        }\n\n\n        if (typeof required !== 'undefined') {\n            payload['required'] = required;\n        }\n\n        if (typeof xdefault !== 'undefined') {\n            payload['default'] = xdefault;\n        }\n\n        return await this.client.call('patch', apiPath, {\n            'content-type': 'application/json',\n        }, payload);\n    }\n\n    /**\n     * Get attribute\n     *\n     * Get attribute by ID.\n     *\n     * @param {string} databaseId\n     * @param {string} collectionId\n     * @param {string} key\n     * @throws {AppwriteException}\n     * @returns {Promise}\n     */\n    async getAttribute(databaseId, collectionId, key) {\n        const apiPath = '/databases/{databaseId}/collections/{collectionId}/attributes/{key}'.replace('{databaseId}', databaseId).replace('{collectionId}', collectionId).replace('{key}', key);\n        let payload = {};\n        if (typeof databaseId === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"databaseId\"');\n        }\n\n        if (typeof collectionId === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"collectionId\"');\n        }\n\n        if (typeof key === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"key\"');\n        }\n\n\n        return await this.client.call('get', apiPath, {\n            'content-type': 'application/json',\n        }, payload);\n    }\n\n    /**\n     * Delete attribute\n     *\n     * Deletes an attribute.\n     *\n     * @param {string} databaseId\n     * @param {string} collectionId\n     * @param {string} key\n     * @throws {AppwriteException}\n     * @returns {Promise}\n     */\n    async deleteAttribute(databaseId, collectionId, key) {\n        const apiPath = '/databases/{databaseId}/collections/{collectionId}/attributes/{key}'.replace('{databaseId}', databaseId).replace('{collectionId}', collectionId).replace('{key}', key);\n        let payload = {};\n        if (typeof databaseId === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"databaseId\"');\n        }\n\n        if (typeof collectionId === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"collectionId\"');\n        }\n\n        if (typeof key === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"key\"');\n        }\n\n\n        return await this.client.call('delete', apiPath, {\n            'content-type': 'application/json',\n        }, payload);\n    }\n\n    /**\n     * Update relationship attribute\n     *\n     * Update relationship attribute. [Learn more about relationship\n     * attributes](https://appwrite.io/docs/databases-relationships#relationship-attributes).\n     * \n     *\n     * @param {string} databaseId\n     * @param {string} collectionId\n     * @param {string} key\n     * @param {RelationMutate} onDelete\n     * @throws {AppwriteException}\n     * @returns {Promise}\n     */\n    async updateRelationshipAttribute(databaseId, collectionId, key, onDelete) {\n        const apiPath = '/databases/{databaseId}/collections/{collectionId}/attributes/{key}/relationship'.replace('{databaseId}', databaseId).replace('{collectionId}', collectionId).replace('{key}', key);\n        let payload = {};\n        if (typeof databaseId === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"databaseId\"');\n        }\n\n        if (typeof collectionId === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"collectionId\"');\n        }\n\n        if (typeof key === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"key\"');\n        }\n\n\n        if (typeof onDelete !== 'undefined') {\n            payload['onDelete'] = onDelete;\n        }\n\n        return await this.client.call('patch', apiPath, {\n            'content-type': 'application/json',\n        }, payload);\n    }\n\n    /**\n     * List documents\n     *\n     * Get a list of all the user's documents in a given collection. You can use\n     * the query params to filter your results.\n     *\n     * @param {string} databaseId\n     * @param {string} collectionId\n     * @param {string[]} queries\n     * @throws {AppwriteException}\n     * @returns {Promise}\n     */\n    async listDocuments(databaseId, collectionId, queries) {\n        const apiPath = '/databases/{databaseId}/collections/{collectionId}/documents'.replace('{databaseId}', databaseId).replace('{collectionId}', collectionId);\n        let payload = {};\n        if (typeof databaseId === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"databaseId\"');\n        }\n\n        if (typeof collectionId === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"collectionId\"');\n        }\n\n\n        if (typeof queries !== 'undefined') {\n            payload['queries'] = queries;\n        }\n\n        return await this.client.call('get', apiPath, {\n            'content-type': 'application/json',\n        }, payload);\n    }\n\n    /**\n     * Create document\n     *\n     * Create a new Document. Before using this route, you should create a new\n     * collection resource using either a [server\n     * integration](https://appwrite.io/docs/server/databases#databasesCreateCollection)\n     * API or directly from your database console.\n     *\n     * @param {string} databaseId\n     * @param {string} collectionId\n     * @param {string} documentId\n     * @param {object} data\n     * @param {string[]} permissions\n     * @throws {AppwriteException}\n     * @returns {Promise}\n     */\n    async createDocument(databaseId, collectionId, documentId, data, permissions) {\n        const apiPath = '/databases/{databaseId}/collections/{collectionId}/documents'.replace('{databaseId}', databaseId).replace('{collectionId}', collectionId);\n        let payload = {};\n        if (typeof databaseId === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"databaseId\"');\n        }\n\n        if (typeof collectionId === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"collectionId\"');\n        }\n\n        if (typeof documentId === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"documentId\"');\n        }\n\n        if (typeof data === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"data\"');\n        }\n\n\n        if (typeof documentId !== 'undefined') {\n            payload['documentId'] = documentId;\n        }\n\n        if (typeof data !== 'undefined') {\n            payload['data'] = data;\n        }\n\n        if (typeof permissions !== 'undefined') {\n            payload['permissions'] = permissions;\n        }\n\n        return await this.client.call('post', apiPath, {\n            'content-type': 'application/json',\n        }, payload);\n    }\n\n    /**\n     * Get document\n     *\n     * Get a document by its unique ID. This endpoint response returns a JSON\n     * object with the document data.\n     *\n     * @param {string} databaseId\n     * @param {string} collectionId\n     * @param {string} documentId\n     * @param {string[]} queries\n     * @throws {AppwriteException}\n     * @returns {Promise}\n     */\n    async getDocument(databaseId, collectionId, documentId, queries) {\n        const apiPath = '/databases/{databaseId}/collections/{collectionId}/documents/{documentId}'.replace('{databaseId}', databaseId).replace('{collectionId}', collectionId).replace('{documentId}', documentId);\n        let payload = {};\n        if (typeof databaseId === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"databaseId\"');\n        }\n\n        if (typeof collectionId === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"collectionId\"');\n        }\n\n        if (typeof documentId === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"documentId\"');\n        }\n\n\n        if (typeof queries !== 'undefined') {\n            payload['queries'] = queries;\n        }\n\n        return await this.client.call('get', apiPath, {\n            'content-type': 'application/json',\n        }, payload);\n    }\n\n    /**\n     * Update document\n     *\n     * Update a document by its unique ID. Using the patch method you can pass\n     * only specific fields that will get updated.\n     *\n     * @param {string} databaseId\n     * @param {string} collectionId\n     * @param {string} documentId\n     * @param {object} data\n     * @param {string[]} permissions\n     * @throws {AppwriteException}\n     * @returns {Promise}\n     */\n    async updateDocument(databaseId, collectionId, documentId, data, permissions) {\n        const apiPath = '/databases/{databaseId}/collections/{collectionId}/documents/{documentId}'.replace('{databaseId}', databaseId).replace('{collectionId}', collectionId).replace('{documentId}', documentId);\n        let payload = {};\n        if (typeof databaseId === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"databaseId\"');\n        }\n\n        if (typeof collectionId === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"collectionId\"');\n        }\n\n        if (typeof documentId === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"documentId\"');\n        }\n\n\n        if (typeof data !== 'undefined') {\n            payload['data'] = data;\n        }\n\n        if (typeof permissions !== 'undefined') {\n            payload['permissions'] = permissions;\n        }\n\n        return await this.client.call('patch', apiPath, {\n            'content-type': 'application/json',\n        }, payload);\n    }\n\n    /**\n     * Delete document\n     *\n     * Delete a document by its unique ID.\n     *\n     * @param {string} databaseId\n     * @param {string} collectionId\n     * @param {string} documentId\n     * @throws {AppwriteException}\n     * @returns {Promise}\n     */\n    async deleteDocument(databaseId, collectionId, documentId) {\n        const apiPath = '/databases/{databaseId}/collections/{collectionId}/documents/{documentId}'.replace('{databaseId}', databaseId).replace('{collectionId}', collectionId).replace('{documentId}', documentId);\n        let payload = {};\n        if (typeof databaseId === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"databaseId\"');\n        }\n\n        if (typeof collectionId === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"collectionId\"');\n        }\n\n        if (typeof documentId === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"documentId\"');\n        }\n\n\n        return await this.client.call('delete', apiPath, {\n            'content-type': 'application/json',\n        }, payload);\n    }\n\n    /**\n     * List indexes\n     *\n     * List indexes in the collection.\n     *\n     * @param {string} databaseId\n     * @param {string} collectionId\n     * @param {string[]} queries\n     * @throws {AppwriteException}\n     * @returns {Promise}\n     */\n    async listIndexes(databaseId, collectionId, queries) {\n        const apiPath = '/databases/{databaseId}/collections/{collectionId}/indexes'.replace('{databaseId}', databaseId).replace('{collectionId}', collectionId);\n        let payload = {};\n        if (typeof databaseId === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"databaseId\"');\n        }\n\n        if (typeof collectionId === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"collectionId\"');\n        }\n\n\n        if (typeof queries !== 'undefined') {\n            payload['queries'] = queries;\n        }\n\n        return await this.client.call('get', apiPath, {\n            'content-type': 'application/json',\n        }, payload);\n    }\n\n    /**\n     * Create index\n     *\n     * Creates an index on the attributes listed. Your index should include all\n     * the attributes you will query in a single request.\n     * Attributes can be `key`, `fulltext`, and `unique`.\n     *\n     * @param {string} databaseId\n     * @param {string} collectionId\n     * @param {string} key\n     * @param {IndexType} type\n     * @param {string[]} attributes\n     * @param {string[]} orders\n     * @throws {AppwriteException}\n     * @returns {Promise}\n     */\n    async createIndex(databaseId, collectionId, key, type, attributes, orders) {\n        const apiPath = '/databases/{databaseId}/collections/{collectionId}/indexes'.replace('{databaseId}', databaseId).replace('{collectionId}', collectionId);\n        let payload = {};\n        if (typeof databaseId === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"databaseId\"');\n        }\n\n        if (typeof collectionId === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"collectionId\"');\n        }\n\n        if (typeof key === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"key\"');\n        }\n\n        if (typeof type === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"type\"');\n        }\n\n        if (typeof attributes === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"attributes\"');\n        }\n\n\n        if (typeof key !== 'undefined') {\n            payload['key'] = key;\n        }\n\n        if (typeof type !== 'undefined') {\n            payload['type'] = type;\n        }\n\n        if (typeof attributes !== 'undefined') {\n            payload['attributes'] = attributes;\n        }\n\n        if (typeof orders !== 'undefined') {\n            payload['orders'] = orders;\n        }\n\n        return await this.client.call('post', apiPath, {\n            'content-type': 'application/json',\n        }, payload);\n    }\n\n    /**\n     * Get index\n     *\n     * Get index by ID.\n     *\n     * @param {string} databaseId\n     * @param {string} collectionId\n     * @param {string} key\n     * @throws {AppwriteException}\n     * @returns {Promise}\n     */\n    async getIndex(databaseId, collectionId, key) {\n        const apiPath = '/databases/{databaseId}/collections/{collectionId}/indexes/{key}'.replace('{databaseId}', databaseId).replace('{collectionId}', collectionId).replace('{key}', key);\n        let payload = {};\n        if (typeof databaseId === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"databaseId\"');\n        }\n\n        if (typeof collectionId === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"collectionId\"');\n        }\n\n        if (typeof key === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"key\"');\n        }\n\n\n        return await this.client.call('get', apiPath, {\n            'content-type': 'application/json',\n        }, payload);\n    }\n\n    /**\n     * Delete index\n     *\n     * Delete an index.\n     *\n     * @param {string} databaseId\n     * @param {string} collectionId\n     * @param {string} key\n     * @throws {AppwriteException}\n     * @returns {Promise}\n     */\n    async deleteIndex(databaseId, collectionId, key) {\n        const apiPath = '/databases/{databaseId}/collections/{collectionId}/indexes/{key}'.replace('{databaseId}', databaseId).replace('{collectionId}', collectionId).replace('{key}', key);\n        let payload = {};\n        if (typeof databaseId === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"databaseId\"');\n        }\n\n        if (typeof collectionId === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"collectionId\"');\n        }\n\n        if (typeof key === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"key\"');\n        }\n\n\n        return await this.client.call('delete', apiPath, {\n            'content-type': 'application/json',\n        }, payload);\n    }\n}\n\nmodule.exports = Databases;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFjdGlvbi1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9ub2RlLWFwcHdyaXRlL2xpYi9zZXJ2aWNlcy9kYXRhYmFzZXMuanMiLCJtYXBwaW5ncyI6IkFBQUEsZ0JBQWdCLG1CQUFPLENBQUMsbUZBQWU7QUFDdkMsMEJBQTBCLG1CQUFPLENBQUMsdUZBQWlCO0FBQ25ELGtCQUFrQixtQkFBTyxDQUFDLHVGQUFpQjtBQUMzQyxlQUFlLG1CQUFPLENBQUMsaUZBQWM7QUFDckMsZUFBZSxtQkFBTyxDQUFDLHNCQUFRO0FBQy9CLFFBQVEsWUFBWSxFQUFFLG1CQUFPLENBQUMsa0JBQU07QUFDcEMsV0FBVyxtQkFBTyxDQUFDLGNBQUk7QUFDdkIsUUFBUSxPQUFPLEVBQUUsbUJBQU8sQ0FBQyxzQkFBUTtBQUNqQyxjQUFjLG1CQUFPLENBQUMsK0VBQWE7O0FBRW5DOztBQUVBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFVBQVU7QUFDekIsZUFBZSxRQUFRO0FBQ3ZCLGdCQUFnQjtBQUNoQixpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsU0FBUztBQUNUOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QixlQUFlLFFBQVE7QUFDdkIsZUFBZSxTQUFTO0FBQ3hCLGdCQUFnQjtBQUNoQixpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsU0FBUztBQUNUOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QixnQkFBZ0I7QUFDaEIsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQSxx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QTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFNBQVM7QUFDVDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsUUFBUTtBQUN2QixlQUFlLFFBQVE7QUFDdkIsZ0JBQWdCO0FBQ2hCLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0EscUNBQXFDLFdBQVcsY0FBYyxhQUFhLFVBQVUsSUFBSSxZQUFZLFdBQVcseUJBQXlCLGFBQWEsMkJBQTJCLElBQUk7QUFDckw7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBLFNBQVM7QUFDVDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsUUFBUTtBQUN2QixlQUFlLFFBQVE7QUFDdkIsZ0JBQWdCO0FBQ2hCLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0EscUNBQXFDLFdBQVcsY0FBYyxhQUFhLFVBQVUsSUFBSSxZQUFZLFdBQVcseUJBQXlCLGFBQWEsMkJBQTJCLElBQUk7QUFDckw7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBOztBQUVBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vanNtX2JhbmtpbmcvLi9ub2RlX21vZHVsZXMvbm9kZS1hcHB3cml0ZS9saWIvc2VydmljZXMvZGF0YWJhc2VzLmpzPzFlZjkiXSwic291cmNlc0NvbnRlbnQiOlsiY29uc3QgU2VydmljZSA9IHJlcXVpcmUoJy4uL3NlcnZpY2UuanMnKTtcbmNvbnN0IEFwcHdyaXRlRXhjZXB0aW9uID0gcmVxdWlyZSgnLi4vZXhjZXB0aW9uLmpzJyk7XG5jb25zdCBJbnB1dEZpbGUgPSByZXF1aXJlKCcuLi9pbnB1dEZpbGUuanMnKTtcbmNvbnN0IGNsaWVudCA9IHJlcXVpcmUoJy4uL2NsaWVudC5qcycpO1xuY29uc3QgU3RyZWFtID0gcmVxdWlyZSgnc3RyZWFtJyk7XG5jb25zdCB7IHByb21pc2lmeSB9ID0gcmVxdWlyZSgndXRpbCcpO1xuY29uc3QgZnMgPSByZXF1aXJlKCdmcycpO1xuY29uc3QgeyBGaWxlIH0gPSByZXF1aXJlKCd1bmRpY2knKTtcbmNvbnN0IFF1ZXJ5ID0gcmVxdWlyZSgnLi4vcXVlcnkuanMnKTtcblxuY2xhc3MgRGF0YWJhc2VzIGV4dGVuZHMgU2VydmljZSB7XG5cbiAgICAgY29uc3RydWN0b3IoY2xpZW50KVxuICAgICB7XG4gICAgICAgIHN1cGVyKGNsaWVudCk7XG4gICAgIH1cblxuXG4gICAgLyoqXG4gICAgICogTGlzdCBkYXRhYmFzZXNcbiAgICAgKlxuICAgICAqIEdldCBhIGxpc3Qgb2YgYWxsIGRhdGFiYXNlcyBmcm9tIHRoZSBjdXJyZW50IEFwcHdyaXRlIHByb2plY3QuIFlvdSBjYW4gdXNlXG4gICAgICogdGhlIHNlYXJjaCBwYXJhbWV0ZXIgdG8gZmlsdGVyIHlvdXIgcmVzdWx0cy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nW119IHF1ZXJpZXNcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gc2VhcmNoXG4gICAgICogQHRocm93cyB7QXBwd3JpdGVFeGNlcHRpb259XG4gICAgICogQHJldHVybnMge1Byb21pc2V9XG4gICAgICovXG4gICAgYXN5bmMgbGlzdChxdWVyaWVzLCBzZWFyY2gpIHtcbiAgICAgICAgY29uc3QgYXBpUGF0aCA9ICcvZGF0YWJhc2VzJztcbiAgICAgICAgbGV0IHBheWxvYWQgPSB7fTtcblxuICAgICAgICBpZiAodHlwZW9mIHF1ZXJpZXMgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICBwYXlsb2FkWydxdWVyaWVzJ10gPSBxdWVyaWVzO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHR5cGVvZiBzZWFyY2ggIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICBwYXlsb2FkWydzZWFyY2gnXSA9IHNlYXJjaDtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBhd2FpdCB0aGlzLmNsaWVudC5jYWxsKCdnZXQnLCBhcGlQYXRoLCB7XG4gICAgICAgICAgICAnY29udGVudC10eXBlJzogJ2FwcGxpY2F0aW9uL2pzb24nLFxuICAgICAgICB9LCBwYXlsb2FkKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGUgZGF0YWJhc2VcbiAgICAgKlxuICAgICAqIENyZWF0ZSBhIG5ldyBEYXRhYmFzZS5cbiAgICAgKiBcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBkYXRhYmFzZUlkXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IG5hbWVcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IGVuYWJsZWRcbiAgICAgKiBAdGhyb3dzIHtBcHB3cml0ZUV4Y2VwdGlvbn1cbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZX1cbiAgICAgKi9cbiAgICBhc3luYyBjcmVhdGUoZGF0YWJhc2VJZCwgbmFtZSwgZW5hYmxlZCkge1xuICAgICAgICBjb25zdCBhcGlQYXRoID0gJy9kYXRhYmFzZXMnO1xuICAgICAgICBsZXQgcGF5bG9hZCA9IHt9O1xuICAgICAgICBpZiAodHlwZW9mIGRhdGFiYXNlSWQgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgQXBwd3JpdGVFeGNlcHRpb24oJ01pc3NpbmcgcmVxdWlyZWQgcGFyYW1ldGVyOiBcImRhdGFiYXNlSWRcIicpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHR5cGVvZiBuYW1lID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEFwcHdyaXRlRXhjZXB0aW9uKCdNaXNzaW5nIHJlcXVpcmVkIHBhcmFtZXRlcjogXCJuYW1lXCInKTtcbiAgICAgICAgfVxuXG5cbiAgICAgICAgaWYgKHR5cGVvZiBkYXRhYmFzZUlkICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgcGF5bG9hZFsnZGF0YWJhc2VJZCddID0gZGF0YWJhc2VJZDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0eXBlb2YgbmFtZSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHBheWxvYWRbJ25hbWUnXSA9IG5hbWU7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodHlwZW9mIGVuYWJsZWQgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICBwYXlsb2FkWydlbmFibGVkJ10gPSBlbmFibGVkO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMuY2xpZW50LmNhbGwoJ3Bvc3QnLCBhcGlQYXRoLCB7XG4gICAgICAgICAgICAnY29udGVudC10eXBlJzogJ2FwcGxpY2F0aW9uL2pzb24nLFxuICAgICAgICB9LCBwYXlsb2FkKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZXQgZGF0YWJhc2VcbiAgICAgKlxuICAgICAqIEdldCBhIGRhdGFiYXNlIGJ5IGl0cyB1bmlxdWUgSUQuIFRoaXMgZW5kcG9pbnQgcmVzcG9uc2UgcmV0dXJucyBhIEpTT05cbiAgICAgKiBvYmplY3Qgd2l0aCB0aGUgZGF0YWJhc2UgbWV0YWRhdGEuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gZGF0YWJhc2VJZFxuICAgICAqIEB0aHJvd3Mge0FwcHdyaXRlRXhjZXB0aW9ufVxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlfVxuICAgICAqL1xuICAgIGFzeW5jIGdldChkYXRhYmFzZUlkKSB7XG4gICAgICAgIGNvbnN0IGFwaVBhdGggPSAnL2RhdGFiYXNlcy97ZGF0YWJhc2VJZH0nLnJlcGxhY2UoJ3tkYXRhYmFzZUlkfScsIGRhdGFiYXNlSWQpO1xuICAgICAgICBsZXQgcGF5bG9hZCA9IHt9O1xuICAgICAgICBpZiAodHlwZW9mIGRhdGFiYXNlSWQgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgQXBwd3JpdGVFeGNlcHRpb24oJ01pc3NpbmcgcmVxdWlyZWQgcGFyYW1ldGVyOiBcImRhdGFiYXNlSWRcIicpO1xuICAgICAgICB9XG5cblxuICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy5jbGllbnQuY2FsbCgnZ2V0JywgYXBpUGF0aCwge1xuICAgICAgICAgICAgJ2NvbnRlbnQtdHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJyxcbiAgICAgICAgfSwgcGF5bG9hZCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVXBkYXRlIGRhdGFiYXNlXG4gICAgICpcbiAgICAgKiBVcGRhdGUgYSBkYXRhYmFzZSBieSBpdHMgdW5pcXVlIElELlxuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGRhdGFiYXNlSWRcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gbmFtZVxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gZW5hYmxlZFxuICAgICAqIEB0aHJvd3Mge0FwcHdyaXRlRXhjZXB0aW9ufVxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlfVxuICAgICAqL1xuICAgIGFzeW5jIHVwZGF0ZShkYXRhYmFzZUlkLCBuYW1lLCBlbmFibGVkKSB7XG4gICAgICAgIGNvbnN0IGFwaVBhdGggPSAnL2RhdGFiYXNlcy97ZGF0YWJhc2VJZH0nLnJlcGxhY2UoJ3tkYXRhYmFzZUlkfScsIGRhdGFiYXNlSWQpO1xuICAgICAgICBsZXQgcGF5bG9hZCA9IHt9O1xuICAgICAgICBpZiAodHlwZW9mIGRhdGFiYXNlSWQgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgQXBwd3JpdGVFeGNlcHRpb24oJ01pc3NpbmcgcmVxdWlyZWQgcGFyYW1ldGVyOiBcImRhdGFiYXNlSWRcIicpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHR5cGVvZiBuYW1lID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEFwcHdyaXRlRXhjZXB0aW9uKCdNaXNzaW5nIHJlcXVpcmVkIHBhcmFtZXRlcjogXCJuYW1lXCInKTtcbiAgICAgICAgfVxuXG5cbiAgICAgICAgaWYgKHR5cGVvZiBuYW1lICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgcGF5bG9hZFsnbmFtZSddID0gbmFtZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0eXBlb2YgZW5hYmxlZCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHBheWxvYWRbJ2VuYWJsZWQnXSA9IGVuYWJsZWQ7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy5jbGllbnQuY2FsbCgncHV0JywgYXBpUGF0aCwge1xuICAgICAgICAgICAgJ2NvbnRlbnQtdHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJyxcbiAgICAgICAgfSwgcGF5bG9hZCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRGVsZXRlIGRhdGFiYXNlXG4gICAgICpcbiAgICAgKiBEZWxldGUgYSBkYXRhYmFzZSBieSBpdHMgdW5pcXVlIElELiBPbmx5IEFQSSBrZXlzIHdpdGggd2l0aCBkYXRhYmFzZXMud3JpdGVcbiAgICAgKiBzY29wZSBjYW4gZGVsZXRlIGEgZGF0YWJhc2UuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gZGF0YWJhc2VJZFxuICAgICAqIEB0aHJvd3Mge0FwcHdyaXRlRXhjZXB0aW9ufVxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlfVxuICAgICAqL1xuICAgIGFzeW5jIGRlbGV0ZShkYXRhYmFzZUlkKSB7XG4gICAgICAgIGNvbnN0IGFwaVBhdGggPSAnL2RhdGFiYXNlcy97ZGF0YWJhc2VJZH0nLnJlcGxhY2UoJ3tkYXRhYmFzZUlkfScsIGRhdGFiYXNlSWQpO1xuICAgICAgICBsZXQgcGF5bG9hZCA9IHt9O1xuICAgICAgICBpZiAodHlwZW9mIGRhdGFiYXNlSWQgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgQXBwd3JpdGVFeGNlcHRpb24oJ01pc3NpbmcgcmVxdWlyZWQgcGFyYW1ldGVyOiBcImRhdGFiYXNlSWRcIicpO1xuICAgICAgICB9XG5cblxuICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy5jbGllbnQuY2FsbCgnZGVsZXRlJywgYXBpUGF0aCwge1xuICAgICAgICAgICAgJ2NvbnRlbnQtdHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJyxcbiAgICAgICAgfSwgcGF5bG9hZCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogTGlzdCBjb2xsZWN0aW9uc1xuICAgICAqXG4gICAgICogR2V0IGEgbGlzdCBvZiBhbGwgY29sbGVjdGlvbnMgdGhhdCBiZWxvbmcgdG8gdGhlIHByb3ZpZGVkIGRhdGFiYXNlSWQuIFlvdVxuICAgICAqIGNhbiB1c2UgdGhlIHNlYXJjaCBwYXJhbWV0ZXIgdG8gZmlsdGVyIHlvdXIgcmVzdWx0cy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBkYXRhYmFzZUlkXG4gICAgICogQHBhcmFtIHtzdHJpbmdbXX0gcXVlcmllc1xuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBzZWFyY2hcbiAgICAgKiBAdGhyb3dzIHtBcHB3cml0ZUV4Y2VwdGlvbn1cbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZX1cbiAgICAgKi9cbiAgICBhc3luYyBsaXN0Q29sbGVjdGlvbnMoZGF0YWJhc2VJZCwgcXVlcmllcywgc2VhcmNoKSB7XG4gICAgICAgIGNvbnN0IGFwaVBhdGggPSAnL2RhdGFiYXNlcy97ZGF0YWJhc2VJZH0vY29sbGVjdGlvbnMnLnJlcGxhY2UoJ3tkYXRhYmFzZUlkfScsIGRhdGFiYXNlSWQpO1xuICAgICAgICBsZXQgcGF5bG9hZCA9IHt9O1xuICAgICAgICBpZiAodHlwZW9mIGRhdGFiYXNlSWQgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgQXBwd3JpdGVFeGNlcHRpb24oJ01pc3NpbmcgcmVxdWlyZWQgcGFyYW1ldGVyOiBcImRhdGFiYXNlSWRcIicpO1xuICAgICAgICB9XG5cblxuICAgICAgICBpZiAodHlwZW9mIHF1ZXJpZXMgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICBwYXlsb2FkWydxdWVyaWVzJ10gPSBxdWVyaWVzO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHR5cGVvZiBzZWFyY2ggIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICBwYXlsb2FkWydzZWFyY2gnXSA9IHNlYXJjaDtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBhd2FpdCB0aGlzLmNsaWVudC5jYWxsKCdnZXQnLCBhcGlQYXRoLCB7XG4gICAgICAgICAgICAnY29udGVudC10eXBlJzogJ2FwcGxpY2F0aW9uL2pzb24nLFxuICAgICAgICB9LCBwYXlsb2FkKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGUgY29sbGVjdGlvblxuICAgICAqXG4gICAgICogQ3JlYXRlIGEgbmV3IENvbGxlY3Rpb24uIEJlZm9yZSB1c2luZyB0aGlzIHJvdXRlLCB5b3Ugc2hvdWxkIGNyZWF0ZSBhIG5ld1xuICAgICAqIGRhdGFiYXNlIHJlc291cmNlIHVzaW5nIGVpdGhlciBhIFtzZXJ2ZXJcbiAgICAgKiBpbnRlZ3JhdGlvbl0oaHR0cHM6Ly9hcHB3cml0ZS5pby9kb2NzL3NlcnZlci9kYXRhYmFzZXMjZGF0YWJhc2VzQ3JlYXRlQ29sbGVjdGlvbilcbiAgICAgKiBBUEkgb3IgZGlyZWN0bHkgZnJvbSB5b3VyIGRhdGFiYXNlIGNvbnNvbGUuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gZGF0YWJhc2VJZFxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBjb2xsZWN0aW9uSWRcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gbmFtZVxuICAgICAqIEBwYXJhbSB7c3RyaW5nW119IHBlcm1pc3Npb25zXG4gICAgICogQHBhcmFtIHtib29sZWFufSBkb2N1bWVudFNlY3VyaXR5XG4gICAgICogQHBhcmFtIHtib29sZWFufSBlbmFibGVkXG4gICAgICogQHRocm93cyB7QXBwd3JpdGVFeGNlcHRpb259XG4gICAgICogQHJldHVybnMge1Byb21pc2V9XG4gICAgICovXG4gICAgYXN5bmMgY3JlYXRlQ29sbGVjdGlvbihkYXRhYmFzZUlkLCBjb2xsZWN0aW9uSWQsIG5hbWUsIHBlcm1pc3Npb25zLCBkb2N1bWVudFNlY3VyaXR5LCBlbmFibGVkKSB7XG4gICAgICAgIGNvbnN0IGFwaVBhdGggPSAnL2RhdGFiYXNlcy97ZGF0YWJhc2VJZH0vY29sbGVjdGlvbnMnLnJlcGxhY2UoJ3tkYXRhYmFzZUlkfScsIGRhdGFiYXNlSWQpO1xuICAgICAgICBsZXQgcGF5bG9hZCA9IHt9O1xuICAgICAgICBpZiAodHlwZW9mIGRhdGFiYXNlSWQgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgQXBwd3JpdGVFeGNlcHRpb24oJ01pc3NpbmcgcmVxdWlyZWQgcGFyYW1ldGVyOiBcImRhdGFiYXNlSWRcIicpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHR5cGVvZiBjb2xsZWN0aW9uSWQgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgQXBwd3JpdGVFeGNlcHRpb24oJ01pc3NpbmcgcmVxdWlyZWQgcGFyYW1ldGVyOiBcImNvbGxlY3Rpb25JZFwiJyk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodHlwZW9mIG5hbWUgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgQXBwd3JpdGVFeGNlcHRpb24oJ01pc3NpbmcgcmVxdWlyZWQgcGFyYW1ldGVyOiBcIm5hbWVcIicpO1xuICAgICAgICB9XG5cblxuICAgICAgICBpZiAodHlwZW9mIGNvbGxlY3Rpb25JZCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHBheWxvYWRbJ2NvbGxlY3Rpb25JZCddID0gY29sbGVjdGlvbklkO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHR5cGVvZiBuYW1lICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgcGF5bG9hZFsnbmFtZSddID0gbmFtZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0eXBlb2YgcGVybWlzc2lvbnMgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICBwYXlsb2FkWydwZXJtaXNzaW9ucyddID0gcGVybWlzc2lvbnM7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodHlwZW9mIGRvY3VtZW50U2VjdXJpdHkgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICBwYXlsb2FkWydkb2N1bWVudFNlY3VyaXR5J10gPSBkb2N1bWVudFNlY3VyaXR5O1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHR5cGVvZiBlbmFibGVkICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgcGF5bG9hZFsnZW5hYmxlZCddID0gZW5hYmxlZDtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBhd2FpdCB0aGlzLmNsaWVudC5jYWxsKCdwb3N0JywgYXBpUGF0aCwge1xuICAgICAgICAgICAgJ2NvbnRlbnQtdHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJyxcbiAgICAgICAgfSwgcGF5bG9hZCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2V0IGNvbGxlY3Rpb25cbiAgICAgKlxuICAgICAqIEdldCBhIGNvbGxlY3Rpb24gYnkgaXRzIHVuaXF1ZSBJRC4gVGhpcyBlbmRwb2ludCByZXNwb25zZSByZXR1cm5zIGEgSlNPTlxuICAgICAqIG9iamVjdCB3aXRoIHRoZSBjb2xsZWN0aW9uIG1ldGFkYXRhLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGRhdGFiYXNlSWRcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gY29sbGVjdGlvbklkXG4gICAgICogQHRocm93cyB7QXBwd3JpdGVFeGNlcHRpb259XG4gICAgICogQHJldHVybnMge1Byb21pc2V9XG4gICAgICovXG4gICAgYXN5bmMgZ2V0Q29sbGVjdGlvbihkYXRhYmFzZUlkLCBjb2xsZWN0aW9uSWQpIHtcbiAgICAgICAgY29uc3QgYXBpUGF0aCA9ICcvZGF0YWJhc2VzL3tkYXRhYmFzZUlkfS9jb2xsZWN0aW9ucy97Y29sbGVjdGlvbklkfScucmVwbGFjZSgne2RhdGFiYXNlSWR9JywgZGF0YWJhc2VJZCkucmVwbGFjZSgne2NvbGxlY3Rpb25JZH0nLCBjb2xsZWN0aW9uSWQpO1xuICAgICAgICBsZXQgcGF5bG9hZCA9IHt9O1xuICAgICAgICBpZiAodHlwZW9mIGRhdGFiYXNlSWQgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgQXBwd3JpdGVFeGNlcHRpb24oJ01pc3NpbmcgcmVxdWlyZWQgcGFyYW1ldGVyOiBcImRhdGFiYXNlSWRcIicpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHR5cGVvZiBjb2xsZWN0aW9uSWQgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgQXBwd3JpdGVFeGNlcHRpb24oJ01pc3NpbmcgcmVxdWlyZWQgcGFyYW1ldGVyOiBcImNvbGxlY3Rpb25JZFwiJyk7XG4gICAgICAgIH1cblxuXG4gICAgICAgIHJldHVybiBhd2FpdCB0aGlzLmNsaWVudC5jYWxsKCdnZXQnLCBhcGlQYXRoLCB7XG4gICAgICAgICAgICAnY29udGVudC10eXBlJzogJ2FwcGxpY2F0aW9uL2pzb24nLFxuICAgICAgICB9LCBwYXlsb2FkKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBVcGRhdGUgY29sbGVjdGlvblxuICAgICAqXG4gICAgICogVXBkYXRlIGEgY29sbGVjdGlvbiBieSBpdHMgdW5pcXVlIElELlxuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGRhdGFiYXNlSWRcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gY29sbGVjdGlvbklkXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IG5hbWVcbiAgICAgKiBAcGFyYW0ge3N0cmluZ1tdfSBwZXJtaXNzaW9uc1xuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gZG9jdW1lbnRTZWN1cml0eVxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gZW5hYmxlZFxuICAgICAqIEB0aHJvd3Mge0FwcHdyaXRlRXhjZXB0aW9ufVxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlfVxuICAgICAqL1xuICAgIGFzeW5jIHVwZGF0ZUNvbGxlY3Rpb24oZGF0YWJhc2VJZCwgY29sbGVjdGlvbklkLCBuYW1lLCBwZXJtaXNzaW9ucywgZG9jdW1lbnRTZWN1cml0eSwgZW5hYmxlZCkge1xuICAgICAgICBjb25zdCBhcGlQYXRoID0gJy9kYXRhYmFzZXMve2RhdGFiYXNlSWR9L2NvbGxlY3Rpb25zL3tjb2xsZWN0aW9uSWR9Jy5yZXBsYWNlKCd7ZGF0YWJhc2VJZH0nLCBkYXRhYmFzZUlkKS5yZXBsYWNlKCd7Y29sbGVjdGlvbklkfScsIGNvbGxlY3Rpb25JZCk7XG4gICAgICAgIGxldCBwYXlsb2FkID0ge307XG4gICAgICAgIGlmICh0eXBlb2YgZGF0YWJhc2VJZCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBBcHB3cml0ZUV4Y2VwdGlvbignTWlzc2luZyByZXF1aXJlZCBwYXJhbWV0ZXI6IFwiZGF0YWJhc2VJZFwiJyk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodHlwZW9mIGNvbGxlY3Rpb25JZCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBBcHB3cml0ZUV4Y2VwdGlvbignTWlzc2luZyByZXF1aXJlZCBwYXJhbWV0ZXI6IFwiY29sbGVjdGlvbklkXCInKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0eXBlb2YgbmFtZSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBBcHB3cml0ZUV4Y2VwdGlvbignTWlzc2luZyByZXF1aXJlZCBwYXJhbWV0ZXI6IFwibmFtZVwiJyk7XG4gICAgICAgIH1cblxuXG4gICAgICAgIGlmICh0eXBlb2YgbmFtZSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHBheWxvYWRbJ25hbWUnXSA9IG5hbWU7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodHlwZW9mIHBlcm1pc3Npb25zICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgcGF5bG9hZFsncGVybWlzc2lvbnMnXSA9IHBlcm1pc3Npb25zO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHR5cGVvZiBkb2N1bWVudFNlY3VyaXR5ICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgcGF5bG9hZFsnZG9jdW1lbnRTZWN1cml0eSddID0gZG9jdW1lbnRTZWN1cml0eTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0eXBlb2YgZW5hYmxlZCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHBheWxvYWRbJ2VuYWJsZWQnXSA9IGVuYWJsZWQ7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy5jbGllbnQuY2FsbCgncHV0JywgYXBpUGF0aCwge1xuICAgICAgICAgICAgJ2NvbnRlbnQtdHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJyxcbiAgICAgICAgfSwgcGF5bG9hZCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRGVsZXRlIGNvbGxlY3Rpb25cbiAgICAgKlxuICAgICAqIERlbGV0ZSBhIGNvbGxlY3Rpb24gYnkgaXRzIHVuaXF1ZSBJRC4gT25seSB1c2VycyB3aXRoIHdyaXRlIHBlcm1pc3Npb25zXG4gICAgICogaGF2ZSBhY2Nlc3MgdG8gZGVsZXRlIHRoaXMgcmVzb3VyY2UuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gZGF0YWJhc2VJZFxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBjb2xsZWN0aW9uSWRcbiAgICAgKiBAdGhyb3dzIHtBcHB3cml0ZUV4Y2VwdGlvbn1cbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZX1cbiAgICAgKi9cbiAgICBhc3luYyBkZWxldGVDb2xsZWN0aW9uKGRhdGFiYXNlSWQsIGNvbGxlY3Rpb25JZCkge1xuICAgICAgICBjb25zdCBhcGlQYXRoID0gJy9kYXRhYmFzZXMve2RhdGFiYXNlSWR9L2NvbGxlY3Rpb25zL3tjb2xsZWN0aW9uSWR9Jy5yZXBsYWNlKCd7ZGF0YWJhc2VJZH0nLCBkYXRhYmFzZUlkKS5yZXBsYWNlKCd7Y29sbGVjdGlvbklkfScsIGNvbGxlY3Rpb25JZCk7XG4gICAgICAgIGxldCBwYXlsb2FkID0ge307XG4gICAgICAgIGlmICh0eXBlb2YgZGF0YWJhc2VJZCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBBcHB3cml0ZUV4Y2VwdGlvbignTWlzc2luZyByZXF1aXJlZCBwYXJhbWV0ZXI6IFwiZGF0YWJhc2VJZFwiJyk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodHlwZW9mIGNvbGxlY3Rpb25JZCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBBcHB3cml0ZUV4Y2VwdGlvbignTWlzc2luZyByZXF1aXJlZCBwYXJhbWV0ZXI6IFwiY29sbGVjdGlvbklkXCInKTtcbiAgICAgICAgfVxuXG5cbiAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMuY2xpZW50LmNhbGwoJ2RlbGV0ZScsIGFwaVBhdGgsIHtcbiAgICAgICAgICAgICdjb250ZW50LXR5cGUnOiAnYXBwbGljYXRpb24vanNvbicsXG4gICAgICAgIH0sIHBheWxvYWQpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIExpc3QgYXR0cmlidXRlc1xuICAgICAqXG4gICAgICogTGlzdCBhdHRyaWJ1dGVzIGluIHRoZSBjb2xsZWN0aW9uLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGRhdGFiYXNlSWRcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gY29sbGVjdGlvbklkXG4gICAgICogQHBhcmFtIHtzdHJpbmdbXX0gcXVlcmllc1xuICAgICAqIEB0aHJvd3Mge0FwcHdyaXRlRXhjZXB0aW9ufVxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlfVxuICAgICAqL1xuICAgIGFzeW5jIGxpc3RBdHRyaWJ1dGVzKGRhdGFiYXNlSWQsIGNvbGxlY3Rpb25JZCwgcXVlcmllcykge1xuICAgICAgICBjb25zdCBhcGlQYXRoID0gJy9kYXRhYmFzZXMve2RhdGFiYXNlSWR9L2NvbGxlY3Rpb25zL3tjb2xsZWN0aW9uSWR9L2F0dHJpYnV0ZXMnLnJlcGxhY2UoJ3tkYXRhYmFzZUlkfScsIGRhdGFiYXNlSWQpLnJlcGxhY2UoJ3tjb2xsZWN0aW9uSWR9JywgY29sbGVjdGlvbklkKTtcbiAgICAgICAgbGV0IHBheWxvYWQgPSB7fTtcbiAgICAgICAgaWYgKHR5cGVvZiBkYXRhYmFzZUlkID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEFwcHdyaXRlRXhjZXB0aW9uKCdNaXNzaW5nIHJlcXVpcmVkIHBhcmFtZXRlcjogXCJkYXRhYmFzZUlkXCInKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0eXBlb2YgY29sbGVjdGlvbklkID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEFwcHdyaXRlRXhjZXB0aW9uKCdNaXNzaW5nIHJlcXVpcmVkIHBhcmFtZXRlcjogXCJjb2xsZWN0aW9uSWRcIicpO1xuICAgICAgICB9XG5cblxuICAgICAgICBpZiAodHlwZW9mIHF1ZXJpZXMgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICBwYXlsb2FkWydxdWVyaWVzJ10gPSBxdWVyaWVzO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMuY2xpZW50LmNhbGwoJ2dldCcsIGFwaVBhdGgsIHtcbiAgICAgICAgICAgICdjb250ZW50LXR5cGUnOiAnYXBwbGljYXRpb24vanNvbicsXG4gICAgICAgIH0sIHBheWxvYWQpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZSBib29sZWFuIGF0dHJpYnV0ZVxuICAgICAqXG4gICAgICogQ3JlYXRlIGEgYm9vbGVhbiBhdHRyaWJ1dGUuXG4gICAgICogXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gZGF0YWJhc2VJZFxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBjb2xsZWN0aW9uSWRcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30ga2V5XG4gICAgICogQHBhcmFtIHtib29sZWFufSByZXF1aXJlZFxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0geGRlZmF1bHRcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IGFycmF5XG4gICAgICogQHRocm93cyB7QXBwd3JpdGVFeGNlcHRpb259XG4gICAgICogQHJldHVybnMge1Byb21pc2V9XG4gICAgICovXG4gICAgYXN5bmMgY3JlYXRlQm9vbGVhbkF0dHJpYnV0ZShkYXRhYmFzZUlkLCBjb2xsZWN0aW9uSWQsIGtleSwgcmVxdWlyZWQsIHhkZWZhdWx0LCBhcnJheSkge1xuICAgICAgICBjb25zdCBhcGlQYXRoID0gJy9kYXRhYmFzZXMve2RhdGFiYXNlSWR9L2NvbGxlY3Rpb25zL3tjb2xsZWN0aW9uSWR9L2F0dHJpYnV0ZXMvYm9vbGVhbicucmVwbGFjZSgne2RhdGFiYXNlSWR9JywgZGF0YWJhc2VJZCkucmVwbGFjZSgne2NvbGxlY3Rpb25JZH0nLCBjb2xsZWN0aW9uSWQpO1xuICAgICAgICBsZXQgcGF5bG9hZCA9IHt9O1xuICAgICAgICBpZiAodHlwZW9mIGRhdGFiYXNlSWQgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgQXBwd3JpdGVFeGNlcHRpb24oJ01pc3NpbmcgcmVxdWlyZWQgcGFyYW1ldGVyOiBcImRhdGFiYXNlSWRcIicpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHR5cGVvZiBjb2xsZWN0aW9uSWQgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgQXBwd3JpdGVFeGNlcHRpb24oJ01pc3NpbmcgcmVxdWlyZWQgcGFyYW1ldGVyOiBcImNvbGxlY3Rpb25JZFwiJyk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodHlwZW9mIGtleSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBBcHB3cml0ZUV4Y2VwdGlvbignTWlzc2luZyByZXF1aXJlZCBwYXJhbWV0ZXI6IFwia2V5XCInKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0eXBlb2YgcmVxdWlyZWQgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgQXBwd3JpdGVFeGNlcHRpb24oJ01pc3NpbmcgcmVxdWlyZWQgcGFyYW1ldGVyOiBcInJlcXVpcmVkXCInKTtcbiAgICAgICAgfVxuXG5cbiAgICAgICAgaWYgKHR5cGVvZiBrZXkgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICBwYXlsb2FkWydrZXknXSA9IGtleTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0eXBlb2YgcmVxdWlyZWQgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICBwYXlsb2FkWydyZXF1aXJlZCddID0gcmVxdWlyZWQ7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodHlwZW9mIHhkZWZhdWx0ICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgcGF5bG9hZFsnZGVmYXVsdCddID0geGRlZmF1bHQ7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodHlwZW9mIGFycmF5ICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgcGF5bG9hZFsnYXJyYXknXSA9IGFycmF5O1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMuY2xpZW50LmNhbGwoJ3Bvc3QnLCBhcGlQYXRoLCB7XG4gICAgICAgICAgICAnY29udGVudC10eXBlJzogJ2FwcGxpY2F0aW9uL2pzb24nLFxuICAgICAgICB9LCBwYXlsb2FkKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBVcGRhdGUgYm9vbGVhbiBhdHRyaWJ1dGVcbiAgICAgKlxuICAgICAqIFVwZGF0ZSBhIGJvb2xlYW4gYXR0cmlidXRlLiBDaGFuZ2luZyB0aGUgYGRlZmF1bHRgIHZhbHVlIHdpbGwgbm90IHVwZGF0ZVxuICAgICAqIGFscmVhZHkgZXhpc3RpbmcgZG9jdW1lbnRzLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGRhdGFiYXNlSWRcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gY29sbGVjdGlvbklkXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGtleVxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gcmVxdWlyZWRcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IHhkZWZhdWx0XG4gICAgICogQHRocm93cyB7QXBwd3JpdGVFeGNlcHRpb259XG4gICAgICogQHJldHVybnMge1Byb21pc2V9XG4gICAgICovXG4gICAgYXN5bmMgdXBkYXRlQm9vbGVhbkF0dHJpYnV0ZShkYXRhYmFzZUlkLCBjb2xsZWN0aW9uSWQsIGtleSwgcmVxdWlyZWQsIHhkZWZhdWx0KSB7XG4gICAgICAgIGNvbnN0IGFwaVBhdGggPSAnL2RhdGFiYXNlcy97ZGF0YWJhc2VJZH0vY29sbGVjdGlvbnMve2NvbGxlY3Rpb25JZH0vYXR0cmlidXRlcy9ib29sZWFuL3trZXl9Jy5yZXBsYWNlKCd7ZGF0YWJhc2VJZH0nLCBkYXRhYmFzZUlkKS5yZXBsYWNlKCd7Y29sbGVjdGlvbklkfScsIGNvbGxlY3Rpb25JZCkucmVwbGFjZSgne2tleX0nLCBrZXkpO1xuICAgICAgICBsZXQgcGF5bG9hZCA9IHt9O1xuICAgICAgICBpZiAodHlwZW9mIGRhdGFiYXNlSWQgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgQXBwd3JpdGVFeGNlcHRpb24oJ01pc3NpbmcgcmVxdWlyZWQgcGFyYW1ldGVyOiBcImRhdGFiYXNlSWRcIicpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHR5cGVvZiBjb2xsZWN0aW9uSWQgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgQXBwd3JpdGVFeGNlcHRpb24oJ01pc3NpbmcgcmVxdWlyZWQgcGFyYW1ldGVyOiBcImNvbGxlY3Rpb25JZFwiJyk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodHlwZW9mIGtleSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBBcHB3cml0ZUV4Y2VwdGlvbignTWlzc2luZyByZXF1aXJlZCBwYXJhbWV0ZXI6IFwia2V5XCInKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0eXBlb2YgcmVxdWlyZWQgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgQXBwd3JpdGVFeGNlcHRpb24oJ01pc3NpbmcgcmVxdWlyZWQgcGFyYW1ldGVyOiBcInJlcXVpcmVkXCInKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0eXBlb2YgeGRlZmF1bHQgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgQXBwd3JpdGVFeGNlcHRpb24oJ01pc3NpbmcgcmVxdWlyZWQgcGFyYW1ldGVyOiBcInhkZWZhdWx0XCInKTtcbiAgICAgICAgfVxuXG5cbiAgICAgICAgaWYgKHR5cGVvZiByZXF1aXJlZCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHBheWxvYWRbJ3JlcXVpcmVkJ10gPSByZXF1aXJlZDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0eXBlb2YgeGRlZmF1bHQgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICBwYXlsb2FkWydkZWZhdWx0J10gPSB4ZGVmYXVsdDtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBhd2FpdCB0aGlzLmNsaWVudC5jYWxsKCdwYXRjaCcsIGFwaVBhdGgsIHtcbiAgICAgICAgICAgICdjb250ZW50LXR5cGUnOiAnYXBwbGljYXRpb24vanNvbicsXG4gICAgICAgIH0sIHBheWxvYWQpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZSBkYXRldGltZSBhdHRyaWJ1dGVcbiAgICAgKlxuICAgICAqIENyZWF0ZSBhIGRhdGUgdGltZSBhdHRyaWJ1dGUgYWNjb3JkaW5nIHRvIHRoZSBJU08gODYwMSBzdGFuZGFyZC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBkYXRhYmFzZUlkXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGNvbGxlY3Rpb25JZFxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBrZXlcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IHJlcXVpcmVkXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHhkZWZhdWx0XG4gICAgICogQHBhcmFtIHtib29sZWFufSBhcnJheVxuICAgICAqIEB0aHJvd3Mge0FwcHdyaXRlRXhjZXB0aW9ufVxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlfVxuICAgICAqL1xuICAgIGFzeW5jIGNyZWF0ZURhdGV0aW1lQXR0cmlidXRlKGRhdGFiYXNlSWQsIGNvbGxlY3Rpb25JZCwga2V5LCByZXF1aXJlZCwgeGRlZmF1bHQsIGFycmF5KSB7XG4gICAgICAgIGNvbnN0IGFwaVBhdGggPSAnL2RhdGFiYXNlcy97ZGF0YWJhc2VJZH0vY29sbGVjdGlvbnMve2NvbGxlY3Rpb25JZH0vYXR0cmlidXRlcy9kYXRldGltZScucmVwbGFjZSgne2RhdGFiYXNlSWR9JywgZGF0YWJhc2VJZCkucmVwbGFjZSgne2NvbGxlY3Rpb25JZH0nLCBjb2xsZWN0aW9uSWQpO1xuICAgICAgICBsZXQgcGF5bG9hZCA9IHt9O1xuICAgICAgICBpZiAodHlwZW9mIGRhdGFiYXNlSWQgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgQXBwd3JpdGVFeGNlcHRpb24oJ01pc3NpbmcgcmVxdWlyZWQgcGFyYW1ldGVyOiBcImRhdGFiYXNlSWRcIicpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHR5cGVvZiBjb2xsZWN0aW9uSWQgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgQXBwd3JpdGVFeGNlcHRpb24oJ01pc3NpbmcgcmVxdWlyZWQgcGFyYW1ldGVyOiBcImNvbGxlY3Rpb25JZFwiJyk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodHlwZW9mIGtleSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBBcHB3cml0ZUV4Y2VwdGlvbignTWlzc2luZyByZXF1aXJlZCBwYXJhbWV0ZXI6IFwia2V5XCInKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0eXBlb2YgcmVxdWlyZWQgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgQXBwd3JpdGVFeGNlcHRpb24oJ01pc3NpbmcgcmVxdWlyZWQgcGFyYW1ldGVyOiBcInJlcXVpcmVkXCInKTtcbiAgICAgICAgfVxuXG5cbiAgICAgICAgaWYgKHR5cGVvZiBrZXkgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICBwYXlsb2FkWydrZXknXSA9IGtleTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0eXBlb2YgcmVxdWlyZWQgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICBwYXlsb2FkWydyZXF1aXJlZCddID0gcmVxdWlyZWQ7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodHlwZW9mIHhkZWZhdWx0ICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgcGF5bG9hZFsnZGVmYXVsdCddID0geGRlZmF1bHQ7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodHlwZW9mIGFycmF5ICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgcGF5bG9hZFsnYXJyYXknXSA9IGFycmF5O1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMuY2xpZW50LmNhbGwoJ3Bvc3QnLCBhcGlQYXRoLCB7XG4gICAgICAgICAgICAnY29udGVudC10eXBlJzogJ2FwcGxpY2F0aW9uL2pzb24nLFxuICAgICAgICB9LCBwYXlsb2FkKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBVcGRhdGUgZGF0ZVRpbWUgYXR0cmlidXRlXG4gICAgICpcbiAgICAgKiBVcGRhdGUgYSBkYXRlIHRpbWUgYXR0cmlidXRlLiBDaGFuZ2luZyB0aGUgYGRlZmF1bHRgIHZhbHVlIHdpbGwgbm90IHVwZGF0ZVxuICAgICAqIGFscmVhZHkgZXhpc3RpbmcgZG9jdW1lbnRzLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGRhdGFiYXNlSWRcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gY29sbGVjdGlvbklkXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGtleVxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gcmVxdWlyZWRcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30geGRlZmF1bHRcbiAgICAgKiBAdGhyb3dzIHtBcHB3cml0ZUV4Y2VwdGlvbn1cbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZX1cbiAgICAgKi9cbiAgICBhc3luYyB1cGRhdGVEYXRldGltZUF0dHJpYnV0ZShkYXRhYmFzZUlkLCBjb2xsZWN0aW9uSWQsIGtleSwgcmVxdWlyZWQsIHhkZWZhdWx0KSB7XG4gICAgICAgIGNvbnN0IGFwaVBhdGggPSAnL2RhdGFiYXNlcy97ZGF0YWJhc2VJZH0vY29sbGVjdGlvbnMve2NvbGxlY3Rpb25JZH0vYXR0cmlidXRlcy9kYXRldGltZS97a2V5fScucmVwbGFjZSgne2RhdGFiYXNlSWR9JywgZGF0YWJhc2VJZCkucmVwbGFjZSgne2NvbGxlY3Rpb25JZH0nLCBjb2xsZWN0aW9uSWQpLnJlcGxhY2UoJ3trZXl9Jywga2V5KTtcbiAgICAgICAgbGV0IHBheWxvYWQgPSB7fTtcbiAgICAgICAgaWYgKHR5cGVvZiBkYXRhYmFzZUlkID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEFwcHdyaXRlRXhjZXB0aW9uKCdNaXNzaW5nIHJlcXVpcmVkIHBhcmFtZXRlcjogXCJkYXRhYmFzZUlkXCInKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0eXBlb2YgY29sbGVjdGlvbklkID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEFwcHdyaXRlRXhjZXB0aW9uKCdNaXNzaW5nIHJlcXVpcmVkIHBhcmFtZXRlcjogXCJjb2xsZWN0aW9uSWRcIicpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHR5cGVvZiBrZXkgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgQXBwd3JpdGVFeGNlcHRpb24oJ01pc3NpbmcgcmVxdWlyZWQgcGFyYW1ldGVyOiBcImtleVwiJyk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodHlwZW9mIHJlcXVpcmVkID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEFwcHdyaXRlRXhjZXB0aW9uKCdNaXNzaW5nIHJlcXVpcmVkIHBhcmFtZXRlcjogXCJyZXF1aXJlZFwiJyk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodHlwZW9mIHhkZWZhdWx0ID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEFwcHdyaXRlRXhjZXB0aW9uKCdNaXNzaW5nIHJlcXVpcmVkIHBhcmFtZXRlcjogXCJ4ZGVmYXVsdFwiJyk7XG4gICAgICAgIH1cblxuXG4gICAgICAgIGlmICh0eXBlb2YgcmVxdWlyZWQgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICBwYXlsb2FkWydyZXF1aXJlZCddID0gcmVxdWlyZWQ7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodHlwZW9mIHhkZWZhdWx0ICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgcGF5bG9hZFsnZGVmYXVsdCddID0geGRlZmF1bHQ7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy5jbGllbnQuY2FsbCgncGF0Y2gnLCBhcGlQYXRoLCB7XG4gICAgICAgICAgICAnY29udGVudC10eXBlJzogJ2FwcGxpY2F0aW9uL2pzb24nLFxuICAgICAgICB9LCBwYXlsb2FkKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGUgZW1haWwgYXR0cmlidXRlXG4gICAgICpcbiAgICAgKiBDcmVhdGUgYW4gZW1haWwgYXR0cmlidXRlLlxuICAgICAqIFxuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGRhdGFiYXNlSWRcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gY29sbGVjdGlvbklkXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGtleVxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gcmVxdWlyZWRcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30geGRlZmF1bHRcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IGFycmF5XG4gICAgICogQHRocm93cyB7QXBwd3JpdGVFeGNlcHRpb259XG4gICAgICogQHJldHVybnMge1Byb21pc2V9XG4gICAgICovXG4gICAgYXN5bmMgY3JlYXRlRW1haWxBdHRyaWJ1dGUoZGF0YWJhc2VJZCwgY29sbGVjdGlvbklkLCBrZXksIHJlcXVpcmVkLCB4ZGVmYXVsdCwgYXJyYXkpIHtcbiAgICAgICAgY29uc3QgYXBpUGF0aCA9ICcvZGF0YWJhc2VzL3tkYXRhYmFzZUlkfS9jb2xsZWN0aW9ucy97Y29sbGVjdGlvbklkfS9hdHRyaWJ1dGVzL2VtYWlsJy5yZXBsYWNlKCd7ZGF0YWJhc2VJZH0nLCBkYXRhYmFzZUlkKS5yZXBsYWNlKCd7Y29sbGVjdGlvbklkfScsIGNvbGxlY3Rpb25JZCk7XG4gICAgICAgIGxldCBwYXlsb2FkID0ge307XG4gICAgICAgIGlmICh0eXBlb2YgZGF0YWJhc2VJZCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBBcHB3cml0ZUV4Y2VwdGlvbignTWlzc2luZyByZXF1aXJlZCBwYXJhbWV0ZXI6IFwiZGF0YWJhc2VJZFwiJyk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodHlwZW9mIGNvbGxlY3Rpb25JZCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBBcHB3cml0ZUV4Y2VwdGlvbignTWlzc2luZyByZXF1aXJlZCBwYXJhbWV0ZXI6IFwiY29sbGVjdGlvbklkXCInKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0eXBlb2Yga2V5ID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEFwcHdyaXRlRXhjZXB0aW9uKCdNaXNzaW5nIHJlcXVpcmVkIHBhcmFtZXRlcjogXCJrZXlcIicpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHR5cGVvZiByZXF1aXJlZCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBBcHB3cml0ZUV4Y2VwdGlvbignTWlzc2luZyByZXF1aXJlZCBwYXJhbWV0ZXI6IFwicmVxdWlyZWRcIicpO1xuICAgICAgICB9XG5cblxuICAgICAgICBpZiAodHlwZW9mIGtleSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHBheWxvYWRbJ2tleSddID0ga2V5O1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHR5cGVvZiByZXF1aXJlZCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHBheWxvYWRbJ3JlcXVpcmVkJ10gPSByZXF1aXJlZDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0eXBlb2YgeGRlZmF1bHQgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICBwYXlsb2FkWydkZWZhdWx0J10gPSB4ZGVmYXVsdDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0eXBlb2YgYXJyYXkgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICBwYXlsb2FkWydhcnJheSddID0gYXJyYXk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy5jbGllbnQuY2FsbCgncG9zdCcsIGFwaVBhdGgsIHtcbiAgICAgICAgICAgICdjb250ZW50LXR5cGUnOiAnYXBwbGljYXRpb24vanNvbicsXG4gICAgICAgIH0sIHBheWxvYWQpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFVwZGF0ZSBlbWFpbCBhdHRyaWJ1dGVcbiAgICAgKlxuICAgICAqIFVwZGF0ZSBhbiBlbWFpbCBhdHRyaWJ1dGUuIENoYW5naW5nIHRoZSBgZGVmYXVsdGAgdmFsdWUgd2lsbCBub3QgdXBkYXRlXG4gICAgICogYWxyZWFkeSBleGlzdGluZyBkb2N1bWVudHMuXG4gICAgICogXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gZGF0YWJhc2VJZFxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBjb2xsZWN0aW9uSWRcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30ga2V5XG4gICAgICogQHBhcmFtIHtib29sZWFufSByZXF1aXJlZFxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSB4ZGVmYXVsdFxuICAgICAqIEB0aHJvd3Mge0FwcHdyaXRlRXhjZXB0aW9ufVxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlfVxuICAgICAqL1xuICAgIGFzeW5jIHVwZGF0ZUVtYWlsQXR0cmlidXRlKGRhdGFiYXNlSWQsIGNvbGxlY3Rpb25JZCwga2V5LCByZXF1aXJlZCwgeGRlZmF1bHQpIHtcbiAgICAgICAgY29uc3QgYXBpUGF0aCA9ICcvZGF0YWJhc2VzL3tkYXRhYmFzZUlkfS9jb2xsZWN0aW9ucy97Y29sbGVjdGlvbklkfS9hdHRyaWJ1dGVzL2VtYWlsL3trZXl9Jy5yZXBsYWNlKCd7ZGF0YWJhc2VJZH0nLCBkYXRhYmFzZUlkKS5yZXBsYWNlKCd7Y29sbGVjdGlvbklkfScsIGNvbGxlY3Rpb25JZCkucmVwbGFjZSgne2tleX0nLCBrZXkpO1xuICAgICAgICBsZXQgcGF5bG9hZCA9IHt9O1xuICAgICAgICBpZiAodHlwZW9mIGRhdGFiYXNlSWQgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgQXBwd3JpdGVFeGNlcHRpb24oJ01pc3NpbmcgcmVxdWlyZWQgcGFyYW1ldGVyOiBcImRhdGFiYXNlSWRcIicpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHR5cGVvZiBjb2xsZWN0aW9uSWQgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgQXBwd3JpdGVFeGNlcHRpb24oJ01pc3NpbmcgcmVxdWlyZWQgcGFyYW1ldGVyOiBcImNvbGxlY3Rpb25JZFwiJyk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodHlwZW9mIGtleSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBBcHB3cml0ZUV4Y2VwdGlvbignTWlzc2luZyByZXF1aXJlZCBwYXJhbWV0ZXI6IFwia2V5XCInKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0eXBlb2YgcmVxdWlyZWQgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgQXBwd3JpdGVFeGNlcHRpb24oJ01pc3NpbmcgcmVxdWlyZWQgcGFyYW1ldGVyOiBcInJlcXVpcmVkXCInKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0eXBlb2YgeGRlZmF1bHQgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgQXBwd3JpdGVFeGNlcHRpb24oJ01pc3NpbmcgcmVxdWlyZWQgcGFyYW1ldGVyOiBcInhkZWZhdWx0XCInKTtcbiAgICAgICAgfVxuXG5cbiAgICAgICAgaWYgKHR5cGVvZiByZXF1aXJlZCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHBheWxvYWRbJ3JlcXVpcmVkJ10gPSByZXF1aXJlZDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0eXBlb2YgeGRlZmF1bHQgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICBwYXlsb2FkWydkZWZhdWx0J10gPSB4ZGVmYXVsdDtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBhd2FpdCB0aGlzLmNsaWVudC5jYWxsKCdwYXRjaCcsIGFwaVBhdGgsIHtcbiAgICAgICAgICAgICdjb250ZW50LXR5cGUnOiAnYXBwbGljYXRpb24vanNvbicsXG4gICAgICAgIH0sIHBheWxvYWQpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZSBlbnVtIGF0dHJpYnV0ZVxuICAgICAqXG4gICAgICogQ3JlYXRlIGFuIGVudW1lcmF0aW9uIGF0dHJpYnV0ZS4gVGhlIGBlbGVtZW50c2AgcGFyYW0gYWN0cyBhcyBhIHdoaXRlLWxpc3RcbiAgICAgKiBvZiBhY2NlcHRlZCB2YWx1ZXMgZm9yIHRoaXMgYXR0cmlidXRlLiBcbiAgICAgKiBcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBkYXRhYmFzZUlkXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGNvbGxlY3Rpb25JZFxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBrZXlcbiAgICAgKiBAcGFyYW0ge3N0cmluZ1tdfSBlbGVtZW50c1xuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gcmVxdWlyZWRcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30geGRlZmF1bHRcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IGFycmF5XG4gICAgICogQHRocm93cyB7QXBwd3JpdGVFeGNlcHRpb259XG4gICAgICogQHJldHVybnMge1Byb21pc2V9XG4gICAgICovXG4gICAgYXN5bmMgY3JlYXRlRW51bUF0dHJpYnV0ZShkYXRhYmFzZUlkLCBjb2xsZWN0aW9uSWQsIGtleSwgZWxlbWVudHMsIHJlcXVpcmVkLCB4ZGVmYXVsdCwgYXJyYXkpIHtcbiAgICAgICAgY29uc3QgYXBpUGF0aCA9ICcvZGF0YWJhc2VzL3tkYXRhYmFzZUlkfS9jb2xsZWN0aW9ucy97Y29sbGVjdGlvbklkfS9hdHRyaWJ1dGVzL2VudW0nLnJlcGxhY2UoJ3tkYXRhYmFzZUlkfScsIGRhdGFiYXNlSWQpLnJlcGxhY2UoJ3tjb2xsZWN0aW9uSWR9JywgY29sbGVjdGlvbklkKTtcbiAgICAgICAgbGV0IHBheWxvYWQgPSB7fTtcbiAgICAgICAgaWYgKHR5cGVvZiBkYXRhYmFzZUlkID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEFwcHdyaXRlRXhjZXB0aW9uKCdNaXNzaW5nIHJlcXVpcmVkIHBhcmFtZXRlcjogXCJkYXRhYmFzZUlkXCInKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0eXBlb2YgY29sbGVjdGlvbklkID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEFwcHdyaXRlRXhjZXB0aW9uKCdNaXNzaW5nIHJlcXVpcmVkIHBhcmFtZXRlcjogXCJjb2xsZWN0aW9uSWRcIicpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHR5cGVvZiBrZXkgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgQXBwd3JpdGVFeGNlcHRpb24oJ01pc3NpbmcgcmVxdWlyZWQgcGFyYW1ldGVyOiBcImtleVwiJyk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodHlwZW9mIGVsZW1lbnRzID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEFwcHdyaXRlRXhjZXB0aW9uKCdNaXNzaW5nIHJlcXVpcmVkIHBhcmFtZXRlcjogXCJlbGVtZW50c1wiJyk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodHlwZW9mIHJlcXVpcmVkID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEFwcHdyaXRlRXhjZXB0aW9uKCdNaXNzaW5nIHJlcXVpcmVkIHBhcmFtZXRlcjogXCJyZXF1aXJlZFwiJyk7XG4gICAgICAgIH1cblxuXG4gICAgICAgIGlmICh0eXBlb2Yga2V5ICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgcGF5bG9hZFsna2V5J10gPSBrZXk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodHlwZW9mIGVsZW1lbnRzICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgcGF5bG9hZFsnZWxlbWVudHMnXSA9IGVsZW1lbnRzO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHR5cGVvZiByZXF1aXJlZCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHBheWxvYWRbJ3JlcXVpcmVkJ10gPSByZXF1aXJlZDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0eXBlb2YgeGRlZmF1bHQgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICBwYXlsb2FkWydkZWZhdWx0J10gPSB4ZGVmYXVsdDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0eXBlb2YgYXJyYXkgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICBwYXlsb2FkWydhcnJheSddID0gYXJyYXk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy5jbGllbnQuY2FsbCgncG9zdCcsIGFwaVBhdGgsIHtcbiAgICAgICAgICAgICdjb250ZW50LXR5cGUnOiAnYXBwbGljYXRpb24vanNvbicsXG4gICAgICAgIH0sIHBheWxvYWQpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFVwZGF0ZSBlbnVtIGF0dHJpYnV0ZVxuICAgICAqXG4gICAgICogVXBkYXRlIGFuIGVudW0gYXR0cmlidXRlLiBDaGFuZ2luZyB0aGUgYGRlZmF1bHRgIHZhbHVlIHdpbGwgbm90IHVwZGF0ZVxuICAgICAqIGFscmVhZHkgZXhpc3RpbmcgZG9jdW1lbnRzLlxuICAgICAqIFxuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGRhdGFiYXNlSWRcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gY29sbGVjdGlvbklkXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGtleVxuICAgICAqIEBwYXJhbSB7c3RyaW5nW119IGVsZW1lbnRzXG4gICAgICogQHBhcmFtIHtib29sZWFufSByZXF1aXJlZFxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSB4ZGVmYXVsdFxuICAgICAqIEB0aHJvd3Mge0FwcHdyaXRlRXhjZXB0aW9ufVxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlfVxuICAgICAqL1xuICAgIGFzeW5jIHVwZGF0ZUVudW1BdHRyaWJ1dGUoZGF0YWJhc2VJZCwgY29sbGVjdGlvbklkLCBrZXksIGVsZW1lbnRzLCByZXF1aXJlZCwgeGRlZmF1bHQpIHtcbiAgICAgICAgY29uc3QgYXBpUGF0aCA9ICcvZGF0YWJhc2VzL3tkYXRhYmFzZUlkfS9jb2xsZWN0aW9ucy97Y29sbGVjdGlvbklkfS9hdHRyaWJ1dGVzL2VudW0ve2tleX0nLnJlcGxhY2UoJ3tkYXRhYmFzZUlkfScsIGRhdGFiYXNlSWQpLnJlcGxhY2UoJ3tjb2xsZWN0aW9uSWR9JywgY29sbGVjdGlvbklkKS5yZXBsYWNlKCd7a2V5fScsIGtleSk7XG4gICAgICAgIGxldCBwYXlsb2FkID0ge307XG4gICAgICAgIGlmICh0eXBlb2YgZGF0YWJhc2VJZCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBBcHB3cml0ZUV4Y2VwdGlvbignTWlzc2luZyByZXF1aXJlZCBwYXJhbWV0ZXI6IFwiZGF0YWJhc2VJZFwiJyk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodHlwZW9mIGNvbGxlY3Rpb25JZCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBBcHB3cml0ZUV4Y2VwdGlvbignTWlzc2luZyByZXF1aXJlZCBwYXJhbWV0ZXI6IFwiY29sbGVjdGlvbklkXCInKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0eXBlb2Yga2V5ID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEFwcHdyaXRlRXhjZXB0aW9uKCdNaXNzaW5nIHJlcXVpcmVkIHBhcmFtZXRlcjogXCJrZXlcIicpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHR5cGVvZiBlbGVtZW50cyA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBBcHB3cml0ZUV4Y2VwdGlvbignTWlzc2luZyByZXF1aXJlZCBwYXJhbWV0ZXI6IFwiZWxlbWVudHNcIicpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHR5cGVvZiByZXF1aXJlZCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBBcHB3cml0ZUV4Y2VwdGlvbignTWlzc2luZyByZXF1aXJlZCBwYXJhbWV0ZXI6IFwicmVxdWlyZWRcIicpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHR5cGVvZiB4ZGVmYXVsdCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBBcHB3cml0ZUV4Y2VwdGlvbignTWlzc2luZyByZXF1aXJlZCBwYXJhbWV0ZXI6IFwieGRlZmF1bHRcIicpO1xuICAgICAgICB9XG5cblxuICAgICAgICBpZiAodHlwZW9mIGVsZW1lbnRzICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgcGF5bG9hZFsnZWxlbWVudHMnXSA9IGVsZW1lbnRzO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHR5cGVvZiByZXF1aXJlZCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHBheWxvYWRbJ3JlcXVpcmVkJ10gPSByZXF1aXJlZDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0eXBlb2YgeGRlZmF1bHQgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICBwYXlsb2FkWydkZWZhdWx0J10gPSB4ZGVmYXVsdDtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBhd2FpdCB0aGlzLmNsaWVudC5jYWxsKCdwYXRjaCcsIGFwaVBhdGgsIHtcbiAgICAgICAgICAgICdjb250ZW50LXR5cGUnOiAnYXBwbGljYXRpb24vanNvbicsXG4gICAgICAgIH0sIHBheWxvYWQpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZSBmbG9hdCBhdHRyaWJ1dGVcbiAgICAgKlxuICAgICAqIENyZWF0ZSBhIGZsb2F0IGF0dHJpYnV0ZS4gT3B0aW9uYWxseSwgbWluaW11bSBhbmQgbWF4aW11bSB2YWx1ZXMgY2FuIGJlXG4gICAgICogcHJvdmlkZWQuXG4gICAgICogXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gZGF0YWJhc2VJZFxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBjb2xsZWN0aW9uSWRcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30ga2V5XG4gICAgICogQHBhcmFtIHtib29sZWFufSByZXF1aXJlZFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBtaW5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gbWF4XG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHhkZWZhdWx0XG4gICAgICogQHBhcmFtIHtib29sZWFufSBhcnJheVxuICAgICAqIEB0aHJvd3Mge0FwcHdyaXRlRXhjZXB0aW9ufVxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlfVxuICAgICAqL1xuICAgIGFzeW5jIGNyZWF0ZUZsb2F0QXR0cmlidXRlKGRhdGFiYXNlSWQsIGNvbGxlY3Rpb25JZCwga2V5LCByZXF1aXJlZCwgbWluLCBtYXgsIHhkZWZhdWx0LCBhcnJheSkge1xuICAgICAgICBjb25zdCBhcGlQYXRoID0gJy9kYXRhYmFzZXMve2RhdGFiYXNlSWR9L2NvbGxlY3Rpb25zL3tjb2xsZWN0aW9uSWR9L2F0dHJpYnV0ZXMvZmxvYXQnLnJlcGxhY2UoJ3tkYXRhYmFzZUlkfScsIGRhdGFiYXNlSWQpLnJlcGxhY2UoJ3tjb2xsZWN0aW9uSWR9JywgY29sbGVjdGlvbklkKTtcbiAgICAgICAgbGV0IHBheWxvYWQgPSB7fTtcbiAgICAgICAgaWYgKHR5cGVvZiBkYXRhYmFzZUlkID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEFwcHdyaXRlRXhjZXB0aW9uKCdNaXNzaW5nIHJlcXVpcmVkIHBhcmFtZXRlcjogXCJkYXRhYmFzZUlkXCInKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0eXBlb2YgY29sbGVjdGlvbklkID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEFwcHdyaXRlRXhjZXB0aW9uKCdNaXNzaW5nIHJlcXVpcmVkIHBhcmFtZXRlcjogXCJjb2xsZWN0aW9uSWRcIicpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHR5cGVvZiBrZXkgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgQXBwd3JpdGVFeGNlcHRpb24oJ01pc3NpbmcgcmVxdWlyZWQgcGFyYW1ldGVyOiBcImtleVwiJyk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodHlwZW9mIHJlcXVpcmVkID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEFwcHdyaXRlRXhjZXB0aW9uKCdNaXNzaW5nIHJlcXVpcmVkIHBhcmFtZXRlcjogXCJyZXF1aXJlZFwiJyk7XG4gICAgICAgIH1cblxuXG4gICAgICAgIGlmICh0eXBlb2Yga2V5ICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgcGF5bG9hZFsna2V5J10gPSBrZXk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodHlwZW9mIHJlcXVpcmVkICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgcGF5bG9hZFsncmVxdWlyZWQnXSA9IHJlcXVpcmVkO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHR5cGVvZiBtaW4gIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICBwYXlsb2FkWydtaW4nXSA9IG1pbjtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0eXBlb2YgbWF4ICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgcGF5bG9hZFsnbWF4J10gPSBtYXg7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodHlwZW9mIHhkZWZhdWx0ICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgcGF5bG9hZFsnZGVmYXVsdCddID0geGRlZmF1bHQ7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodHlwZW9mIGFycmF5ICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgcGF5bG9hZFsnYXJyYXknXSA9IGFycmF5O1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMuY2xpZW50LmNhbGwoJ3Bvc3QnLCBhcGlQYXRoLCB7XG4gICAgICAgICAgICAnY29udGVudC10eXBlJzogJ2FwcGxpY2F0aW9uL2pzb24nLFxuICAgICAgICB9LCBwYXlsb2FkKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBVcGRhdGUgZmxvYXQgYXR0cmlidXRlXG4gICAgICpcbiAgICAgKiBVcGRhdGUgYSBmbG9hdCBhdHRyaWJ1dGUuIENoYW5naW5nIHRoZSBgZGVmYXVsdGAgdmFsdWUgd2lsbCBub3QgdXBkYXRlXG4gICAgICogYWxyZWFkeSBleGlzdGluZyBkb2N1bWVudHMuXG4gICAgICogXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gZGF0YWJhc2VJZFxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBjb2xsZWN0aW9uSWRcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30ga2V5XG4gICAgICogQHBhcmFtIHtib29sZWFufSByZXF1aXJlZFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBtaW5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gbWF4XG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHhkZWZhdWx0XG4gICAgICogQHRocm93cyB7QXBwd3JpdGVFeGNlcHRpb259XG4gICAgICogQHJldHVybnMge1Byb21pc2V9XG4gICAgICovXG4gICAgYXN5bmMgdXBkYXRlRmxvYXRBdHRyaWJ1dGUoZGF0YWJhc2VJZCwgY29sbGVjdGlvbklkLCBrZXksIHJlcXVpcmVkLCBtaW4sIG1heCwgeGRlZmF1bHQpIHtcbiAgICAgICAgY29uc3QgYXBpUGF0aCA9ICcvZGF0YWJhc2VzL3tkYXRhYmFzZUlkfS9jb2xsZWN0aW9ucy97Y29sbGVjdGlvbklkfS9hdHRyaWJ1dGVzL2Zsb2F0L3trZXl9Jy5yZXBsYWNlKCd7ZGF0YWJhc2VJZH0nLCBkYXRhYmFzZUlkKS5yZXBsYWNlKCd7Y29sbGVjdGlvbklkfScsIGNvbGxlY3Rpb25JZCkucmVwbGFjZSgne2tleX0nLCBrZXkpO1xuICAgICAgICBsZXQgcGF5bG9hZCA9IHt9O1xuICAgICAgICBpZiAodHlwZW9mIGRhdGFiYXNlSWQgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgQXBwd3JpdGVFeGNlcHRpb24oJ01pc3NpbmcgcmVxdWlyZWQgcGFyYW1ldGVyOiBcImRhdGFiYXNlSWRcIicpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHR5cGVvZiBjb2xsZWN0aW9uSWQgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgQXBwd3JpdGVFeGNlcHRpb24oJ01pc3NpbmcgcmVxdWlyZWQgcGFyYW1ldGVyOiBcImNvbGxlY3Rpb25JZFwiJyk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodHlwZW9mIGtleSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBBcHB3cml0ZUV4Y2VwdGlvbignTWlzc2luZyByZXF1aXJlZCBwYXJhbWV0ZXI6IFwia2V5XCInKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0eXBlb2YgcmVxdWlyZWQgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgQXBwd3JpdGVFeGNlcHRpb24oJ01pc3NpbmcgcmVxdWlyZWQgcGFyYW1ldGVyOiBcInJlcXVpcmVkXCInKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0eXBlb2YgbWluID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEFwcHdyaXRlRXhjZXB0aW9uKCdNaXNzaW5nIHJlcXVpcmVkIHBhcmFtZXRlcjogXCJtaW5cIicpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHR5cGVvZiBtYXggPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgQXBwd3JpdGVFeGNlcHRpb24oJ01pc3NpbmcgcmVxdWlyZWQgcGFyYW1ldGVyOiBcIm1heFwiJyk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodHlwZW9mIHhkZWZhdWx0ID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEFwcHdyaXRlRXhjZXB0aW9uKCdNaXNzaW5nIHJlcXVpcmVkIHBhcmFtZXRlcjogXCJ4ZGVmYXVsdFwiJyk7XG4gICAgICAgIH1cblxuXG4gICAgICAgIGlmICh0eXBlb2YgcmVxdWlyZWQgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICBwYXlsb2FkWydyZXF1aXJlZCddID0gcmVxdWlyZWQ7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodHlwZW9mIG1pbiAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHBheWxvYWRbJ21pbiddID0gbWluO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHR5cGVvZiBtYXggIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICBwYXlsb2FkWydtYXgnXSA9IG1heDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0eXBlb2YgeGRlZmF1bHQgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICBwYXlsb2FkWydkZWZhdWx0J10gPSB4ZGVmYXVsdDtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBhd2FpdCB0aGlzLmNsaWVudC5jYWxsKCdwYXRjaCcsIGFwaVBhdGgsIHtcbiAgICAgICAgICAgICdjb250ZW50LXR5cGUnOiAnYXBwbGljYXRpb24vanNvbicsXG4gICAgICAgIH0sIHBheWxvYWQpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZSBpbnRlZ2VyIGF0dHJpYnV0ZVxuICAgICAqXG4gICAgICogQ3JlYXRlIGFuIGludGVnZXIgYXR0cmlidXRlLiBPcHRpb25hbGx5LCBtaW5pbXVtIGFuZCBtYXhpbXVtIHZhbHVlcyBjYW4gYmVcbiAgICAgKiBwcm92aWRlZC5cbiAgICAgKiBcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBkYXRhYmFzZUlkXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGNvbGxlY3Rpb25JZFxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBrZXlcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IHJlcXVpcmVkXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IG1pblxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBtYXhcbiAgICAgKiBAcGFyYW0ge251bWJlcn0geGRlZmF1bHRcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IGFycmF5XG4gICAgICogQHRocm93cyB7QXBwd3JpdGVFeGNlcHRpb259XG4gICAgICogQHJldHVybnMge1Byb21pc2V9XG4gICAgICovXG4gICAgYXN5bmMgY3JlYXRlSW50ZWdlckF0dHJpYnV0ZShkYXRhYmFzZUlkLCBjb2xsZWN0aW9uSWQsIGtleSwgcmVxdWlyZWQsIG1pbiwgbWF4LCB4ZGVmYXVsdCwgYXJyYXkpIHtcbiAgICAgICAgY29uc3QgYXBpUGF0aCA9ICcvZGF0YWJhc2VzL3tkYXRhYmFzZUlkfS9jb2xsZWN0aW9ucy97Y29sbGVjdGlvbklkfS9hdHRyaWJ1dGVzL2ludGVnZXInLnJlcGxhY2UoJ3tkYXRhYmFzZUlkfScsIGRhdGFiYXNlSWQpLnJlcGxhY2UoJ3tjb2xsZWN0aW9uSWR9JywgY29sbGVjdGlvbklkKTtcbiAgICAgICAgbGV0IHBheWxvYWQgPSB7fTtcbiAgICAgICAgaWYgKHR5cGVvZiBkYXRhYmFzZUlkID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEFwcHdyaXRlRXhjZXB0aW9uKCdNaXNzaW5nIHJlcXVpcmVkIHBhcmFtZXRlcjogXCJkYXRhYmFzZUlkXCInKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0eXBlb2YgY29sbGVjdGlvbklkID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEFwcHdyaXRlRXhjZXB0aW9uKCdNaXNzaW5nIHJlcXVpcmVkIHBhcmFtZXRlcjogXCJjb2xsZWN0aW9uSWRcIicpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHR5cGVvZiBrZXkgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgQXBwd3JpdGVFeGNlcHRpb24oJ01pc3NpbmcgcmVxdWlyZWQgcGFyYW1ldGVyOiBcImtleVwiJyk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodHlwZW9mIHJlcXVpcmVkID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEFwcHdyaXRlRXhjZXB0aW9uKCdNaXNzaW5nIHJlcXVpcmVkIHBhcmFtZXRlcjogXCJyZXF1aXJlZFwiJyk7XG4gICAgICAgIH1cblxuXG4gICAgICAgIGlmICh0eXBlb2Yga2V5ICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgcGF5bG9hZFsna2V5J10gPSBrZXk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodHlwZW9mIHJlcXVpcmVkICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgcGF5bG9hZFsncmVxdWlyZWQnXSA9IHJlcXVpcmVkO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHR5cGVvZiBtaW4gIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICBwYXlsb2FkWydtaW4nXSA9IG1pbjtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0eXBlb2YgbWF4ICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgcGF5bG9hZFsnbWF4J10gPSBtYXg7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodHlwZW9mIHhkZWZhdWx0ICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgcGF5bG9hZFsnZGVmYXVsdCddID0geGRlZmF1bHQ7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodHlwZW9mIGFycmF5ICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgcGF5bG9hZFsnYXJyYXknXSA9IGFycmF5O1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMuY2xpZW50LmNhbGwoJ3Bvc3QnLCBhcGlQYXRoLCB7XG4gICAgICAgICAgICAnY29udGVudC10eXBlJzogJ2FwcGxpY2F0aW9uL2pzb24nLFxuICAgICAgICB9LCBwYXlsb2FkKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBVcGRhdGUgaW50ZWdlciBhdHRyaWJ1dGVcbiAgICAgKlxuICAgICAqIFVwZGF0ZSBhbiBpbnRlZ2VyIGF0dHJpYnV0ZS4gQ2hhbmdpbmcgdGhlIGBkZWZhdWx0YCB2YWx1ZSB3aWxsIG5vdCB1cGRhdGVcbiAgICAgKiBhbHJlYWR5IGV4aXN0aW5nIGRvY3VtZW50cy5cbiAgICAgKiBcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBkYXRhYmFzZUlkXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGNvbGxlY3Rpb25JZFxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBrZXlcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IHJlcXVpcmVkXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IG1pblxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBtYXhcbiAgICAgKiBAcGFyYW0ge251bWJlcn0geGRlZmF1bHRcbiAgICAgKiBAdGhyb3dzIHtBcHB3cml0ZUV4Y2VwdGlvbn1cbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZX1cbiAgICAgKi9cbiAgICBhc3luYyB1cGRhdGVJbnRlZ2VyQXR0cmlidXRlKGRhdGFiYXNlSWQsIGNvbGxlY3Rpb25JZCwga2V5LCByZXF1aXJlZCwgbWluLCBtYXgsIHhkZWZhdWx0KSB7XG4gICAgICAgIGNvbnN0IGFwaVBhdGggPSAnL2RhdGFiYXNlcy97ZGF0YWJhc2VJZH0vY29sbGVjdGlvbnMve2NvbGxlY3Rpb25JZH0vYXR0cmlidXRlcy9pbnRlZ2VyL3trZXl9Jy5yZXBsYWNlKCd7ZGF0YWJhc2VJZH0nLCBkYXRhYmFzZUlkKS5yZXBsYWNlKCd7Y29sbGVjdGlvbklkfScsIGNvbGxlY3Rpb25JZCkucmVwbGFjZSgne2tleX0nLCBrZXkpO1xuICAgICAgICBsZXQgcGF5bG9hZCA9IHt9O1xuICAgICAgICBpZiAodHlwZW9mIGRhdGFiYXNlSWQgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgQXBwd3JpdGVFeGNlcHRpb24oJ01pc3NpbmcgcmVxdWlyZWQgcGFyYW1ldGVyOiBcImRhdGFiYXNlSWRcIicpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHR5cGVvZiBjb2xsZWN0aW9uSWQgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgQXBwd3JpdGVFeGNlcHRpb24oJ01pc3NpbmcgcmVxdWlyZWQgcGFyYW1ldGVyOiBcImNvbGxlY3Rpb25JZFwiJyk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodHlwZW9mIGtleSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBBcHB3cml0ZUV4Y2VwdGlvbignTWlzc2luZyByZXF1aXJlZCBwYXJhbWV0ZXI6IFwia2V5XCInKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0eXBlb2YgcmVxdWlyZWQgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgQXBwd3JpdGVFeGNlcHRpb24oJ01pc3NpbmcgcmVxdWlyZWQgcGFyYW1ldGVyOiBcInJlcXVpcmVkXCInKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0eXBlb2YgbWluID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEFwcHdyaXRlRXhjZXB0aW9uKCdNaXNzaW5nIHJlcXVpcmVkIHBhcmFtZXRlcjogXCJtaW5cIicpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHR5cGVvZiBtYXggPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgQXBwd3JpdGVFeGNlcHRpb24oJ01pc3NpbmcgcmVxdWlyZWQgcGFyYW1ldGVyOiBcIm1heFwiJyk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodHlwZW9mIHhkZWZhdWx0ID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEFwcHdyaXRlRXhjZXB0aW9uKCdNaXNzaW5nIHJlcXVpcmVkIHBhcmFtZXRlcjogXCJ4ZGVmYXVsdFwiJyk7XG4gICAgICAgIH1cblxuXG4gICAgICAgIGlmICh0eXBlb2YgcmVxdWlyZWQgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICBwYXlsb2FkWydyZXF1aXJlZCddID0gcmVxdWlyZWQ7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodHlwZW9mIG1pbiAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHBheWxvYWRbJ21pbiddID0gbWluO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHR5cGVvZiBtYXggIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICBwYXlsb2FkWydtYXgnXSA9IG1heDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0eXBlb2YgeGRlZmF1bHQgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICBwYXlsb2FkWydkZWZhdWx0J10gPSB4ZGVmYXVsdDtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBhd2FpdCB0aGlzLmNsaWVudC5jYWxsKCdwYXRjaCcsIGFwaVBhdGgsIHtcbiAgICAgICAgICAgICdjb250ZW50LXR5cGUnOiAnYXBwbGljYXRpb24vanNvbicsXG4gICAgICAgIH0sIHBheWxvYWQpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZSBJUCBhZGRyZXNzIGF0dHJpYnV0ZVxuICAgICAqXG4gICAgICogQ3JlYXRlIElQIGFkZHJlc3MgYXR0cmlidXRlLlxuICAgICAqIFxuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGRhdGFiYXNlSWRcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gY29sbGVjdGlvbklkXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGtleVxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gcmVxdWlyZWRcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30geGRlZmF1bHRcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IGFycmF5XG4gICAgICogQHRocm93cyB7QXBwd3JpdGVFeGNlcHRpb259XG4gICAgICogQHJldHVybnMge1Byb21pc2V9XG4gICAgICovXG4gICAgYXN5bmMgY3JlYXRlSXBBdHRyaWJ1dGUoZGF0YWJhc2VJZCwgY29sbGVjdGlvbklkLCBrZXksIHJlcXVpcmVkLCB4ZGVmYXVsdCwgYXJyYXkpIHtcbiAgICAgICAgY29uc3QgYXBpUGF0aCA9ICcvZGF0YWJhc2VzL3tkYXRhYmFzZUlkfS9jb2xsZWN0aW9ucy97Y29sbGVjdGlvbklkfS9hdHRyaWJ1dGVzL2lwJy5yZXBsYWNlKCd7ZGF0YWJhc2VJZH0nLCBkYXRhYmFzZUlkKS5yZXBsYWNlKCd7Y29sbGVjdGlvbklkfScsIGNvbGxlY3Rpb25JZCk7XG4gICAgICAgIGxldCBwYXlsb2FkID0ge307XG4gICAgICAgIGlmICh0eXBlb2YgZGF0YWJhc2VJZCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBBcHB3cml0ZUV4Y2VwdGlvbignTWlzc2luZyByZXF1aXJlZCBwYXJhbWV0ZXI6IFwiZGF0YWJhc2VJZFwiJyk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodHlwZW9mIGNvbGxlY3Rpb25JZCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBBcHB3cml0ZUV4Y2VwdGlvbignTWlzc2luZyByZXF1aXJlZCBwYXJhbWV0ZXI6IFwiY29sbGVjdGlvbklkXCInKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0eXBlb2Yga2V5ID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEFwcHdyaXRlRXhjZXB0aW9uKCdNaXNzaW5nIHJlcXVpcmVkIHBhcmFtZXRlcjogXCJrZXlcIicpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHR5cGVvZiByZXF1aXJlZCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBBcHB3cml0ZUV4Y2VwdGlvbignTWlzc2luZyByZXF1aXJlZCBwYXJhbWV0ZXI6IFwicmVxdWlyZWRcIicpO1xuICAgICAgICB9XG5cblxuICAgICAgICBpZiAodHlwZW9mIGtleSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHBheWxvYWRbJ2tleSddID0ga2V5O1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHR5cGVvZiByZXF1aXJlZCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHBheWxvYWRbJ3JlcXVpcmVkJ10gPSByZXF1aXJlZDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0eXBlb2YgeGRlZmF1bHQgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICBwYXlsb2FkWydkZWZhdWx0J10gPSB4ZGVmYXVsdDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0eXBlb2YgYXJyYXkgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICBwYXlsb2FkWydhcnJheSddID0gYXJyYXk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy5jbGllbnQuY2FsbCgncG9zdCcsIGFwaVBhdGgsIHtcbiAgICAgICAgICAgICdjb250ZW50LXR5cGUnOiAnYXBwbGljYXRpb24vanNvbicsXG4gICAgICAgIH0sIHBheWxvYWQpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFVwZGF0ZSBJUCBhZGRyZXNzIGF0dHJpYnV0ZVxuICAgICAqXG4gICAgICogVXBkYXRlIGFuIGlwIGF0dHJpYnV0ZS4gQ2hhbmdpbmcgdGhlIGBkZWZhdWx0YCB2YWx1ZSB3aWxsIG5vdCB1cGRhdGVcbiAgICAgKiBhbHJlYWR5IGV4aXN0aW5nIGRvY3VtZW50cy5cbiAgICAgKiBcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBkYXRhYmFzZUlkXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGNvbGxlY3Rpb25JZFxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBrZXlcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IHJlcXVpcmVkXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHhkZWZhdWx0XG4gICAgICogQHRocm93cyB7QXBwd3JpdGVFeGNlcHRpb259XG4gICAgICogQHJldHVybnMge1Byb21pc2V9XG4gICAgICovXG4gICAgYXN5bmMgdXBkYXRlSXBBdHRyaWJ1dGUoZGF0YWJhc2VJZCwgY29sbGVjdGlvbklkLCBrZXksIHJlcXVpcmVkLCB4ZGVmYXVsdCkge1xuICAgICAgICBjb25zdCBhcGlQYXRoID0gJy9kYXRhYmFzZXMve2RhdGFiYXNlSWR9L2NvbGxlY3Rpb25zL3tjb2xsZWN0aW9uSWR9L2F0dHJpYnV0ZXMvaXAve2tleX0nLnJlcGxhY2UoJ3tkYXRhYmFzZUlkfScsIGRhdGFiYXNlSWQpLnJlcGxhY2UoJ3tjb2xsZWN0aW9uSWR9JywgY29sbGVjdGlvbklkKS5yZXBsYWNlKCd7a2V5fScsIGtleSk7XG4gICAgICAgIGxldCBwYXlsb2FkID0ge307XG4gICAgICAgIGlmICh0eXBlb2YgZGF0YWJhc2VJZCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBBcHB3cml0ZUV4Y2VwdGlvbignTWlzc2luZyByZXF1aXJlZCBwYXJhbWV0ZXI6IFwiZGF0YWJhc2VJZFwiJyk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodHlwZW9mIGNvbGxlY3Rpb25JZCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBBcHB3cml0ZUV4Y2VwdGlvbignTWlzc2luZyByZXF1aXJlZCBwYXJhbWV0ZXI6IFwiY29sbGVjdGlvbklkXCInKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0eXBlb2Yga2V5ID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEFwcHdyaXRlRXhjZXB0aW9uKCdNaXNzaW5nIHJlcXVpcmVkIHBhcmFtZXRlcjogXCJrZXlcIicpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHR5cGVvZiByZXF1aXJlZCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBBcHB3cml0ZUV4Y2VwdGlvbignTWlzc2luZyByZXF1aXJlZCBwYXJhbWV0ZXI6IFwicmVxdWlyZWRcIicpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHR5cGVvZiB4ZGVmYXVsdCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBBcHB3cml0ZUV4Y2VwdGlvbignTWlzc2luZyByZXF1aXJlZCBwYXJhbWV0ZXI6IFwieGRlZmF1bHRcIicpO1xuICAgICAgICB9XG5cblxuICAgICAgICBpZiAodHlwZW9mIHJlcXVpcmVkICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgcGF5bG9hZFsncmVxdWlyZWQnXSA9IHJlcXVpcmVkO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHR5cGVvZiB4ZGVmYXVsdCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHBheWxvYWRbJ2RlZmF1bHQnXSA9IHhkZWZhdWx0O1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMuY2xpZW50LmNhbGwoJ3BhdGNoJywgYXBpUGF0aCwge1xuICAgICAgICAgICAgJ2NvbnRlbnQtdHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJyxcbiAgICAgICAgfSwgcGF5bG9hZCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlIHJlbGF0aW9uc2hpcCBhdHRyaWJ1dGVcbiAgICAgKlxuICAgICAqIENyZWF0ZSByZWxhdGlvbnNoaXAgYXR0cmlidXRlLiBbTGVhcm4gbW9yZSBhYm91dCByZWxhdGlvbnNoaXBcbiAgICAgKiBhdHRyaWJ1dGVzXShodHRwczovL2FwcHdyaXRlLmlvL2RvY3MvZGF0YWJhc2VzLXJlbGF0aW9uc2hpcHMjcmVsYXRpb25zaGlwLWF0dHJpYnV0ZXMpLlxuICAgICAqIFxuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGRhdGFiYXNlSWRcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gY29sbGVjdGlvbklkXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHJlbGF0ZWRDb2xsZWN0aW9uSWRcbiAgICAgKiBAcGFyYW0ge1JlbGF0aW9uc2hpcFR5cGV9IHR5cGVcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IHR3b1dheVxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBrZXlcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gdHdvV2F5S2V5XG4gICAgICogQHBhcmFtIHtSZWxhdGlvbk11dGF0ZX0gb25EZWxldGVcbiAgICAgKiBAdGhyb3dzIHtBcHB3cml0ZUV4Y2VwdGlvbn1cbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZX1cbiAgICAgKi9cbiAgICBhc3luYyBjcmVhdGVSZWxhdGlvbnNoaXBBdHRyaWJ1dGUoZGF0YWJhc2VJZCwgY29sbGVjdGlvbklkLCByZWxhdGVkQ29sbGVjdGlvbklkLCB0eXBlLCB0d29XYXksIGtleSwgdHdvV2F5S2V5LCBvbkRlbGV0ZSkge1xuICAgICAgICBjb25zdCBhcGlQYXRoID0gJy9kYXRhYmFzZXMve2RhdGFiYXNlSWR9L2NvbGxlY3Rpb25zL3tjb2xsZWN0aW9uSWR9L2F0dHJpYnV0ZXMvcmVsYXRpb25zaGlwJy5yZXBsYWNlKCd7ZGF0YWJhc2VJZH0nLCBkYXRhYmFzZUlkKS5yZXBsYWNlKCd7Y29sbGVjdGlvbklkfScsIGNvbGxlY3Rpb25JZCk7XG4gICAgICAgIGxldCBwYXlsb2FkID0ge307XG4gICAgICAgIGlmICh0eXBlb2YgZGF0YWJhc2VJZCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBBcHB3cml0ZUV4Y2VwdGlvbignTWlzc2luZyByZXF1aXJlZCBwYXJhbWV0ZXI6IFwiZGF0YWJhc2VJZFwiJyk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodHlwZW9mIGNvbGxlY3Rpb25JZCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBBcHB3cml0ZUV4Y2VwdGlvbignTWlzc2luZyByZXF1aXJlZCBwYXJhbWV0ZXI6IFwiY29sbGVjdGlvbklkXCInKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0eXBlb2YgcmVsYXRlZENvbGxlY3Rpb25JZCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBBcHB3cml0ZUV4Y2VwdGlvbignTWlzc2luZyByZXF1aXJlZCBwYXJhbWV0ZXI6IFwicmVsYXRlZENvbGxlY3Rpb25JZFwiJyk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodHlwZW9mIHR5cGUgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgQXBwd3JpdGVFeGNlcHRpb24oJ01pc3NpbmcgcmVxdWlyZWQgcGFyYW1ldGVyOiBcInR5cGVcIicpO1xuICAgICAgICB9XG5cblxuICAgICAgICBpZiAodHlwZW9mIHJlbGF0ZWRDb2xsZWN0aW9uSWQgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICBwYXlsb2FkWydyZWxhdGVkQ29sbGVjdGlvbklkJ10gPSByZWxhdGVkQ29sbGVjdGlvbklkO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHR5cGVvZiB0eXBlICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgcGF5bG9hZFsndHlwZSddID0gdHlwZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0eXBlb2YgdHdvV2F5ICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgcGF5bG9hZFsndHdvV2F5J10gPSB0d29XYXk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodHlwZW9mIGtleSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHBheWxvYWRbJ2tleSddID0ga2V5O1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHR5cGVvZiB0d29XYXlLZXkgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICBwYXlsb2FkWyd0d29XYXlLZXknXSA9IHR3b1dheUtleTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0eXBlb2Ygb25EZWxldGUgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICBwYXlsb2FkWydvbkRlbGV0ZSddID0gb25EZWxldGU7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy5jbGllbnQuY2FsbCgncG9zdCcsIGFwaVBhdGgsIHtcbiAgICAgICAgICAgICdjb250ZW50LXR5cGUnOiAnYXBwbGljYXRpb24vanNvbicsXG4gICAgICAgIH0sIHBheWxvYWQpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZSBzdHJpbmcgYXR0cmlidXRlXG4gICAgICpcbiAgICAgKiBDcmVhdGUgYSBzdHJpbmcgYXR0cmlidXRlLlxuICAgICAqIFxuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGRhdGFiYXNlSWRcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gY29sbGVjdGlvbklkXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGtleVxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBzaXplXG4gICAgICogQHBhcmFtIHtib29sZWFufSByZXF1aXJlZFxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSB4ZGVmYXVsdFxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gYXJyYXlcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IGVuY3J5cHRcbiAgICAgKiBAdGhyb3dzIHtBcHB3cml0ZUV4Y2VwdGlvbn1cbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZX1cbiAgICAgKi9cbiAgICBhc3luYyBjcmVhdGVTdHJpbmdBdHRyaWJ1dGUoZGF0YWJhc2VJZCwgY29sbGVjdGlvbklkLCBrZXksIHNpemUsIHJlcXVpcmVkLCB4ZGVmYXVsdCwgYXJyYXksIGVuY3J5cHQpIHtcbiAgICAgICAgY29uc3QgYXBpUGF0aCA9ICcvZGF0YWJhc2VzL3tkYXRhYmFzZUlkfS9jb2xsZWN0aW9ucy97Y29sbGVjdGlvbklkfS9hdHRyaWJ1dGVzL3N0cmluZycucmVwbGFjZSgne2RhdGFiYXNlSWR9JywgZGF0YWJhc2VJZCkucmVwbGFjZSgne2NvbGxlY3Rpb25JZH0nLCBjb2xsZWN0aW9uSWQpO1xuICAgICAgICBsZXQgcGF5bG9hZCA9IHt9O1xuICAgICAgICBpZiAodHlwZW9mIGRhdGFiYXNlSWQgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgQXBwd3JpdGVFeGNlcHRpb24oJ01pc3NpbmcgcmVxdWlyZWQgcGFyYW1ldGVyOiBcImRhdGFiYXNlSWRcIicpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHR5cGVvZiBjb2xsZWN0aW9uSWQgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgQXBwd3JpdGVFeGNlcHRpb24oJ01pc3NpbmcgcmVxdWlyZWQgcGFyYW1ldGVyOiBcImNvbGxlY3Rpb25JZFwiJyk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodHlwZW9mIGtleSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBBcHB3cml0ZUV4Y2VwdGlvbignTWlzc2luZyByZXF1aXJlZCBwYXJhbWV0ZXI6IFwia2V5XCInKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0eXBlb2Ygc2l6ZSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBBcHB3cml0ZUV4Y2VwdGlvbignTWlzc2luZyByZXF1aXJlZCBwYXJhbWV0ZXI6IFwic2l6ZVwiJyk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodHlwZW9mIHJlcXVpcmVkID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEFwcHdyaXRlRXhjZXB0aW9uKCdNaXNzaW5nIHJlcXVpcmVkIHBhcmFtZXRlcjogXCJyZXF1aXJlZFwiJyk7XG4gICAgICAgIH1cblxuXG4gICAgICAgIGlmICh0eXBlb2Yga2V5ICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgcGF5bG9hZFsna2V5J10gPSBrZXk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodHlwZW9mIHNpemUgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICBwYXlsb2FkWydzaXplJ10gPSBzaXplO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHR5cGVvZiByZXF1aXJlZCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHBheWxvYWRbJ3JlcXVpcmVkJ10gPSByZXF1aXJlZDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0eXBlb2YgeGRlZmF1bHQgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICBwYXlsb2FkWydkZWZhdWx0J10gPSB4ZGVmYXVsdDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0eXBlb2YgYXJyYXkgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICBwYXlsb2FkWydhcnJheSddID0gYXJyYXk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodHlwZW9mIGVuY3J5cHQgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICBwYXlsb2FkWydlbmNyeXB0J10gPSBlbmNyeXB0O1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMuY2xpZW50LmNhbGwoJ3Bvc3QnLCBhcGlQYXRoLCB7XG4gICAgICAgICAgICAnY29udGVudC10eXBlJzogJ2FwcGxpY2F0aW9uL2pzb24nLFxuICAgICAgICB9LCBwYXlsb2FkKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBVcGRhdGUgc3RyaW5nIGF0dHJpYnV0ZVxuICAgICAqXG4gICAgICogVXBkYXRlIGEgc3RyaW5nIGF0dHJpYnV0ZS4gQ2hhbmdpbmcgdGhlIGBkZWZhdWx0YCB2YWx1ZSB3aWxsIG5vdCB1cGRhdGVcbiAgICAgKiBhbHJlYWR5IGV4aXN0aW5nIGRvY3VtZW50cy5cbiAgICAgKiBcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBkYXRhYmFzZUlkXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGNvbGxlY3Rpb25JZFxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBrZXlcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IHJlcXVpcmVkXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHhkZWZhdWx0XG4gICAgICogQHRocm93cyB7QXBwd3JpdGVFeGNlcHRpb259XG4gICAgICogQHJldHVybnMge1Byb21pc2V9XG4gICAgICovXG4gICAgYXN5bmMgdXBkYXRlU3RyaW5nQXR0cmlidXRlKGRhdGFiYXNlSWQsIGNvbGxlY3Rpb25JZCwga2V5LCByZXF1aXJlZCwgeGRlZmF1bHQpIHtcbiAgICAgICAgY29uc3QgYXBpUGF0aCA9ICcvZGF0YWJhc2VzL3tkYXRhYmFzZUlkfS9jb2xsZWN0aW9ucy97Y29sbGVjdGlvbklkfS9hdHRyaWJ1dGVzL3N0cmluZy97a2V5fScucmVwbGFjZSgne2RhdGFiYXNlSWR9JywgZGF0YWJhc2VJZCkucmVwbGFjZSgne2NvbGxlY3Rpb25JZH0nLCBjb2xsZWN0aW9uSWQpLnJlcGxhY2UoJ3trZXl9Jywga2V5KTtcbiAgICAgICAgbGV0IHBheWxvYWQgPSB7fTtcbiAgICAgICAgaWYgKHR5cGVvZiBkYXRhYmFzZUlkID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEFwcHdyaXRlRXhjZXB0aW9uKCdNaXNzaW5nIHJlcXVpcmVkIHBhcmFtZXRlcjogXCJkYXRhYmFzZUlkXCInKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0eXBlb2YgY29sbGVjdGlvbklkID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEFwcHdyaXRlRXhjZXB0aW9uKCdNaXNzaW5nIHJlcXVpcmVkIHBhcmFtZXRlcjogXCJjb2xsZWN0aW9uSWRcIicpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHR5cGVvZiBrZXkgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgQXBwd3JpdGVFeGNlcHRpb24oJ01pc3NpbmcgcmVxdWlyZWQgcGFyYW1ldGVyOiBcImtleVwiJyk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodHlwZW9mIHJlcXVpcmVkID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEFwcHdyaXRlRXhjZXB0aW9uKCdNaXNzaW5nIHJlcXVpcmVkIHBhcmFtZXRlcjogXCJyZXF1aXJlZFwiJyk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodHlwZW9mIHhkZWZhdWx0ID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEFwcHdyaXRlRXhjZXB0aW9uKCdNaXNzaW5nIHJlcXVpcmVkIHBhcmFtZXRlcjogXCJ4ZGVmYXVsdFwiJyk7XG4gICAgICAgIH1cblxuXG4gICAgICAgIGlmICh0eXBlb2YgcmVxdWlyZWQgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICBwYXlsb2FkWydyZXF1aXJlZCddID0gcmVxdWlyZWQ7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodHlwZW9mIHhkZWZhdWx0ICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgcGF5bG9hZFsnZGVmYXVsdCddID0geGRlZmF1bHQ7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy5jbGllbnQuY2FsbCgncGF0Y2gnLCBhcGlQYXRoLCB7XG4gICAgICAgICAgICAnY29udGVudC10eXBlJzogJ2FwcGxpY2F0aW9uL2pzb24nLFxuICAgICAgICB9LCBwYXlsb2FkKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGUgVVJMIGF0dHJpYnV0ZVxuICAgICAqXG4gICAgICogQ3JlYXRlIGEgVVJMIGF0dHJpYnV0ZS5cbiAgICAgKiBcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBkYXRhYmFzZUlkXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGNvbGxlY3Rpb25JZFxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBrZXlcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IHJlcXVpcmVkXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHhkZWZhdWx0XG4gICAgICogQHBhcmFtIHtib29sZWFufSBhcnJheVxuICAgICAqIEB0aHJvd3Mge0FwcHdyaXRlRXhjZXB0aW9ufVxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlfVxuICAgICAqL1xuICAgIGFzeW5jIGNyZWF0ZVVybEF0dHJpYnV0ZShkYXRhYmFzZUlkLCBjb2xsZWN0aW9uSWQsIGtleSwgcmVxdWlyZWQsIHhkZWZhdWx0LCBhcnJheSkge1xuICAgICAgICBjb25zdCBhcGlQYXRoID0gJy9kYXRhYmFzZXMve2RhdGFiYXNlSWR9L2NvbGxlY3Rpb25zL3tjb2xsZWN0aW9uSWR9L2F0dHJpYnV0ZXMvdXJsJy5yZXBsYWNlKCd7ZGF0YWJhc2VJZH0nLCBkYXRhYmFzZUlkKS5yZXBsYWNlKCd7Y29sbGVjdGlvbklkfScsIGNvbGxlY3Rpb25JZCk7XG4gICAgICAgIGxldCBwYXlsb2FkID0ge307XG4gICAgICAgIGlmICh0eXBlb2YgZGF0YWJhc2VJZCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBBcHB3cml0ZUV4Y2VwdGlvbignTWlzc2luZyByZXF1aXJlZCBwYXJhbWV0ZXI6IFwiZGF0YWJhc2VJZFwiJyk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodHlwZW9mIGNvbGxlY3Rpb25JZCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBBcHB3cml0ZUV4Y2VwdGlvbignTWlzc2luZyByZXF1aXJlZCBwYXJhbWV0ZXI6IFwiY29sbGVjdGlvbklkXCInKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0eXBlb2Yga2V5ID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEFwcHdyaXRlRXhjZXB0aW9uKCdNaXNzaW5nIHJlcXVpcmVkIHBhcmFtZXRlcjogXCJrZXlcIicpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHR5cGVvZiByZXF1aXJlZCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBBcHB3cml0ZUV4Y2VwdGlvbignTWlzc2luZyByZXF1aXJlZCBwYXJhbWV0ZXI6IFwicmVxdWlyZWRcIicpO1xuICAgICAgICB9XG5cblxuICAgICAgICBpZiAodHlwZW9mIGtleSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHBheWxvYWRbJ2tleSddID0ga2V5O1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHR5cGVvZiByZXF1aXJlZCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHBheWxvYWRbJ3JlcXVpcmVkJ10gPSByZXF1aXJlZDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0eXBlb2YgeGRlZmF1bHQgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICBwYXlsb2FkWydkZWZhdWx0J10gPSB4ZGVmYXVsdDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0eXBlb2YgYXJyYXkgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICBwYXlsb2FkWydhcnJheSddID0gYXJyYXk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy5jbGllbnQuY2FsbCgncG9zdCcsIGFwaVBhdGgsIHtcbiAgICAgICAgICAgICdjb250ZW50LXR5cGUnOiAnYXBwbGljYXRpb24vanNvbicsXG4gICAgICAgIH0sIHBheWxvYWQpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFVwZGF0ZSBVUkwgYXR0cmlidXRlXG4gICAgICpcbiAgICAgKiBVcGRhdGUgYW4gdXJsIGF0dHJpYnV0ZS4gQ2hhbmdpbmcgdGhlIGBkZWZhdWx0YCB2YWx1ZSB3aWxsIG5vdCB1cGRhdGVcbiAgICAgKiBhbHJlYWR5IGV4aXN0aW5nIGRvY3VtZW50cy5cbiAgICAgKiBcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBkYXRhYmFzZUlkXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGNvbGxlY3Rpb25JZFxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBrZXlcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IHJlcXVpcmVkXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHhkZWZhdWx0XG4gICAgICogQHRocm93cyB7QXBwd3JpdGVFeGNlcHRpb259XG4gICAgICogQHJldHVybnMge1Byb21pc2V9XG4gICAgICovXG4gICAgYXN5bmMgdXBkYXRlVXJsQXR0cmlidXRlKGRhdGFiYXNlSWQsIGNvbGxlY3Rpb25JZCwga2V5LCByZXF1aXJlZCwgeGRlZmF1bHQpIHtcbiAgICAgICAgY29uc3QgYXBpUGF0aCA9ICcvZGF0YWJhc2VzL3tkYXRhYmFzZUlkfS9jb2xsZWN0aW9ucy97Y29sbGVjdGlvbklkfS9hdHRyaWJ1dGVzL3VybC97a2V5fScucmVwbGFjZSgne2RhdGFiYXNlSWR9JywgZGF0YWJhc2VJZCkucmVwbGFjZSgne2NvbGxlY3Rpb25JZH0nLCBjb2xsZWN0aW9uSWQpLnJlcGxhY2UoJ3trZXl9Jywga2V5KTtcbiAgICAgICAgbGV0IHBheWxvYWQgPSB7fTtcbiAgICAgICAgaWYgKHR5cGVvZiBkYXRhYmFzZUlkID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEFwcHdyaXRlRXhjZXB0aW9uKCdNaXNzaW5nIHJlcXVpcmVkIHBhcmFtZXRlcjogXCJkYXRhYmFzZUlkXCInKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0eXBlb2YgY29sbGVjdGlvbklkID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEFwcHdyaXRlRXhjZXB0aW9uKCdNaXNzaW5nIHJlcXVpcmVkIHBhcmFtZXRlcjogXCJjb2xsZWN0aW9uSWRcIicpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHR5cGVvZiBrZXkgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgQXBwd3JpdGVFeGNlcHRpb24oJ01pc3NpbmcgcmVxdWlyZWQgcGFyYW1ldGVyOiBcImtleVwiJyk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodHlwZW9mIHJlcXVpcmVkID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEFwcHdyaXRlRXhjZXB0aW9uKCdNaXNzaW5nIHJlcXVpcmVkIHBhcmFtZXRlcjogXCJyZXF1aXJlZFwiJyk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodHlwZW9mIHhkZWZhdWx0ID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEFwcHdyaXRlRXhjZXB0aW9uKCdNaXNzaW5nIHJlcXVpcmVkIHBhcmFtZXRlcjogXCJ4ZGVmYXVsdFwiJyk7XG4gICAgICAgIH1cblxuXG4gICAgICAgIGlmICh0eXBlb2YgcmVxdWlyZWQgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICBwYXlsb2FkWydyZXF1aXJlZCddID0gcmVxdWlyZWQ7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodHlwZW9mIHhkZWZhdWx0ICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgcGF5bG9hZFsnZGVmYXVsdCddID0geGRlZmF1bHQ7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy5jbGllbnQuY2FsbCgncGF0Y2gnLCBhcGlQYXRoLCB7XG4gICAgICAgICAgICAnY29udGVudC10eXBlJzogJ2FwcGxpY2F0aW9uL2pzb24nLFxuICAgICAgICB9LCBwYXlsb2FkKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZXQgYXR0cmlidXRlXG4gICAgICpcbiAgICAgKiBHZXQgYXR0cmlidXRlIGJ5IElELlxuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGRhdGFiYXNlSWRcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gY29sbGVjdGlvbklkXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGtleVxuICAgICAqIEB0aHJvd3Mge0FwcHdyaXRlRXhjZXB0aW9ufVxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlfVxuICAgICAqL1xuICAgIGFzeW5jIGdldEF0dHJpYnV0ZShkYXRhYmFzZUlkLCBjb2xsZWN0aW9uSWQsIGtleSkge1xuICAgICAgICBjb25zdCBhcGlQYXRoID0gJy9kYXRhYmFzZXMve2RhdGFiYXNlSWR9L2NvbGxlY3Rpb25zL3tjb2xsZWN0aW9uSWR9L2F0dHJpYnV0ZXMve2tleX0nLnJlcGxhY2UoJ3tkYXRhYmFzZUlkfScsIGRhdGFiYXNlSWQpLnJlcGxhY2UoJ3tjb2xsZWN0aW9uSWR9JywgY29sbGVjdGlvbklkKS5yZXBsYWNlKCd7a2V5fScsIGtleSk7XG4gICAgICAgIGxldCBwYXlsb2FkID0ge307XG4gICAgICAgIGlmICh0eXBlb2YgZGF0YWJhc2VJZCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBBcHB3cml0ZUV4Y2VwdGlvbignTWlzc2luZyByZXF1aXJlZCBwYXJhbWV0ZXI6IFwiZGF0YWJhc2VJZFwiJyk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodHlwZW9mIGNvbGxlY3Rpb25JZCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBBcHB3cml0ZUV4Y2VwdGlvbignTWlzc2luZyByZXF1aXJlZCBwYXJhbWV0ZXI6IFwiY29sbGVjdGlvbklkXCInKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0eXBlb2Yga2V5ID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEFwcHdyaXRlRXhjZXB0aW9uKCdNaXNzaW5nIHJlcXVpcmVkIHBhcmFtZXRlcjogXCJrZXlcIicpO1xuICAgICAgICB9XG5cblxuICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy5jbGllbnQuY2FsbCgnZ2V0JywgYXBpUGF0aCwge1xuICAgICAgICAgICAgJ2NvbnRlbnQtdHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJyxcbiAgICAgICAgfSwgcGF5bG9hZCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRGVsZXRlIGF0dHJpYnV0ZVxuICAgICAqXG4gICAgICogRGVsZXRlcyBhbiBhdHRyaWJ1dGUuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gZGF0YWJhc2VJZFxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBjb2xsZWN0aW9uSWRcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30ga2V5XG4gICAgICogQHRocm93cyB7QXBwd3JpdGVFeGNlcHRpb259XG4gICAgICogQHJldHVybnMge1Byb21pc2V9XG4gICAgICovXG4gICAgYXN5bmMgZGVsZXRlQXR0cmlidXRlKGRhdGFiYXNlSWQsIGNvbGxlY3Rpb25JZCwga2V5KSB7XG4gICAgICAgIGNvbnN0IGFwaVBhdGggPSAnL2RhdGFiYXNlcy97ZGF0YWJhc2VJZH0vY29sbGVjdGlvbnMve2NvbGxlY3Rpb25JZH0vYXR0cmlidXRlcy97a2V5fScucmVwbGFjZSgne2RhdGFiYXNlSWR9JywgZGF0YWJhc2VJZCkucmVwbGFjZSgne2NvbGxlY3Rpb25JZH0nLCBjb2xsZWN0aW9uSWQpLnJlcGxhY2UoJ3trZXl9Jywga2V5KTtcbiAgICAgICAgbGV0IHBheWxvYWQgPSB7fTtcbiAgICAgICAgaWYgKHR5cGVvZiBkYXRhYmFzZUlkID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEFwcHdyaXRlRXhjZXB0aW9uKCdNaXNzaW5nIHJlcXVpcmVkIHBhcmFtZXRlcjogXCJkYXRhYmFzZUlkXCInKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0eXBlb2YgY29sbGVjdGlvbklkID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEFwcHdyaXRlRXhjZXB0aW9uKCdNaXNzaW5nIHJlcXVpcmVkIHBhcmFtZXRlcjogXCJjb2xsZWN0aW9uSWRcIicpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHR5cGVvZiBrZXkgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgQXBwd3JpdGVFeGNlcHRpb24oJ01pc3NpbmcgcmVxdWlyZWQgcGFyYW1ldGVyOiBcImtleVwiJyk7XG4gICAgICAgIH1cblxuXG4gICAgICAgIHJldHVybiBhd2FpdCB0aGlzLmNsaWVudC5jYWxsKCdkZWxldGUnLCBhcGlQYXRoLCB7XG4gICAgICAgICAgICAnY29udGVudC10eXBlJzogJ2FwcGxpY2F0aW9uL2pzb24nLFxuICAgICAgICB9LCBwYXlsb2FkKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBVcGRhdGUgcmVsYXRpb25zaGlwIGF0dHJpYnV0ZVxuICAgICAqXG4gICAgICogVXBkYXRlIHJlbGF0aW9uc2hpcCBhdHRyaWJ1dGUuIFtMZWFybiBtb3JlIGFib3V0IHJlbGF0aW9uc2hpcFxuICAgICAqIGF0dHJpYnV0ZXNdKGh0dHBzOi8vYXBwd3JpdGUuaW8vZG9jcy9kYXRhYmFzZXMtcmVsYXRpb25zaGlwcyNyZWxhdGlvbnNoaXAtYXR0cmlidXRlcykuXG4gICAgICogXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gZGF0YWJhc2VJZFxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBjb2xsZWN0aW9uSWRcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30ga2V5XG4gICAgICogQHBhcmFtIHtSZWxhdGlvbk11dGF0ZX0gb25EZWxldGVcbiAgICAgKiBAdGhyb3dzIHtBcHB3cml0ZUV4Y2VwdGlvbn1cbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZX1cbiAgICAgKi9cbiAgICBhc3luYyB1cGRhdGVSZWxhdGlvbnNoaXBBdHRyaWJ1dGUoZGF0YWJhc2VJZCwgY29sbGVjdGlvbklkLCBrZXksIG9uRGVsZXRlKSB7XG4gICAgICAgIGNvbnN0IGFwaVBhdGggPSAnL2RhdGFiYXNlcy97ZGF0YWJhc2VJZH0vY29sbGVjdGlvbnMve2NvbGxlY3Rpb25JZH0vYXR0cmlidXRlcy97a2V5fS9yZWxhdGlvbnNoaXAnLnJlcGxhY2UoJ3tkYXRhYmFzZUlkfScsIGRhdGFiYXNlSWQpLnJlcGxhY2UoJ3tjb2xsZWN0aW9uSWR9JywgY29sbGVjdGlvbklkKS5yZXBsYWNlKCd7a2V5fScsIGtleSk7XG4gICAgICAgIGxldCBwYXlsb2FkID0ge307XG4gICAgICAgIGlmICh0eXBlb2YgZGF0YWJhc2VJZCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBBcHB3cml0ZUV4Y2VwdGlvbignTWlzc2luZyByZXF1aXJlZCBwYXJhbWV0ZXI6IFwiZGF0YWJhc2VJZFwiJyk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodHlwZW9mIGNvbGxlY3Rpb25JZCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBBcHB3cml0ZUV4Y2VwdGlvbignTWlzc2luZyByZXF1aXJlZCBwYXJhbWV0ZXI6IFwiY29sbGVjdGlvbklkXCInKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0eXBlb2Yga2V5ID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEFwcHdyaXRlRXhjZXB0aW9uKCdNaXNzaW5nIHJlcXVpcmVkIHBhcmFtZXRlcjogXCJrZXlcIicpO1xuICAgICAgICB9XG5cblxuICAgICAgICBpZiAodHlwZW9mIG9uRGVsZXRlICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgcGF5bG9hZFsnb25EZWxldGUnXSA9IG9uRGVsZXRlO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMuY2xpZW50LmNhbGwoJ3BhdGNoJywgYXBpUGF0aCwge1xuICAgICAgICAgICAgJ2NvbnRlbnQtdHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJyxcbiAgICAgICAgfSwgcGF5bG9hZCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogTGlzdCBkb2N1bWVudHNcbiAgICAgKlxuICAgICAqIEdldCBhIGxpc3Qgb2YgYWxsIHRoZSB1c2VyJ3MgZG9jdW1lbnRzIGluIGEgZ2l2ZW4gY29sbGVjdGlvbi4gWW91IGNhbiB1c2VcbiAgICAgKiB0aGUgcXVlcnkgcGFyYW1zIHRvIGZpbHRlciB5b3VyIHJlc3VsdHMuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gZGF0YWJhc2VJZFxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBjb2xsZWN0aW9uSWRcbiAgICAgKiBAcGFyYW0ge3N0cmluZ1tdfSBxdWVyaWVzXG4gICAgICogQHRocm93cyB7QXBwd3JpdGVFeGNlcHRpb259XG4gICAgICogQHJldHVybnMge1Byb21pc2V9XG4gICAgICovXG4gICAgYXN5bmMgbGlzdERvY3VtZW50cyhkYXRhYmFzZUlkLCBjb2xsZWN0aW9uSWQsIHF1ZXJpZXMpIHtcbiAgICAgICAgY29uc3QgYXBpUGF0aCA9ICcvZGF0YWJhc2VzL3tkYXRhYmFzZUlkfS9jb2xsZWN0aW9ucy97Y29sbGVjdGlvbklkfS9kb2N1bWVudHMnLnJlcGxhY2UoJ3tkYXRhYmFzZUlkfScsIGRhdGFiYXNlSWQpLnJlcGxhY2UoJ3tjb2xsZWN0aW9uSWR9JywgY29sbGVjdGlvbklkKTtcbiAgICAgICAgbGV0IHBheWxvYWQgPSB7fTtcbiAgICAgICAgaWYgKHR5cGVvZiBkYXRhYmFzZUlkID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEFwcHdyaXRlRXhjZXB0aW9uKCdNaXNzaW5nIHJlcXVpcmVkIHBhcmFtZXRlcjogXCJkYXRhYmFzZUlkXCInKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0eXBlb2YgY29sbGVjdGlvbklkID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEFwcHdyaXRlRXhjZXB0aW9uKCdNaXNzaW5nIHJlcXVpcmVkIHBhcmFtZXRlcjogXCJjb2xsZWN0aW9uSWRcIicpO1xuICAgICAgICB9XG5cblxuICAgICAgICBpZiAodHlwZW9mIHF1ZXJpZXMgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICBwYXlsb2FkWydxdWVyaWVzJ10gPSBxdWVyaWVzO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMuY2xpZW50LmNhbGwoJ2dldCcsIGFwaVBhdGgsIHtcbiAgICAgICAgICAgICdjb250ZW50LXR5cGUnOiAnYXBwbGljYXRpb24vanNvbicsXG4gICAgICAgIH0sIHBheWxvYWQpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZSBkb2N1bWVudFxuICAgICAqXG4gICAgICogQ3JlYXRlIGEgbmV3IERvY3VtZW50LiBCZWZvcmUgdXNpbmcgdGhpcyByb3V0ZSwgeW91IHNob3VsZCBjcmVhdGUgYSBuZXdcbiAgICAgKiBjb2xsZWN0aW9uIHJlc291cmNlIHVzaW5nIGVpdGhlciBhIFtzZXJ2ZXJcbiAgICAgKiBpbnRlZ3JhdGlvbl0oaHR0cHM6Ly9hcHB3cml0ZS5pby9kb2NzL3NlcnZlci9kYXRhYmFzZXMjZGF0YWJhc2VzQ3JlYXRlQ29sbGVjdGlvbilcbiAgICAgKiBBUEkgb3IgZGlyZWN0bHkgZnJvbSB5b3VyIGRhdGFiYXNlIGNvbnNvbGUuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gZGF0YWJhc2VJZFxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBjb2xsZWN0aW9uSWRcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gZG9jdW1lbnRJZFxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBkYXRhXG4gICAgICogQHBhcmFtIHtzdHJpbmdbXX0gcGVybWlzc2lvbnNcbiAgICAgKiBAdGhyb3dzIHtBcHB3cml0ZUV4Y2VwdGlvbn1cbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZX1cbiAgICAgKi9cbiAgICBhc3luYyBjcmVhdGVEb2N1bWVudChkYXRhYmFzZUlkLCBjb2xsZWN0aW9uSWQsIGRvY3VtZW50SWQsIGRhdGEsIHBlcm1pc3Npb25zKSB7XG4gICAgICAgIGNvbnN0IGFwaVBhdGggPSAnL2RhdGFiYXNlcy97ZGF0YWJhc2VJZH0vY29sbGVjdGlvbnMve2NvbGxlY3Rpb25JZH0vZG9jdW1lbnRzJy5yZXBsYWNlKCd7ZGF0YWJhc2VJZH0nLCBkYXRhYmFzZUlkKS5yZXBsYWNlKCd7Y29sbGVjdGlvbklkfScsIGNvbGxlY3Rpb25JZCk7XG4gICAgICAgIGxldCBwYXlsb2FkID0ge307XG4gICAgICAgIGlmICh0eXBlb2YgZGF0YWJhc2VJZCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBBcHB3cml0ZUV4Y2VwdGlvbignTWlzc2luZyByZXF1aXJlZCBwYXJhbWV0ZXI6IFwiZGF0YWJhc2VJZFwiJyk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodHlwZW9mIGNvbGxlY3Rpb25JZCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBBcHB3cml0ZUV4Y2VwdGlvbignTWlzc2luZyByZXF1aXJlZCBwYXJhbWV0ZXI6IFwiY29sbGVjdGlvbklkXCInKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0eXBlb2YgZG9jdW1lbnRJZCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBBcHB3cml0ZUV4Y2VwdGlvbignTWlzc2luZyByZXF1aXJlZCBwYXJhbWV0ZXI6IFwiZG9jdW1lbnRJZFwiJyk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodHlwZW9mIGRhdGEgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgQXBwd3JpdGVFeGNlcHRpb24oJ01pc3NpbmcgcmVxdWlyZWQgcGFyYW1ldGVyOiBcImRhdGFcIicpO1xuICAgICAgICB9XG5cblxuICAgICAgICBpZiAodHlwZW9mIGRvY3VtZW50SWQgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICBwYXlsb2FkWydkb2N1bWVudElkJ10gPSBkb2N1bWVudElkO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHR5cGVvZiBkYXRhICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgcGF5bG9hZFsnZGF0YSddID0gZGF0YTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0eXBlb2YgcGVybWlzc2lvbnMgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICBwYXlsb2FkWydwZXJtaXNzaW9ucyddID0gcGVybWlzc2lvbnM7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy5jbGllbnQuY2FsbCgncG9zdCcsIGFwaVBhdGgsIHtcbiAgICAgICAgICAgICdjb250ZW50LXR5cGUnOiAnYXBwbGljYXRpb24vanNvbicsXG4gICAgICAgIH0sIHBheWxvYWQpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdldCBkb2N1bWVudFxuICAgICAqXG4gICAgICogR2V0IGEgZG9jdW1lbnQgYnkgaXRzIHVuaXF1ZSBJRC4gVGhpcyBlbmRwb2ludCByZXNwb25zZSByZXR1cm5zIGEgSlNPTlxuICAgICAqIG9iamVjdCB3aXRoIHRoZSBkb2N1bWVudCBkYXRhLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGRhdGFiYXNlSWRcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gY29sbGVjdGlvbklkXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGRvY3VtZW50SWRcbiAgICAgKiBAcGFyYW0ge3N0cmluZ1tdfSBxdWVyaWVzXG4gICAgICogQHRocm93cyB7QXBwd3JpdGVFeGNlcHRpb259XG4gICAgICogQHJldHVybnMge1Byb21pc2V9XG4gICAgICovXG4gICAgYXN5bmMgZ2V0RG9jdW1lbnQoZGF0YWJhc2VJZCwgY29sbGVjdGlvbklkLCBkb2N1bWVudElkLCBxdWVyaWVzKSB7XG4gICAgICAgIGNvbnN0IGFwaVBhdGggPSAnL2RhdGFiYXNlcy97ZGF0YWJhc2VJZH0vY29sbGVjdGlvbnMve2NvbGxlY3Rpb25JZH0vZG9jdW1lbnRzL3tkb2N1bWVudElkfScucmVwbGFjZSgne2RhdGFiYXNlSWR9JywgZGF0YWJhc2VJZCkucmVwbGFjZSgne2NvbGxlY3Rpb25JZH0nLCBjb2xsZWN0aW9uSWQpLnJlcGxhY2UoJ3tkb2N1bWVudElkfScsIGRvY3VtZW50SWQpO1xuICAgICAgICBsZXQgcGF5bG9hZCA9IHt9O1xuICAgICAgICBpZiAodHlwZW9mIGRhdGFiYXNlSWQgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgQXBwd3JpdGVFeGNlcHRpb24oJ01pc3NpbmcgcmVxdWlyZWQgcGFyYW1ldGVyOiBcImRhdGFiYXNlSWRcIicpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHR5cGVvZiBjb2xsZWN0aW9uSWQgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgQXBwd3JpdGVFeGNlcHRpb24oJ01pc3NpbmcgcmVxdWlyZWQgcGFyYW1ldGVyOiBcImNvbGxlY3Rpb25JZFwiJyk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodHlwZW9mIGRvY3VtZW50SWQgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgQXBwd3JpdGVFeGNlcHRpb24oJ01pc3NpbmcgcmVxdWlyZWQgcGFyYW1ldGVyOiBcImRvY3VtZW50SWRcIicpO1xuICAgICAgICB9XG5cblxuICAgICAgICBpZiAodHlwZW9mIHF1ZXJpZXMgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICBwYXlsb2FkWydxdWVyaWVzJ10gPSBxdWVyaWVzO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMuY2xpZW50LmNhbGwoJ2dldCcsIGFwaVBhdGgsIHtcbiAgICAgICAgICAgICdjb250ZW50LXR5cGUnOiAnYXBwbGljYXRpb24vanNvbicsXG4gICAgICAgIH0sIHBheWxvYWQpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFVwZGF0ZSBkb2N1bWVudFxuICAgICAqXG4gICAgICogVXBkYXRlIGEgZG9jdW1lbnQgYnkgaXRzIHVuaXF1ZSBJRC4gVXNpbmcgdGhlIHBhdGNoIG1ldGhvZCB5b3UgY2FuIHBhc3NcbiAgICAgKiBvbmx5IHNwZWNpZmljIGZpZWxkcyB0aGF0IHdpbGwgZ2V0IHVwZGF0ZWQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gZGF0YWJhc2VJZFxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBjb2xsZWN0aW9uSWRcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gZG9jdW1lbnRJZFxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBkYXRhXG4gICAgICogQHBhcmFtIHtzdHJpbmdbXX0gcGVybWlzc2lvbnNcbiAgICAgKiBAdGhyb3dzIHtBcHB3cml0ZUV4Y2VwdGlvbn1cbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZX1cbiAgICAgKi9cbiAgICBhc3luYyB1cGRhdGVEb2N1bWVudChkYXRhYmFzZUlkLCBjb2xsZWN0aW9uSWQsIGRvY3VtZW50SWQsIGRhdGEsIHBlcm1pc3Npb25zKSB7XG4gICAgICAgIGNvbnN0IGFwaVBhdGggPSAnL2RhdGFiYXNlcy97ZGF0YWJhc2VJZH0vY29sbGVjdGlvbnMve2NvbGxlY3Rpb25JZH0vZG9jdW1lbnRzL3tkb2N1bWVudElkfScucmVwbGFjZSgne2RhdGFiYXNlSWR9JywgZGF0YWJhc2VJZCkucmVwbGFjZSgne2NvbGxlY3Rpb25JZH0nLCBjb2xsZWN0aW9uSWQpLnJlcGxhY2UoJ3tkb2N1bWVudElkfScsIGRvY3VtZW50SWQpO1xuICAgICAgICBsZXQgcGF5bG9hZCA9IHt9O1xuICAgICAgICBpZiAodHlwZW9mIGRhdGFiYXNlSWQgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgQXBwd3JpdGVFeGNlcHRpb24oJ01pc3NpbmcgcmVxdWlyZWQgcGFyYW1ldGVyOiBcImRhdGFiYXNlSWRcIicpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHR5cGVvZiBjb2xsZWN0aW9uSWQgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgQXBwd3JpdGVFeGNlcHRpb24oJ01pc3NpbmcgcmVxdWlyZWQgcGFyYW1ldGVyOiBcImNvbGxlY3Rpb25JZFwiJyk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodHlwZW9mIGRvY3VtZW50SWQgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgQXBwd3JpdGVFeGNlcHRpb24oJ01pc3NpbmcgcmVxdWlyZWQgcGFyYW1ldGVyOiBcImRvY3VtZW50SWRcIicpO1xuICAgICAgICB9XG5cblxuICAgICAgICBpZiAodHlwZW9mIGRhdGEgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICBwYXlsb2FkWydkYXRhJ10gPSBkYXRhO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHR5cGVvZiBwZXJtaXNzaW9ucyAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHBheWxvYWRbJ3Blcm1pc3Npb25zJ10gPSBwZXJtaXNzaW9ucztcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBhd2FpdCB0aGlzLmNsaWVudC5jYWxsKCdwYXRjaCcsIGFwaVBhdGgsIHtcbiAgICAgICAgICAgICdjb250ZW50LXR5cGUnOiAnYXBwbGljYXRpb24vanNvbicsXG4gICAgICAgIH0sIHBheWxvYWQpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIERlbGV0ZSBkb2N1bWVudFxuICAgICAqXG4gICAgICogRGVsZXRlIGEgZG9jdW1lbnQgYnkgaXRzIHVuaXF1ZSBJRC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBkYXRhYmFzZUlkXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGNvbGxlY3Rpb25JZFxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBkb2N1bWVudElkXG4gICAgICogQHRocm93cyB7QXBwd3JpdGVFeGNlcHRpb259XG4gICAgICogQHJldHVybnMge1Byb21pc2V9XG4gICAgICovXG4gICAgYXN5bmMgZGVsZXRlRG9jdW1lbnQoZGF0YWJhc2VJZCwgY29sbGVjdGlvbklkLCBkb2N1bWVudElkKSB7XG4gICAgICAgIGNvbnN0IGFwaVBhdGggPSAnL2RhdGFiYXNlcy97ZGF0YWJhc2VJZH0vY29sbGVjdGlvbnMve2NvbGxlY3Rpb25JZH0vZG9jdW1lbnRzL3tkb2N1bWVudElkfScucmVwbGFjZSgne2RhdGFiYXNlSWR9JywgZGF0YWJhc2VJZCkucmVwbGFjZSgne2NvbGxlY3Rpb25JZH0nLCBjb2xsZWN0aW9uSWQpLnJlcGxhY2UoJ3tkb2N1bWVudElkfScsIGRvY3VtZW50SWQpO1xuICAgICAgICBsZXQgcGF5bG9hZCA9IHt9O1xuICAgICAgICBpZiAodHlwZW9mIGRhdGFiYXNlSWQgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgQXBwd3JpdGVFeGNlcHRpb24oJ01pc3NpbmcgcmVxdWlyZWQgcGFyYW1ldGVyOiBcImRhdGFiYXNlSWRcIicpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHR5cGVvZiBjb2xsZWN0aW9uSWQgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgQXBwd3JpdGVFeGNlcHRpb24oJ01pc3NpbmcgcmVxdWlyZWQgcGFyYW1ldGVyOiBcImNvbGxlY3Rpb25JZFwiJyk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodHlwZW9mIGRvY3VtZW50SWQgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgQXBwd3JpdGVFeGNlcHRpb24oJ01pc3NpbmcgcmVxdWlyZWQgcGFyYW1ldGVyOiBcImRvY3VtZW50SWRcIicpO1xuICAgICAgICB9XG5cblxuICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy5jbGllbnQuY2FsbCgnZGVsZXRlJywgYXBpUGF0aCwge1xuICAgICAgICAgICAgJ2NvbnRlbnQtdHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJyxcbiAgICAgICAgfSwgcGF5bG9hZCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogTGlzdCBpbmRleGVzXG4gICAgICpcbiAgICAgKiBMaXN0IGluZGV4ZXMgaW4gdGhlIGNvbGxlY3Rpb24uXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gZGF0YWJhc2VJZFxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBjb2xsZWN0aW9uSWRcbiAgICAgKiBAcGFyYW0ge3N0cmluZ1tdfSBxdWVyaWVzXG4gICAgICogQHRocm93cyB7QXBwd3JpdGVFeGNlcHRpb259XG4gICAgICogQHJldHVybnMge1Byb21pc2V9XG4gICAgICovXG4gICAgYXN5bmMgbGlzdEluZGV4ZXMoZGF0YWJhc2VJZCwgY29sbGVjdGlvbklkLCBxdWVyaWVzKSB7XG4gICAgICAgIGNvbnN0IGFwaVBhdGggPSAnL2RhdGFiYXNlcy97ZGF0YWJhc2VJZH0vY29sbGVjdGlvbnMve2NvbGxlY3Rpb25JZH0vaW5kZXhlcycucmVwbGFjZSgne2RhdGFiYXNlSWR9JywgZGF0YWJhc2VJZCkucmVwbGFjZSgne2NvbGxlY3Rpb25JZH0nLCBjb2xsZWN0aW9uSWQpO1xuICAgICAgICBsZXQgcGF5bG9hZCA9IHt9O1xuICAgICAgICBpZiAodHlwZW9mIGRhdGFiYXNlSWQgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgQXBwd3JpdGVFeGNlcHRpb24oJ01pc3NpbmcgcmVxdWlyZWQgcGFyYW1ldGVyOiBcImRhdGFiYXNlSWRcIicpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHR5cGVvZiBjb2xsZWN0aW9uSWQgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgQXBwd3JpdGVFeGNlcHRpb24oJ01pc3NpbmcgcmVxdWlyZWQgcGFyYW1ldGVyOiBcImNvbGxlY3Rpb25JZFwiJyk7XG4gICAgICAgIH1cblxuXG4gICAgICAgIGlmICh0eXBlb2YgcXVlcmllcyAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHBheWxvYWRbJ3F1ZXJpZXMnXSA9IHF1ZXJpZXM7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy5jbGllbnQuY2FsbCgnZ2V0JywgYXBpUGF0aCwge1xuICAgICAgICAgICAgJ2NvbnRlbnQtdHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJyxcbiAgICAgICAgfSwgcGF5bG9hZCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlIGluZGV4XG4gICAgICpcbiAgICAgKiBDcmVhdGVzIGFuIGluZGV4IG9uIHRoZSBhdHRyaWJ1dGVzIGxpc3RlZC4gWW91ciBpbmRleCBzaG91bGQgaW5jbHVkZSBhbGxcbiAgICAgKiB0aGUgYXR0cmlidXRlcyB5b3Ugd2lsbCBxdWVyeSBpbiBhIHNpbmdsZSByZXF1ZXN0LlxuICAgICAqIEF0dHJpYnV0ZXMgY2FuIGJlIGBrZXlgLCBgZnVsbHRleHRgLCBhbmQgYHVuaXF1ZWAuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gZGF0YWJhc2VJZFxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBjb2xsZWN0aW9uSWRcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30ga2V5XG4gICAgICogQHBhcmFtIHtJbmRleFR5cGV9IHR5cGVcbiAgICAgKiBAcGFyYW0ge3N0cmluZ1tdfSBhdHRyaWJ1dGVzXG4gICAgICogQHBhcmFtIHtzdHJpbmdbXX0gb3JkZXJzXG4gICAgICogQHRocm93cyB7QXBwd3JpdGVFeGNlcHRpb259XG4gICAgICogQHJldHVybnMge1Byb21pc2V9XG4gICAgICovXG4gICAgYXN5bmMgY3JlYXRlSW5kZXgoZGF0YWJhc2VJZCwgY29sbGVjdGlvbklkLCBrZXksIHR5cGUsIGF0dHJpYnV0ZXMsIG9yZGVycykge1xuICAgICAgICBjb25zdCBhcGlQYXRoID0gJy9kYXRhYmFzZXMve2RhdGFiYXNlSWR9L2NvbGxlY3Rpb25zL3tjb2xsZWN0aW9uSWR9L2luZGV4ZXMnLnJlcGxhY2UoJ3tkYXRhYmFzZUlkfScsIGRhdGFiYXNlSWQpLnJlcGxhY2UoJ3tjb2xsZWN0aW9uSWR9JywgY29sbGVjdGlvbklkKTtcbiAgICAgICAgbGV0IHBheWxvYWQgPSB7fTtcbiAgICAgICAgaWYgKHR5cGVvZiBkYXRhYmFzZUlkID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEFwcHdyaXRlRXhjZXB0aW9uKCdNaXNzaW5nIHJlcXVpcmVkIHBhcmFtZXRlcjogXCJkYXRhYmFzZUlkXCInKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0eXBlb2YgY29sbGVjdGlvbklkID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEFwcHdyaXRlRXhjZXB0aW9uKCdNaXNzaW5nIHJlcXVpcmVkIHBhcmFtZXRlcjogXCJjb2xsZWN0aW9uSWRcIicpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHR5cGVvZiBrZXkgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgQXBwd3JpdGVFeGNlcHRpb24oJ01pc3NpbmcgcmVxdWlyZWQgcGFyYW1ldGVyOiBcImtleVwiJyk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodHlwZW9mIHR5cGUgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgQXBwd3JpdGVFeGNlcHRpb24oJ01pc3NpbmcgcmVxdWlyZWQgcGFyYW1ldGVyOiBcInR5cGVcIicpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHR5cGVvZiBhdHRyaWJ1dGVzID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEFwcHdyaXRlRXhjZXB0aW9uKCdNaXNzaW5nIHJlcXVpcmVkIHBhcmFtZXRlcjogXCJhdHRyaWJ1dGVzXCInKTtcbiAgICAgICAgfVxuXG5cbiAgICAgICAgaWYgKHR5cGVvZiBrZXkgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICBwYXlsb2FkWydrZXknXSA9IGtleTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0eXBlb2YgdHlwZSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHBheWxvYWRbJ3R5cGUnXSA9IHR5cGU7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodHlwZW9mIGF0dHJpYnV0ZXMgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICBwYXlsb2FkWydhdHRyaWJ1dGVzJ10gPSBhdHRyaWJ1dGVzO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHR5cGVvZiBvcmRlcnMgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICBwYXlsb2FkWydvcmRlcnMnXSA9IG9yZGVycztcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBhd2FpdCB0aGlzLmNsaWVudC5jYWxsKCdwb3N0JywgYXBpUGF0aCwge1xuICAgICAgICAgICAgJ2NvbnRlbnQtdHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJyxcbiAgICAgICAgfSwgcGF5bG9hZCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2V0IGluZGV4XG4gICAgICpcbiAgICAgKiBHZXQgaW5kZXggYnkgSUQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gZGF0YWJhc2VJZFxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBjb2xsZWN0aW9uSWRcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30ga2V5XG4gICAgICogQHRocm93cyB7QXBwd3JpdGVFeGNlcHRpb259XG4gICAgICogQHJldHVybnMge1Byb21pc2V9XG4gICAgICovXG4gICAgYXN5bmMgZ2V0SW5kZXgoZGF0YWJhc2VJZCwgY29sbGVjdGlvbklkLCBrZXkpIHtcbiAgICAgICAgY29uc3QgYXBpUGF0aCA9ICcvZGF0YWJhc2VzL3tkYXRhYmFzZUlkfS9jb2xsZWN0aW9ucy97Y29sbGVjdGlvbklkfS9pbmRleGVzL3trZXl9Jy5yZXBsYWNlKCd7ZGF0YWJhc2VJZH0nLCBkYXRhYmFzZUlkKS5yZXBsYWNlKCd7Y29sbGVjdGlvbklkfScsIGNvbGxlY3Rpb25JZCkucmVwbGFjZSgne2tleX0nLCBrZXkpO1xuICAgICAgICBsZXQgcGF5bG9hZCA9IHt9O1xuICAgICAgICBpZiAodHlwZW9mIGRhdGFiYXNlSWQgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgQXBwd3JpdGVFeGNlcHRpb24oJ01pc3NpbmcgcmVxdWlyZWQgcGFyYW1ldGVyOiBcImRhdGFiYXNlSWRcIicpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHR5cGVvZiBjb2xsZWN0aW9uSWQgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgQXBwd3JpdGVFeGNlcHRpb24oJ01pc3NpbmcgcmVxdWlyZWQgcGFyYW1ldGVyOiBcImNvbGxlY3Rpb25JZFwiJyk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodHlwZW9mIGtleSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBBcHB3cml0ZUV4Y2VwdGlvbignTWlzc2luZyByZXF1aXJlZCBwYXJhbWV0ZXI6IFwia2V5XCInKTtcbiAgICAgICAgfVxuXG5cbiAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMuY2xpZW50LmNhbGwoJ2dldCcsIGFwaVBhdGgsIHtcbiAgICAgICAgICAgICdjb250ZW50LXR5cGUnOiAnYXBwbGljYXRpb24vanNvbicsXG4gICAgICAgIH0sIHBheWxvYWQpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIERlbGV0ZSBpbmRleFxuICAgICAqXG4gICAgICogRGVsZXRlIGFuIGluZGV4LlxuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGRhdGFiYXNlSWRcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gY29sbGVjdGlvbklkXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGtleVxuICAgICAqIEB0aHJvd3Mge0FwcHdyaXRlRXhjZXB0aW9ufVxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlfVxuICAgICAqL1xuICAgIGFzeW5jIGRlbGV0ZUluZGV4KGRhdGFiYXNlSWQsIGNvbGxlY3Rpb25JZCwga2V5KSB7XG4gICAgICAgIGNvbnN0IGFwaVBhdGggPSAnL2RhdGFiYXNlcy97ZGF0YWJhc2VJZH0vY29sbGVjdGlvbnMve2NvbGxlY3Rpb25JZH0vaW5kZXhlcy97a2V5fScucmVwbGFjZSgne2RhdGFiYXNlSWR9JywgZGF0YWJhc2VJZCkucmVwbGFjZSgne2NvbGxlY3Rpb25JZH0nLCBjb2xsZWN0aW9uSWQpLnJlcGxhY2UoJ3trZXl9Jywga2V5KTtcbiAgICAgICAgbGV0IHBheWxvYWQgPSB7fTtcbiAgICAgICAgaWYgKHR5cGVvZiBkYXRhYmFzZUlkID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEFwcHdyaXRlRXhjZXB0aW9uKCdNaXNzaW5nIHJlcXVpcmVkIHBhcmFtZXRlcjogXCJkYXRhYmFzZUlkXCInKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0eXBlb2YgY29sbGVjdGlvbklkID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEFwcHdyaXRlRXhjZXB0aW9uKCdNaXNzaW5nIHJlcXVpcmVkIHBhcmFtZXRlcjogXCJjb2xsZWN0aW9uSWRcIicpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHR5cGVvZiBrZXkgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgQXBwd3JpdGVFeGNlcHRpb24oJ01pc3NpbmcgcmVxdWlyZWQgcGFyYW1ldGVyOiBcImtleVwiJyk7XG4gICAgICAgIH1cblxuXG4gICAgICAgIHJldHVybiBhd2FpdCB0aGlzLmNsaWVudC5jYWxsKCdkZWxldGUnLCBhcGlQYXRoLCB7XG4gICAgICAgICAgICAnY29udGVudC10eXBlJzogJ2FwcGxpY2F0aW9uL2pzb24nLFxuICAgICAgICB9LCBwYXlsb2FkKTtcbiAgICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gRGF0YWJhc2VzO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(action-browser)/./node_modules/node-appwrite/lib/services/databases.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/node-appwrite/lib/services/databases.js":
/*!**************************************************************!*\
  !*** ./node_modules/node-appwrite/lib/services/databases.js ***!
  \**************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("const Service = __webpack_require__(/*! ../service.js */ \"(rsc)/./node_modules/node-appwrite/lib/service.js\");\nconst AppwriteException = __webpack_require__(/*! ../exception.js */ \"(rsc)/./node_modules/node-appwrite/lib/exception.js\");\nconst InputFile = __webpack_require__(/*! ../inputFile.js */ \"(rsc)/./node_modules/node-appwrite/lib/inputFile.js\");\nconst client = __webpack_require__(/*! ../client.js */ \"(rsc)/./node_modules/node-appwrite/lib/client.js\");\nconst Stream = __webpack_require__(/*! stream */ \"stream\");\nconst { promisify } = __webpack_require__(/*! util */ \"util\");\nconst fs = __webpack_require__(/*! fs */ \"fs\");\nconst { File } = __webpack_require__(/*! undici */ \"undici\");\nconst Query = __webpack_require__(/*! ../query.js */ \"(rsc)/./node_modules/node-appwrite/lib/query.js\");\n\nclass Databases extends Service {\n\n     constructor(client)\n     {\n        super(client);\n     }\n\n\n    /**\n     * List databases\n     *\n     * Get a list of all databases from the current Appwrite project. You can use\n     * the search parameter to filter your results.\n     *\n     * @param {string[]} queries\n     * @param {string} search\n     * @throws {AppwriteException}\n     * @returns {Promise}\n     */\n    async list(queries, search) {\n        const apiPath = '/databases';\n        let payload = {};\n\n        if (typeof queries !== 'undefined') {\n            payload['queries'] = queries;\n        }\n\n        if (typeof search !== 'undefined') {\n            payload['search'] = search;\n        }\n\n        return await this.client.call('get', apiPath, {\n            'content-type': 'application/json',\n        }, payload);\n    }\n\n    /**\n     * Create database\n     *\n     * Create a new Database.\n     * \n     *\n     * @param {string} databaseId\n     * @param {string} name\n     * @param {boolean} enabled\n     * @throws {AppwriteException}\n     * @returns {Promise}\n     */\n    async create(databaseId, name, enabled) {\n        const apiPath = '/databases';\n        let payload = {};\n        if (typeof databaseId === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"databaseId\"');\n        }\n\n        if (typeof name === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"name\"');\n        }\n\n\n        if (typeof databaseId !== 'undefined') {\n            payload['databaseId'] = databaseId;\n        }\n\n        if (typeof name !== 'undefined') {\n            payload['name'] = name;\n        }\n\n        if (typeof enabled !== 'undefined') {\n            payload['enabled'] = enabled;\n        }\n\n        return await this.client.call('post', apiPath, {\n            'content-type': 'application/json',\n        }, payload);\n    }\n\n    /**\n     * Get database\n     *\n     * Get a database by its unique ID. This endpoint response returns a JSON\n     * object with the database metadata.\n     *\n     * @param {string} databaseId\n     * @throws {AppwriteException}\n     * @returns {Promise}\n     */\n    async get(databaseId) {\n        const apiPath = '/databases/{databaseId}'.replace('{databaseId}', databaseId);\n        let payload = {};\n        if (typeof databaseId === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"databaseId\"');\n        }\n\n\n        return await this.client.call('get', apiPath, {\n            'content-type': 'application/json',\n        }, payload);\n    }\n\n    /**\n     * Update database\n     *\n     * Update a database by its unique ID.\n     *\n     * @param {string} databaseId\n     * @param {string} name\n     * @param {boolean} enabled\n     * @throws {AppwriteException}\n     * @returns {Promise}\n     */\n    async update(databaseId, name, enabled) {\n        const apiPath = '/databases/{databaseId}'.replace('{databaseId}', databaseId);\n        let payload = {};\n        if (typeof databaseId === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"databaseId\"');\n        }\n\n        if (typeof name === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"name\"');\n        }\n\n\n        if (typeof name !== 'undefined') {\n            payload['name'] = name;\n        }\n\n        if (typeof enabled !== 'undefined') {\n            payload['enabled'] = enabled;\n        }\n\n        return await this.client.call('put', apiPath, {\n            'content-type': 'application/json',\n        }, payload);\n    }\n\n    /**\n     * Delete database\n     *\n     * Delete a database by its unique ID. Only API keys with with databases.write\n     * scope can delete a database.\n     *\n     * @param {string} databaseId\n     * @throws {AppwriteException}\n     * @returns {Promise}\n     */\n    async delete(databaseId) {\n        const apiPath = '/databases/{databaseId}'.replace('{databaseId}', databaseId);\n        let payload = {};\n        if (typeof databaseId === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"databaseId\"');\n        }\n\n\n        return await this.client.call('delete', apiPath, {\n            'content-type': 'application/json',\n        }, payload);\n    }\n\n    /**\n     * List collections\n     *\n     * Get a list of all collections that belong to the provided databaseId. You\n     * can use the search parameter to filter your results.\n     *\n     * @param {string} databaseId\n     * @param {string[]} queries\n     * @param {string} search\n     * @throws {AppwriteException}\n     * @returns {Promise}\n     */\n    async listCollections(databaseId, queries, search) {\n        const apiPath = '/databases/{databaseId}/collections'.replace('{databaseId}', databaseId);\n        let payload = {};\n        if (typeof databaseId === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"databaseId\"');\n        }\n\n\n        if (typeof queries !== 'undefined') {\n            payload['queries'] = queries;\n        }\n\n        if (typeof search !== 'undefined') {\n            payload['search'] = search;\n        }\n\n        return await this.client.call('get', apiPath, {\n            'content-type': 'application/json',\n        }, payload);\n    }\n\n    /**\n     * Create collection\n     *\n     * Create a new Collection. Before using this route, you should create a new\n     * database resource using either a [server\n     * integration](https://appwrite.io/docs/server/databases#databasesCreateCollection)\n     * API or directly from your database console.\n     *\n     * @param {string} databaseId\n     * @param {string} collectionId\n     * @param {string} name\n     * @param {string[]} permissions\n     * @param {boolean} documentSecurity\n     * @param {boolean} enabled\n     * @throws {AppwriteException}\n     * @returns {Promise}\n     */\n    async createCollection(databaseId, collectionId, name, permissions, documentSecurity, enabled) {\n        const apiPath = '/databases/{databaseId}/collections'.replace('{databaseId}', databaseId);\n        let payload = {};\n        if (typeof databaseId === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"databaseId\"');\n        }\n\n        if (typeof collectionId === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"collectionId\"');\n        }\n\n        if (typeof name === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"name\"');\n        }\n\n\n        if (typeof collectionId !== 'undefined') {\n            payload['collectionId'] = collectionId;\n        }\n\n        if (typeof name !== 'undefined') {\n            payload['name'] = name;\n        }\n\n        if (typeof permissions !== 'undefined') {\n            payload['permissions'] = permissions;\n        }\n\n        if (typeof documentSecurity !== 'undefined') {\n            payload['documentSecurity'] = documentSecurity;\n        }\n\n        if (typeof enabled !== 'undefined') {\n            payload['enabled'] = enabled;\n        }\n\n        return await this.client.call('post', apiPath, {\n            'content-type': 'application/json',\n        }, payload);\n    }\n\n    /**\n     * Get collection\n     *\n     * Get a collection by its unique ID. This endpoint response returns a JSON\n     * object with the collection metadata.\n     *\n     * @param {string} databaseId\n     * @param {string} collectionId\n     * @throws {AppwriteException}\n     * @returns {Promise}\n     */\n    async getCollection(databaseId, collectionId) {\n        const apiPath = '/databases/{databaseId}/collections/{collectionId}'.replace('{databaseId}', databaseId).replace('{collectionId}', collectionId);\n        let payload = {};\n        if (typeof databaseId === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"databaseId\"');\n        }\n\n        if (typeof collectionId === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"collectionId\"');\n        }\n\n\n        return await this.client.call('get', apiPath, {\n            'content-type': 'application/json',\n        }, payload);\n    }\n\n    /**\n     * Update collection\n     *\n     * Update a collection by its unique ID.\n     *\n     * @param {string} databaseId\n     * @param {string} collectionId\n     * @param {string} name\n     * @param {string[]} permissions\n     * @param {boolean} documentSecurity\n     * @param {boolean} enabled\n     * @throws {AppwriteException}\n     * @returns {Promise}\n     */\n    async updateCollection(databaseId, collectionId, name, permissions, documentSecurity, enabled) {\n        const apiPath = '/databases/{databaseId}/collections/{collectionId}'.replace('{databaseId}', databaseId).replace('{collectionId}', collectionId);\n        let payload = {};\n        if (typeof databaseId === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"databaseId\"');\n        }\n\n        if (typeof collectionId === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"collectionId\"');\n        }\n\n        if (typeof name === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"name\"');\n        }\n\n\n        if (typeof name !== 'undefined') {\n            payload['name'] = name;\n        }\n\n        if (typeof permissions !== 'undefined') {\n            payload['permissions'] = permissions;\n        }\n\n        if (typeof documentSecurity !== 'undefined') {\n            payload['documentSecurity'] = documentSecurity;\n        }\n\n        if (typeof enabled !== 'undefined') {\n            payload['enabled'] = enabled;\n        }\n\n        return await this.client.call('put', apiPath, {\n            'content-type': 'application/json',\n        }, payload);\n    }\n\n    /**\n     * Delete collection\n     *\n     * Delete a collection by its unique ID. Only users with write permissions\n     * have access to delete this resource.\n     *\n     * @param {string} databaseId\n     * @param {string} collectionId\n     * @throws {AppwriteException}\n     * @returns {Promise}\n     */\n    async deleteCollection(databaseId, collectionId) {\n        const apiPath = '/databases/{databaseId}/collections/{collectionId}'.replace('{databaseId}', databaseId).replace('{collectionId}', collectionId);\n        let payload = {};\n        if (typeof databaseId === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"databaseId\"');\n        }\n\n        if (typeof collectionId === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"collectionId\"');\n        }\n\n\n        return await this.client.call('delete', apiPath, {\n            'content-type': 'application/json',\n        }, payload);\n    }\n\n    /**\n     * List attributes\n     *\n     * List attributes in the collection.\n     *\n     * @param {string} databaseId\n     * @param {string} collectionId\n     * @param {string[]} queries\n     * @throws {AppwriteException}\n     * @returns {Promise}\n     */\n    async listAttributes(databaseId, collectionId, queries) {\n        const apiPath = '/databases/{databaseId}/collections/{collectionId}/attributes'.replace('{databaseId}', databaseId).replace('{collectionId}', collectionId);\n        let payload = {};\n        if (typeof databaseId === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"databaseId\"');\n        }\n\n        if (typeof collectionId === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"collectionId\"');\n        }\n\n\n        if (typeof queries !== 'undefined') {\n            payload['queries'] = queries;\n        }\n\n        return await this.client.call('get', apiPath, {\n            'content-type': 'application/json',\n        }, payload);\n    }\n\n    /**\n     * Create boolean attribute\n     *\n     * Create a boolean attribute.\n     * \n     *\n     * @param {string} databaseId\n     * @param {string} collectionId\n     * @param {string} key\n     * @param {boolean} required\n     * @param {boolean} xdefault\n     * @param {boolean} array\n     * @throws {AppwriteException}\n     * @returns {Promise}\n     */\n    async createBooleanAttribute(databaseId, collectionId, key, required, xdefault, array) {\n        const apiPath = '/databases/{databaseId}/collections/{collectionId}/attributes/boolean'.replace('{databaseId}', databaseId).replace('{collectionId}', collectionId);\n        let payload = {};\n        if (typeof databaseId === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"databaseId\"');\n        }\n\n        if (typeof collectionId === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"collectionId\"');\n        }\n\n        if (typeof key === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"key\"');\n        }\n\n        if (typeof required === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"required\"');\n        }\n\n\n        if (typeof key !== 'undefined') {\n            payload['key'] = key;\n        }\n\n        if (typeof required !== 'undefined') {\n            payload['required'] = required;\n        }\n\n        if (typeof xdefault !== 'undefined') {\n            payload['default'] = xdefault;\n        }\n\n        if (typeof array !== 'undefined') {\n            payload['array'] = array;\n        }\n\n        return await this.client.call('post', apiPath, {\n            'content-type': 'application/json',\n        }, payload);\n    }\n\n    /**\n     * Update boolean attribute\n     *\n     * Update a boolean attribute. Changing the `default` value will not update\n     * already existing documents.\n     *\n     * @param {string} databaseId\n     * @param {string} collectionId\n     * @param {string} key\n     * @param {boolean} required\n     * @param {boolean} xdefault\n     * @throws {AppwriteException}\n     * @returns {Promise}\n     */\n    async updateBooleanAttribute(databaseId, collectionId, key, required, xdefault) {\n        const apiPath = '/databases/{databaseId}/collections/{collectionId}/attributes/boolean/{key}'.replace('{databaseId}', databaseId).replace('{collectionId}', collectionId).replace('{key}', key);\n        let payload = {};\n        if (typeof databaseId === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"databaseId\"');\n        }\n\n        if (typeof collectionId === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"collectionId\"');\n        }\n\n        if (typeof key === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"key\"');\n        }\n\n        if (typeof required === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"required\"');\n        }\n\n        if (typeof xdefault === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"xdefault\"');\n        }\n\n\n        if (typeof required !== 'undefined') {\n            payload['required'] = required;\n        }\n\n        if (typeof xdefault !== 'undefined') {\n            payload['default'] = xdefault;\n        }\n\n        return await this.client.call('patch', apiPath, {\n            'content-type': 'application/json',\n        }, payload);\n    }\n\n    /**\n     * Create datetime attribute\n     *\n     * Create a date time attribute according to the ISO 8601 standard.\n     *\n     * @param {string} databaseId\n     * @param {string} collectionId\n     * @param {string} key\n     * @param {boolean} required\n     * @param {string} xdefault\n     * @param {boolean} array\n     * @throws {AppwriteException}\n     * @returns {Promise}\n     */\n    async createDatetimeAttribute(databaseId, collectionId, key, required, xdefault, array) {\n        const apiPath = '/databases/{databaseId}/collections/{collectionId}/attributes/datetime'.replace('{databaseId}', databaseId).replace('{collectionId}', collectionId);\n        let payload = {};\n        if (typeof databaseId === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"databaseId\"');\n        }\n\n        if (typeof collectionId === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"collectionId\"');\n        }\n\n        if (typeof key === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"key\"');\n        }\n\n        if (typeof required === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"required\"');\n        }\n\n\n        if (typeof key !== 'undefined') {\n            payload['key'] = key;\n        }\n\n        if (typeof required !== 'undefined') {\n            payload['required'] = required;\n        }\n\n        if (typeof xdefault !== 'undefined') {\n            payload['default'] = xdefault;\n        }\n\n        if (typeof array !== 'undefined') {\n            payload['array'] = array;\n        }\n\n        return await this.client.call('post', apiPath, {\n            'content-type': 'application/json',\n        }, payload);\n    }\n\n    /**\n     * Update dateTime attribute\n     *\n     * Update a date time attribute. Changing the `default` value will not update\n     * already existing documents.\n     *\n     * @param {string} databaseId\n     * @param {string} collectionId\n     * @param {string} key\n     * @param {boolean} required\n     * @param {string} xdefault\n     * @throws {AppwriteException}\n     * @returns {Promise}\n     */\n    async updateDatetimeAttribute(databaseId, collectionId, key, required, xdefault) {\n        const apiPath = '/databases/{databaseId}/collections/{collectionId}/attributes/datetime/{key}'.replace('{databaseId}', databaseId).replace('{collectionId}', collectionId).replace('{key}', key);\n        let payload = {};\n        if (typeof databaseId === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"databaseId\"');\n        }\n\n        if (typeof collectionId === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"collectionId\"');\n        }\n\n        if (typeof key === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"key\"');\n        }\n\n        if (typeof required === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"required\"');\n        }\n\n        if (typeof xdefault === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"xdefault\"');\n        }\n\n\n        if (typeof required !== 'undefined') {\n            payload['required'] = required;\n        }\n\n        if (typeof xdefault !== 'undefined') {\n            payload['default'] = xdefault;\n        }\n\n        return await this.client.call('patch', apiPath, {\n            'content-type': 'application/json',\n        }, payload);\n    }\n\n    /**\n     * Create email attribute\n     *\n     * Create an email attribute.\n     * \n     *\n     * @param {string} databaseId\n     * @param {string} collectionId\n     * @param {string} key\n     * @param {boolean} required\n     * @param {string} xdefault\n     * @param {boolean} array\n     * @throws {AppwriteException}\n     * @returns {Promise}\n     */\n    async createEmailAttribute(databaseId, collectionId, key, required, xdefault, array) {\n        const apiPath = '/databases/{databaseId}/collections/{collectionId}/attributes/email'.replace('{databaseId}', databaseId).replace('{collectionId}', collectionId);\n        let payload = {};\n        if (typeof databaseId === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"databaseId\"');\n        }\n\n        if (typeof collectionId === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"collectionId\"');\n        }\n\n        if (typeof key === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"key\"');\n        }\n\n        if (typeof required === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"required\"');\n        }\n\n\n        if (typeof key !== 'undefined') {\n            payload['key'] = key;\n        }\n\n        if (typeof required !== 'undefined') {\n            payload['required'] = required;\n        }\n\n        if (typeof xdefault !== 'undefined') {\n            payload['default'] = xdefault;\n        }\n\n        if (typeof array !== 'undefined') {\n            payload['array'] = array;\n        }\n\n        return await this.client.call('post', apiPath, {\n            'content-type': 'application/json',\n        }, payload);\n    }\n\n    /**\n     * Update email attribute\n     *\n     * Update an email attribute. Changing the `default` value will not update\n     * already existing documents.\n     * \n     *\n     * @param {string} databaseId\n     * @param {string} collectionId\n     * @param {string} key\n     * @param {boolean} required\n     * @param {string} xdefault\n     * @throws {AppwriteException}\n     * @returns {Promise}\n     */\n    async updateEmailAttribute(databaseId, collectionId, key, required, xdefault) {\n        const apiPath = '/databases/{databaseId}/collections/{collectionId}/attributes/email/{key}'.replace('{databaseId}', databaseId).replace('{collectionId}', collectionId).replace('{key}', key);\n        let payload = {};\n        if (typeof databaseId === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"databaseId\"');\n        }\n\n        if (typeof collectionId === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"collectionId\"');\n        }\n\n        if (typeof key === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"key\"');\n        }\n\n        if (typeof required === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"required\"');\n        }\n\n        if (typeof xdefault === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"xdefault\"');\n        }\n\n\n        if (typeof required !== 'undefined') {\n            payload['required'] = required;\n        }\n\n        if (typeof xdefault !== 'undefined') {\n            payload['default'] = xdefault;\n        }\n\n        return await this.client.call('patch', apiPath, {\n            'content-type': 'application/json',\n        }, payload);\n    }\n\n    /**\n     * Create enum attribute\n     *\n     * Create an enumeration attribute. The `elements` param acts as a white-list\n     * of accepted values for this attribute. \n     * \n     *\n     * @param {string} databaseId\n     * @param {string} collectionId\n     * @param {string} key\n     * @param {string[]} elements\n     * @param {boolean} required\n     * @param {string} xdefault\n     * @param {boolean} array\n     * @throws {AppwriteException}\n     * @returns {Promise}\n     */\n    async createEnumAttribute(databaseId, collectionId, key, elements, required, xdefault, array) {\n        const apiPath = '/databases/{databaseId}/collections/{collectionId}/attributes/enum'.replace('{databaseId}', databaseId).replace('{collectionId}', collectionId);\n        let payload = {};\n        if (typeof databaseId === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"databaseId\"');\n        }\n\n        if (typeof collectionId === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"collectionId\"');\n        }\n\n        if (typeof key === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"key\"');\n        }\n\n        if (typeof elements === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"elements\"');\n        }\n\n        if (typeof required === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"required\"');\n        }\n\n\n        if (typeof key !== 'undefined') {\n            payload['key'] = key;\n        }\n\n        if (typeof elements !== 'undefined') {\n            payload['elements'] = elements;\n        }\n\n        if (typeof required !== 'undefined') {\n            payload['required'] = required;\n        }\n\n        if (typeof xdefault !== 'undefined') {\n            payload['default'] = xdefault;\n        }\n\n        if (typeof array !== 'undefined') {\n            payload['array'] = array;\n        }\n\n        return await this.client.call('post', apiPath, {\n            'content-type': 'application/json',\n        }, payload);\n    }\n\n    /**\n     * Update enum attribute\n     *\n     * Update an enum attribute. Changing the `default` value will not update\n     * already existing documents.\n     * \n     *\n     * @param {string} databaseId\n     * @param {string} collectionId\n     * @param {string} key\n     * @param {string[]} elements\n     * @param {boolean} required\n     * @param {string} xdefault\n     * @throws {AppwriteException}\n     * @returns {Promise}\n     */\n    async updateEnumAttribute(databaseId, collectionId, key, elements, required, xdefault) {\n        const apiPath = '/databases/{databaseId}/collections/{collectionId}/attributes/enum/{key}'.replace('{databaseId}', databaseId).replace('{collectionId}', collectionId).replace('{key}', key);\n        let payload = {};\n        if (typeof databaseId === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"databaseId\"');\n        }\n\n        if (typeof collectionId === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"collectionId\"');\n        }\n\n        if (typeof key === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"key\"');\n        }\n\n        if (typeof elements === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"elements\"');\n        }\n\n        if (typeof required === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"required\"');\n        }\n\n        if (typeof xdefault === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"xdefault\"');\n        }\n\n\n        if (typeof elements !== 'undefined') {\n            payload['elements'] = elements;\n        }\n\n        if (typeof required !== 'undefined') {\n            payload['required'] = required;\n        }\n\n        if (typeof xdefault !== 'undefined') {\n            payload['default'] = xdefault;\n        }\n\n        return await this.client.call('patch', apiPath, {\n            'content-type': 'application/json',\n        }, payload);\n    }\n\n    /**\n     * Create float attribute\n     *\n     * Create a float attribute. Optionally, minimum and maximum values can be\n     * provided.\n     * \n     *\n     * @param {string} databaseId\n     * @param {string} collectionId\n     * @param {string} key\n     * @param {boolean} required\n     * @param {number} min\n     * @param {number} max\n     * @param {number} xdefault\n     * @param {boolean} array\n     * @throws {AppwriteException}\n     * @returns {Promise}\n     */\n    async createFloatAttribute(databaseId, collectionId, key, required, min, max, xdefault, array) {\n        const apiPath = '/databases/{databaseId}/collections/{collectionId}/attributes/float'.replace('{databaseId}', databaseId).replace('{collectionId}', collectionId);\n        let payload = {};\n        if (typeof databaseId === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"databaseId\"');\n        }\n\n        if (typeof collectionId === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"collectionId\"');\n        }\n\n        if (typeof key === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"key\"');\n        }\n\n        if (typeof required === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"required\"');\n        }\n\n\n        if (typeof key !== 'undefined') {\n            payload['key'] = key;\n        }\n\n        if (typeof required !== 'undefined') {\n            payload['required'] = required;\n        }\n\n        if (typeof min !== 'undefined') {\n            payload['min'] = min;\n        }\n\n        if (typeof max !== 'undefined') {\n            payload['max'] = max;\n        }\n\n        if (typeof xdefault !== 'undefined') {\n            payload['default'] = xdefault;\n        }\n\n        if (typeof array !== 'undefined') {\n            payload['array'] = array;\n        }\n\n        return await this.client.call('post', apiPath, {\n            'content-type': 'application/json',\n        }, payload);\n    }\n\n    /**\n     * Update float attribute\n     *\n     * Update a float attribute. Changing the `default` value will not update\n     * already existing documents.\n     * \n     *\n     * @param {string} databaseId\n     * @param {string} collectionId\n     * @param {string} key\n     * @param {boolean} required\n     * @param {number} min\n     * @param {number} max\n     * @param {number} xdefault\n     * @throws {AppwriteException}\n     * @returns {Promise}\n     */\n    async updateFloatAttribute(databaseId, collectionId, key, required, min, max, xdefault) {\n        const apiPath = '/databases/{databaseId}/collections/{collectionId}/attributes/float/{key}'.replace('{databaseId}', databaseId).replace('{collectionId}', collectionId).replace('{key}', key);\n        let payload = {};\n        if (typeof databaseId === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"databaseId\"');\n        }\n\n        if (typeof collectionId === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"collectionId\"');\n        }\n\n        if (typeof key === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"key\"');\n        }\n\n        if (typeof required === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"required\"');\n        }\n\n        if (typeof min === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"min\"');\n        }\n\n        if (typeof max === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"max\"');\n        }\n\n        if (typeof xdefault === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"xdefault\"');\n        }\n\n\n        if (typeof required !== 'undefined') {\n            payload['required'] = required;\n        }\n\n        if (typeof min !== 'undefined') {\n            payload['min'] = min;\n        }\n\n        if (typeof max !== 'undefined') {\n            payload['max'] = max;\n        }\n\n        if (typeof xdefault !== 'undefined') {\n            payload['default'] = xdefault;\n        }\n\n        return await this.client.call('patch', apiPath, {\n            'content-type': 'application/json',\n        }, payload);\n    }\n\n    /**\n     * Create integer attribute\n     *\n     * Create an integer attribute. Optionally, minimum and maximum values can be\n     * provided.\n     * \n     *\n     * @param {string} databaseId\n     * @param {string} collectionId\n     * @param {string} key\n     * @param {boolean} required\n     * @param {number} min\n     * @param {number} max\n     * @param {number} xdefault\n     * @param {boolean} array\n     * @throws {AppwriteException}\n     * @returns {Promise}\n     */\n    async createIntegerAttribute(databaseId, collectionId, key, required, min, max, xdefault, array) {\n        const apiPath = '/databases/{databaseId}/collections/{collectionId}/attributes/integer'.replace('{databaseId}', databaseId).replace('{collectionId}', collectionId);\n        let payload = {};\n        if (typeof databaseId === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"databaseId\"');\n        }\n\n        if (typeof collectionId === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"collectionId\"');\n        }\n\n        if (typeof key === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"key\"');\n        }\n\n        if (typeof required === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"required\"');\n        }\n\n\n        if (typeof key !== 'undefined') {\n            payload['key'] = key;\n        }\n\n        if (typeof required !== 'undefined') {\n            payload['required'] = required;\n        }\n\n        if (typeof min !== 'undefined') {\n            payload['min'] = min;\n        }\n\n        if (typeof max !== 'undefined') {\n            payload['max'] = max;\n        }\n\n        if (typeof xdefault !== 'undefined') {\n            payload['default'] = xdefault;\n        }\n\n        if (typeof array !== 'undefined') {\n            payload['array'] = array;\n        }\n\n        return await this.client.call('post', apiPath, {\n            'content-type': 'application/json',\n        }, payload);\n    }\n\n    /**\n     * Update integer attribute\n     *\n     * Update an integer attribute. Changing the `default` value will not update\n     * already existing documents.\n     * \n     *\n     * @param {string} databaseId\n     * @param {string} collectionId\n     * @param {string} key\n     * @param {boolean} required\n     * @param {number} min\n     * @param {number} max\n     * @param {number} xdefault\n     * @throws {AppwriteException}\n     * @returns {Promise}\n     */\n    async updateIntegerAttribute(databaseId, collectionId, key, required, min, max, xdefault) {\n        const apiPath = '/databases/{databaseId}/collections/{collectionId}/attributes/integer/{key}'.replace('{databaseId}', databaseId).replace('{collectionId}', collectionId).replace('{key}', key);\n        let payload = {};\n        if (typeof databaseId === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"databaseId\"');\n        }\n\n        if (typeof collectionId === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"collectionId\"');\n        }\n\n        if (typeof key === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"key\"');\n        }\n\n        if (typeof required === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"required\"');\n        }\n\n        if (typeof min === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"min\"');\n        }\n\n        if (typeof max === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"max\"');\n        }\n\n        if (typeof xdefault === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"xdefault\"');\n        }\n\n\n        if (typeof required !== 'undefined') {\n            payload['required'] = required;\n        }\n\n        if (typeof min !== 'undefined') {\n            payload['min'] = min;\n        }\n\n        if (typeof max !== 'undefined') {\n            payload['max'] = max;\n        }\n\n        if (typeof xdefault !== 'undefined') {\n            payload['default'] = xdefault;\n        }\n\n        return await this.client.call('patch', apiPath, {\n            'content-type': 'application/json',\n        }, payload);\n    }\n\n    /**\n     * Create IP address attribute\n     *\n     * Create IP address attribute.\n     * \n     *\n     * @param {string} databaseId\n     * @param {string} collectionId\n     * @param {string} key\n     * @param {boolean} required\n     * @param {string} xdefault\n     * @param {boolean} array\n     * @throws {AppwriteException}\n     * @returns {Promise}\n     */\n    async createIpAttribute(databaseId, collectionId, key, required, xdefault, array) {\n        const apiPath = '/databases/{databaseId}/collections/{collectionId}/attributes/ip'.replace('{databaseId}', databaseId).replace('{collectionId}', collectionId);\n        let payload = {};\n        if (typeof databaseId === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"databaseId\"');\n        }\n\n        if (typeof collectionId === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"collectionId\"');\n        }\n\n        if (typeof key === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"key\"');\n        }\n\n        if (typeof required === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"required\"');\n        }\n\n\n        if (typeof key !== 'undefined') {\n            payload['key'] = key;\n        }\n\n        if (typeof required !== 'undefined') {\n            payload['required'] = required;\n        }\n\n        if (typeof xdefault !== 'undefined') {\n            payload['default'] = xdefault;\n        }\n\n        if (typeof array !== 'undefined') {\n            payload['array'] = array;\n        }\n\n        return await this.client.call('post', apiPath, {\n            'content-type': 'application/json',\n        }, payload);\n    }\n\n    /**\n     * Update IP address attribute\n     *\n     * Update an ip attribute. Changing the `default` value will not update\n     * already existing documents.\n     * \n     *\n     * @param {string} databaseId\n     * @param {string} collectionId\n     * @param {string} key\n     * @param {boolean} required\n     * @param {string} xdefault\n     * @throws {AppwriteException}\n     * @returns {Promise}\n     */\n    async updateIpAttribute(databaseId, collectionId, key, required, xdefault) {\n        const apiPath = '/databases/{databaseId}/collections/{collectionId}/attributes/ip/{key}'.replace('{databaseId}', databaseId).replace('{collectionId}', collectionId).replace('{key}', key);\n        let payload = {};\n        if (typeof databaseId === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"databaseId\"');\n        }\n\n        if (typeof collectionId === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"collectionId\"');\n        }\n\n        if (typeof key === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"key\"');\n        }\n\n        if (typeof required === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"required\"');\n        }\n\n        if (typeof xdefault === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"xdefault\"');\n        }\n\n\n        if (typeof required !== 'undefined') {\n            payload['required'] = required;\n        }\n\n        if (typeof xdefault !== 'undefined') {\n            payload['default'] = xdefault;\n        }\n\n        return await this.client.call('patch', apiPath, {\n            'content-type': 'application/json',\n        }, payload);\n    }\n\n    /**\n     * Create relationship attribute\n     *\n     * Create relationship attribute. [Learn more about relationship\n     * attributes](https://appwrite.io/docs/databases-relationships#relationship-attributes).\n     * \n     *\n     * @param {string} databaseId\n     * @param {string} collectionId\n     * @param {string} relatedCollectionId\n     * @param {RelationshipType} type\n     * @param {boolean} twoWay\n     * @param {string} key\n     * @param {string} twoWayKey\n     * @param {RelationMutate} onDelete\n     * @throws {AppwriteException}\n     * @returns {Promise}\n     */\n    async createRelationshipAttribute(databaseId, collectionId, relatedCollectionId, type, twoWay, key, twoWayKey, onDelete) {\n        const apiPath = '/databases/{databaseId}/collections/{collectionId}/attributes/relationship'.replace('{databaseId}', databaseId).replace('{collectionId}', collectionId);\n        let payload = {};\n        if (typeof databaseId === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"databaseId\"');\n        }\n\n        if (typeof collectionId === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"collectionId\"');\n        }\n\n        if (typeof relatedCollectionId === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"relatedCollectionId\"');\n        }\n\n        if (typeof type === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"type\"');\n        }\n\n\n        if (typeof relatedCollectionId !== 'undefined') {\n            payload['relatedCollectionId'] = relatedCollectionId;\n        }\n\n        if (typeof type !== 'undefined') {\n            payload['type'] = type;\n        }\n\n        if (typeof twoWay !== 'undefined') {\n            payload['twoWay'] = twoWay;\n        }\n\n        if (typeof key !== 'undefined') {\n            payload['key'] = key;\n        }\n\n        if (typeof twoWayKey !== 'undefined') {\n            payload['twoWayKey'] = twoWayKey;\n        }\n\n        if (typeof onDelete !== 'undefined') {\n            payload['onDelete'] = onDelete;\n        }\n\n        return await this.client.call('post', apiPath, {\n            'content-type': 'application/json',\n        }, payload);\n    }\n\n    /**\n     * Create string attribute\n     *\n     * Create a string attribute.\n     * \n     *\n     * @param {string} databaseId\n     * @param {string} collectionId\n     * @param {string} key\n     * @param {number} size\n     * @param {boolean} required\n     * @param {string} xdefault\n     * @param {boolean} array\n     * @param {boolean} encrypt\n     * @throws {AppwriteException}\n     * @returns {Promise}\n     */\n    async createStringAttribute(databaseId, collectionId, key, size, required, xdefault, array, encrypt) {\n        const apiPath = '/databases/{databaseId}/collections/{collectionId}/attributes/string'.replace('{databaseId}', databaseId).replace('{collectionId}', collectionId);\n        let payload = {};\n        if (typeof databaseId === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"databaseId\"');\n        }\n\n        if (typeof collectionId === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"collectionId\"');\n        }\n\n        if (typeof key === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"key\"');\n        }\n\n        if (typeof size === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"size\"');\n        }\n\n        if (typeof required === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"required\"');\n        }\n\n\n        if (typeof key !== 'undefined') {\n            payload['key'] = key;\n        }\n\n        if (typeof size !== 'undefined') {\n            payload['size'] = size;\n        }\n\n        if (typeof required !== 'undefined') {\n            payload['required'] = required;\n        }\n\n        if (typeof xdefault !== 'undefined') {\n            payload['default'] = xdefault;\n        }\n\n        if (typeof array !== 'undefined') {\n            payload['array'] = array;\n        }\n\n        if (typeof encrypt !== 'undefined') {\n            payload['encrypt'] = encrypt;\n        }\n\n        return await this.client.call('post', apiPath, {\n            'content-type': 'application/json',\n        }, payload);\n    }\n\n    /**\n     * Update string attribute\n     *\n     * Update a string attribute. Changing the `default` value will not update\n     * already existing documents.\n     * \n     *\n     * @param {string} databaseId\n     * @param {string} collectionId\n     * @param {string} key\n     * @param {boolean} required\n     * @param {string} xdefault\n     * @throws {AppwriteException}\n     * @returns {Promise}\n     */\n    async updateStringAttribute(databaseId, collectionId, key, required, xdefault) {\n        const apiPath = '/databases/{databaseId}/collections/{collectionId}/attributes/string/{key}'.replace('{databaseId}', databaseId).replace('{collectionId}', collectionId).replace('{key}', key);\n        let payload = {};\n        if (typeof databaseId === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"databaseId\"');\n        }\n\n        if (typeof collectionId === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"collectionId\"');\n        }\n\n        if (typeof key === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"key\"');\n        }\n\n        if (typeof required === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"required\"');\n        }\n\n        if (typeof xdefault === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"xdefault\"');\n        }\n\n\n        if (typeof required !== 'undefined') {\n            payload['required'] = required;\n        }\n\n        if (typeof xdefault !== 'undefined') {\n            payload['default'] = xdefault;\n        }\n\n        return await this.client.call('patch', apiPath, {\n            'content-type': 'application/json',\n        }, payload);\n    }\n\n    /**\n     * Create URL attribute\n     *\n     * Create a URL attribute.\n     * \n     *\n     * @param {string} databaseId\n     * @param {string} collectionId\n     * @param {string} key\n     * @param {boolean} required\n     * @param {string} xdefault\n     * @param {boolean} array\n     * @throws {AppwriteException}\n     * @returns {Promise}\n     */\n    async createUrlAttribute(databaseId, collectionId, key, required, xdefault, array) {\n        const apiPath = '/databases/{databaseId}/collections/{collectionId}/attributes/url'.replace('{databaseId}', databaseId).replace('{collectionId}', collectionId);\n        let payload = {};\n        if (typeof databaseId === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"databaseId\"');\n        }\n\n        if (typeof collectionId === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"collectionId\"');\n        }\n\n        if (typeof key === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"key\"');\n        }\n\n        if (typeof required === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"required\"');\n        }\n\n\n        if (typeof key !== 'undefined') {\n            payload['key'] = key;\n        }\n\n        if (typeof required !== 'undefined') {\n            payload['required'] = required;\n        }\n\n        if (typeof xdefault !== 'undefined') {\n            payload['default'] = xdefault;\n        }\n\n        if (typeof array !== 'undefined') {\n            payload['array'] = array;\n        }\n\n        return await this.client.call('post', apiPath, {\n            'content-type': 'application/json',\n        }, payload);\n    }\n\n    /**\n     * Update URL attribute\n     *\n     * Update an url attribute. Changing the `default` value will not update\n     * already existing documents.\n     * \n     *\n     * @param {string} databaseId\n     * @param {string} collectionId\n     * @param {string} key\n     * @param {boolean} required\n     * @param {string} xdefault\n     * @throws {AppwriteException}\n     * @returns {Promise}\n     */\n    async updateUrlAttribute(databaseId, collectionId, key, required, xdefault) {\n        const apiPath = '/databases/{databaseId}/collections/{collectionId}/attributes/url/{key}'.replace('{databaseId}', databaseId).replace('{collectionId}', collectionId).replace('{key}', key);\n        let payload = {};\n        if (typeof databaseId === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"databaseId\"');\n        }\n\n        if (typeof collectionId === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"collectionId\"');\n        }\n\n        if (typeof key === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"key\"');\n        }\n\n        if (typeof required === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"required\"');\n        }\n\n        if (typeof xdefault === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"xdefault\"');\n        }\n\n\n        if (typeof required !== 'undefined') {\n            payload['required'] = required;\n        }\n\n        if (typeof xdefault !== 'undefined') {\n            payload['default'] = xdefault;\n        }\n\n        return await this.client.call('patch', apiPath, {\n            'content-type': 'application/json',\n        }, payload);\n    }\n\n    /**\n     * Get attribute\n     *\n     * Get attribute by ID.\n     *\n     * @param {string} databaseId\n     * @param {string} collectionId\n     * @param {string} key\n     * @throws {AppwriteException}\n     * @returns {Promise}\n     */\n    async getAttribute(databaseId, collectionId, key) {\n        const apiPath = '/databases/{databaseId}/collections/{collectionId}/attributes/{key}'.replace('{databaseId}', databaseId).replace('{collectionId}', collectionId).replace('{key}', key);\n        let payload = {};\n        if (typeof databaseId === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"databaseId\"');\n        }\n\n        if (typeof collectionId === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"collectionId\"');\n        }\n\n        if (typeof key === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"key\"');\n        }\n\n\n        return await this.client.call('get', apiPath, {\n            'content-type': 'application/json',\n        }, payload);\n    }\n\n    /**\n     * Delete attribute\n     *\n     * Deletes an attribute.\n     *\n     * @param {string} databaseId\n     * @param {string} collectionId\n     * @param {string} key\n     * @throws {AppwriteException}\n     * @returns {Promise}\n     */\n    async deleteAttribute(databaseId, collectionId, key) {\n        const apiPath = '/databases/{databaseId}/collections/{collectionId}/attributes/{key}'.replace('{databaseId}', databaseId).replace('{collectionId}', collectionId).replace('{key}', key);\n        let payload = {};\n        if (typeof databaseId === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"databaseId\"');\n        }\n\n        if (typeof collectionId === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"collectionId\"');\n        }\n\n        if (typeof key === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"key\"');\n        }\n\n\n        return await this.client.call('delete', apiPath, {\n            'content-type': 'application/json',\n        }, payload);\n    }\n\n    /**\n     * Update relationship attribute\n     *\n     * Update relationship attribute. [Learn more about relationship\n     * attributes](https://appwrite.io/docs/databases-relationships#relationship-attributes).\n     * \n     *\n     * @param {string} databaseId\n     * @param {string} collectionId\n     * @param {string} key\n     * @param {RelationMutate} onDelete\n     * @throws {AppwriteException}\n     * @returns {Promise}\n     */\n    async updateRelationshipAttribute(databaseId, collectionId, key, onDelete) {\n        const apiPath = '/databases/{databaseId}/collections/{collectionId}/attributes/{key}/relationship'.replace('{databaseId}', databaseId).replace('{collectionId}', collectionId).replace('{key}', key);\n        let payload = {};\n        if (typeof databaseId === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"databaseId\"');\n        }\n\n        if (typeof collectionId === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"collectionId\"');\n        }\n\n        if (typeof key === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"key\"');\n        }\n\n\n        if (typeof onDelete !== 'undefined') {\n            payload['onDelete'] = onDelete;\n        }\n\n        return await this.client.call('patch', apiPath, {\n            'content-type': 'application/json',\n        }, payload);\n    }\n\n    /**\n     * List documents\n     *\n     * Get a list of all the user's documents in a given collection. You can use\n     * the query params to filter your results.\n     *\n     * @param {string} databaseId\n     * @param {string} collectionId\n     * @param {string[]} queries\n     * @throws {AppwriteException}\n     * @returns {Promise}\n     */\n    async listDocuments(databaseId, collectionId, queries) {\n        const apiPath = '/databases/{databaseId}/collections/{collectionId}/documents'.replace('{databaseId}', databaseId).replace('{collectionId}', collectionId);\n        let payload = {};\n        if (typeof databaseId === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"databaseId\"');\n        }\n\n        if (typeof collectionId === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"collectionId\"');\n        }\n\n\n        if (typeof queries !== 'undefined') {\n            payload['queries'] = queries;\n        }\n\n        return await this.client.call('get', apiPath, {\n            'content-type': 'application/json',\n        }, payload);\n    }\n\n    /**\n     * Create document\n     *\n     * Create a new Document. Before using this route, you should create a new\n     * collection resource using either a [server\n     * integration](https://appwrite.io/docs/server/databases#databasesCreateCollection)\n     * API or directly from your database console.\n     *\n     * @param {string} databaseId\n     * @param {string} collectionId\n     * @param {string} documentId\n     * @param {object} data\n     * @param {string[]} permissions\n     * @throws {AppwriteException}\n     * @returns {Promise}\n     */\n    async createDocument(databaseId, collectionId, documentId, data, permissions) {\n        const apiPath = '/databases/{databaseId}/collections/{collectionId}/documents'.replace('{databaseId}', databaseId).replace('{collectionId}', collectionId);\n        let payload = {};\n        if (typeof databaseId === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"databaseId\"');\n        }\n\n        if (typeof collectionId === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"collectionId\"');\n        }\n\n        if (typeof documentId === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"documentId\"');\n        }\n\n        if (typeof data === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"data\"');\n        }\n\n\n        if (typeof documentId !== 'undefined') {\n            payload['documentId'] = documentId;\n        }\n\n        if (typeof data !== 'undefined') {\n            payload['data'] = data;\n        }\n\n        if (typeof permissions !== 'undefined') {\n            payload['permissions'] = permissions;\n        }\n\n        return await this.client.call('post', apiPath, {\n            'content-type': 'application/json',\n        }, payload);\n    }\n\n    /**\n     * Get document\n     *\n     * Get a document by its unique ID. This endpoint response returns a JSON\n     * object with the document data.\n     *\n     * @param {string} databaseId\n     * @param {string} collectionId\n     * @param {string} documentId\n     * @param {string[]} queries\n     * @throws {AppwriteException}\n     * @returns {Promise}\n     */\n    async getDocument(databaseId, collectionId, documentId, queries) {\n        const apiPath = '/databases/{databaseId}/collections/{collectionId}/documents/{documentId}'.replace('{databaseId}', databaseId).replace('{collectionId}', collectionId).replace('{documentId}', documentId);\n        let payload = {};\n        if (typeof databaseId === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"databaseId\"');\n        }\n\n        if (typeof collectionId === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"collectionId\"');\n        }\n\n        if (typeof documentId === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"documentId\"');\n        }\n\n\n        if (typeof queries !== 'undefined') {\n            payload['queries'] = queries;\n        }\n\n        return await this.client.call('get', apiPath, {\n            'content-type': 'application/json',\n        }, payload);\n    }\n\n    /**\n     * Update document\n     *\n     * Update a document by its unique ID. Using the patch method you can pass\n     * only specific fields that will get updated.\n     *\n     * @param {string} databaseId\n     * @param {string} collectionId\n     * @param {string} documentId\n     * @param {object} data\n     * @param {string[]} permissions\n     * @throws {AppwriteException}\n     * @returns {Promise}\n     */\n    async updateDocument(databaseId, collectionId, documentId, data, permissions) {\n        const apiPath = '/databases/{databaseId}/collections/{collectionId}/documents/{documentId}'.replace('{databaseId}', databaseId).replace('{collectionId}', collectionId).replace('{documentId}', documentId);\n        let payload = {};\n        if (typeof databaseId === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"databaseId\"');\n        }\n\n        if (typeof collectionId === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"collectionId\"');\n        }\n\n        if (typeof documentId === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"documentId\"');\n        }\n\n\n        if (typeof data !== 'undefined') {\n            payload['data'] = data;\n        }\n\n        if (typeof permissions !== 'undefined') {\n            payload['permissions'] = permissions;\n        }\n\n        return await this.client.call('patch', apiPath, {\n            'content-type': 'application/json',\n        }, payload);\n    }\n\n    /**\n     * Delete document\n     *\n     * Delete a document by its unique ID.\n     *\n     * @param {string} databaseId\n     * @param {string} collectionId\n     * @param {string} documentId\n     * @throws {AppwriteException}\n     * @returns {Promise}\n     */\n    async deleteDocument(databaseId, collectionId, documentId) {\n        const apiPath = '/databases/{databaseId}/collections/{collectionId}/documents/{documentId}'.replace('{databaseId}', databaseId).replace('{collectionId}', collectionId).replace('{documentId}', documentId);\n        let payload = {};\n        if (typeof databaseId === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"databaseId\"');\n        }\n\n        if (typeof collectionId === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"collectionId\"');\n        }\n\n        if (typeof documentId === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"documentId\"');\n        }\n\n\n        return await this.client.call('delete', apiPath, {\n            'content-type': 'application/json',\n        }, payload);\n    }\n\n    /**\n     * List indexes\n     *\n     * List indexes in the collection.\n     *\n     * @param {string} databaseId\n     * @param {string} collectionId\n     * @param {string[]} queries\n     * @throws {AppwriteException}\n     * @returns {Promise}\n     */\n    async listIndexes(databaseId, collectionId, queries) {\n        const apiPath = '/databases/{databaseId}/collections/{collectionId}/indexes'.replace('{databaseId}', databaseId).replace('{collectionId}', collectionId);\n        let payload = {};\n        if (typeof databaseId === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"databaseId\"');\n        }\n\n        if (typeof collectionId === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"collectionId\"');\n        }\n\n\n        if (typeof queries !== 'undefined') {\n            payload['queries'] = queries;\n        }\n\n        return await this.client.call('get', apiPath, {\n            'content-type': 'application/json',\n        }, payload);\n    }\n\n    /**\n     * Create index\n     *\n     * Creates an index on the attributes listed. Your index should include all\n     * the attributes you will query in a single request.\n     * Attributes can be `key`, `fulltext`, and `unique`.\n     *\n     * @param {string} databaseId\n     * @param {string} collectionId\n     * @param {string} key\n     * @param {IndexType} type\n     * @param {string[]} attributes\n     * @param {string[]} orders\n     * @throws {AppwriteException}\n     * @returns {Promise}\n     */\n    async createIndex(databaseId, collectionId, key, type, attributes, orders) {\n        const apiPath = '/databases/{databaseId}/collections/{collectionId}/indexes'.replace('{databaseId}', databaseId).replace('{collectionId}', collectionId);\n        let payload = {};\n        if (typeof databaseId === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"databaseId\"');\n        }\n\n        if (typeof collectionId === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"collectionId\"');\n        }\n\n        if (typeof key === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"key\"');\n        }\n\n        if (typeof type === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"type\"');\n        }\n\n        if (typeof attributes === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"attributes\"');\n        }\n\n\n        if (typeof key !== 'undefined') {\n            payload['key'] = key;\n        }\n\n        if (typeof type !== 'undefined') {\n            payload['type'] = type;\n        }\n\n        if (typeof attributes !== 'undefined') {\n            payload['attributes'] = attributes;\n        }\n\n        if (typeof orders !== 'undefined') {\n            payload['orders'] = orders;\n        }\n\n        return await this.client.call('post', apiPath, {\n            'content-type': 'application/json',\n        }, payload);\n    }\n\n    /**\n     * Get index\n     *\n     * Get index by ID.\n     *\n     * @param {string} databaseId\n     * @param {string} collectionId\n     * @param {string} key\n     * @throws {AppwriteException}\n     * @returns {Promise}\n     */\n    async getIndex(databaseId, collectionId, key) {\n        const apiPath = '/databases/{databaseId}/collections/{collectionId}/indexes/{key}'.replace('{databaseId}', databaseId).replace('{collectionId}', collectionId).replace('{key}', key);\n        let payload = {};\n        if (typeof databaseId === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"databaseId\"');\n        }\n\n        if (typeof collectionId === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"collectionId\"');\n        }\n\n        if (typeof key === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"key\"');\n        }\n\n\n        return await this.client.call('get', apiPath, {\n            'content-type': 'application/json',\n        }, payload);\n    }\n\n    /**\n     * Delete index\n     *\n     * Delete an index.\n     *\n     * @param {string} databaseId\n     * @param {string} collectionId\n     * @param {string} key\n     * @throws {AppwriteException}\n     * @returns {Promise}\n     */\n    async deleteIndex(databaseId, collectionId, key) {\n        const apiPath = '/databases/{databaseId}/collections/{collectionId}/indexes/{key}'.replace('{databaseId}', databaseId).replace('{collectionId}', collectionId).replace('{key}', key);\n        let payload = {};\n        if (typeof databaseId === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"databaseId\"');\n        }\n\n        if (typeof collectionId === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"collectionId\"');\n        }\n\n        if (typeof key === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"key\"');\n        }\n\n\n        return await this.client.call('delete', apiPath, {\n            'content-type': 'application/json',\n        }, payload);\n    }\n}\n\nmodule.exports = Databases;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvbm9kZS1hcHB3cml0ZS9saWIvc2VydmljZXMvZGF0YWJhc2VzLmpzIiwibWFwcGluZ3MiOiJBQUFBLGdCQUFnQixtQkFBTyxDQUFDLHdFQUFlO0FBQ3ZDLDBCQUEwQixtQkFBTyxDQUFDLDRFQUFpQjtBQUNuRCxrQkFBa0IsbUJBQU8sQ0FBQyw0RUFBaUI7QUFDM0MsZUFBZSxtQkFBTyxDQUFDLHNFQUFjO0FBQ3JDLGVBQWUsbUJBQU8sQ0FBQyxzQkFBUTtBQUMvQixRQUFRLFlBQVksRUFBRSxtQkFBTyxDQUFDLGtCQUFNO0FBQ3BDLFdBQVcsbUJBQU8sQ0FBQyxjQUFJO0FBQ3ZCLFFBQVEsT0FBTyxFQUFFLG1CQUFPLENBQUMsc0JBQVE7QUFDakMsY0FBYyxtQkFBTyxDQUFDLG9FQUFhOztBQUVuQzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxVQUFVO0FBQ3pCLGVBQWUsUUFBUTtBQUN2QixnQkFBZ0I7QUFDaEIsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFNBQVM7QUFDVDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkIsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsU0FBUztBQUN4QixnQkFBZ0I7QUFDaEIsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFNBQVM7QUFDVDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkIsZ0JBQWdCO0FBQ2hCLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0EscUNBQXFDLFdBQVcs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QTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QixlQUFlLFFBQVE7QUFDdkIsZUFBZSxRQUFRO0FBQ3ZCLGdCQUFnQjtBQUNoQixpQkFBaUI7QUFDakI7QUFDQTtBQUNBLHFDQUFxQyxXQUFXLGNBQWMsYUFBYSxVQUFVLElBQUksWUFBWSxXQUFXLHlCQUF5QixhQUFhLDJCQUEyQixJQUFJO0FBQ3JMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QixlQUFlLFFBQVE7QUFDdkIsZUFBZSxRQUFRO0FBQ3ZCLGdCQUFnQjtBQUNoQixpQkFBaUI7QUFDakI7QUFDQTtBQUNBLHFDQUFxQyxXQUFXLGNBQWMsYUFBYSxVQUFVLElBQUksWUFBWSxXQUFXLHlCQUF5QixhQUFhLDJCQUEyQixJQUFJO0FBQ3JMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTs7QUFFQSIsInNvdXJjZXMiOlsid2VicGFjazovL2pzbV9iYW5raW5nLy4vbm9kZV9tb2R1bGVzL25vZGUtYXBwd3JpdGUvbGliL3NlcnZpY2VzL2RhdGFiYXNlcy5qcz9kZDM2Il0sInNvdXJjZXNDb250ZW50IjpbImNvbnN0IFNlcnZpY2UgPSByZXF1aXJlKCcuLi9zZXJ2aWNlLmpzJyk7XG5jb25zdCBBcHB3cml0ZUV4Y2VwdGlvbiA9IHJlcXVpcmUoJy4uL2V4Y2VwdGlvbi5qcycpO1xuY29uc3QgSW5wdXRGaWxlID0gcmVxdWlyZSgnLi4vaW5wdXRGaWxlLmpzJyk7XG5jb25zdCBjbGllbnQgPSByZXF1aXJlKCcuLi9jbGllbnQuanMnKTtcbmNvbnN0IFN0cmVhbSA9IHJlcXVpcmUoJ3N0cmVhbScpO1xuY29uc3QgeyBwcm9taXNpZnkgfSA9IHJlcXVpcmUoJ3V0aWwnKTtcbmNvbnN0IGZzID0gcmVxdWlyZSgnZnMnKTtcbmNvbnN0IHsgRmlsZSB9ID0gcmVxdWlyZSgndW5kaWNpJyk7XG5jb25zdCBRdWVyeSA9IHJlcXVpcmUoJy4uL3F1ZXJ5LmpzJyk7XG5cbmNsYXNzIERhdGFiYXNlcyBleHRlbmRzIFNlcnZpY2Uge1xuXG4gICAgIGNvbnN0cnVjdG9yKGNsaWVudClcbiAgICAge1xuICAgICAgICBzdXBlcihjbGllbnQpO1xuICAgICB9XG5cblxuICAgIC8qKlxuICAgICAqIExpc3QgZGF0YWJhc2VzXG4gICAgICpcbiAgICAgKiBHZXQgYSBsaXN0IG9mIGFsbCBkYXRhYmFzZXMgZnJvbSB0aGUgY3VycmVudCBBcHB3cml0ZSBwcm9qZWN0LiBZb3UgY2FuIHVzZVxuICAgICAqIHRoZSBzZWFyY2ggcGFyYW1ldGVyIHRvIGZpbHRlciB5b3VyIHJlc3VsdHMuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZ1tdfSBxdWVyaWVzXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHNlYXJjaFxuICAgICAqIEB0aHJvd3Mge0FwcHdyaXRlRXhjZXB0aW9ufVxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlfVxuICAgICAqL1xuICAgIGFzeW5jIGxpc3QocXVlcmllcywgc2VhcmNoKSB7XG4gICAgICAgIGNvbnN0IGFwaVBhdGggPSAnL2RhdGFiYXNlcyc7XG4gICAgICAgIGxldCBwYXlsb2FkID0ge307XG5cbiAgICAgICAgaWYgKHR5cGVvZiBxdWVyaWVzICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgcGF5bG9hZFsncXVlcmllcyddID0gcXVlcmllcztcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0eXBlb2Ygc2VhcmNoICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgcGF5bG9hZFsnc2VhcmNoJ10gPSBzZWFyY2g7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy5jbGllbnQuY2FsbCgnZ2V0JywgYXBpUGF0aCwge1xuICAgICAgICAgICAgJ2NvbnRlbnQtdHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJyxcbiAgICAgICAgfSwgcGF5bG9hZCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlIGRhdGFiYXNlXG4gICAgICpcbiAgICAgKiBDcmVhdGUgYSBuZXcgRGF0YWJhc2UuXG4gICAgICogXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gZGF0YWJhc2VJZFxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lXG4gICAgICogQHBhcmFtIHtib29sZWFufSBlbmFibGVkXG4gICAgICogQHRocm93cyB7QXBwd3JpdGVFeGNlcHRpb259XG4gICAgICogQHJldHVybnMge1Byb21pc2V9XG4gICAgICovXG4gICAgYXN5bmMgY3JlYXRlKGRhdGFiYXNlSWQsIG5hbWUsIGVuYWJsZWQpIHtcbiAgICAgICAgY29uc3QgYXBpUGF0aCA9ICcvZGF0YWJhc2VzJztcbiAgICAgICAgbGV0IHBheWxvYWQgPSB7fTtcbiAgICAgICAgaWYgKHR5cGVvZiBkYXRhYmFzZUlkID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEFwcHdyaXRlRXhjZXB0aW9uKCdNaXNzaW5nIHJlcXVpcmVkIHBhcmFtZXRlcjogXCJkYXRhYmFzZUlkXCInKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0eXBlb2YgbmFtZSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBBcHB3cml0ZUV4Y2VwdGlvbignTWlzc2luZyByZXF1aXJlZCBwYXJhbWV0ZXI6IFwibmFtZVwiJyk7XG4gICAgICAgIH1cblxuXG4gICAgICAgIGlmICh0eXBlb2YgZGF0YWJhc2VJZCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHBheWxvYWRbJ2RhdGFiYXNlSWQnXSA9IGRhdGFiYXNlSWQ7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodHlwZW9mIG5hbWUgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICBwYXlsb2FkWyduYW1lJ10gPSBuYW1lO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHR5cGVvZiBlbmFibGVkICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgcGF5bG9hZFsnZW5hYmxlZCddID0gZW5hYmxlZDtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBhd2FpdCB0aGlzLmNsaWVudC5jYWxsKCdwb3N0JywgYXBpUGF0aCwge1xuICAgICAgICAgICAgJ2NvbnRlbnQtdHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJyxcbiAgICAgICAgfSwgcGF5bG9hZCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2V0IGRhdGFiYXNlXG4gICAgICpcbiAgICAgKiBHZXQgYSBkYXRhYmFzZSBieSBpdHMgdW5pcXVlIElELiBUaGlzIGVuZHBvaW50IHJlc3BvbnNlIHJldHVybnMgYSBKU09OXG4gICAgICogb2JqZWN0IHdpdGggdGhlIGRhdGFiYXNlIG1ldGFkYXRhLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGRhdGFiYXNlSWRcbiAgICAgKiBAdGhyb3dzIHtBcHB3cml0ZUV4Y2VwdGlvbn1cbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZX1cbiAgICAgKi9cbiAgICBhc3luYyBnZXQoZGF0YWJhc2VJZCkge1xuICAgICAgICBjb25zdCBhcGlQYXRoID0gJy9kYXRhYmFzZXMve2RhdGFiYXNlSWR9Jy5yZXBsYWNlKCd7ZGF0YWJhc2VJZH0nLCBkYXRhYmFzZUlkKTtcbiAgICAgICAgbGV0IHBheWxvYWQgPSB7fTtcbiAgICAgICAgaWYgKHR5cGVvZiBkYXRhYmFzZUlkID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEFwcHdyaXRlRXhjZXB0aW9uKCdNaXNzaW5nIHJlcXVpcmVkIHBhcmFtZXRlcjogXCJkYXRhYmFzZUlkXCInKTtcbiAgICAgICAgfVxuXG5cbiAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMuY2xpZW50LmNhbGwoJ2dldCcsIGFwaVBhdGgsIHtcbiAgICAgICAgICAgICdjb250ZW50LXR5cGUnOiAnYXBwbGljYXRpb24vanNvbicsXG4gICAgICAgIH0sIHBheWxvYWQpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFVwZGF0ZSBkYXRhYmFzZVxuICAgICAqXG4gICAgICogVXBkYXRlIGEgZGF0YWJhc2UgYnkgaXRzIHVuaXF1ZSBJRC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBkYXRhYmFzZUlkXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IG5hbWVcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IGVuYWJsZWRcbiAgICAgKiBAdGhyb3dzIHtBcHB3cml0ZUV4Y2VwdGlvbn1cbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZX1cbiAgICAgKi9cbiAgICBhc3luYyB1cGRhdGUoZGF0YWJhc2VJZCwgbmFtZSwgZW5hYmxlZCkge1xuICAgICAgICBjb25zdCBhcGlQYXRoID0gJy9kYXRhYmFzZXMve2RhdGFiYXNlSWR9Jy5yZXBsYWNlKCd7ZGF0YWJhc2VJZH0nLCBkYXRhYmFzZUlkKTtcbiAgICAgICAgbGV0IHBheWxvYWQgPSB7fTtcbiAgICAgICAgaWYgKHR5cGVvZiBkYXRhYmFzZUlkID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEFwcHdyaXRlRXhjZXB0aW9uKCdNaXNzaW5nIHJlcXVpcmVkIHBhcmFtZXRlcjogXCJkYXRhYmFzZUlkXCInKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0eXBlb2YgbmFtZSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBBcHB3cml0ZUV4Y2VwdGlvbignTWlzc2luZyByZXF1aXJlZCBwYXJhbWV0ZXI6IFwibmFtZVwiJyk7XG4gICAgICAgIH1cblxuXG4gICAgICAgIGlmICh0eXBlb2YgbmFtZSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHBheWxvYWRbJ25hbWUnXSA9IG5hbWU7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodHlwZW9mIGVuYWJsZWQgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICBwYXlsb2FkWydlbmFibGVkJ10gPSBlbmFibGVkO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMuY2xpZW50LmNhbGwoJ3B1dCcsIGFwaVBhdGgsIHtcbiAgICAgICAgICAgICdjb250ZW50LXR5cGUnOiAnYXBwbGljYXRpb24vanNvbicsXG4gICAgICAgIH0sIHBheWxvYWQpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIERlbGV0ZSBkYXRhYmFzZVxuICAgICAqXG4gICAgICogRGVsZXRlIGEgZGF0YWJhc2UgYnkgaXRzIHVuaXF1ZSBJRC4gT25seSBBUEkga2V5cyB3aXRoIHdpdGggZGF0YWJhc2VzLndyaXRlXG4gICAgICogc2NvcGUgY2FuIGRlbGV0ZSBhIGRhdGFiYXNlLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGRhdGFiYXNlSWRcbiAgICAgKiBAdGhyb3dzIHtBcHB3cml0ZUV4Y2VwdGlvbn1cbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZX1cbiAgICAgKi9cbiAgICBhc3luYyBkZWxldGUoZGF0YWJhc2VJZCkge1xuICAgICAgICBjb25zdCBhcGlQYXRoID0gJy9kYXRhYmFzZXMve2RhdGFiYXNlSWR9Jy5yZXBsYWNlKCd7ZGF0YWJhc2VJZH0nLCBkYXRhYmFzZUlkKTtcbiAgICAgICAgbGV0IHBheWxvYWQgPSB7fTtcbiAgICAgICAgaWYgKHR5cGVvZiBkYXRhYmFzZUlkID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEFwcHdyaXRlRXhjZXB0aW9uKCdNaXNzaW5nIHJlcXVpcmVkIHBhcmFtZXRlcjogXCJkYXRhYmFzZUlkXCInKTtcbiAgICAgICAgfVxuXG5cbiAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMuY2xpZW50LmNhbGwoJ2RlbGV0ZScsIGFwaVBhdGgsIHtcbiAgICAgICAgICAgICdjb250ZW50LXR5cGUnOiAnYXBwbGljYXRpb24vanNvbicsXG4gICAgICAgIH0sIHBheWxvYWQpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIExpc3QgY29sbGVjdGlvbnNcbiAgICAgKlxuICAgICAqIEdldCBhIGxpc3Qgb2YgYWxsIGNvbGxlY3Rpb25zIHRoYXQgYmVsb25nIHRvIHRoZSBwcm92aWRlZCBkYXRhYmFzZUlkLiBZb3VcbiAgICAgKiBjYW4gdXNlIHRoZSBzZWFyY2ggcGFyYW1ldGVyIHRvIGZpbHRlciB5b3VyIHJlc3VsdHMuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gZGF0YWJhc2VJZFxuICAgICAqIEBwYXJhbSB7c3RyaW5nW119IHF1ZXJpZXNcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gc2VhcmNoXG4gICAgICogQHRocm93cyB7QXBwd3JpdGVFeGNlcHRpb259XG4gICAgICogQHJldHVybnMge1Byb21pc2V9XG4gICAgICovXG4gICAgYXN5bmMgbGlzdENvbGxlY3Rpb25zKGRhdGFiYXNlSWQsIHF1ZXJpZXMsIHNlYXJjaCkge1xuICAgICAgICBjb25zdCBhcGlQYXRoID0gJy9kYXRhYmFzZXMve2RhdGFiYXNlSWR9L2NvbGxlY3Rpb25zJy5yZXBsYWNlKCd7ZGF0YWJhc2VJZH0nLCBkYXRhYmFzZUlkKTtcbiAgICAgICAgbGV0IHBheWxvYWQgPSB7fTtcbiAgICAgICAgaWYgKHR5cGVvZiBkYXRhYmFzZUlkID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEFwcHdyaXRlRXhjZXB0aW9uKCdNaXNzaW5nIHJlcXVpcmVkIHBhcmFtZXRlcjogXCJkYXRhYmFzZUlkXCInKTtcbiAgICAgICAgfVxuXG5cbiAgICAgICAgaWYgKHR5cGVvZiBxdWVyaWVzICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgcGF5bG9hZFsncXVlcmllcyddID0gcXVlcmllcztcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0eXBlb2Ygc2VhcmNoICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgcGF5bG9hZFsnc2VhcmNoJ10gPSBzZWFyY2g7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy5jbGllbnQuY2FsbCgnZ2V0JywgYXBpUGF0aCwge1xuICAgICAgICAgICAgJ2NvbnRlbnQtdHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJyxcbiAgICAgICAgfSwgcGF5bG9hZCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlIGNvbGxlY3Rpb25cbiAgICAgKlxuICAgICAqIENyZWF0ZSBhIG5ldyBDb2xsZWN0aW9uLiBCZWZvcmUgdXNpbmcgdGhpcyByb3V0ZSwgeW91IHNob3VsZCBjcmVhdGUgYSBuZXdcbiAgICAgKiBkYXRhYmFzZSByZXNvdXJjZSB1c2luZyBlaXRoZXIgYSBbc2VydmVyXG4gICAgICogaW50ZWdyYXRpb25dKGh0dHBzOi8vYXBwd3JpdGUuaW8vZG9jcy9zZXJ2ZXIvZGF0YWJhc2VzI2RhdGFiYXNlc0NyZWF0ZUNvbGxlY3Rpb24pXG4gICAgICogQVBJIG9yIGRpcmVjdGx5IGZyb20geW91ciBkYXRhYmFzZSBjb25zb2xlLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGRhdGFiYXNlSWRcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gY29sbGVjdGlvbklkXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IG5hbWVcbiAgICAgKiBAcGFyYW0ge3N0cmluZ1tdfSBwZXJtaXNzaW9uc1xuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gZG9jdW1lbnRTZWN1cml0eVxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gZW5hYmxlZFxuICAgICAqIEB0aHJvd3Mge0FwcHdyaXRlRXhjZXB0aW9ufVxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlfVxuICAgICAqL1xuICAgIGFzeW5jIGNyZWF0ZUNvbGxlY3Rpb24oZGF0YWJhc2VJZCwgY29sbGVjdGlvbklkLCBuYW1lLCBwZXJtaXNzaW9ucywgZG9jdW1lbnRTZWN1cml0eSwgZW5hYmxlZCkge1xuICAgICAgICBjb25zdCBhcGlQYXRoID0gJy9kYXRhYmFzZXMve2RhdGFiYXNlSWR9L2NvbGxlY3Rpb25zJy5yZXBsYWNlKCd7ZGF0YWJhc2VJZH0nLCBkYXRhYmFzZUlkKTtcbiAgICAgICAgbGV0IHBheWxvYWQgPSB7fTtcbiAgICAgICAgaWYgKHR5cGVvZiBkYXRhYmFzZUlkID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEFwcHdyaXRlRXhjZXB0aW9uKCdNaXNzaW5nIHJlcXVpcmVkIHBhcmFtZXRlcjogXCJkYXRhYmFzZUlkXCInKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0eXBlb2YgY29sbGVjdGlvbklkID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEFwcHdyaXRlRXhjZXB0aW9uKCdNaXNzaW5nIHJlcXVpcmVkIHBhcmFtZXRlcjogXCJjb2xsZWN0aW9uSWRcIicpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHR5cGVvZiBuYW1lID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEFwcHdyaXRlRXhjZXB0aW9uKCdNaXNzaW5nIHJlcXVpcmVkIHBhcmFtZXRlcjogXCJuYW1lXCInKTtcbiAgICAgICAgfVxuXG5cbiAgICAgICAgaWYgKHR5cGVvZiBjb2xsZWN0aW9uSWQgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICBwYXlsb2FkWydjb2xsZWN0aW9uSWQnXSA9IGNvbGxlY3Rpb25JZDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0eXBlb2YgbmFtZSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHBheWxvYWRbJ25hbWUnXSA9IG5hbWU7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodHlwZW9mIHBlcm1pc3Npb25zICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgcGF5bG9hZFsncGVybWlzc2lvbnMnXSA9IHBlcm1pc3Npb25zO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHR5cGVvZiBkb2N1bWVudFNlY3VyaXR5ICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgcGF5bG9hZFsnZG9jdW1lbnRTZWN1cml0eSddID0gZG9jdW1lbnRTZWN1cml0eTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0eXBlb2YgZW5hYmxlZCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHBheWxvYWRbJ2VuYWJsZWQnXSA9IGVuYWJsZWQ7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy5jbGllbnQuY2FsbCgncG9zdCcsIGFwaVBhdGgsIHtcbiAgICAgICAgICAgICdjb250ZW50LXR5cGUnOiAnYXBwbGljYXRpb24vanNvbicsXG4gICAgICAgIH0sIHBheWxvYWQpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdldCBjb2xsZWN0aW9uXG4gICAgICpcbiAgICAgKiBHZXQgYSBjb2xsZWN0aW9uIGJ5IGl0cyB1bmlxdWUgSUQuIFRoaXMgZW5kcG9pbnQgcmVzcG9uc2UgcmV0dXJucyBhIEpTT05cbiAgICAgKiBvYmplY3Qgd2l0aCB0aGUgY29sbGVjdGlvbiBtZXRhZGF0YS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBkYXRhYmFzZUlkXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGNvbGxlY3Rpb25JZFxuICAgICAqIEB0aHJvd3Mge0FwcHdyaXRlRXhjZXB0aW9ufVxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlfVxuICAgICAqL1xuICAgIGFzeW5jIGdldENvbGxlY3Rpb24oZGF0YWJhc2VJZCwgY29sbGVjdGlvbklkKSB7XG4gICAgICAgIGNvbnN0IGFwaVBhdGggPSAnL2RhdGFiYXNlcy97ZGF0YWJhc2VJZH0vY29sbGVjdGlvbnMve2NvbGxlY3Rpb25JZH0nLnJlcGxhY2UoJ3tkYXRhYmFzZUlkfScsIGRhdGFiYXNlSWQpLnJlcGxhY2UoJ3tjb2xsZWN0aW9uSWR9JywgY29sbGVjdGlvbklkKTtcbiAgICAgICAgbGV0IHBheWxvYWQgPSB7fTtcbiAgICAgICAgaWYgKHR5cGVvZiBkYXRhYmFzZUlkID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEFwcHdyaXRlRXhjZXB0aW9uKCdNaXNzaW5nIHJlcXVpcmVkIHBhcmFtZXRlcjogXCJkYXRhYmFzZUlkXCInKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0eXBlb2YgY29sbGVjdGlvbklkID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEFwcHdyaXRlRXhjZXB0aW9uKCdNaXNzaW5nIHJlcXVpcmVkIHBhcmFtZXRlcjogXCJjb2xsZWN0aW9uSWRcIicpO1xuICAgICAgICB9XG5cblxuICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy5jbGllbnQuY2FsbCgnZ2V0JywgYXBpUGF0aCwge1xuICAgICAgICAgICAgJ2NvbnRlbnQtdHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJyxcbiAgICAgICAgfSwgcGF5bG9hZCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVXBkYXRlIGNvbGxlY3Rpb25cbiAgICAgKlxuICAgICAqIFVwZGF0ZSBhIGNvbGxlY3Rpb24gYnkgaXRzIHVuaXF1ZSBJRC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBkYXRhYmFzZUlkXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGNvbGxlY3Rpb25JZFxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lXG4gICAgICogQHBhcmFtIHtzdHJpbmdbXX0gcGVybWlzc2lvbnNcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IGRvY3VtZW50U2VjdXJpdHlcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IGVuYWJsZWRcbiAgICAgKiBAdGhyb3dzIHtBcHB3cml0ZUV4Y2VwdGlvbn1cbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZX1cbiAgICAgKi9cbiAgICBhc3luYyB1cGRhdGVDb2xsZWN0aW9uKGRhdGFiYXNlSWQsIGNvbGxlY3Rpb25JZCwgbmFtZSwgcGVybWlzc2lvbnMsIGRvY3VtZW50U2VjdXJpdHksIGVuYWJsZWQpIHtcbiAgICAgICAgY29uc3QgYXBpUGF0aCA9ICcvZGF0YWJhc2VzL3tkYXRhYmFzZUlkfS9jb2xsZWN0aW9ucy97Y29sbGVjdGlvbklkfScucmVwbGFjZSgne2RhdGFiYXNlSWR9JywgZGF0YWJhc2VJZCkucmVwbGFjZSgne2NvbGxlY3Rpb25JZH0nLCBjb2xsZWN0aW9uSWQpO1xuICAgICAgICBsZXQgcGF5bG9hZCA9IHt9O1xuICAgICAgICBpZiAodHlwZW9mIGRhdGFiYXNlSWQgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgQXBwd3JpdGVFeGNlcHRpb24oJ01pc3NpbmcgcmVxdWlyZWQgcGFyYW1ldGVyOiBcImRhdGFiYXNlSWRcIicpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHR5cGVvZiBjb2xsZWN0aW9uSWQgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgQXBwd3JpdGVFeGNlcHRpb24oJ01pc3NpbmcgcmVxdWlyZWQgcGFyYW1ldGVyOiBcImNvbGxlY3Rpb25JZFwiJyk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodHlwZW9mIG5hbWUgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgQXBwd3JpdGVFeGNlcHRpb24oJ01pc3NpbmcgcmVxdWlyZWQgcGFyYW1ldGVyOiBcIm5hbWVcIicpO1xuICAgICAgICB9XG5cblxuICAgICAgICBpZiAodHlwZW9mIG5hbWUgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICBwYXlsb2FkWyduYW1lJ10gPSBuYW1lO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHR5cGVvZiBwZXJtaXNzaW9ucyAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHBheWxvYWRbJ3Blcm1pc3Npb25zJ10gPSBwZXJtaXNzaW9ucztcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0eXBlb2YgZG9jdW1lbnRTZWN1cml0eSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHBheWxvYWRbJ2RvY3VtZW50U2VjdXJpdHknXSA9IGRvY3VtZW50U2VjdXJpdHk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodHlwZW9mIGVuYWJsZWQgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICBwYXlsb2FkWydlbmFibGVkJ10gPSBlbmFibGVkO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMuY2xpZW50LmNhbGwoJ3B1dCcsIGFwaVBhdGgsIHtcbiAgICAgICAgICAgICdjb250ZW50LXR5cGUnOiAnYXBwbGljYXRpb24vanNvbicsXG4gICAgICAgIH0sIHBheWxvYWQpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIERlbGV0ZSBjb2xsZWN0aW9uXG4gICAgICpcbiAgICAgKiBEZWxldGUgYSBjb2xsZWN0aW9uIGJ5IGl0cyB1bmlxdWUgSUQuIE9ubHkgdXNlcnMgd2l0aCB3cml0ZSBwZXJtaXNzaW9uc1xuICAgICAqIGhhdmUgYWNjZXNzIHRvIGRlbGV0ZSB0aGlzIHJlc291cmNlLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGRhdGFiYXNlSWRcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gY29sbGVjdGlvbklkXG4gICAgICogQHRocm93cyB7QXBwd3JpdGVFeGNlcHRpb259XG4gICAgICogQHJldHVybnMge1Byb21pc2V9XG4gICAgICovXG4gICAgYXN5bmMgZGVsZXRlQ29sbGVjdGlvbihkYXRhYmFzZUlkLCBjb2xsZWN0aW9uSWQpIHtcbiAgICAgICAgY29uc3QgYXBpUGF0aCA9ICcvZGF0YWJhc2VzL3tkYXRhYmFzZUlkfS9jb2xsZWN0aW9ucy97Y29sbGVjdGlvbklkfScucmVwbGFjZSgne2RhdGFiYXNlSWR9JywgZGF0YWJhc2VJZCkucmVwbGFjZSgne2NvbGxlY3Rpb25JZH0nLCBjb2xsZWN0aW9uSWQpO1xuICAgICAgICBsZXQgcGF5bG9hZCA9IHt9O1xuICAgICAgICBpZiAodHlwZW9mIGRhdGFiYXNlSWQgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgQXBwd3JpdGVFeGNlcHRpb24oJ01pc3NpbmcgcmVxdWlyZWQgcGFyYW1ldGVyOiBcImRhdGFiYXNlSWRcIicpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHR5cGVvZiBjb2xsZWN0aW9uSWQgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgQXBwd3JpdGVFeGNlcHRpb24oJ01pc3NpbmcgcmVxdWlyZWQgcGFyYW1ldGVyOiBcImNvbGxlY3Rpb25JZFwiJyk7XG4gICAgICAgIH1cblxuXG4gICAgICAgIHJldHVybiBhd2FpdCB0aGlzLmNsaWVudC5jYWxsKCdkZWxldGUnLCBhcGlQYXRoLCB7XG4gICAgICAgICAgICAnY29udGVudC10eXBlJzogJ2FwcGxpY2F0aW9uL2pzb24nLFxuICAgICAgICB9LCBwYXlsb2FkKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBMaXN0IGF0dHJpYnV0ZXNcbiAgICAgKlxuICAgICAqIExpc3QgYXR0cmlidXRlcyBpbiB0aGUgY29sbGVjdGlvbi5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBkYXRhYmFzZUlkXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGNvbGxlY3Rpb25JZFxuICAgICAqIEBwYXJhbSB7c3RyaW5nW119IHF1ZXJpZXNcbiAgICAgKiBAdGhyb3dzIHtBcHB3cml0ZUV4Y2VwdGlvbn1cbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZX1cbiAgICAgKi9cbiAgICBhc3luYyBsaXN0QXR0cmlidXRlcyhkYXRhYmFzZUlkLCBjb2xsZWN0aW9uSWQsIHF1ZXJpZXMpIHtcbiAgICAgICAgY29uc3QgYXBpUGF0aCA9ICcvZGF0YWJhc2VzL3tkYXRhYmFzZUlkfS9jb2xsZWN0aW9ucy97Y29sbGVjdGlvbklkfS9hdHRyaWJ1dGVzJy5yZXBsYWNlKCd7ZGF0YWJhc2VJZH0nLCBkYXRhYmFzZUlkKS5yZXBsYWNlKCd7Y29sbGVjdGlvbklkfScsIGNvbGxlY3Rpb25JZCk7XG4gICAgICAgIGxldCBwYXlsb2FkID0ge307XG4gICAgICAgIGlmICh0eXBlb2YgZGF0YWJhc2VJZCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBBcHB3cml0ZUV4Y2VwdGlvbignTWlzc2luZyByZXF1aXJlZCBwYXJhbWV0ZXI6IFwiZGF0YWJhc2VJZFwiJyk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodHlwZW9mIGNvbGxlY3Rpb25JZCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBBcHB3cml0ZUV4Y2VwdGlvbignTWlzc2luZyByZXF1aXJlZCBwYXJhbWV0ZXI6IFwiY29sbGVjdGlvbklkXCInKTtcbiAgICAgICAgfVxuXG5cbiAgICAgICAgaWYgKHR5cGVvZiBxdWVyaWVzICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgcGF5bG9hZFsncXVlcmllcyddID0gcXVlcmllcztcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBhd2FpdCB0aGlzLmNsaWVudC5jYWxsKCdnZXQnLCBhcGlQYXRoLCB7XG4gICAgICAgICAgICAnY29udGVudC10eXBlJzogJ2FwcGxpY2F0aW9uL2pzb24nLFxuICAgICAgICB9LCBwYXlsb2FkKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGUgYm9vbGVhbiBhdHRyaWJ1dGVcbiAgICAgKlxuICAgICAqIENyZWF0ZSBhIGJvb2xlYW4gYXR0cmlidXRlLlxuICAgICAqIFxuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGRhdGFiYXNlSWRcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gY29sbGVjdGlvbklkXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGtleVxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gcmVxdWlyZWRcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IHhkZWZhdWx0XG4gICAgICogQHBhcmFtIHtib29sZWFufSBhcnJheVxuICAgICAqIEB0aHJvd3Mge0FwcHdyaXRlRXhjZXB0aW9ufVxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlfVxuICAgICAqL1xuICAgIGFzeW5jIGNyZWF0ZUJvb2xlYW5BdHRyaWJ1dGUoZGF0YWJhc2VJZCwgY29sbGVjdGlvbklkLCBrZXksIHJlcXVpcmVkLCB4ZGVmYXVsdCwgYXJyYXkpIHtcbiAgICAgICAgY29uc3QgYXBpUGF0aCA9ICcvZGF0YWJhc2VzL3tkYXRhYmFzZUlkfS9jb2xsZWN0aW9ucy97Y29sbGVjdGlvbklkfS9hdHRyaWJ1dGVzL2Jvb2xlYW4nLnJlcGxhY2UoJ3tkYXRhYmFzZUlkfScsIGRhdGFiYXNlSWQpLnJlcGxhY2UoJ3tjb2xsZWN0aW9uSWR9JywgY29sbGVjdGlvbklkKTtcbiAgICAgICAgbGV0IHBheWxvYWQgPSB7fTtcbiAgICAgICAgaWYgKHR5cGVvZiBkYXRhYmFzZUlkID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEFwcHdyaXRlRXhjZXB0aW9uKCdNaXNzaW5nIHJlcXVpcmVkIHBhcmFtZXRlcjogXCJkYXRhYmFzZUlkXCInKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0eXBlb2YgY29sbGVjdGlvbklkID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEFwcHdyaXRlRXhjZXB0aW9uKCdNaXNzaW5nIHJlcXVpcmVkIHBhcmFtZXRlcjogXCJjb2xsZWN0aW9uSWRcIicpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHR5cGVvZiBrZXkgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgQXBwd3JpdGVFeGNlcHRpb24oJ01pc3NpbmcgcmVxdWlyZWQgcGFyYW1ldGVyOiBcImtleVwiJyk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodHlwZW9mIHJlcXVpcmVkID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEFwcHdyaXRlRXhjZXB0aW9uKCdNaXNzaW5nIHJlcXVpcmVkIHBhcmFtZXRlcjogXCJyZXF1aXJlZFwiJyk7XG4gICAgICAgIH1cblxuXG4gICAgICAgIGlmICh0eXBlb2Yga2V5ICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgcGF5bG9hZFsna2V5J10gPSBrZXk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodHlwZW9mIHJlcXVpcmVkICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgcGF5bG9hZFsncmVxdWlyZWQnXSA9IHJlcXVpcmVkO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHR5cGVvZiB4ZGVmYXVsdCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHBheWxvYWRbJ2RlZmF1bHQnXSA9IHhkZWZhdWx0O1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHR5cGVvZiBhcnJheSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHBheWxvYWRbJ2FycmF5J10gPSBhcnJheTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBhd2FpdCB0aGlzLmNsaWVudC5jYWxsKCdwb3N0JywgYXBpUGF0aCwge1xuICAgICAgICAgICAgJ2NvbnRlbnQtdHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJyxcbiAgICAgICAgfSwgcGF5bG9hZCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVXBkYXRlIGJvb2xlYW4gYXR0cmlidXRlXG4gICAgICpcbiAgICAgKiBVcGRhdGUgYSBib29sZWFuIGF0dHJpYnV0ZS4gQ2hhbmdpbmcgdGhlIGBkZWZhdWx0YCB2YWx1ZSB3aWxsIG5vdCB1cGRhdGVcbiAgICAgKiBhbHJlYWR5IGV4aXN0aW5nIGRvY3VtZW50cy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBkYXRhYmFzZUlkXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGNvbGxlY3Rpb25JZFxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBrZXlcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IHJlcXVpcmVkXG4gICAgICogQHBhcmFtIHtib29sZWFufSB4ZGVmYXVsdFxuICAgICAqIEB0aHJvd3Mge0FwcHdyaXRlRXhjZXB0aW9ufVxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlfVxuICAgICAqL1xuICAgIGFzeW5jIHVwZGF0ZUJvb2xlYW5BdHRyaWJ1dGUoZGF0YWJhc2VJZCwgY29sbGVjdGlvbklkLCBrZXksIHJlcXVpcmVkLCB4ZGVmYXVsdCkge1xuICAgICAgICBjb25zdCBhcGlQYXRoID0gJy9kYXRhYmFzZXMve2RhdGFiYXNlSWR9L2NvbGxlY3Rpb25zL3tjb2xsZWN0aW9uSWR9L2F0dHJpYnV0ZXMvYm9vbGVhbi97a2V5fScucmVwbGFjZSgne2RhdGFiYXNlSWR9JywgZGF0YWJhc2VJZCkucmVwbGFjZSgne2NvbGxlY3Rpb25JZH0nLCBjb2xsZWN0aW9uSWQpLnJlcGxhY2UoJ3trZXl9Jywga2V5KTtcbiAgICAgICAgbGV0IHBheWxvYWQgPSB7fTtcbiAgICAgICAgaWYgKHR5cGVvZiBkYXRhYmFzZUlkID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEFwcHdyaXRlRXhjZXB0aW9uKCdNaXNzaW5nIHJlcXVpcmVkIHBhcmFtZXRlcjogXCJkYXRhYmFzZUlkXCInKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0eXBlb2YgY29sbGVjdGlvbklkID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEFwcHdyaXRlRXhjZXB0aW9uKCdNaXNzaW5nIHJlcXVpcmVkIHBhcmFtZXRlcjogXCJjb2xsZWN0aW9uSWRcIicpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHR5cGVvZiBrZXkgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgQXBwd3JpdGVFeGNlcHRpb24oJ01pc3NpbmcgcmVxdWlyZWQgcGFyYW1ldGVyOiBcImtleVwiJyk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodHlwZW9mIHJlcXVpcmVkID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEFwcHdyaXRlRXhjZXB0aW9uKCdNaXNzaW5nIHJlcXVpcmVkIHBhcmFtZXRlcjogXCJyZXF1aXJlZFwiJyk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodHlwZW9mIHhkZWZhdWx0ID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEFwcHdyaXRlRXhjZXB0aW9uKCdNaXNzaW5nIHJlcXVpcmVkIHBhcmFtZXRlcjogXCJ4ZGVmYXVsdFwiJyk7XG4gICAgICAgIH1cblxuXG4gICAgICAgIGlmICh0eXBlb2YgcmVxdWlyZWQgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICBwYXlsb2FkWydyZXF1aXJlZCddID0gcmVxdWlyZWQ7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodHlwZW9mIHhkZWZhdWx0ICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgcGF5bG9hZFsnZGVmYXVsdCddID0geGRlZmF1bHQ7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy5jbGllbnQuY2FsbCgncGF0Y2gnLCBhcGlQYXRoLCB7XG4gICAgICAgICAgICAnY29udGVudC10eXBlJzogJ2FwcGxpY2F0aW9uL2pzb24nLFxuICAgICAgICB9LCBwYXlsb2FkKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGUgZGF0ZXRpbWUgYXR0cmlidXRlXG4gICAgICpcbiAgICAgKiBDcmVhdGUgYSBkYXRlIHRpbWUgYXR0cmlidXRlIGFjY29yZGluZyB0byB0aGUgSVNPIDg2MDEgc3RhbmRhcmQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gZGF0YWJhc2VJZFxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBjb2xsZWN0aW9uSWRcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30ga2V5XG4gICAgICogQHBhcmFtIHtib29sZWFufSByZXF1aXJlZFxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSB4ZGVmYXVsdFxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gYXJyYXlcbiAgICAgKiBAdGhyb3dzIHtBcHB3cml0ZUV4Y2VwdGlvbn1cbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZX1cbiAgICAgKi9cbiAgICBhc3luYyBjcmVhdGVEYXRldGltZUF0dHJpYnV0ZShkYXRhYmFzZUlkLCBjb2xsZWN0aW9uSWQsIGtleSwgcmVxdWlyZWQsIHhkZWZhdWx0LCBhcnJheSkge1xuICAgICAgICBjb25zdCBhcGlQYXRoID0gJy9kYXRhYmFzZXMve2RhdGFiYXNlSWR9L2NvbGxlY3Rpb25zL3tjb2xsZWN0aW9uSWR9L2F0dHJpYnV0ZXMvZGF0ZXRpbWUnLnJlcGxhY2UoJ3tkYXRhYmFzZUlkfScsIGRhdGFiYXNlSWQpLnJlcGxhY2UoJ3tjb2xsZWN0aW9uSWR9JywgY29sbGVjdGlvbklkKTtcbiAgICAgICAgbGV0IHBheWxvYWQgPSB7fTtcbiAgICAgICAgaWYgKHR5cGVvZiBkYXRhYmFzZUlkID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEFwcHdyaXRlRXhjZXB0aW9uKCdNaXNzaW5nIHJlcXVpcmVkIHBhcmFtZXRlcjogXCJkYXRhYmFzZUlkXCInKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0eXBlb2YgY29sbGVjdGlvbklkID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEFwcHdyaXRlRXhjZXB0aW9uKCdNaXNzaW5nIHJlcXVpcmVkIHBhcmFtZXRlcjogXCJjb2xsZWN0aW9uSWRcIicpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHR5cGVvZiBrZXkgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgQXBwd3JpdGVFeGNlcHRpb24oJ01pc3NpbmcgcmVxdWlyZWQgcGFyYW1ldGVyOiBcImtleVwiJyk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodHlwZW9mIHJlcXVpcmVkID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEFwcHdyaXRlRXhjZXB0aW9uKCdNaXNzaW5nIHJlcXVpcmVkIHBhcmFtZXRlcjogXCJyZXF1aXJlZFwiJyk7XG4gICAgICAgIH1cblxuXG4gICAgICAgIGlmICh0eXBlb2Yga2V5ICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgcGF5bG9hZFsna2V5J10gPSBrZXk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodHlwZW9mIHJlcXVpcmVkICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgcGF5bG9hZFsncmVxdWlyZWQnXSA9IHJlcXVpcmVkO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHR5cGVvZiB4ZGVmYXVsdCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHBheWxvYWRbJ2RlZmF1bHQnXSA9IHhkZWZhdWx0O1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHR5cGVvZiBhcnJheSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHBheWxvYWRbJ2FycmF5J10gPSBhcnJheTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBhd2FpdCB0aGlzLmNsaWVudC5jYWxsKCdwb3N0JywgYXBpUGF0aCwge1xuICAgICAgICAgICAgJ2NvbnRlbnQtdHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJyxcbiAgICAgICAgfSwgcGF5bG9hZCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVXBkYXRlIGRhdGVUaW1lIGF0dHJpYnV0ZVxuICAgICAqXG4gICAgICogVXBkYXRlIGEgZGF0ZSB0aW1lIGF0dHJpYnV0ZS4gQ2hhbmdpbmcgdGhlIGBkZWZhdWx0YCB2YWx1ZSB3aWxsIG5vdCB1cGRhdGVcbiAgICAgKiBhbHJlYWR5IGV4aXN0aW5nIGRvY3VtZW50cy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBkYXRhYmFzZUlkXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGNvbGxlY3Rpb25JZFxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBrZXlcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IHJlcXVpcmVkXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHhkZWZhdWx0XG4gICAgICogQHRocm93cyB7QXBwd3JpdGVFeGNlcHRpb259XG4gICAgICogQHJldHVybnMge1Byb21pc2V9XG4gICAgICovXG4gICAgYXN5bmMgdXBkYXRlRGF0ZXRpbWVBdHRyaWJ1dGUoZGF0YWJhc2VJZCwgY29sbGVjdGlvbklkLCBrZXksIHJlcXVpcmVkLCB4ZGVmYXVsdCkge1xuICAgICAgICBjb25zdCBhcGlQYXRoID0gJy9kYXRhYmFzZXMve2RhdGFiYXNlSWR9L2NvbGxlY3Rpb25zL3tjb2xsZWN0aW9uSWR9L2F0dHJpYnV0ZXMvZGF0ZXRpbWUve2tleX0nLnJlcGxhY2UoJ3tkYXRhYmFzZUlkfScsIGRhdGFiYXNlSWQpLnJlcGxhY2UoJ3tjb2xsZWN0aW9uSWR9JywgY29sbGVjdGlvbklkKS5yZXBsYWNlKCd7a2V5fScsIGtleSk7XG4gICAgICAgIGxldCBwYXlsb2FkID0ge307XG4gICAgICAgIGlmICh0eXBlb2YgZGF0YWJhc2VJZCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBBcHB3cml0ZUV4Y2VwdGlvbignTWlzc2luZyByZXF1aXJlZCBwYXJhbWV0ZXI6IFwiZGF0YWJhc2VJZFwiJyk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodHlwZW9mIGNvbGxlY3Rpb25JZCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBBcHB3cml0ZUV4Y2VwdGlvbignTWlzc2luZyByZXF1aXJlZCBwYXJhbWV0ZXI6IFwiY29sbGVjdGlvbklkXCInKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0eXBlb2Yga2V5ID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEFwcHdyaXRlRXhjZXB0aW9uKCdNaXNzaW5nIHJlcXVpcmVkIHBhcmFtZXRlcjogXCJrZXlcIicpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHR5cGVvZiByZXF1aXJlZCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBBcHB3cml0ZUV4Y2VwdGlvbignTWlzc2luZyByZXF1aXJlZCBwYXJhbWV0ZXI6IFwicmVxdWlyZWRcIicpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHR5cGVvZiB4ZGVmYXVsdCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBBcHB3cml0ZUV4Y2VwdGlvbignTWlzc2luZyByZXF1aXJlZCBwYXJhbWV0ZXI6IFwieGRlZmF1bHRcIicpO1xuICAgICAgICB9XG5cblxuICAgICAgICBpZiAodHlwZW9mIHJlcXVpcmVkICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgcGF5bG9hZFsncmVxdWlyZWQnXSA9IHJlcXVpcmVkO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHR5cGVvZiB4ZGVmYXVsdCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHBheWxvYWRbJ2RlZmF1bHQnXSA9IHhkZWZhdWx0O1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMuY2xpZW50LmNhbGwoJ3BhdGNoJywgYXBpUGF0aCwge1xuICAgICAgICAgICAgJ2NvbnRlbnQtdHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJyxcbiAgICAgICAgfSwgcGF5bG9hZCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlIGVtYWlsIGF0dHJpYnV0ZVxuICAgICAqXG4gICAgICogQ3JlYXRlIGFuIGVtYWlsIGF0dHJpYnV0ZS5cbiAgICAgKiBcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBkYXRhYmFzZUlkXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGNvbGxlY3Rpb25JZFxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBrZXlcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IHJlcXVpcmVkXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHhkZWZhdWx0XG4gICAgICogQHBhcmFtIHtib29sZWFufSBhcnJheVxuICAgICAqIEB0aHJvd3Mge0FwcHdyaXRlRXhjZXB0aW9ufVxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlfVxuICAgICAqL1xuICAgIGFzeW5jIGNyZWF0ZUVtYWlsQXR0cmlidXRlKGRhdGFiYXNlSWQsIGNvbGxlY3Rpb25JZCwga2V5LCByZXF1aXJlZCwgeGRlZmF1bHQsIGFycmF5KSB7XG4gICAgICAgIGNvbnN0IGFwaVBhdGggPSAnL2RhdGFiYXNlcy97ZGF0YWJhc2VJZH0vY29sbGVjdGlvbnMve2NvbGxlY3Rpb25JZH0vYXR0cmlidXRlcy9lbWFpbCcucmVwbGFjZSgne2RhdGFiYXNlSWR9JywgZGF0YWJhc2VJZCkucmVwbGFjZSgne2NvbGxlY3Rpb25JZH0nLCBjb2xsZWN0aW9uSWQpO1xuICAgICAgICBsZXQgcGF5bG9hZCA9IHt9O1xuICAgICAgICBpZiAodHlwZW9mIGRhdGFiYXNlSWQgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgQXBwd3JpdGVFeGNlcHRpb24oJ01pc3NpbmcgcmVxdWlyZWQgcGFyYW1ldGVyOiBcImRhdGFiYXNlSWRcIicpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHR5cGVvZiBjb2xsZWN0aW9uSWQgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgQXBwd3JpdGVFeGNlcHRpb24oJ01pc3NpbmcgcmVxdWlyZWQgcGFyYW1ldGVyOiBcImNvbGxlY3Rpb25JZFwiJyk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodHlwZW9mIGtleSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBBcHB3cml0ZUV4Y2VwdGlvbignTWlzc2luZyByZXF1aXJlZCBwYXJhbWV0ZXI6IFwia2V5XCInKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0eXBlb2YgcmVxdWlyZWQgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgQXBwd3JpdGVFeGNlcHRpb24oJ01pc3NpbmcgcmVxdWlyZWQgcGFyYW1ldGVyOiBcInJlcXVpcmVkXCInKTtcbiAgICAgICAgfVxuXG5cbiAgICAgICAgaWYgKHR5cGVvZiBrZXkgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICBwYXlsb2FkWydrZXknXSA9IGtleTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0eXBlb2YgcmVxdWlyZWQgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICBwYXlsb2FkWydyZXF1aXJlZCddID0gcmVxdWlyZWQ7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodHlwZW9mIHhkZWZhdWx0ICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgcGF5bG9hZFsnZGVmYXVsdCddID0geGRlZmF1bHQ7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodHlwZW9mIGFycmF5ICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgcGF5bG9hZFsnYXJyYXknXSA9IGFycmF5O1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMuY2xpZW50LmNhbGwoJ3Bvc3QnLCBhcGlQYXRoLCB7XG4gICAgICAgICAgICAnY29udGVudC10eXBlJzogJ2FwcGxpY2F0aW9uL2pzb24nLFxuICAgICAgICB9LCBwYXlsb2FkKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBVcGRhdGUgZW1haWwgYXR0cmlidXRlXG4gICAgICpcbiAgICAgKiBVcGRhdGUgYW4gZW1haWwgYXR0cmlidXRlLiBDaGFuZ2luZyB0aGUgYGRlZmF1bHRgIHZhbHVlIHdpbGwgbm90IHVwZGF0ZVxuICAgICAqIGFscmVhZHkgZXhpc3RpbmcgZG9jdW1lbnRzLlxuICAgICAqIFxuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGRhdGFiYXNlSWRcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gY29sbGVjdGlvbklkXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGtleVxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gcmVxdWlyZWRcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30geGRlZmF1bHRcbiAgICAgKiBAdGhyb3dzIHtBcHB3cml0ZUV4Y2VwdGlvbn1cbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZX1cbiAgICAgKi9cbiAgICBhc3luYyB1cGRhdGVFbWFpbEF0dHJpYnV0ZShkYXRhYmFzZUlkLCBjb2xsZWN0aW9uSWQsIGtleSwgcmVxdWlyZWQsIHhkZWZhdWx0KSB7XG4gICAgICAgIGNvbnN0IGFwaVBhdGggPSAnL2RhdGFiYXNlcy97ZGF0YWJhc2VJZH0vY29sbGVjdGlvbnMve2NvbGxlY3Rpb25JZH0vYXR0cmlidXRlcy9lbWFpbC97a2V5fScucmVwbGFjZSgne2RhdGFiYXNlSWR9JywgZGF0YWJhc2VJZCkucmVwbGFjZSgne2NvbGxlY3Rpb25JZH0nLCBjb2xsZWN0aW9uSWQpLnJlcGxhY2UoJ3trZXl9Jywga2V5KTtcbiAgICAgICAgbGV0IHBheWxvYWQgPSB7fTtcbiAgICAgICAgaWYgKHR5cGVvZiBkYXRhYmFzZUlkID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEFwcHdyaXRlRXhjZXB0aW9uKCdNaXNzaW5nIHJlcXVpcmVkIHBhcmFtZXRlcjogXCJkYXRhYmFzZUlkXCInKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0eXBlb2YgY29sbGVjdGlvbklkID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEFwcHdyaXRlRXhjZXB0aW9uKCdNaXNzaW5nIHJlcXVpcmVkIHBhcmFtZXRlcjogXCJjb2xsZWN0aW9uSWRcIicpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHR5cGVvZiBrZXkgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgQXBwd3JpdGVFeGNlcHRpb24oJ01pc3NpbmcgcmVxdWlyZWQgcGFyYW1ldGVyOiBcImtleVwiJyk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodHlwZW9mIHJlcXVpcmVkID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEFwcHdyaXRlRXhjZXB0aW9uKCdNaXNzaW5nIHJlcXVpcmVkIHBhcmFtZXRlcjogXCJyZXF1aXJlZFwiJyk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodHlwZW9mIHhkZWZhdWx0ID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEFwcHdyaXRlRXhjZXB0aW9uKCdNaXNzaW5nIHJlcXVpcmVkIHBhcmFtZXRlcjogXCJ4ZGVmYXVsdFwiJyk7XG4gICAgICAgIH1cblxuXG4gICAgICAgIGlmICh0eXBlb2YgcmVxdWlyZWQgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICBwYXlsb2FkWydyZXF1aXJlZCddID0gcmVxdWlyZWQ7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodHlwZW9mIHhkZWZhdWx0ICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgcGF5bG9hZFsnZGVmYXVsdCddID0geGRlZmF1bHQ7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy5jbGllbnQuY2FsbCgncGF0Y2gnLCBhcGlQYXRoLCB7XG4gICAgICAgICAgICAnY29udGVudC10eXBlJzogJ2FwcGxpY2F0aW9uL2pzb24nLFxuICAgICAgICB9LCBwYXlsb2FkKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGUgZW51bSBhdHRyaWJ1dGVcbiAgICAgKlxuICAgICAqIENyZWF0ZSBhbiBlbnVtZXJhdGlvbiBhdHRyaWJ1dGUuIFRoZSBgZWxlbWVudHNgIHBhcmFtIGFjdHMgYXMgYSB3aGl0ZS1saXN0XG4gICAgICogb2YgYWNjZXB0ZWQgdmFsdWVzIGZvciB0aGlzIGF0dHJpYnV0ZS4gXG4gICAgICogXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gZGF0YWJhc2VJZFxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBjb2xsZWN0aW9uSWRcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30ga2V5XG4gICAgICogQHBhcmFtIHtzdHJpbmdbXX0gZWxlbWVudHNcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IHJlcXVpcmVkXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHhkZWZhdWx0XG4gICAgICogQHBhcmFtIHtib29sZWFufSBhcnJheVxuICAgICAqIEB0aHJvd3Mge0FwcHdyaXRlRXhjZXB0aW9ufVxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlfVxuICAgICAqL1xuICAgIGFzeW5jIGNyZWF0ZUVudW1BdHRyaWJ1dGUoZGF0YWJhc2VJZCwgY29sbGVjdGlvbklkLCBrZXksIGVsZW1lbnRzLCByZXF1aXJlZCwgeGRlZmF1bHQsIGFycmF5KSB7XG4gICAgICAgIGNvbnN0IGFwaVBhdGggPSAnL2RhdGFiYXNlcy97ZGF0YWJhc2VJZH0vY29sbGVjdGlvbnMve2NvbGxlY3Rpb25JZH0vYXR0cmlidXRlcy9lbnVtJy5yZXBsYWNlKCd7ZGF0YWJhc2VJZH0nLCBkYXRhYmFzZUlkKS5yZXBsYWNlKCd7Y29sbGVjdGlvbklkfScsIGNvbGxlY3Rpb25JZCk7XG4gICAgICAgIGxldCBwYXlsb2FkID0ge307XG4gICAgICAgIGlmICh0eXBlb2YgZGF0YWJhc2VJZCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBBcHB3cml0ZUV4Y2VwdGlvbignTWlzc2luZyByZXF1aXJlZCBwYXJhbWV0ZXI6IFwiZGF0YWJhc2VJZFwiJyk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodHlwZW9mIGNvbGxlY3Rpb25JZCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBBcHB3cml0ZUV4Y2VwdGlvbignTWlzc2luZyByZXF1aXJlZCBwYXJhbWV0ZXI6IFwiY29sbGVjdGlvbklkXCInKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0eXBlb2Yga2V5ID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEFwcHdyaXRlRXhjZXB0aW9uKCdNaXNzaW5nIHJlcXVpcmVkIHBhcmFtZXRlcjogXCJrZXlcIicpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHR5cGVvZiBlbGVtZW50cyA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBBcHB3cml0ZUV4Y2VwdGlvbignTWlzc2luZyByZXF1aXJlZCBwYXJhbWV0ZXI6IFwiZWxlbWVudHNcIicpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHR5cGVvZiByZXF1aXJlZCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBBcHB3cml0ZUV4Y2VwdGlvbignTWlzc2luZyByZXF1aXJlZCBwYXJhbWV0ZXI6IFwicmVxdWlyZWRcIicpO1xuICAgICAgICB9XG5cblxuICAgICAgICBpZiAodHlwZW9mIGtleSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHBheWxvYWRbJ2tleSddID0ga2V5O1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHR5cGVvZiBlbGVtZW50cyAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHBheWxvYWRbJ2VsZW1lbnRzJ10gPSBlbGVtZW50cztcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0eXBlb2YgcmVxdWlyZWQgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICBwYXlsb2FkWydyZXF1aXJlZCddID0gcmVxdWlyZWQ7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodHlwZW9mIHhkZWZhdWx0ICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgcGF5bG9hZFsnZGVmYXVsdCddID0geGRlZmF1bHQ7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodHlwZW9mIGFycmF5ICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgcGF5bG9hZFsnYXJyYXknXSA9IGFycmF5O1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMuY2xpZW50LmNhbGwoJ3Bvc3QnLCBhcGlQYXRoLCB7XG4gICAgICAgICAgICAnY29udGVudC10eXBlJzogJ2FwcGxpY2F0aW9uL2pzb24nLFxuICAgICAgICB9LCBwYXlsb2FkKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBVcGRhdGUgZW51bSBhdHRyaWJ1dGVcbiAgICAgKlxuICAgICAqIFVwZGF0ZSBhbiBlbnVtIGF0dHJpYnV0ZS4gQ2hhbmdpbmcgdGhlIGBkZWZhdWx0YCB2YWx1ZSB3aWxsIG5vdCB1cGRhdGVcbiAgICAgKiBhbHJlYWR5IGV4aXN0aW5nIGRvY3VtZW50cy5cbiAgICAgKiBcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBkYXRhYmFzZUlkXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGNvbGxlY3Rpb25JZFxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBrZXlcbiAgICAgKiBAcGFyYW0ge3N0cmluZ1tdfSBlbGVtZW50c1xuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gcmVxdWlyZWRcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30geGRlZmF1bHRcbiAgICAgKiBAdGhyb3dzIHtBcHB3cml0ZUV4Y2VwdGlvbn1cbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZX1cbiAgICAgKi9cbiAgICBhc3luYyB1cGRhdGVFbnVtQXR0cmlidXRlKGRhdGFiYXNlSWQsIGNvbGxlY3Rpb25JZCwga2V5LCBlbGVtZW50cywgcmVxdWlyZWQsIHhkZWZhdWx0KSB7XG4gICAgICAgIGNvbnN0IGFwaVBhdGggPSAnL2RhdGFiYXNlcy97ZGF0YWJhc2VJZH0vY29sbGVjdGlvbnMve2NvbGxlY3Rpb25JZH0vYXR0cmlidXRlcy9lbnVtL3trZXl9Jy5yZXBsYWNlKCd7ZGF0YWJhc2VJZH0nLCBkYXRhYmFzZUlkKS5yZXBsYWNlKCd7Y29sbGVjdGlvbklkfScsIGNvbGxlY3Rpb25JZCkucmVwbGFjZSgne2tleX0nLCBrZXkpO1xuICAgICAgICBsZXQgcGF5bG9hZCA9IHt9O1xuICAgICAgICBpZiAodHlwZW9mIGRhdGFiYXNlSWQgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgQXBwd3JpdGVFeGNlcHRpb24oJ01pc3NpbmcgcmVxdWlyZWQgcGFyYW1ldGVyOiBcImRhdGFiYXNlSWRcIicpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHR5cGVvZiBjb2xsZWN0aW9uSWQgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgQXBwd3JpdGVFeGNlcHRpb24oJ01pc3NpbmcgcmVxdWlyZWQgcGFyYW1ldGVyOiBcImNvbGxlY3Rpb25JZFwiJyk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodHlwZW9mIGtleSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBBcHB3cml0ZUV4Y2VwdGlvbignTWlzc2luZyByZXF1aXJlZCBwYXJhbWV0ZXI6IFwia2V5XCInKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0eXBlb2YgZWxlbWVudHMgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgQXBwd3JpdGVFeGNlcHRpb24oJ01pc3NpbmcgcmVxdWlyZWQgcGFyYW1ldGVyOiBcImVsZW1lbnRzXCInKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0eXBlb2YgcmVxdWlyZWQgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgQXBwd3JpdGVFeGNlcHRpb24oJ01pc3NpbmcgcmVxdWlyZWQgcGFyYW1ldGVyOiBcInJlcXVpcmVkXCInKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0eXBlb2YgeGRlZmF1bHQgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgQXBwd3JpdGVFeGNlcHRpb24oJ01pc3NpbmcgcmVxdWlyZWQgcGFyYW1ldGVyOiBcInhkZWZhdWx0XCInKTtcbiAgICAgICAgfVxuXG5cbiAgICAgICAgaWYgKHR5cGVvZiBlbGVtZW50cyAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHBheWxvYWRbJ2VsZW1lbnRzJ10gPSBlbGVtZW50cztcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0eXBlb2YgcmVxdWlyZWQgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICBwYXlsb2FkWydyZXF1aXJlZCddID0gcmVxdWlyZWQ7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodHlwZW9mIHhkZWZhdWx0ICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgcGF5bG9hZFsnZGVmYXVsdCddID0geGRlZmF1bHQ7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy5jbGllbnQuY2FsbCgncGF0Y2gnLCBhcGlQYXRoLCB7XG4gICAgICAgICAgICAnY29udGVudC10eXBlJzogJ2FwcGxpY2F0aW9uL2pzb24nLFxuICAgICAgICB9LCBwYXlsb2FkKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGUgZmxvYXQgYXR0cmlidXRlXG4gICAgICpcbiAgICAgKiBDcmVhdGUgYSBmbG9hdCBhdHRyaWJ1dGUuIE9wdGlvbmFsbHksIG1pbmltdW0gYW5kIG1heGltdW0gdmFsdWVzIGNhbiBiZVxuICAgICAqIHByb3ZpZGVkLlxuICAgICAqIFxuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGRhdGFiYXNlSWRcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gY29sbGVjdGlvbklkXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGtleVxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gcmVxdWlyZWRcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gbWluXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IG1heFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB4ZGVmYXVsdFxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gYXJyYXlcbiAgICAgKiBAdGhyb3dzIHtBcHB3cml0ZUV4Y2VwdGlvbn1cbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZX1cbiAgICAgKi9cbiAgICBhc3luYyBjcmVhdGVGbG9hdEF0dHJpYnV0ZShkYXRhYmFzZUlkLCBjb2xsZWN0aW9uSWQsIGtleSwgcmVxdWlyZWQsIG1pbiwgbWF4LCB4ZGVmYXVsdCwgYXJyYXkpIHtcbiAgICAgICAgY29uc3QgYXBpUGF0aCA9ICcvZGF0YWJhc2VzL3tkYXRhYmFzZUlkfS9jb2xsZWN0aW9ucy97Y29sbGVjdGlvbklkfS9hdHRyaWJ1dGVzL2Zsb2F0Jy5yZXBsYWNlKCd7ZGF0YWJhc2VJZH0nLCBkYXRhYmFzZUlkKS5yZXBsYWNlKCd7Y29sbGVjdGlvbklkfScsIGNvbGxlY3Rpb25JZCk7XG4gICAgICAgIGxldCBwYXlsb2FkID0ge307XG4gICAgICAgIGlmICh0eXBlb2YgZGF0YWJhc2VJZCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBBcHB3cml0ZUV4Y2VwdGlvbignTWlzc2luZyByZXF1aXJlZCBwYXJhbWV0ZXI6IFwiZGF0YWJhc2VJZFwiJyk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodHlwZW9mIGNvbGxlY3Rpb25JZCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBBcHB3cml0ZUV4Y2VwdGlvbignTWlzc2luZyByZXF1aXJlZCBwYXJhbWV0ZXI6IFwiY29sbGVjdGlvbklkXCInKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0eXBlb2Yga2V5ID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEFwcHdyaXRlRXhjZXB0aW9uKCdNaXNzaW5nIHJlcXVpcmVkIHBhcmFtZXRlcjogXCJrZXlcIicpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHR5cGVvZiByZXF1aXJlZCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBBcHB3cml0ZUV4Y2VwdGlvbignTWlzc2luZyByZXF1aXJlZCBwYXJhbWV0ZXI6IFwicmVxdWlyZWRcIicpO1xuICAgICAgICB9XG5cblxuICAgICAgICBpZiAodHlwZW9mIGtleSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHBheWxvYWRbJ2tleSddID0ga2V5O1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHR5cGVvZiByZXF1aXJlZCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHBheWxvYWRbJ3JlcXVpcmVkJ10gPSByZXF1aXJlZDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0eXBlb2YgbWluICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgcGF5bG9hZFsnbWluJ10gPSBtaW47XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodHlwZW9mIG1heCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHBheWxvYWRbJ21heCddID0gbWF4O1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHR5cGVvZiB4ZGVmYXVsdCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHBheWxvYWRbJ2RlZmF1bHQnXSA9IHhkZWZhdWx0O1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHR5cGVvZiBhcnJheSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHBheWxvYWRbJ2FycmF5J10gPSBhcnJheTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBhd2FpdCB0aGlzLmNsaWVudC5jYWxsKCdwb3N0JywgYXBpUGF0aCwge1xuICAgICAgICAgICAgJ2NvbnRlbnQtdHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJyxcbiAgICAgICAgfSwgcGF5bG9hZCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVXBkYXRlIGZsb2F0IGF0dHJpYnV0ZVxuICAgICAqXG4gICAgICogVXBkYXRlIGEgZmxvYXQgYXR0cmlidXRlLiBDaGFuZ2luZyB0aGUgYGRlZmF1bHRgIHZhbHVlIHdpbGwgbm90IHVwZGF0ZVxuICAgICAqIGFscmVhZHkgZXhpc3RpbmcgZG9jdW1lbnRzLlxuICAgICAqIFxuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGRhdGFiYXNlSWRcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gY29sbGVjdGlvbklkXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGtleVxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gcmVxdWlyZWRcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gbWluXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IG1heFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB4ZGVmYXVsdFxuICAgICAqIEB0aHJvd3Mge0FwcHdyaXRlRXhjZXB0aW9ufVxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlfVxuICAgICAqL1xuICAgIGFzeW5jIHVwZGF0ZUZsb2F0QXR0cmlidXRlKGRhdGFiYXNlSWQsIGNvbGxlY3Rpb25JZCwga2V5LCByZXF1aXJlZCwgbWluLCBtYXgsIHhkZWZhdWx0KSB7XG4gICAgICAgIGNvbnN0IGFwaVBhdGggPSAnL2RhdGFiYXNlcy97ZGF0YWJhc2VJZH0vY29sbGVjdGlvbnMve2NvbGxlY3Rpb25JZH0vYXR0cmlidXRlcy9mbG9hdC97a2V5fScucmVwbGFjZSgne2RhdGFiYXNlSWR9JywgZGF0YWJhc2VJZCkucmVwbGFjZSgne2NvbGxlY3Rpb25JZH0nLCBjb2xsZWN0aW9uSWQpLnJlcGxhY2UoJ3trZXl9Jywga2V5KTtcbiAgICAgICAgbGV0IHBheWxvYWQgPSB7fTtcbiAgICAgICAgaWYgKHR5cGVvZiBkYXRhYmFzZUlkID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEFwcHdyaXRlRXhjZXB0aW9uKCdNaXNzaW5nIHJlcXVpcmVkIHBhcmFtZXRlcjogXCJkYXRhYmFzZUlkXCInKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0eXBlb2YgY29sbGVjdGlvbklkID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEFwcHdyaXRlRXhjZXB0aW9uKCdNaXNzaW5nIHJlcXVpcmVkIHBhcmFtZXRlcjogXCJjb2xsZWN0aW9uSWRcIicpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHR5cGVvZiBrZXkgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgQXBwd3JpdGVFeGNlcHRpb24oJ01pc3NpbmcgcmVxdWlyZWQgcGFyYW1ldGVyOiBcImtleVwiJyk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodHlwZW9mIHJlcXVpcmVkID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEFwcHdyaXRlRXhjZXB0aW9uKCdNaXNzaW5nIHJlcXVpcmVkIHBhcmFtZXRlcjogXCJyZXF1aXJlZFwiJyk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodHlwZW9mIG1pbiA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBBcHB3cml0ZUV4Y2VwdGlvbignTWlzc2luZyByZXF1aXJlZCBwYXJhbWV0ZXI6IFwibWluXCInKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0eXBlb2YgbWF4ID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEFwcHdyaXRlRXhjZXB0aW9uKCdNaXNzaW5nIHJlcXVpcmVkIHBhcmFtZXRlcjogXCJtYXhcIicpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHR5cGVvZiB4ZGVmYXVsdCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBBcHB3cml0ZUV4Y2VwdGlvbignTWlzc2luZyByZXF1aXJlZCBwYXJhbWV0ZXI6IFwieGRlZmF1bHRcIicpO1xuICAgICAgICB9XG5cblxuICAgICAgICBpZiAodHlwZW9mIHJlcXVpcmVkICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgcGF5bG9hZFsncmVxdWlyZWQnXSA9IHJlcXVpcmVkO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHR5cGVvZiBtaW4gIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICBwYXlsb2FkWydtaW4nXSA9IG1pbjtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0eXBlb2YgbWF4ICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgcGF5bG9hZFsnbWF4J10gPSBtYXg7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodHlwZW9mIHhkZWZhdWx0ICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgcGF5bG9hZFsnZGVmYXVsdCddID0geGRlZmF1bHQ7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy5jbGllbnQuY2FsbCgncGF0Y2gnLCBhcGlQYXRoLCB7XG4gICAgICAgICAgICAnY29udGVudC10eXBlJzogJ2FwcGxpY2F0aW9uL2pzb24nLFxuICAgICAgICB9LCBwYXlsb2FkKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGUgaW50ZWdlciBhdHRyaWJ1dGVcbiAgICAgKlxuICAgICAqIENyZWF0ZSBhbiBpbnRlZ2VyIGF0dHJpYnV0ZS4gT3B0aW9uYWxseSwgbWluaW11bSBhbmQgbWF4aW11bSB2YWx1ZXMgY2FuIGJlXG4gICAgICogcHJvdmlkZWQuXG4gICAgICogXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gZGF0YWJhc2VJZFxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBjb2xsZWN0aW9uSWRcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30ga2V5XG4gICAgICogQHBhcmFtIHtib29sZWFufSByZXF1aXJlZFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBtaW5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gbWF4XG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHhkZWZhdWx0XG4gICAgICogQHBhcmFtIHtib29sZWFufSBhcnJheVxuICAgICAqIEB0aHJvd3Mge0FwcHdyaXRlRXhjZXB0aW9ufVxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlfVxuICAgICAqL1xuICAgIGFzeW5jIGNyZWF0ZUludGVnZXJBdHRyaWJ1dGUoZGF0YWJhc2VJZCwgY29sbGVjdGlvbklkLCBrZXksIHJlcXVpcmVkLCBtaW4sIG1heCwgeGRlZmF1bHQsIGFycmF5KSB7XG4gICAgICAgIGNvbnN0IGFwaVBhdGggPSAnL2RhdGFiYXNlcy97ZGF0YWJhc2VJZH0vY29sbGVjdGlvbnMve2NvbGxlY3Rpb25JZH0vYXR0cmlidXRlcy9pbnRlZ2VyJy5yZXBsYWNlKCd7ZGF0YWJhc2VJZH0nLCBkYXRhYmFzZUlkKS5yZXBsYWNlKCd7Y29sbGVjdGlvbklkfScsIGNvbGxlY3Rpb25JZCk7XG4gICAgICAgIGxldCBwYXlsb2FkID0ge307XG4gICAgICAgIGlmICh0eXBlb2YgZGF0YWJhc2VJZCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBBcHB3cml0ZUV4Y2VwdGlvbignTWlzc2luZyByZXF1aXJlZCBwYXJhbWV0ZXI6IFwiZGF0YWJhc2VJZFwiJyk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodHlwZW9mIGNvbGxlY3Rpb25JZCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBBcHB3cml0ZUV4Y2VwdGlvbignTWlzc2luZyByZXF1aXJlZCBwYXJhbWV0ZXI6IFwiY29sbGVjdGlvbklkXCInKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0eXBlb2Yga2V5ID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEFwcHdyaXRlRXhjZXB0aW9uKCdNaXNzaW5nIHJlcXVpcmVkIHBhcmFtZXRlcjogXCJrZXlcIicpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHR5cGVvZiByZXF1aXJlZCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBBcHB3cml0ZUV4Y2VwdGlvbignTWlzc2luZyByZXF1aXJlZCBwYXJhbWV0ZXI6IFwicmVxdWlyZWRcIicpO1xuICAgICAgICB9XG5cblxuICAgICAgICBpZiAodHlwZW9mIGtleSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHBheWxvYWRbJ2tleSddID0ga2V5O1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHR5cGVvZiByZXF1aXJlZCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHBheWxvYWRbJ3JlcXVpcmVkJ10gPSByZXF1aXJlZDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0eXBlb2YgbWluICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgcGF5bG9hZFsnbWluJ10gPSBtaW47XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodHlwZW9mIG1heCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHBheWxvYWRbJ21heCddID0gbWF4O1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHR5cGVvZiB4ZGVmYXVsdCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHBheWxvYWRbJ2RlZmF1bHQnXSA9IHhkZWZhdWx0O1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHR5cGVvZiBhcnJheSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHBheWxvYWRbJ2FycmF5J10gPSBhcnJheTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBhd2FpdCB0aGlzLmNsaWVudC5jYWxsKCdwb3N0JywgYXBpUGF0aCwge1xuICAgICAgICAgICAgJ2NvbnRlbnQtdHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJyxcbiAgICAgICAgfSwgcGF5bG9hZCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVXBkYXRlIGludGVnZXIgYXR0cmlidXRlXG4gICAgICpcbiAgICAgKiBVcGRhdGUgYW4gaW50ZWdlciBhdHRyaWJ1dGUuIENoYW5naW5nIHRoZSBgZGVmYXVsdGAgdmFsdWUgd2lsbCBub3QgdXBkYXRlXG4gICAgICogYWxyZWFkeSBleGlzdGluZyBkb2N1bWVudHMuXG4gICAgICogXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gZGF0YWJhc2VJZFxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBjb2xsZWN0aW9uSWRcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30ga2V5XG4gICAgICogQHBhcmFtIHtib29sZWFufSByZXF1aXJlZFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBtaW5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gbWF4XG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHhkZWZhdWx0XG4gICAgICogQHRocm93cyB7QXBwd3JpdGVFeGNlcHRpb259XG4gICAgICogQHJldHVybnMge1Byb21pc2V9XG4gICAgICovXG4gICAgYXN5bmMgdXBkYXRlSW50ZWdlckF0dHJpYnV0ZShkYXRhYmFzZUlkLCBjb2xsZWN0aW9uSWQsIGtleSwgcmVxdWlyZWQsIG1pbiwgbWF4LCB4ZGVmYXVsdCkge1xuICAgICAgICBjb25zdCBhcGlQYXRoID0gJy9kYXRhYmFzZXMve2RhdGFiYXNlSWR9L2NvbGxlY3Rpb25zL3tjb2xsZWN0aW9uSWR9L2F0dHJpYnV0ZXMvaW50ZWdlci97a2V5fScucmVwbGFjZSgne2RhdGFiYXNlSWR9JywgZGF0YWJhc2VJZCkucmVwbGFjZSgne2NvbGxlY3Rpb25JZH0nLCBjb2xsZWN0aW9uSWQpLnJlcGxhY2UoJ3trZXl9Jywga2V5KTtcbiAgICAgICAgbGV0IHBheWxvYWQgPSB7fTtcbiAgICAgICAgaWYgKHR5cGVvZiBkYXRhYmFzZUlkID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEFwcHdyaXRlRXhjZXB0aW9uKCdNaXNzaW5nIHJlcXVpcmVkIHBhcmFtZXRlcjogXCJkYXRhYmFzZUlkXCInKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0eXBlb2YgY29sbGVjdGlvbklkID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEFwcHdyaXRlRXhjZXB0aW9uKCdNaXNzaW5nIHJlcXVpcmVkIHBhcmFtZXRlcjogXCJjb2xsZWN0aW9uSWRcIicpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHR5cGVvZiBrZXkgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgQXBwd3JpdGVFeGNlcHRpb24oJ01pc3NpbmcgcmVxdWlyZWQgcGFyYW1ldGVyOiBcImtleVwiJyk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodHlwZW9mIHJlcXVpcmVkID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEFwcHdyaXRlRXhjZXB0aW9uKCdNaXNzaW5nIHJlcXVpcmVkIHBhcmFtZXRlcjogXCJyZXF1aXJlZFwiJyk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodHlwZW9mIG1pbiA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBBcHB3cml0ZUV4Y2VwdGlvbignTWlzc2luZyByZXF1aXJlZCBwYXJhbWV0ZXI6IFwibWluXCInKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0eXBlb2YgbWF4ID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEFwcHdyaXRlRXhjZXB0aW9uKCdNaXNzaW5nIHJlcXVpcmVkIHBhcmFtZXRlcjogXCJtYXhcIicpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHR5cGVvZiB4ZGVmYXVsdCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBBcHB3cml0ZUV4Y2VwdGlvbignTWlzc2luZyByZXF1aXJlZCBwYXJhbWV0ZXI6IFwieGRlZmF1bHRcIicpO1xuICAgICAgICB9XG5cblxuICAgICAgICBpZiAodHlwZW9mIHJlcXVpcmVkICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgcGF5bG9hZFsncmVxdWlyZWQnXSA9IHJlcXVpcmVkO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHR5cGVvZiBtaW4gIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICBwYXlsb2FkWydtaW4nXSA9IG1pbjtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0eXBlb2YgbWF4ICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgcGF5bG9hZFsnbWF4J10gPSBtYXg7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodHlwZW9mIHhkZWZhdWx0ICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgcGF5bG9hZFsnZGVmYXVsdCddID0geGRlZmF1bHQ7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy5jbGllbnQuY2FsbCgncGF0Y2gnLCBhcGlQYXRoLCB7XG4gICAgICAgICAgICAnY29udGVudC10eXBlJzogJ2FwcGxpY2F0aW9uL2pzb24nLFxuICAgICAgICB9LCBwYXlsb2FkKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGUgSVAgYWRkcmVzcyBhdHRyaWJ1dGVcbiAgICAgKlxuICAgICAqIENyZWF0ZSBJUCBhZGRyZXNzIGF0dHJpYnV0ZS5cbiAgICAgKiBcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBkYXRhYmFzZUlkXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGNvbGxlY3Rpb25JZFxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBrZXlcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IHJlcXVpcmVkXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHhkZWZhdWx0XG4gICAgICogQHBhcmFtIHtib29sZWFufSBhcnJheVxuICAgICAqIEB0aHJvd3Mge0FwcHdyaXRlRXhjZXB0aW9ufVxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlfVxuICAgICAqL1xuICAgIGFzeW5jIGNyZWF0ZUlwQXR0cmlidXRlKGRhdGFiYXNlSWQsIGNvbGxlY3Rpb25JZCwga2V5LCByZXF1aXJlZCwgeGRlZmF1bHQsIGFycmF5KSB7XG4gICAgICAgIGNvbnN0IGFwaVBhdGggPSAnL2RhdGFiYXNlcy97ZGF0YWJhc2VJZH0vY29sbGVjdGlvbnMve2NvbGxlY3Rpb25JZH0vYXR0cmlidXRlcy9pcCcucmVwbGFjZSgne2RhdGFiYXNlSWR9JywgZGF0YWJhc2VJZCkucmVwbGFjZSgne2NvbGxlY3Rpb25JZH0nLCBjb2xsZWN0aW9uSWQpO1xuICAgICAgICBsZXQgcGF5bG9hZCA9IHt9O1xuICAgICAgICBpZiAodHlwZW9mIGRhdGFiYXNlSWQgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgQXBwd3JpdGVFeGNlcHRpb24oJ01pc3NpbmcgcmVxdWlyZWQgcGFyYW1ldGVyOiBcImRhdGFiYXNlSWRcIicpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHR5cGVvZiBjb2xsZWN0aW9uSWQgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgQXBwd3JpdGVFeGNlcHRpb24oJ01pc3NpbmcgcmVxdWlyZWQgcGFyYW1ldGVyOiBcImNvbGxlY3Rpb25JZFwiJyk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodHlwZW9mIGtleSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBBcHB3cml0ZUV4Y2VwdGlvbignTWlzc2luZyByZXF1aXJlZCBwYXJhbWV0ZXI6IFwia2V5XCInKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0eXBlb2YgcmVxdWlyZWQgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgQXBwd3JpdGVFeGNlcHRpb24oJ01pc3NpbmcgcmVxdWlyZWQgcGFyYW1ldGVyOiBcInJlcXVpcmVkXCInKTtcbiAgICAgICAgfVxuXG5cbiAgICAgICAgaWYgKHR5cGVvZiBrZXkgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICBwYXlsb2FkWydrZXknXSA9IGtleTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0eXBlb2YgcmVxdWlyZWQgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICBwYXlsb2FkWydyZXF1aXJlZCddID0gcmVxdWlyZWQ7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodHlwZW9mIHhkZWZhdWx0ICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgcGF5bG9hZFsnZGVmYXVsdCddID0geGRlZmF1bHQ7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodHlwZW9mIGFycmF5ICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgcGF5bG9hZFsnYXJyYXknXSA9IGFycmF5O1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMuY2xpZW50LmNhbGwoJ3Bvc3QnLCBhcGlQYXRoLCB7XG4gICAgICAgICAgICAnY29udGVudC10eXBlJzogJ2FwcGxpY2F0aW9uL2pzb24nLFxuICAgICAgICB9LCBwYXlsb2FkKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBVcGRhdGUgSVAgYWRkcmVzcyBhdHRyaWJ1dGVcbiAgICAgKlxuICAgICAqIFVwZGF0ZSBhbiBpcCBhdHRyaWJ1dGUuIENoYW5naW5nIHRoZSBgZGVmYXVsdGAgdmFsdWUgd2lsbCBub3QgdXBkYXRlXG4gICAgICogYWxyZWFkeSBleGlzdGluZyBkb2N1bWVudHMuXG4gICAgICogXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gZGF0YWJhc2VJZFxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBjb2xsZWN0aW9uSWRcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30ga2V5XG4gICAgICogQHBhcmFtIHtib29sZWFufSByZXF1aXJlZFxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSB4ZGVmYXVsdFxuICAgICAqIEB0aHJvd3Mge0FwcHdyaXRlRXhjZXB0aW9ufVxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlfVxuICAgICAqL1xuICAgIGFzeW5jIHVwZGF0ZUlwQXR0cmlidXRlKGRhdGFiYXNlSWQsIGNvbGxlY3Rpb25JZCwga2V5LCByZXF1aXJlZCwgeGRlZmF1bHQpIHtcbiAgICAgICAgY29uc3QgYXBpUGF0aCA9ICcvZGF0YWJhc2VzL3tkYXRhYmFzZUlkfS9jb2xsZWN0aW9ucy97Y29sbGVjdGlvbklkfS9hdHRyaWJ1dGVzL2lwL3trZXl9Jy5yZXBsYWNlKCd7ZGF0YWJhc2VJZH0nLCBkYXRhYmFzZUlkKS5yZXBsYWNlKCd7Y29sbGVjdGlvbklkfScsIGNvbGxlY3Rpb25JZCkucmVwbGFjZSgne2tleX0nLCBrZXkpO1xuICAgICAgICBsZXQgcGF5bG9hZCA9IHt9O1xuICAgICAgICBpZiAodHlwZW9mIGRhdGFiYXNlSWQgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgQXBwd3JpdGVFeGNlcHRpb24oJ01pc3NpbmcgcmVxdWlyZWQgcGFyYW1ldGVyOiBcImRhdGFiYXNlSWRcIicpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHR5cGVvZiBjb2xsZWN0aW9uSWQgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgQXBwd3JpdGVFeGNlcHRpb24oJ01pc3NpbmcgcmVxdWlyZWQgcGFyYW1ldGVyOiBcImNvbGxlY3Rpb25JZFwiJyk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodHlwZW9mIGtleSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBBcHB3cml0ZUV4Y2VwdGlvbignTWlzc2luZyByZXF1aXJlZCBwYXJhbWV0ZXI6IFwia2V5XCInKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0eXBlb2YgcmVxdWlyZWQgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgQXBwd3JpdGVFeGNlcHRpb24oJ01pc3NpbmcgcmVxdWlyZWQgcGFyYW1ldGVyOiBcInJlcXVpcmVkXCInKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0eXBlb2YgeGRlZmF1bHQgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgQXBwd3JpdGVFeGNlcHRpb24oJ01pc3NpbmcgcmVxdWlyZWQgcGFyYW1ldGVyOiBcInhkZWZhdWx0XCInKTtcbiAgICAgICAgfVxuXG5cbiAgICAgICAgaWYgKHR5cGVvZiByZXF1aXJlZCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHBheWxvYWRbJ3JlcXVpcmVkJ10gPSByZXF1aXJlZDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0eXBlb2YgeGRlZmF1bHQgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICBwYXlsb2FkWydkZWZhdWx0J10gPSB4ZGVmYXVsdDtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBhd2FpdCB0aGlzLmNsaWVudC5jYWxsKCdwYXRjaCcsIGFwaVBhdGgsIHtcbiAgICAgICAgICAgICdjb250ZW50LXR5cGUnOiAnYXBwbGljYXRpb24vanNvbicsXG4gICAgICAgIH0sIHBheWxvYWQpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZSByZWxhdGlvbnNoaXAgYXR0cmlidXRlXG4gICAgICpcbiAgICAgKiBDcmVhdGUgcmVsYXRpb25zaGlwIGF0dHJpYnV0ZS4gW0xlYXJuIG1vcmUgYWJvdXQgcmVsYXRpb25zaGlwXG4gICAgICogYXR0cmlidXRlc10oaHR0cHM6Ly9hcHB3cml0ZS5pby9kb2NzL2RhdGFiYXNlcy1yZWxhdGlvbnNoaXBzI3JlbGF0aW9uc2hpcC1hdHRyaWJ1dGVzKS5cbiAgICAgKiBcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBkYXRhYmFzZUlkXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGNvbGxlY3Rpb25JZFxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSByZWxhdGVkQ29sbGVjdGlvbklkXG4gICAgICogQHBhcmFtIHtSZWxhdGlvbnNoaXBUeXBlfSB0eXBlXG4gICAgICogQHBhcmFtIHtib29sZWFufSB0d29XYXlcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30ga2V5XG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHR3b1dheUtleVxuICAgICAqIEBwYXJhbSB7UmVsYXRpb25NdXRhdGV9IG9uRGVsZXRlXG4gICAgICogQHRocm93cyB7QXBwd3JpdGVFeGNlcHRpb259XG4gICAgICogQHJldHVybnMge1Byb21pc2V9XG4gICAgICovXG4gICAgYXN5bmMgY3JlYXRlUmVsYXRpb25zaGlwQXR0cmlidXRlKGRhdGFiYXNlSWQsIGNvbGxlY3Rpb25JZCwgcmVsYXRlZENvbGxlY3Rpb25JZCwgdHlwZSwgdHdvV2F5LCBrZXksIHR3b1dheUtleSwgb25EZWxldGUpIHtcbiAgICAgICAgY29uc3QgYXBpUGF0aCA9ICcvZGF0YWJhc2VzL3tkYXRhYmFzZUlkfS9jb2xsZWN0aW9ucy97Y29sbGVjdGlvbklkfS9hdHRyaWJ1dGVzL3JlbGF0aW9uc2hpcCcucmVwbGFjZSgne2RhdGFiYXNlSWR9JywgZGF0YWJhc2VJZCkucmVwbGFjZSgne2NvbGxlY3Rpb25JZH0nLCBjb2xsZWN0aW9uSWQpO1xuICAgICAgICBsZXQgcGF5bG9hZCA9IHt9O1xuICAgICAgICBpZiAodHlwZW9mIGRhdGFiYXNlSWQgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgQXBwd3JpdGVFeGNlcHRpb24oJ01pc3NpbmcgcmVxdWlyZWQgcGFyYW1ldGVyOiBcImRhdGFiYXNlSWRcIicpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHR5cGVvZiBjb2xsZWN0aW9uSWQgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgQXBwd3JpdGVFeGNlcHRpb24oJ01pc3NpbmcgcmVxdWlyZWQgcGFyYW1ldGVyOiBcImNvbGxlY3Rpb25JZFwiJyk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodHlwZW9mIHJlbGF0ZWRDb2xsZWN0aW9uSWQgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgQXBwd3JpdGVFeGNlcHRpb24oJ01pc3NpbmcgcmVxdWlyZWQgcGFyYW1ldGVyOiBcInJlbGF0ZWRDb2xsZWN0aW9uSWRcIicpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHR5cGVvZiB0eXBlID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEFwcHdyaXRlRXhjZXB0aW9uKCdNaXNzaW5nIHJlcXVpcmVkIHBhcmFtZXRlcjogXCJ0eXBlXCInKTtcbiAgICAgICAgfVxuXG5cbiAgICAgICAgaWYgKHR5cGVvZiByZWxhdGVkQ29sbGVjdGlvbklkICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgcGF5bG9hZFsncmVsYXRlZENvbGxlY3Rpb25JZCddID0gcmVsYXRlZENvbGxlY3Rpb25JZDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0eXBlb2YgdHlwZSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHBheWxvYWRbJ3R5cGUnXSA9IHR5cGU7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodHlwZW9mIHR3b1dheSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHBheWxvYWRbJ3R3b1dheSddID0gdHdvV2F5O1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHR5cGVvZiBrZXkgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICBwYXlsb2FkWydrZXknXSA9IGtleTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0eXBlb2YgdHdvV2F5S2V5ICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgcGF5bG9hZFsndHdvV2F5S2V5J10gPSB0d29XYXlLZXk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodHlwZW9mIG9uRGVsZXRlICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgcGF5bG9hZFsnb25EZWxldGUnXSA9IG9uRGVsZXRlO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMuY2xpZW50LmNhbGwoJ3Bvc3QnLCBhcGlQYXRoLCB7XG4gICAgICAgICAgICAnY29udGVudC10eXBlJzogJ2FwcGxpY2F0aW9uL2pzb24nLFxuICAgICAgICB9LCBwYXlsb2FkKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGUgc3RyaW5nIGF0dHJpYnV0ZVxuICAgICAqXG4gICAgICogQ3JlYXRlIGEgc3RyaW5nIGF0dHJpYnV0ZS5cbiAgICAgKiBcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBkYXRhYmFzZUlkXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGNvbGxlY3Rpb25JZFxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBrZXlcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gc2l6ZVxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gcmVxdWlyZWRcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30geGRlZmF1bHRcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IGFycmF5XG4gICAgICogQHBhcmFtIHtib29sZWFufSBlbmNyeXB0XG4gICAgICogQHRocm93cyB7QXBwd3JpdGVFeGNlcHRpb259XG4gICAgICogQHJldHVybnMge1Byb21pc2V9XG4gICAgICovXG4gICAgYXN5bmMgY3JlYXRlU3RyaW5nQXR0cmlidXRlKGRhdGFiYXNlSWQsIGNvbGxlY3Rpb25JZCwga2V5LCBzaXplLCByZXF1aXJlZCwgeGRlZmF1bHQsIGFycmF5LCBlbmNyeXB0KSB7XG4gICAgICAgIGNvbnN0IGFwaVBhdGggPSAnL2RhdGFiYXNlcy97ZGF0YWJhc2VJZH0vY29sbGVjdGlvbnMve2NvbGxlY3Rpb25JZH0vYXR0cmlidXRlcy9zdHJpbmcnLnJlcGxhY2UoJ3tkYXRhYmFzZUlkfScsIGRhdGFiYXNlSWQpLnJlcGxhY2UoJ3tjb2xsZWN0aW9uSWR9JywgY29sbGVjdGlvbklkKTtcbiAgICAgICAgbGV0IHBheWxvYWQgPSB7fTtcbiAgICAgICAgaWYgKHR5cGVvZiBkYXRhYmFzZUlkID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEFwcHdyaXRlRXhjZXB0aW9uKCdNaXNzaW5nIHJlcXVpcmVkIHBhcmFtZXRlcjogXCJkYXRhYmFzZUlkXCInKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0eXBlb2YgY29sbGVjdGlvbklkID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEFwcHdyaXRlRXhjZXB0aW9uKCdNaXNzaW5nIHJlcXVpcmVkIHBhcmFtZXRlcjogXCJjb2xsZWN0aW9uSWRcIicpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHR5cGVvZiBrZXkgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgQXBwd3JpdGVFeGNlcHRpb24oJ01pc3NpbmcgcmVxdWlyZWQgcGFyYW1ldGVyOiBcImtleVwiJyk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodHlwZW9mIHNpemUgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgQXBwd3JpdGVFeGNlcHRpb24oJ01pc3NpbmcgcmVxdWlyZWQgcGFyYW1ldGVyOiBcInNpemVcIicpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHR5cGVvZiByZXF1aXJlZCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBBcHB3cml0ZUV4Y2VwdGlvbignTWlzc2luZyByZXF1aXJlZCBwYXJhbWV0ZXI6IFwicmVxdWlyZWRcIicpO1xuICAgICAgICB9XG5cblxuICAgICAgICBpZiAodHlwZW9mIGtleSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHBheWxvYWRbJ2tleSddID0ga2V5O1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHR5cGVvZiBzaXplICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgcGF5bG9hZFsnc2l6ZSddID0gc2l6ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0eXBlb2YgcmVxdWlyZWQgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICBwYXlsb2FkWydyZXF1aXJlZCddID0gcmVxdWlyZWQ7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodHlwZW9mIHhkZWZhdWx0ICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgcGF5bG9hZFsnZGVmYXVsdCddID0geGRlZmF1bHQ7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodHlwZW9mIGFycmF5ICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgcGF5bG9hZFsnYXJyYXknXSA9IGFycmF5O1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHR5cGVvZiBlbmNyeXB0ICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgcGF5bG9hZFsnZW5jcnlwdCddID0gZW5jcnlwdDtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBhd2FpdCB0aGlzLmNsaWVudC5jYWxsKCdwb3N0JywgYXBpUGF0aCwge1xuICAgICAgICAgICAgJ2NvbnRlbnQtdHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJyxcbiAgICAgICAgfSwgcGF5bG9hZCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVXBkYXRlIHN0cmluZyBhdHRyaWJ1dGVcbiAgICAgKlxuICAgICAqIFVwZGF0ZSBhIHN0cmluZyBhdHRyaWJ1dGUuIENoYW5naW5nIHRoZSBgZGVmYXVsdGAgdmFsdWUgd2lsbCBub3QgdXBkYXRlXG4gICAgICogYWxyZWFkeSBleGlzdGluZyBkb2N1bWVudHMuXG4gICAgICogXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gZGF0YWJhc2VJZFxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBjb2xsZWN0aW9uSWRcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30ga2V5XG4gICAgICogQHBhcmFtIHtib29sZWFufSByZXF1aXJlZFxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSB4ZGVmYXVsdFxuICAgICAqIEB0aHJvd3Mge0FwcHdyaXRlRXhjZXB0aW9ufVxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlfVxuICAgICAqL1xuICAgIGFzeW5jIHVwZGF0ZVN0cmluZ0F0dHJpYnV0ZShkYXRhYmFzZUlkLCBjb2xsZWN0aW9uSWQsIGtleSwgcmVxdWlyZWQsIHhkZWZhdWx0KSB7XG4gICAgICAgIGNvbnN0IGFwaVBhdGggPSAnL2RhdGFiYXNlcy97ZGF0YWJhc2VJZH0vY29sbGVjdGlvbnMve2NvbGxlY3Rpb25JZH0vYXR0cmlidXRlcy9zdHJpbmcve2tleX0nLnJlcGxhY2UoJ3tkYXRhYmFzZUlkfScsIGRhdGFiYXNlSWQpLnJlcGxhY2UoJ3tjb2xsZWN0aW9uSWR9JywgY29sbGVjdGlvbklkKS5yZXBsYWNlKCd7a2V5fScsIGtleSk7XG4gICAgICAgIGxldCBwYXlsb2FkID0ge307XG4gICAgICAgIGlmICh0eXBlb2YgZGF0YWJhc2VJZCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBBcHB3cml0ZUV4Y2VwdGlvbignTWlzc2luZyByZXF1aXJlZCBwYXJhbWV0ZXI6IFwiZGF0YWJhc2VJZFwiJyk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodHlwZW9mIGNvbGxlY3Rpb25JZCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBBcHB3cml0ZUV4Y2VwdGlvbignTWlzc2luZyByZXF1aXJlZCBwYXJhbWV0ZXI6IFwiY29sbGVjdGlvbklkXCInKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0eXBlb2Yga2V5ID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEFwcHdyaXRlRXhjZXB0aW9uKCdNaXNzaW5nIHJlcXVpcmVkIHBhcmFtZXRlcjogXCJrZXlcIicpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHR5cGVvZiByZXF1aXJlZCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBBcHB3cml0ZUV4Y2VwdGlvbignTWlzc2luZyByZXF1aXJlZCBwYXJhbWV0ZXI6IFwicmVxdWlyZWRcIicpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHR5cGVvZiB4ZGVmYXVsdCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBBcHB3cml0ZUV4Y2VwdGlvbignTWlzc2luZyByZXF1aXJlZCBwYXJhbWV0ZXI6IFwieGRlZmF1bHRcIicpO1xuICAgICAgICB9XG5cblxuICAgICAgICBpZiAodHlwZW9mIHJlcXVpcmVkICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgcGF5bG9hZFsncmVxdWlyZWQnXSA9IHJlcXVpcmVkO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHR5cGVvZiB4ZGVmYXVsdCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHBheWxvYWRbJ2RlZmF1bHQnXSA9IHhkZWZhdWx0O1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMuY2xpZW50LmNhbGwoJ3BhdGNoJywgYXBpUGF0aCwge1xuICAgICAgICAgICAgJ2NvbnRlbnQtdHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJyxcbiAgICAgICAgfSwgcGF5bG9hZCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlIFVSTCBhdHRyaWJ1dGVcbiAgICAgKlxuICAgICAqIENyZWF0ZSBhIFVSTCBhdHRyaWJ1dGUuXG4gICAgICogXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gZGF0YWJhc2VJZFxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBjb2xsZWN0aW9uSWRcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30ga2V5XG4gICAgICogQHBhcmFtIHtib29sZWFufSByZXF1aXJlZFxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSB4ZGVmYXVsdFxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gYXJyYXlcbiAgICAgKiBAdGhyb3dzIHtBcHB3cml0ZUV4Y2VwdGlvbn1cbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZX1cbiAgICAgKi9cbiAgICBhc3luYyBjcmVhdGVVcmxBdHRyaWJ1dGUoZGF0YWJhc2VJZCwgY29sbGVjdGlvbklkLCBrZXksIHJlcXVpcmVkLCB4ZGVmYXVsdCwgYXJyYXkpIHtcbiAgICAgICAgY29uc3QgYXBpUGF0aCA9ICcvZGF0YWJhc2VzL3tkYXRhYmFzZUlkfS9jb2xsZWN0aW9ucy97Y29sbGVjdGlvbklkfS9hdHRyaWJ1dGVzL3VybCcucmVwbGFjZSgne2RhdGFiYXNlSWR9JywgZGF0YWJhc2VJZCkucmVwbGFjZSgne2NvbGxlY3Rpb25JZH0nLCBjb2xsZWN0aW9uSWQpO1xuICAgICAgICBsZXQgcGF5bG9hZCA9IHt9O1xuICAgICAgICBpZiAodHlwZW9mIGRhdGFiYXNlSWQgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgQXBwd3JpdGVFeGNlcHRpb24oJ01pc3NpbmcgcmVxdWlyZWQgcGFyYW1ldGVyOiBcImRhdGFiYXNlSWRcIicpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHR5cGVvZiBjb2xsZWN0aW9uSWQgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgQXBwd3JpdGVFeGNlcHRpb24oJ01pc3NpbmcgcmVxdWlyZWQgcGFyYW1ldGVyOiBcImNvbGxlY3Rpb25JZFwiJyk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodHlwZW9mIGtleSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBBcHB3cml0ZUV4Y2VwdGlvbignTWlzc2luZyByZXF1aXJlZCBwYXJhbWV0ZXI6IFwia2V5XCInKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0eXBlb2YgcmVxdWlyZWQgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgQXBwd3JpdGVFeGNlcHRpb24oJ01pc3NpbmcgcmVxdWlyZWQgcGFyYW1ldGVyOiBcInJlcXVpcmVkXCInKTtcbiAgICAgICAgfVxuXG5cbiAgICAgICAgaWYgKHR5cGVvZiBrZXkgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICBwYXlsb2FkWydrZXknXSA9IGtleTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0eXBlb2YgcmVxdWlyZWQgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICBwYXlsb2FkWydyZXF1aXJlZCddID0gcmVxdWlyZWQ7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodHlwZW9mIHhkZWZhdWx0ICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgcGF5bG9hZFsnZGVmYXVsdCddID0geGRlZmF1bHQ7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodHlwZW9mIGFycmF5ICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgcGF5bG9hZFsnYXJyYXknXSA9IGFycmF5O1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMuY2xpZW50LmNhbGwoJ3Bvc3QnLCBhcGlQYXRoLCB7XG4gICAgICAgICAgICAnY29udGVudC10eXBlJzogJ2FwcGxpY2F0aW9uL2pzb24nLFxuICAgICAgICB9LCBwYXlsb2FkKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBVcGRhdGUgVVJMIGF0dHJpYnV0ZVxuICAgICAqXG4gICAgICogVXBkYXRlIGFuIHVybCBhdHRyaWJ1dGUuIENoYW5naW5nIHRoZSBgZGVmYXVsdGAgdmFsdWUgd2lsbCBub3QgdXBkYXRlXG4gICAgICogYWxyZWFkeSBleGlzdGluZyBkb2N1bWVudHMuXG4gICAgICogXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gZGF0YWJhc2VJZFxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBjb2xsZWN0aW9uSWRcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30ga2V5XG4gICAgICogQHBhcmFtIHtib29sZWFufSByZXF1aXJlZFxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSB4ZGVmYXVsdFxuICAgICAqIEB0aHJvd3Mge0FwcHdyaXRlRXhjZXB0aW9ufVxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlfVxuICAgICAqL1xuICAgIGFzeW5jIHVwZGF0ZVVybEF0dHJpYnV0ZShkYXRhYmFzZUlkLCBjb2xsZWN0aW9uSWQsIGtleSwgcmVxdWlyZWQsIHhkZWZhdWx0KSB7XG4gICAgICAgIGNvbnN0IGFwaVBhdGggPSAnL2RhdGFiYXNlcy97ZGF0YWJhc2VJZH0vY29sbGVjdGlvbnMve2NvbGxlY3Rpb25JZH0vYXR0cmlidXRlcy91cmwve2tleX0nLnJlcGxhY2UoJ3tkYXRhYmFzZUlkfScsIGRhdGFiYXNlSWQpLnJlcGxhY2UoJ3tjb2xsZWN0aW9uSWR9JywgY29sbGVjdGlvbklkKS5yZXBsYWNlKCd7a2V5fScsIGtleSk7XG4gICAgICAgIGxldCBwYXlsb2FkID0ge307XG4gICAgICAgIGlmICh0eXBlb2YgZGF0YWJhc2VJZCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBBcHB3cml0ZUV4Y2VwdGlvbignTWlzc2luZyByZXF1aXJlZCBwYXJhbWV0ZXI6IFwiZGF0YWJhc2VJZFwiJyk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodHlwZW9mIGNvbGxlY3Rpb25JZCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBBcHB3cml0ZUV4Y2VwdGlvbignTWlzc2luZyByZXF1aXJlZCBwYXJhbWV0ZXI6IFwiY29sbGVjdGlvbklkXCInKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0eXBlb2Yga2V5ID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEFwcHdyaXRlRXhjZXB0aW9uKCdNaXNzaW5nIHJlcXVpcmVkIHBhcmFtZXRlcjogXCJrZXlcIicpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHR5cGVvZiByZXF1aXJlZCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBBcHB3cml0ZUV4Y2VwdGlvbignTWlzc2luZyByZXF1aXJlZCBwYXJhbWV0ZXI6IFwicmVxdWlyZWRcIicpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHR5cGVvZiB4ZGVmYXVsdCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBBcHB3cml0ZUV4Y2VwdGlvbignTWlzc2luZyByZXF1aXJlZCBwYXJhbWV0ZXI6IFwieGRlZmF1bHRcIicpO1xuICAgICAgICB9XG5cblxuICAgICAgICBpZiAodHlwZW9mIHJlcXVpcmVkICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgcGF5bG9hZFsncmVxdWlyZWQnXSA9IHJlcXVpcmVkO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHR5cGVvZiB4ZGVmYXVsdCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHBheWxvYWRbJ2RlZmF1bHQnXSA9IHhkZWZhdWx0O1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMuY2xpZW50LmNhbGwoJ3BhdGNoJywgYXBpUGF0aCwge1xuICAgICAgICAgICAgJ2NvbnRlbnQtdHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJyxcbiAgICAgICAgfSwgcGF5bG9hZCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2V0IGF0dHJpYnV0ZVxuICAgICAqXG4gICAgICogR2V0IGF0dHJpYnV0ZSBieSBJRC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBkYXRhYmFzZUlkXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGNvbGxlY3Rpb25JZFxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBrZXlcbiAgICAgKiBAdGhyb3dzIHtBcHB3cml0ZUV4Y2VwdGlvbn1cbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZX1cbiAgICAgKi9cbiAgICBhc3luYyBnZXRBdHRyaWJ1dGUoZGF0YWJhc2VJZCwgY29sbGVjdGlvbklkLCBrZXkpIHtcbiAgICAgICAgY29uc3QgYXBpUGF0aCA9ICcvZGF0YWJhc2VzL3tkYXRhYmFzZUlkfS9jb2xsZWN0aW9ucy97Y29sbGVjdGlvbklkfS9hdHRyaWJ1dGVzL3trZXl9Jy5yZXBsYWNlKCd7ZGF0YWJhc2VJZH0nLCBkYXRhYmFzZUlkKS5yZXBsYWNlKCd7Y29sbGVjdGlvbklkfScsIGNvbGxlY3Rpb25JZCkucmVwbGFjZSgne2tleX0nLCBrZXkpO1xuICAgICAgICBsZXQgcGF5bG9hZCA9IHt9O1xuICAgICAgICBpZiAodHlwZW9mIGRhdGFiYXNlSWQgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgQXBwd3JpdGVFeGNlcHRpb24oJ01pc3NpbmcgcmVxdWlyZWQgcGFyYW1ldGVyOiBcImRhdGFiYXNlSWRcIicpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHR5cGVvZiBjb2xsZWN0aW9uSWQgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgQXBwd3JpdGVFeGNlcHRpb24oJ01pc3NpbmcgcmVxdWlyZWQgcGFyYW1ldGVyOiBcImNvbGxlY3Rpb25JZFwiJyk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodHlwZW9mIGtleSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBBcHB3cml0ZUV4Y2VwdGlvbignTWlzc2luZyByZXF1aXJlZCBwYXJhbWV0ZXI6IFwia2V5XCInKTtcbiAgICAgICAgfVxuXG5cbiAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMuY2xpZW50LmNhbGwoJ2dldCcsIGFwaVBhdGgsIHtcbiAgICAgICAgICAgICdjb250ZW50LXR5cGUnOiAnYXBwbGljYXRpb24vanNvbicsXG4gICAgICAgIH0sIHBheWxvYWQpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIERlbGV0ZSBhdHRyaWJ1dGVcbiAgICAgKlxuICAgICAqIERlbGV0ZXMgYW4gYXR0cmlidXRlLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGRhdGFiYXNlSWRcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gY29sbGVjdGlvbklkXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGtleVxuICAgICAqIEB0aHJvd3Mge0FwcHdyaXRlRXhjZXB0aW9ufVxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlfVxuICAgICAqL1xuICAgIGFzeW5jIGRlbGV0ZUF0dHJpYnV0ZShkYXRhYmFzZUlkLCBjb2xsZWN0aW9uSWQsIGtleSkge1xuICAgICAgICBjb25zdCBhcGlQYXRoID0gJy9kYXRhYmFzZXMve2RhdGFiYXNlSWR9L2NvbGxlY3Rpb25zL3tjb2xsZWN0aW9uSWR9L2F0dHJpYnV0ZXMve2tleX0nLnJlcGxhY2UoJ3tkYXRhYmFzZUlkfScsIGRhdGFiYXNlSWQpLnJlcGxhY2UoJ3tjb2xsZWN0aW9uSWR9JywgY29sbGVjdGlvbklkKS5yZXBsYWNlKCd7a2V5fScsIGtleSk7XG4gICAgICAgIGxldCBwYXlsb2FkID0ge307XG4gICAgICAgIGlmICh0eXBlb2YgZGF0YWJhc2VJZCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBBcHB3cml0ZUV4Y2VwdGlvbignTWlzc2luZyByZXF1aXJlZCBwYXJhbWV0ZXI6IFwiZGF0YWJhc2VJZFwiJyk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodHlwZW9mIGNvbGxlY3Rpb25JZCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBBcHB3cml0ZUV4Y2VwdGlvbignTWlzc2luZyByZXF1aXJlZCBwYXJhbWV0ZXI6IFwiY29sbGVjdGlvbklkXCInKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0eXBlb2Yga2V5ID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEFwcHdyaXRlRXhjZXB0aW9uKCdNaXNzaW5nIHJlcXVpcmVkIHBhcmFtZXRlcjogXCJrZXlcIicpO1xuICAgICAgICB9XG5cblxuICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy5jbGllbnQuY2FsbCgnZGVsZXRlJywgYXBpUGF0aCwge1xuICAgICAgICAgICAgJ2NvbnRlbnQtdHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJyxcbiAgICAgICAgfSwgcGF5bG9hZCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVXBkYXRlIHJlbGF0aW9uc2hpcCBhdHRyaWJ1dGVcbiAgICAgKlxuICAgICAqIFVwZGF0ZSByZWxhdGlvbnNoaXAgYXR0cmlidXRlLiBbTGVhcm4gbW9yZSBhYm91dCByZWxhdGlvbnNoaXBcbiAgICAgKiBhdHRyaWJ1dGVzXShodHRwczovL2FwcHdyaXRlLmlvL2RvY3MvZGF0YWJhc2VzLXJlbGF0aW9uc2hpcHMjcmVsYXRpb25zaGlwLWF0dHJpYnV0ZXMpLlxuICAgICAqIFxuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGRhdGFiYXNlSWRcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gY29sbGVjdGlvbklkXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGtleVxuICAgICAqIEBwYXJhbSB7UmVsYXRpb25NdXRhdGV9IG9uRGVsZXRlXG4gICAgICogQHRocm93cyB7QXBwd3JpdGVFeGNlcHRpb259XG4gICAgICogQHJldHVybnMge1Byb21pc2V9XG4gICAgICovXG4gICAgYXN5bmMgdXBkYXRlUmVsYXRpb25zaGlwQXR0cmlidXRlKGRhdGFiYXNlSWQsIGNvbGxlY3Rpb25JZCwga2V5LCBvbkRlbGV0ZSkge1xuICAgICAgICBjb25zdCBhcGlQYXRoID0gJy9kYXRhYmFzZXMve2RhdGFiYXNlSWR9L2NvbGxlY3Rpb25zL3tjb2xsZWN0aW9uSWR9L2F0dHJpYnV0ZXMve2tleX0vcmVsYXRpb25zaGlwJy5yZXBsYWNlKCd7ZGF0YWJhc2VJZH0nLCBkYXRhYmFzZUlkKS5yZXBsYWNlKCd7Y29sbGVjdGlvbklkfScsIGNvbGxlY3Rpb25JZCkucmVwbGFjZSgne2tleX0nLCBrZXkpO1xuICAgICAgICBsZXQgcGF5bG9hZCA9IHt9O1xuICAgICAgICBpZiAodHlwZW9mIGRhdGFiYXNlSWQgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgQXBwd3JpdGVFeGNlcHRpb24oJ01pc3NpbmcgcmVxdWlyZWQgcGFyYW1ldGVyOiBcImRhdGFiYXNlSWRcIicpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHR5cGVvZiBjb2xsZWN0aW9uSWQgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgQXBwd3JpdGVFeGNlcHRpb24oJ01pc3NpbmcgcmVxdWlyZWQgcGFyYW1ldGVyOiBcImNvbGxlY3Rpb25JZFwiJyk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodHlwZW9mIGtleSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBBcHB3cml0ZUV4Y2VwdGlvbignTWlzc2luZyByZXF1aXJlZCBwYXJhbWV0ZXI6IFwia2V5XCInKTtcbiAgICAgICAgfVxuXG5cbiAgICAgICAgaWYgKHR5cGVvZiBvbkRlbGV0ZSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHBheWxvYWRbJ29uRGVsZXRlJ10gPSBvbkRlbGV0ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBhd2FpdCB0aGlzLmNsaWVudC5jYWxsKCdwYXRjaCcsIGFwaVBhdGgsIHtcbiAgICAgICAgICAgICdjb250ZW50LXR5cGUnOiAnYXBwbGljYXRpb24vanNvbicsXG4gICAgICAgIH0sIHBheWxvYWQpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIExpc3QgZG9jdW1lbnRzXG4gICAgICpcbiAgICAgKiBHZXQgYSBsaXN0IG9mIGFsbCB0aGUgdXNlcidzIGRvY3VtZW50cyBpbiBhIGdpdmVuIGNvbGxlY3Rpb24uIFlvdSBjYW4gdXNlXG4gICAgICogdGhlIHF1ZXJ5IHBhcmFtcyB0byBmaWx0ZXIgeW91ciByZXN1bHRzLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGRhdGFiYXNlSWRcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gY29sbGVjdGlvbklkXG4gICAgICogQHBhcmFtIHtzdHJpbmdbXX0gcXVlcmllc1xuICAgICAqIEB0aHJvd3Mge0FwcHdyaXRlRXhjZXB0aW9ufVxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlfVxuICAgICAqL1xuICAgIGFzeW5jIGxpc3REb2N1bWVudHMoZGF0YWJhc2VJZCwgY29sbGVjdGlvbklkLCBxdWVyaWVzKSB7XG4gICAgICAgIGNvbnN0IGFwaVBhdGggPSAnL2RhdGFiYXNlcy97ZGF0YWJhc2VJZH0vY29sbGVjdGlvbnMve2NvbGxlY3Rpb25JZH0vZG9jdW1lbnRzJy5yZXBsYWNlKCd7ZGF0YWJhc2VJZH0nLCBkYXRhYmFzZUlkKS5yZXBsYWNlKCd7Y29sbGVjdGlvbklkfScsIGNvbGxlY3Rpb25JZCk7XG4gICAgICAgIGxldCBwYXlsb2FkID0ge307XG4gICAgICAgIGlmICh0eXBlb2YgZGF0YWJhc2VJZCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBBcHB3cml0ZUV4Y2VwdGlvbignTWlzc2luZyByZXF1aXJlZCBwYXJhbWV0ZXI6IFwiZGF0YWJhc2VJZFwiJyk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodHlwZW9mIGNvbGxlY3Rpb25JZCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBBcHB3cml0ZUV4Y2VwdGlvbignTWlzc2luZyByZXF1aXJlZCBwYXJhbWV0ZXI6IFwiY29sbGVjdGlvbklkXCInKTtcbiAgICAgICAgfVxuXG5cbiAgICAgICAgaWYgKHR5cGVvZiBxdWVyaWVzICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgcGF5bG9hZFsncXVlcmllcyddID0gcXVlcmllcztcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBhd2FpdCB0aGlzLmNsaWVudC5jYWxsKCdnZXQnLCBhcGlQYXRoLCB7XG4gICAgICAgICAgICAnY29udGVudC10eXBlJzogJ2FwcGxpY2F0aW9uL2pzb24nLFxuICAgICAgICB9LCBwYXlsb2FkKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGUgZG9jdW1lbnRcbiAgICAgKlxuICAgICAqIENyZWF0ZSBhIG5ldyBEb2N1bWVudC4gQmVmb3JlIHVzaW5nIHRoaXMgcm91dGUsIHlvdSBzaG91bGQgY3JlYXRlIGEgbmV3XG4gICAgICogY29sbGVjdGlvbiByZXNvdXJjZSB1c2luZyBlaXRoZXIgYSBbc2VydmVyXG4gICAgICogaW50ZWdyYXRpb25dKGh0dHBzOi8vYXBwd3JpdGUuaW8vZG9jcy9zZXJ2ZXIvZGF0YWJhc2VzI2RhdGFiYXNlc0NyZWF0ZUNvbGxlY3Rpb24pXG4gICAgICogQVBJIG9yIGRpcmVjdGx5IGZyb20geW91ciBkYXRhYmFzZSBjb25zb2xlLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGRhdGFiYXNlSWRcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gY29sbGVjdGlvbklkXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGRvY3VtZW50SWRcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gZGF0YVxuICAgICAqIEBwYXJhbSB7c3RyaW5nW119IHBlcm1pc3Npb25zXG4gICAgICogQHRocm93cyB7QXBwd3JpdGVFeGNlcHRpb259XG4gICAgICogQHJldHVybnMge1Byb21pc2V9XG4gICAgICovXG4gICAgYXN5bmMgY3JlYXRlRG9jdW1lbnQoZGF0YWJhc2VJZCwgY29sbGVjdGlvbklkLCBkb2N1bWVudElkLCBkYXRhLCBwZXJtaXNzaW9ucykge1xuICAgICAgICBjb25zdCBhcGlQYXRoID0gJy9kYXRhYmFzZXMve2RhdGFiYXNlSWR9L2NvbGxlY3Rpb25zL3tjb2xsZWN0aW9uSWR9L2RvY3VtZW50cycucmVwbGFjZSgne2RhdGFiYXNlSWR9JywgZGF0YWJhc2VJZCkucmVwbGFjZSgne2NvbGxlY3Rpb25JZH0nLCBjb2xsZWN0aW9uSWQpO1xuICAgICAgICBsZXQgcGF5bG9hZCA9IHt9O1xuICAgICAgICBpZiAodHlwZW9mIGRhdGFiYXNlSWQgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgQXBwd3JpdGVFeGNlcHRpb24oJ01pc3NpbmcgcmVxdWlyZWQgcGFyYW1ldGVyOiBcImRhdGFiYXNlSWRcIicpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHR5cGVvZiBjb2xsZWN0aW9uSWQgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgQXBwd3JpdGVFeGNlcHRpb24oJ01pc3NpbmcgcmVxdWlyZWQgcGFyYW1ldGVyOiBcImNvbGxlY3Rpb25JZFwiJyk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodHlwZW9mIGRvY3VtZW50SWQgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgQXBwd3JpdGVFeGNlcHRpb24oJ01pc3NpbmcgcmVxdWlyZWQgcGFyYW1ldGVyOiBcImRvY3VtZW50SWRcIicpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHR5cGVvZiBkYXRhID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEFwcHdyaXRlRXhjZXB0aW9uKCdNaXNzaW5nIHJlcXVpcmVkIHBhcmFtZXRlcjogXCJkYXRhXCInKTtcbiAgICAgICAgfVxuXG5cbiAgICAgICAgaWYgKHR5cGVvZiBkb2N1bWVudElkICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgcGF5bG9hZFsnZG9jdW1lbnRJZCddID0gZG9jdW1lbnRJZDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0eXBlb2YgZGF0YSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHBheWxvYWRbJ2RhdGEnXSA9IGRhdGE7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodHlwZW9mIHBlcm1pc3Npb25zICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgcGF5bG9hZFsncGVybWlzc2lvbnMnXSA9IHBlcm1pc3Npb25zO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMuY2xpZW50LmNhbGwoJ3Bvc3QnLCBhcGlQYXRoLCB7XG4gICAgICAgICAgICAnY29udGVudC10eXBlJzogJ2FwcGxpY2F0aW9uL2pzb24nLFxuICAgICAgICB9LCBwYXlsb2FkKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZXQgZG9jdW1lbnRcbiAgICAgKlxuICAgICAqIEdldCBhIGRvY3VtZW50IGJ5IGl0cyB1bmlxdWUgSUQuIFRoaXMgZW5kcG9pbnQgcmVzcG9uc2UgcmV0dXJucyBhIEpTT05cbiAgICAgKiBvYmplY3Qgd2l0aCB0aGUgZG9jdW1lbnQgZGF0YS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBkYXRhYmFzZUlkXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGNvbGxlY3Rpb25JZFxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBkb2N1bWVudElkXG4gICAgICogQHBhcmFtIHtzdHJpbmdbXX0gcXVlcmllc1xuICAgICAqIEB0aHJvd3Mge0FwcHdyaXRlRXhjZXB0aW9ufVxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlfVxuICAgICAqL1xuICAgIGFzeW5jIGdldERvY3VtZW50KGRhdGFiYXNlSWQsIGNvbGxlY3Rpb25JZCwgZG9jdW1lbnRJZCwgcXVlcmllcykge1xuICAgICAgICBjb25zdCBhcGlQYXRoID0gJy9kYXRhYmFzZXMve2RhdGFiYXNlSWR9L2NvbGxlY3Rpb25zL3tjb2xsZWN0aW9uSWR9L2RvY3VtZW50cy97ZG9jdW1lbnRJZH0nLnJlcGxhY2UoJ3tkYXRhYmFzZUlkfScsIGRhdGFiYXNlSWQpLnJlcGxhY2UoJ3tjb2xsZWN0aW9uSWR9JywgY29sbGVjdGlvbklkKS5yZXBsYWNlKCd7ZG9jdW1lbnRJZH0nLCBkb2N1bWVudElkKTtcbiAgICAgICAgbGV0IHBheWxvYWQgPSB7fTtcbiAgICAgICAgaWYgKHR5cGVvZiBkYXRhYmFzZUlkID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEFwcHdyaXRlRXhjZXB0aW9uKCdNaXNzaW5nIHJlcXVpcmVkIHBhcmFtZXRlcjogXCJkYXRhYmFzZUlkXCInKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0eXBlb2YgY29sbGVjdGlvbklkID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEFwcHdyaXRlRXhjZXB0aW9uKCdNaXNzaW5nIHJlcXVpcmVkIHBhcmFtZXRlcjogXCJjb2xsZWN0aW9uSWRcIicpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHR5cGVvZiBkb2N1bWVudElkID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEFwcHdyaXRlRXhjZXB0aW9uKCdNaXNzaW5nIHJlcXVpcmVkIHBhcmFtZXRlcjogXCJkb2N1bWVudElkXCInKTtcbiAgICAgICAgfVxuXG5cbiAgICAgICAgaWYgKHR5cGVvZiBxdWVyaWVzICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgcGF5bG9hZFsncXVlcmllcyddID0gcXVlcmllcztcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBhd2FpdCB0aGlzLmNsaWVudC5jYWxsKCdnZXQnLCBhcGlQYXRoLCB7XG4gICAgICAgICAgICAnY29udGVudC10eXBlJzogJ2FwcGxpY2F0aW9uL2pzb24nLFxuICAgICAgICB9LCBwYXlsb2FkKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBVcGRhdGUgZG9jdW1lbnRcbiAgICAgKlxuICAgICAqIFVwZGF0ZSBhIGRvY3VtZW50IGJ5IGl0cyB1bmlxdWUgSUQuIFVzaW5nIHRoZSBwYXRjaCBtZXRob2QgeW91IGNhbiBwYXNzXG4gICAgICogb25seSBzcGVjaWZpYyBmaWVsZHMgdGhhdCB3aWxsIGdldCB1cGRhdGVkLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGRhdGFiYXNlSWRcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gY29sbGVjdGlvbklkXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGRvY3VtZW50SWRcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gZGF0YVxuICAgICAqIEBwYXJhbSB7c3RyaW5nW119IHBlcm1pc3Npb25zXG4gICAgICogQHRocm93cyB7QXBwd3JpdGVFeGNlcHRpb259XG4gICAgICogQHJldHVybnMge1Byb21pc2V9XG4gICAgICovXG4gICAgYXN5bmMgdXBkYXRlRG9jdW1lbnQoZGF0YWJhc2VJZCwgY29sbGVjdGlvbklkLCBkb2N1bWVudElkLCBkYXRhLCBwZXJtaXNzaW9ucykge1xuICAgICAgICBjb25zdCBhcGlQYXRoID0gJy9kYXRhYmFzZXMve2RhdGFiYXNlSWR9L2NvbGxlY3Rpb25zL3tjb2xsZWN0aW9uSWR9L2RvY3VtZW50cy97ZG9jdW1lbnRJZH0nLnJlcGxhY2UoJ3tkYXRhYmFzZUlkfScsIGRhdGFiYXNlSWQpLnJlcGxhY2UoJ3tjb2xsZWN0aW9uSWR9JywgY29sbGVjdGlvbklkKS5yZXBsYWNlKCd7ZG9jdW1lbnRJZH0nLCBkb2N1bWVudElkKTtcbiAgICAgICAgbGV0IHBheWxvYWQgPSB7fTtcbiAgICAgICAgaWYgKHR5cGVvZiBkYXRhYmFzZUlkID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEFwcHdyaXRlRXhjZXB0aW9uKCdNaXNzaW5nIHJlcXVpcmVkIHBhcmFtZXRlcjogXCJkYXRhYmFzZUlkXCInKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0eXBlb2YgY29sbGVjdGlvbklkID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEFwcHdyaXRlRXhjZXB0aW9uKCdNaXNzaW5nIHJlcXVpcmVkIHBhcmFtZXRlcjogXCJjb2xsZWN0aW9uSWRcIicpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHR5cGVvZiBkb2N1bWVudElkID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEFwcHdyaXRlRXhjZXB0aW9uKCdNaXNzaW5nIHJlcXVpcmVkIHBhcmFtZXRlcjogXCJkb2N1bWVudElkXCInKTtcbiAgICAgICAgfVxuXG5cbiAgICAgICAgaWYgKHR5cGVvZiBkYXRhICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgcGF5bG9hZFsnZGF0YSddID0gZGF0YTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0eXBlb2YgcGVybWlzc2lvbnMgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICBwYXlsb2FkWydwZXJtaXNzaW9ucyddID0gcGVybWlzc2lvbnM7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy5jbGllbnQuY2FsbCgncGF0Y2gnLCBhcGlQYXRoLCB7XG4gICAgICAgICAgICAnY29udGVudC10eXBlJzogJ2FwcGxpY2F0aW9uL2pzb24nLFxuICAgICAgICB9LCBwYXlsb2FkKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBEZWxldGUgZG9jdW1lbnRcbiAgICAgKlxuICAgICAqIERlbGV0ZSBhIGRvY3VtZW50IGJ5IGl0cyB1bmlxdWUgSUQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gZGF0YWJhc2VJZFxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBjb2xsZWN0aW9uSWRcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gZG9jdW1lbnRJZFxuICAgICAqIEB0aHJvd3Mge0FwcHdyaXRlRXhjZXB0aW9ufVxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlfVxuICAgICAqL1xuICAgIGFzeW5jIGRlbGV0ZURvY3VtZW50KGRhdGFiYXNlSWQsIGNvbGxlY3Rpb25JZCwgZG9jdW1lbnRJZCkge1xuICAgICAgICBjb25zdCBhcGlQYXRoID0gJy9kYXRhYmFzZXMve2RhdGFiYXNlSWR9L2NvbGxlY3Rpb25zL3tjb2xsZWN0aW9uSWR9L2RvY3VtZW50cy97ZG9jdW1lbnRJZH0nLnJlcGxhY2UoJ3tkYXRhYmFzZUlkfScsIGRhdGFiYXNlSWQpLnJlcGxhY2UoJ3tjb2xsZWN0aW9uSWR9JywgY29sbGVjdGlvbklkKS5yZXBsYWNlKCd7ZG9jdW1lbnRJZH0nLCBkb2N1bWVudElkKTtcbiAgICAgICAgbGV0IHBheWxvYWQgPSB7fTtcbiAgICAgICAgaWYgKHR5cGVvZiBkYXRhYmFzZUlkID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEFwcHdyaXRlRXhjZXB0aW9uKCdNaXNzaW5nIHJlcXVpcmVkIHBhcmFtZXRlcjogXCJkYXRhYmFzZUlkXCInKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0eXBlb2YgY29sbGVjdGlvbklkID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEFwcHdyaXRlRXhjZXB0aW9uKCdNaXNzaW5nIHJlcXVpcmVkIHBhcmFtZXRlcjogXCJjb2xsZWN0aW9uSWRcIicpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHR5cGVvZiBkb2N1bWVudElkID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEFwcHdyaXRlRXhjZXB0aW9uKCdNaXNzaW5nIHJlcXVpcmVkIHBhcmFtZXRlcjogXCJkb2N1bWVudElkXCInKTtcbiAgICAgICAgfVxuXG5cbiAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMuY2xpZW50LmNhbGwoJ2RlbGV0ZScsIGFwaVBhdGgsIHtcbiAgICAgICAgICAgICdjb250ZW50LXR5cGUnOiAnYXBwbGljYXRpb24vanNvbicsXG4gICAgICAgIH0sIHBheWxvYWQpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIExpc3QgaW5kZXhlc1xuICAgICAqXG4gICAgICogTGlzdCBpbmRleGVzIGluIHRoZSBjb2xsZWN0aW9uLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGRhdGFiYXNlSWRcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gY29sbGVjdGlvbklkXG4gICAgICogQHBhcmFtIHtzdHJpbmdbXX0gcXVlcmllc1xuICAgICAqIEB0aHJvd3Mge0FwcHdyaXRlRXhjZXB0aW9ufVxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlfVxuICAgICAqL1xuICAgIGFzeW5jIGxpc3RJbmRleGVzKGRhdGFiYXNlSWQsIGNvbGxlY3Rpb25JZCwgcXVlcmllcykge1xuICAgICAgICBjb25zdCBhcGlQYXRoID0gJy9kYXRhYmFzZXMve2RhdGFiYXNlSWR9L2NvbGxlY3Rpb25zL3tjb2xsZWN0aW9uSWR9L2luZGV4ZXMnLnJlcGxhY2UoJ3tkYXRhYmFzZUlkfScsIGRhdGFiYXNlSWQpLnJlcGxhY2UoJ3tjb2xsZWN0aW9uSWR9JywgY29sbGVjdGlvbklkKTtcbiAgICAgICAgbGV0IHBheWxvYWQgPSB7fTtcbiAgICAgICAgaWYgKHR5cGVvZiBkYXRhYmFzZUlkID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEFwcHdyaXRlRXhjZXB0aW9uKCdNaXNzaW5nIHJlcXVpcmVkIHBhcmFtZXRlcjogXCJkYXRhYmFzZUlkXCInKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0eXBlb2YgY29sbGVjdGlvbklkID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEFwcHdyaXRlRXhjZXB0aW9uKCdNaXNzaW5nIHJlcXVpcmVkIHBhcmFtZXRlcjogXCJjb2xsZWN0aW9uSWRcIicpO1xuICAgICAgICB9XG5cblxuICAgICAgICBpZiAodHlwZW9mIHF1ZXJpZXMgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICBwYXlsb2FkWydxdWVyaWVzJ10gPSBxdWVyaWVzO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMuY2xpZW50LmNhbGwoJ2dldCcsIGFwaVBhdGgsIHtcbiAgICAgICAgICAgICdjb250ZW50LXR5cGUnOiAnYXBwbGljYXRpb24vanNvbicsXG4gICAgICAgIH0sIHBheWxvYWQpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZSBpbmRleFxuICAgICAqXG4gICAgICogQ3JlYXRlcyBhbiBpbmRleCBvbiB0aGUgYXR0cmlidXRlcyBsaXN0ZWQuIFlvdXIgaW5kZXggc2hvdWxkIGluY2x1ZGUgYWxsXG4gICAgICogdGhlIGF0dHJpYnV0ZXMgeW91IHdpbGwgcXVlcnkgaW4gYSBzaW5nbGUgcmVxdWVzdC5cbiAgICAgKiBBdHRyaWJ1dGVzIGNhbiBiZSBga2V5YCwgYGZ1bGx0ZXh0YCwgYW5kIGB1bmlxdWVgLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGRhdGFiYXNlSWRcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gY29sbGVjdGlvbklkXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGtleVxuICAgICAqIEBwYXJhbSB7SW5kZXhUeXBlfSB0eXBlXG4gICAgICogQHBhcmFtIHtzdHJpbmdbXX0gYXR0cmlidXRlc1xuICAgICAqIEBwYXJhbSB7c3RyaW5nW119IG9yZGVyc1xuICAgICAqIEB0aHJvd3Mge0FwcHdyaXRlRXhjZXB0aW9ufVxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlfVxuICAgICAqL1xuICAgIGFzeW5jIGNyZWF0ZUluZGV4KGRhdGFiYXNlSWQsIGNvbGxlY3Rpb25JZCwga2V5LCB0eXBlLCBhdHRyaWJ1dGVzLCBvcmRlcnMpIHtcbiAgICAgICAgY29uc3QgYXBpUGF0aCA9ICcvZGF0YWJhc2VzL3tkYXRhYmFzZUlkfS9jb2xsZWN0aW9ucy97Y29sbGVjdGlvbklkfS9pbmRleGVzJy5yZXBsYWNlKCd7ZGF0YWJhc2VJZH0nLCBkYXRhYmFzZUlkKS5yZXBsYWNlKCd7Y29sbGVjdGlvbklkfScsIGNvbGxlY3Rpb25JZCk7XG4gICAgICAgIGxldCBwYXlsb2FkID0ge307XG4gICAgICAgIGlmICh0eXBlb2YgZGF0YWJhc2VJZCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBBcHB3cml0ZUV4Y2VwdGlvbignTWlzc2luZyByZXF1aXJlZCBwYXJhbWV0ZXI6IFwiZGF0YWJhc2VJZFwiJyk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodHlwZW9mIGNvbGxlY3Rpb25JZCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBBcHB3cml0ZUV4Y2VwdGlvbignTWlzc2luZyByZXF1aXJlZCBwYXJhbWV0ZXI6IFwiY29sbGVjdGlvbklkXCInKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0eXBlb2Yga2V5ID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEFwcHdyaXRlRXhjZXB0aW9uKCdNaXNzaW5nIHJlcXVpcmVkIHBhcmFtZXRlcjogXCJrZXlcIicpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHR5cGVvZiB0eXBlID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEFwcHdyaXRlRXhjZXB0aW9uKCdNaXNzaW5nIHJlcXVpcmVkIHBhcmFtZXRlcjogXCJ0eXBlXCInKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0eXBlb2YgYXR0cmlidXRlcyA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBBcHB3cml0ZUV4Y2VwdGlvbignTWlzc2luZyByZXF1aXJlZCBwYXJhbWV0ZXI6IFwiYXR0cmlidXRlc1wiJyk7XG4gICAgICAgIH1cblxuXG4gICAgICAgIGlmICh0eXBlb2Yga2V5ICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgcGF5bG9hZFsna2V5J10gPSBrZXk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodHlwZW9mIHR5cGUgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICBwYXlsb2FkWyd0eXBlJ10gPSB0eXBlO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHR5cGVvZiBhdHRyaWJ1dGVzICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgcGF5bG9hZFsnYXR0cmlidXRlcyddID0gYXR0cmlidXRlcztcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0eXBlb2Ygb3JkZXJzICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgcGF5bG9hZFsnb3JkZXJzJ10gPSBvcmRlcnM7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy5jbGllbnQuY2FsbCgncG9zdCcsIGFwaVBhdGgsIHtcbiAgICAgICAgICAgICdjb250ZW50LXR5cGUnOiAnYXBwbGljYXRpb24vanNvbicsXG4gICAgICAgIH0sIHBheWxvYWQpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdldCBpbmRleFxuICAgICAqXG4gICAgICogR2V0IGluZGV4IGJ5IElELlxuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGRhdGFiYXNlSWRcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gY29sbGVjdGlvbklkXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGtleVxuICAgICAqIEB0aHJvd3Mge0FwcHdyaXRlRXhjZXB0aW9ufVxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlfVxuICAgICAqL1xuICAgIGFzeW5jIGdldEluZGV4KGRhdGFiYXNlSWQsIGNvbGxlY3Rpb25JZCwga2V5KSB7XG4gICAgICAgIGNvbnN0IGFwaVBhdGggPSAnL2RhdGFiYXNlcy97ZGF0YWJhc2VJZH0vY29sbGVjdGlvbnMve2NvbGxlY3Rpb25JZH0vaW5kZXhlcy97a2V5fScucmVwbGFjZSgne2RhdGFiYXNlSWR9JywgZGF0YWJhc2VJZCkucmVwbGFjZSgne2NvbGxlY3Rpb25JZH0nLCBjb2xsZWN0aW9uSWQpLnJlcGxhY2UoJ3trZXl9Jywga2V5KTtcbiAgICAgICAgbGV0IHBheWxvYWQgPSB7fTtcbiAgICAgICAgaWYgKHR5cGVvZiBkYXRhYmFzZUlkID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEFwcHdyaXRlRXhjZXB0aW9uKCdNaXNzaW5nIHJlcXVpcmVkIHBhcmFtZXRlcjogXCJkYXRhYmFzZUlkXCInKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0eXBlb2YgY29sbGVjdGlvbklkID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEFwcHdyaXRlRXhjZXB0aW9uKCdNaXNzaW5nIHJlcXVpcmVkIHBhcmFtZXRlcjogXCJjb2xsZWN0aW9uSWRcIicpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHR5cGVvZiBrZXkgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgQXBwd3JpdGVFeGNlcHRpb24oJ01pc3NpbmcgcmVxdWlyZWQgcGFyYW1ldGVyOiBcImtleVwiJyk7XG4gICAgICAgIH1cblxuXG4gICAgICAgIHJldHVybiBhd2FpdCB0aGlzLmNsaWVudC5jYWxsKCdnZXQnLCBhcGlQYXRoLCB7XG4gICAgICAgICAgICAnY29udGVudC10eXBlJzogJ2FwcGxpY2F0aW9uL2pzb24nLFxuICAgICAgICB9LCBwYXlsb2FkKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBEZWxldGUgaW5kZXhcbiAgICAgKlxuICAgICAqIERlbGV0ZSBhbiBpbmRleC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBkYXRhYmFzZUlkXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGNvbGxlY3Rpb25JZFxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBrZXlcbiAgICAgKiBAdGhyb3dzIHtBcHB3cml0ZUV4Y2VwdGlvbn1cbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZX1cbiAgICAgKi9cbiAgICBhc3luYyBkZWxldGVJbmRleChkYXRhYmFzZUlkLCBjb2xsZWN0aW9uSWQsIGtleSkge1xuICAgICAgICBjb25zdCBhcGlQYXRoID0gJy9kYXRhYmFzZXMve2RhdGFiYXNlSWR9L2NvbGxlY3Rpb25zL3tjb2xsZWN0aW9uSWR9L2luZGV4ZXMve2tleX0nLnJlcGxhY2UoJ3tkYXRhYmFzZUlkfScsIGRhdGFiYXNlSWQpLnJlcGxhY2UoJ3tjb2xsZWN0aW9uSWR9JywgY29sbGVjdGlvbklkKS5yZXBsYWNlKCd7a2V5fScsIGtleSk7XG4gICAgICAgIGxldCBwYXlsb2FkID0ge307XG4gICAgICAgIGlmICh0eXBlb2YgZGF0YWJhc2VJZCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBBcHB3cml0ZUV4Y2VwdGlvbignTWlzc2luZyByZXF1aXJlZCBwYXJhbWV0ZXI6IFwiZGF0YWJhc2VJZFwiJyk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodHlwZW9mIGNvbGxlY3Rpb25JZCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBBcHB3cml0ZUV4Y2VwdGlvbignTWlzc2luZyByZXF1aXJlZCBwYXJhbWV0ZXI6IFwiY29sbGVjdGlvbklkXCInKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0eXBlb2Yga2V5ID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEFwcHdyaXRlRXhjZXB0aW9uKCdNaXNzaW5nIHJlcXVpcmVkIHBhcmFtZXRlcjogXCJrZXlcIicpO1xuICAgICAgICB9XG5cblxuICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy5jbGllbnQuY2FsbCgnZGVsZXRlJywgYXBpUGF0aCwge1xuICAgICAgICAgICAgJ2NvbnRlbnQtdHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJyxcbiAgICAgICAgfSwgcGF5bG9hZCk7XG4gICAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IERhdGFiYXNlcztcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/node-appwrite/lib/services/databases.js\n");

/***/ }),

/***/ "(action-browser)/./node_modules/node-appwrite/lib/services/functions.js":
/*!**************************************************************!*\
  !*** ./node_modules/node-appwrite/lib/services/functions.js ***!
  \**************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("const Service = __webpack_require__(/*! ../service.js */ \"(action-browser)/./node_modules/node-appwrite/lib/service.js\");\nconst AppwriteException = __webpack_require__(/*! ../exception.js */ \"(action-browser)/./node_modules/node-appwrite/lib/exception.js\");\nconst InputFile = __webpack_require__(/*! ../inputFile.js */ \"(action-browser)/./node_modules/node-appwrite/lib/inputFile.js\");\nconst client = __webpack_require__(/*! ../client.js */ \"(action-browser)/./node_modules/node-appwrite/lib/client.js\");\nconst Stream = __webpack_require__(/*! stream */ \"stream\");\nconst { promisify } = __webpack_require__(/*! util */ \"util\");\nconst fs = __webpack_require__(/*! fs */ \"fs\");\nconst { File } = __webpack_require__(/*! undici */ \"undici\");\nconst Query = __webpack_require__(/*! ../query.js */ \"(action-browser)/./node_modules/node-appwrite/lib/query.js\");\n\nclass Functions extends Service {\n\n     constructor(client)\n     {\n        super(client);\n     }\n\n\n    /**\n     * List functions\n     *\n     * Get a list of all the project's functions. You can use the query params to\n     * filter your results.\n     *\n     * @param {string[]} queries\n     * @param {string} search\n     * @throws {AppwriteException}\n     * @returns {Promise}\n     */\n    async list(queries, search) {\n        const apiPath = '/functions';\n        let payload = {};\n\n        if (typeof queries !== 'undefined') {\n            payload['queries'] = queries;\n        }\n\n        if (typeof search !== 'undefined') {\n            payload['search'] = search;\n        }\n\n        return await this.client.call('get', apiPath, {\n            'content-type': 'application/json',\n        }, payload);\n    }\n\n    /**\n     * Create function\n     *\n     * Create a new function. You can pass a list of\n     * [permissions](https://appwrite.io/docs/permissions) to allow different\n     * project users or team with access to execute the function using the client\n     * API.\n     *\n     * @param {string} functionId\n     * @param {string} name\n     * @param {Runtime} runtime\n     * @param {string[]} execute\n     * @param {string[]} events\n     * @param {string} schedule\n     * @param {number} timeout\n     * @param {boolean} enabled\n     * @param {boolean} logging\n     * @param {string} entrypoint\n     * @param {string} commands\n     * @param {string} installationId\n     * @param {string} providerRepositoryId\n     * @param {string} providerBranch\n     * @param {boolean} providerSilentMode\n     * @param {string} providerRootDirectory\n     * @param {string} templateRepository\n     * @param {string} templateOwner\n     * @param {string} templateRootDirectory\n     * @param {string} templateBranch\n     * @throws {AppwriteException}\n     * @returns {Promise}\n     */\n    async create(functionId, name, runtime, execute, events, schedule, timeout, enabled, logging, entrypoint, commands, installationId, providerRepositoryId, providerBranch, providerSilentMode, providerRootDirectory, templateRepository, templateOwner, templateRootDirectory, templateBranch) {\n        const apiPath = '/functions';\n        let payload = {};\n        if (typeof functionId === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"functionId\"');\n        }\n\n        if (typeof name === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"name\"');\n        }\n\n        if (typeof runtime === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"runtime\"');\n        }\n\n\n        if (typeof functionId !== 'undefined') {\n            payload['functionId'] = functionId;\n        }\n\n        if (typeof name !== 'undefined') {\n            payload['name'] = name;\n        }\n\n        if (typeof runtime !== 'undefined') {\n            payload['runtime'] = runtime;\n        }\n\n        if (typeof execute !== 'undefined') {\n            payload['execute'] = execute;\n        }\n\n        if (typeof events !== 'undefined') {\n            payload['events'] = events;\n        }\n\n        if (typeof schedule !== 'undefined') {\n            payload['schedule'] = schedule;\n        }\n\n        if (typeof timeout !== 'undefined') {\n            payload['timeout'] = timeout;\n        }\n\n        if (typeof enabled !== 'undefined') {\n            payload['enabled'] = enabled;\n        }\n\n        if (typeof logging !== 'undefined') {\n            payload['logging'] = logging;\n        }\n\n        if (typeof entrypoint !== 'undefined') {\n            payload['entrypoint'] = entrypoint;\n        }\n\n        if (typeof commands !== 'undefined') {\n            payload['commands'] = commands;\n        }\n\n        if (typeof installationId !== 'undefined') {\n            payload['installationId'] = installationId;\n        }\n\n        if (typeof providerRepositoryId !== 'undefined') {\n            payload['providerRepositoryId'] = providerRepositoryId;\n        }\n\n        if (typeof providerBranch !== 'undefined') {\n            payload['providerBranch'] = providerBranch;\n        }\n\n        if (typeof providerSilentMode !== 'undefined') {\n            payload['providerSilentMode'] = providerSilentMode;\n        }\n\n        if (typeof providerRootDirectory !== 'undefined') {\n            payload['providerRootDirectory'] = providerRootDirectory;\n        }\n\n        if (typeof templateRepository !== 'undefined') {\n            payload['templateRepository'] = templateRepository;\n        }\n\n        if (typeof templateOwner !== 'undefined') {\n            payload['templateOwner'] = templateOwner;\n        }\n\n        if (typeof templateRootDirectory !== 'undefined') {\n            payload['templateRootDirectory'] = templateRootDirectory;\n        }\n\n        if (typeof templateBranch !== 'undefined') {\n            payload['templateBranch'] = templateBranch;\n        }\n\n        return await this.client.call('post', apiPath, {\n            'content-type': 'application/json',\n        }, payload);\n    }\n\n    /**\n     * List runtimes\n     *\n     * Get a list of all runtimes that are currently active on your instance.\n     *\n     * @throws {AppwriteException}\n     * @returns {Promise}\n     */\n    async listRuntimes() {\n        const apiPath = '/functions/runtimes';\n        let payload = {};\n\n        return await this.client.call('get', apiPath, {\n            'content-type': 'application/json',\n        }, payload);\n    }\n\n    /**\n     * Get function\n     *\n     * Get a function by its unique ID.\n     *\n     * @param {string} functionId\n     * @throws {AppwriteException}\n     * @returns {Promise}\n     */\n    async get(functionId) {\n        const apiPath = '/functions/{functionId}'.replace('{functionId}', functionId);\n        let payload = {};\n        if (typeof functionId === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"functionId\"');\n        }\n\n\n        return await this.client.call('get', apiPath, {\n            'content-type': 'application/json',\n        }, payload);\n    }\n\n    /**\n     * Update function\n     *\n     * Update function by its unique ID.\n     *\n     * @param {string} functionId\n     * @param {string} name\n     * @param {Runtime} runtime\n     * @param {string[]} execute\n     * @param {string[]} events\n     * @param {string} schedule\n     * @param {number} timeout\n     * @param {boolean} enabled\n     * @param {boolean} logging\n     * @param {string} entrypoint\n     * @param {string} commands\n     * @param {string} installationId\n     * @param {string} providerRepositoryId\n     * @param {string} providerBranch\n     * @param {boolean} providerSilentMode\n     * @param {string} providerRootDirectory\n     * @throws {AppwriteException}\n     * @returns {Promise}\n     */\n    async update(functionId, name, runtime, execute, events, schedule, timeout, enabled, logging, entrypoint, commands, installationId, providerRepositoryId, providerBranch, providerSilentMode, providerRootDirectory) {\n        const apiPath = '/functions/{functionId}'.replace('{functionId}', functionId);\n        let payload = {};\n        if (typeof functionId === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"functionId\"');\n        }\n\n        if (typeof name === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"name\"');\n        }\n\n\n        if (typeof name !== 'undefined') {\n            payload['name'] = name;\n        }\n\n        if (typeof runtime !== 'undefined') {\n            payload['runtime'] = runtime;\n        }\n\n        if (typeof execute !== 'undefined') {\n            payload['execute'] = execute;\n        }\n\n        if (typeof events !== 'undefined') {\n            payload['events'] = events;\n        }\n\n        if (typeof schedule !== 'undefined') {\n            payload['schedule'] = schedule;\n        }\n\n        if (typeof timeout !== 'undefined') {\n            payload['timeout'] = timeout;\n        }\n\n        if (typeof enabled !== 'undefined') {\n            payload['enabled'] = enabled;\n        }\n\n        if (typeof logging !== 'undefined') {\n            payload['logging'] = logging;\n        }\n\n        if (typeof entrypoint !== 'undefined') {\n            payload['entrypoint'] = entrypoint;\n        }\n\n        if (typeof commands !== 'undefined') {\n            payload['commands'] = commands;\n        }\n\n        if (typeof installationId !== 'undefined') {\n            payload['installationId'] = installationId;\n        }\n\n        if (typeof providerRepositoryId !== 'undefined') {\n            payload['providerRepositoryId'] = providerRepositoryId;\n        }\n\n        if (typeof providerBranch !== 'undefined') {\n            payload['providerBranch'] = providerBranch;\n        }\n\n        if (typeof providerSilentMode !== 'undefined') {\n            payload['providerSilentMode'] = providerSilentMode;\n        }\n\n        if (typeof providerRootDirectory !== 'undefined') {\n            payload['providerRootDirectory'] = providerRootDirectory;\n        }\n\n        return await this.client.call('put', apiPath, {\n            'content-type': 'application/json',\n        }, payload);\n    }\n\n    /**\n     * Delete function\n     *\n     * Delete a function by its unique ID.\n     *\n     * @param {string} functionId\n     * @throws {AppwriteException}\n     * @returns {Promise}\n     */\n    async delete(functionId) {\n        const apiPath = '/functions/{functionId}'.replace('{functionId}', functionId);\n        let payload = {};\n        if (typeof functionId === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"functionId\"');\n        }\n\n\n        return await this.client.call('delete', apiPath, {\n            'content-type': 'application/json',\n        }, payload);\n    }\n\n    /**\n     * List deployments\n     *\n     * Get a list of all the project's code deployments. You can use the query\n     * params to filter your results.\n     *\n     * @param {string} functionId\n     * @param {string[]} queries\n     * @param {string} search\n     * @throws {AppwriteException}\n     * @returns {Promise}\n     */\n    async listDeployments(functionId, queries, search) {\n        const apiPath = '/functions/{functionId}/deployments'.replace('{functionId}', functionId);\n        let payload = {};\n        if (typeof functionId === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"functionId\"');\n        }\n\n\n        if (typeof queries !== 'undefined') {\n            payload['queries'] = queries;\n        }\n\n        if (typeof search !== 'undefined') {\n            payload['search'] = search;\n        }\n\n        return await this.client.call('get', apiPath, {\n            'content-type': 'application/json',\n        }, payload);\n    }\n\n    /**\n     * Create deployment\n     *\n     * Create a new function code deployment. Use this endpoint to upload a new\n     * version of your code function. To execute your newly uploaded code, you'll\n     * need to update the function's deployment to use your new deployment UID.\n     * \n     * This endpoint accepts a tar.gz file compressed with your code. Make sure to\n     * include any dependencies your code has within the compressed file. You can\n     * learn more about code packaging in the [Appwrite Cloud Functions\n     * tutorial](https://appwrite.io/docs/functions).\n     * \n     * Use the \"command\" param to set the entrypoint used to execute your code.\n     *\n     * @param {string} functionId\n     * @param {InputFile} code\n     * @param {boolean} activate\n     * @param {string} entrypoint\n     * @param {string} commands\n     * @param {CallableFunction} onProgress\n     * @throws {AppwriteException}\n     * @returns {Promise}\n     */\n    async createDeployment(functionId, code, activate, entrypoint, commands, onProgress = () => {}) {\n        const apiPath = '/functions/{functionId}/deployments'.replace('{functionId}', functionId);\n        let payload = {};\n        if (typeof functionId === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"functionId\"');\n        }\n\n        if (typeof code === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"code\"');\n        }\n\n        if (typeof activate === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"activate\"');\n        }\n\n\n        if (typeof entrypoint !== 'undefined') {\n            payload['entrypoint'] = entrypoint;\n        }\n\n        if (typeof commands !== 'undefined') {\n            payload['commands'] = commands;\n        }\n\n        if (typeof code !== 'undefined') {\n            payload['code'] = code;\n        }\n\n        if (typeof activate !== 'undefined') {\n            payload['activate'] = activate.toString();\n        }\n\n\n        const size = code.size;\n        \n        const apiHeaders = {\n            'content-type': 'multipart/form-data',\n        };\n\n        let id = undefined;\n        let response = undefined;\n\n        let chunksUploaded = 0;\n\n\n        let currentChunk = 1;\n        let currentPosition = 0;\n        let uploadableChunk = new Uint8Array(client.CHUNK_SIZE);\n    \n\n        const uploadChunk = async (lastUpload = false) => {\n            if(currentChunk <= chunksUploaded) {\n                return;\n            }\n\n            const start = ((currentChunk - 1) * client.CHUNK_SIZE);\n            let end = start + currentPosition - 1;\n\n            if(!lastUpload || currentChunk !== 1) {\n                apiHeaders['content-range'] = 'bytes ' + start + '-' + end + '/' + size;\n            }\n\n            let uploadableChunkTrimmed;\n            \n            if(currentPosition + 1 >= client.CHUNK_SIZE) {\n                uploadableChunkTrimmed = uploadableChunk;\n            } else {\n                uploadableChunkTrimmed = new Uint8Array(currentPosition);\n                for(let i = 0; i <= currentPosition; i++) {\n                    uploadableChunkTrimmed[i] = uploadableChunk[i];\n                }\n            }\n\n            if (id) {\n                apiHeaders['x-appwrite-id'] = id;\n            }\n\n            payload['code'] = { type: 'file', file: new File([uploadableChunkTrimmed], code.filename), filename: code.filename };\n\n            response = await this.client.call('post', apiPath, apiHeaders, payload);\n\n            if (!id) {\n                id = response['$id'];\n            }\n\n            if (onProgress !== null) {\n                onProgress({\n                    $id: response['$id'],\n                    progress: Math.min((currentChunk) * client.CHUNK_SIZE, size) / size * 100,\n                    sizeUploaded: end+1,\n                    chunksTotal: response['chunksTotal'],\n                    chunksUploaded: response['chunksUploaded']\n                });\n            }\n\n            uploadableChunk = new Uint8Array(client.CHUNK_SIZE);\n            currentChunk++;\n            currentPosition = 0;\n        }\n\n        for await (const chunk of code.stream) {\n            for(const b of chunk) {\n                uploadableChunk[currentPosition] = b;\n\n                currentPosition++;\n                if(currentPosition >= client.CHUNK_SIZE) {\n                    await uploadChunk();\n                    currentPosition = 0;\n                }\n            }\n        }\n\n        if (currentPosition > 0) { // Check if there's any remaining data for the last chunk\n            await uploadChunk(true);\n        }\n\n        return response;\n\n    }\n\n    /**\n     * Get deployment\n     *\n     * Get a code deployment by its unique ID.\n     *\n     * @param {string} functionId\n     * @param {string} deploymentId\n     * @throws {AppwriteException}\n     * @returns {Promise}\n     */\n    async getDeployment(functionId, deploymentId) {\n        const apiPath = '/functions/{functionId}/deployments/{deploymentId}'.replace('{functionId}', functionId).replace('{deploymentId}', deploymentId);\n        let payload = {};\n        if (typeof functionId === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"functionId\"');\n        }\n\n        if (typeof deploymentId === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"deploymentId\"');\n        }\n\n\n        return await this.client.call('get', apiPath, {\n            'content-type': 'application/json',\n        }, payload);\n    }\n\n    /**\n     * Update function deployment\n     *\n     * Update the function code deployment ID using the unique function ID. Use\n     * this endpoint to switch the code deployment that should be executed by the\n     * execution endpoint.\n     *\n     * @param {string} functionId\n     * @param {string} deploymentId\n     * @throws {AppwriteException}\n     * @returns {Promise}\n     */\n    async updateDeployment(functionId, deploymentId) {\n        const apiPath = '/functions/{functionId}/deployments/{deploymentId}'.replace('{functionId}', functionId).replace('{deploymentId}', deploymentId);\n        let payload = {};\n        if (typeof functionId === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"functionId\"');\n        }\n\n        if (typeof deploymentId === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"deploymentId\"');\n        }\n\n\n        return await this.client.call('patch', apiPath, {\n            'content-type': 'application/json',\n        }, payload);\n    }\n\n    /**\n     * Delete deployment\n     *\n     * Delete a code deployment by its unique ID.\n     *\n     * @param {string} functionId\n     * @param {string} deploymentId\n     * @throws {AppwriteException}\n     * @returns {Promise}\n     */\n    async deleteDeployment(functionId, deploymentId) {\n        const apiPath = '/functions/{functionId}/deployments/{deploymentId}'.replace('{functionId}', functionId).replace('{deploymentId}', deploymentId);\n        let payload = {};\n        if (typeof functionId === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"functionId\"');\n        }\n\n        if (typeof deploymentId === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"deploymentId\"');\n        }\n\n\n        return await this.client.call('delete', apiPath, {\n            'content-type': 'application/json',\n        }, payload);\n    }\n\n    /**\n     * Create build\n     *\n     * Create a new build for an Appwrite Function deployment. This endpoint can\n     * be used to retry a failed build.\n     *\n     * @param {string} functionId\n     * @param {string} deploymentId\n     * @param {string} buildId\n     * @throws {AppwriteException}\n     * @returns {Promise}\n     */\n    async createBuild(functionId, deploymentId, buildId) {\n        const apiPath = '/functions/{functionId}/deployments/{deploymentId}/builds/{buildId}'.replace('{functionId}', functionId).replace('{deploymentId}', deploymentId).replace('{buildId}', buildId);\n        let payload = {};\n        if (typeof functionId === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"functionId\"');\n        }\n\n        if (typeof deploymentId === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"deploymentId\"');\n        }\n\n        if (typeof buildId === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"buildId\"');\n        }\n\n\n        return await this.client.call('post', apiPath, {\n            'content-type': 'application/json',\n        }, payload);\n    }\n\n    /**\n     * Download Deployment\n     *\n     * Get a Deployment's contents by its unique ID. This endpoint supports range\n     * requests for partial or streaming file download.\n     *\n     * @param {string} functionId\n     * @param {string} deploymentId\n     * @throws {AppwriteException}\n     * @returns {Promise}\n     */\n    async downloadDeployment(functionId, deploymentId) {\n        const apiPath = '/functions/{functionId}/deployments/{deploymentId}/download'.replace('{functionId}', functionId).replace('{deploymentId}', deploymentId);\n        let payload = {};\n        if (typeof functionId === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"functionId\"');\n        }\n\n        if (typeof deploymentId === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"deploymentId\"');\n        }\n\n\n        return await this.client.call('get', apiPath, {\n            'content-type': 'application/json',\n        }, payload, 'arraybuffer');\n    }\n\n    /**\n     * List executions\n     *\n     * Get a list of all the current user function execution logs. You can use the\n     * query params to filter your results.\n     *\n     * @param {string} functionId\n     * @param {string[]} queries\n     * @param {string} search\n     * @throws {AppwriteException}\n     * @returns {Promise}\n     */\n    async listExecutions(functionId, queries, search) {\n        const apiPath = '/functions/{functionId}/executions'.replace('{functionId}', functionId);\n        let payload = {};\n        if (typeof functionId === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"functionId\"');\n        }\n\n\n        if (typeof queries !== 'undefined') {\n            payload['queries'] = queries;\n        }\n\n        if (typeof search !== 'undefined') {\n            payload['search'] = search;\n        }\n\n        return await this.client.call('get', apiPath, {\n            'content-type': 'application/json',\n        }, payload);\n    }\n\n    /**\n     * Create execution\n     *\n     * Trigger a function execution. The returned object will return you the\n     * current execution status. You can ping the `Get Execution` endpoint to get\n     * updates on the current execution status. Once this endpoint is called, your\n     * function execution process will start asynchronously.\n     *\n     * @param {string} functionId\n     * @param {string} body\n     * @param {boolean} async\n     * @param {string} xpath\n     * @param {ExecutionMethod} method\n     * @param {object} headers\n     * @throws {AppwriteException}\n     * @returns {Promise}\n     */\n    async createExecution(functionId, body, async, xpath, method, headers) {\n        const apiPath = '/functions/{functionId}/executions'.replace('{functionId}', functionId);\n        let payload = {};\n        if (typeof functionId === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"functionId\"');\n        }\n\n\n        if (typeof body !== 'undefined') {\n            payload['body'] = body;\n        }\n\n        if (typeof async !== 'undefined') {\n            payload['async'] = async;\n        }\n\n        if (typeof xpath !== 'undefined') {\n            payload['path'] = xpath;\n        }\n\n        if (typeof method !== 'undefined') {\n            payload['method'] = method;\n        }\n\n        if (typeof headers !== 'undefined') {\n            payload['headers'] = headers;\n        }\n\n        return await this.client.call('post', apiPath, {\n            'content-type': 'application/json',\n        }, payload);\n    }\n\n    /**\n     * Get execution\n     *\n     * Get a function execution log by its unique ID.\n     *\n     * @param {string} functionId\n     * @param {string} executionId\n     * @throws {AppwriteException}\n     * @returns {Promise}\n     */\n    async getExecution(functionId, executionId) {\n        const apiPath = '/functions/{functionId}/executions/{executionId}'.replace('{functionId}', functionId).replace('{executionId}', executionId);\n        let payload = {};\n        if (typeof functionId === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"functionId\"');\n        }\n\n        if (typeof executionId === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"executionId\"');\n        }\n\n\n        return await this.client.call('get', apiPath, {\n            'content-type': 'application/json',\n        }, payload);\n    }\n\n    /**\n     * List variables\n     *\n     * Get a list of all variables of a specific function.\n     *\n     * @param {string} functionId\n     * @throws {AppwriteException}\n     * @returns {Promise}\n     */\n    async listVariables(functionId) {\n        const apiPath = '/functions/{functionId}/variables'.replace('{functionId}', functionId);\n        let payload = {};\n        if (typeof functionId === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"functionId\"');\n        }\n\n\n        return await this.client.call('get', apiPath, {\n            'content-type': 'application/json',\n        }, payload);\n    }\n\n    /**\n     * Create variable\n     *\n     * Create a new function environment variable. These variables can be accessed\n     * in the function at runtime as environment variables.\n     *\n     * @param {string} functionId\n     * @param {string} key\n     * @param {string} value\n     * @throws {AppwriteException}\n     * @returns {Promise}\n     */\n    async createVariable(functionId, key, value) {\n        const apiPath = '/functions/{functionId}/variables'.replace('{functionId}', functionId);\n        let payload = {};\n        if (typeof functionId === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"functionId\"');\n        }\n\n        if (typeof key === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"key\"');\n        }\n\n        if (typeof value === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"value\"');\n        }\n\n\n        if (typeof key !== 'undefined') {\n            payload['key'] = key;\n        }\n\n        if (typeof value !== 'undefined') {\n            payload['value'] = value;\n        }\n\n        return await this.client.call('post', apiPath, {\n            'content-type': 'application/json',\n        }, payload);\n    }\n\n    /**\n     * Get variable\n     *\n     * Get a variable by its unique ID.\n     *\n     * @param {string} functionId\n     * @param {string} variableId\n     * @throws {AppwriteException}\n     * @returns {Promise}\n     */\n    async getVariable(functionId, variableId) {\n        const apiPath = '/functions/{functionId}/variables/{variableId}'.replace('{functionId}', functionId).replace('{variableId}', variableId);\n        let payload = {};\n        if (typeof functionId === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"functionId\"');\n        }\n\n        if (typeof variableId === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"variableId\"');\n        }\n\n\n        return await this.client.call('get', apiPath, {\n            'content-type': 'application/json',\n        }, payload);\n    }\n\n    /**\n     * Update variable\n     *\n     * Update variable by its unique ID.\n     *\n     * @param {string} functionId\n     * @param {string} variableId\n     * @param {string} key\n     * @param {string} value\n     * @throws {AppwriteException}\n     * @returns {Promise}\n     */\n    async updateVariable(functionId, variableId, key, value) {\n        const apiPath = '/functions/{functionId}/variables/{variableId}'.replace('{functionId}', functionId).replace('{variableId}', variableId);\n        let payload = {};\n        if (typeof functionId === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"functionId\"');\n        }\n\n        if (typeof variableId === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"variableId\"');\n        }\n\n        if (typeof key === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"key\"');\n        }\n\n\n        if (typeof key !== 'undefined') {\n            payload['key'] = key;\n        }\n\n        if (typeof value !== 'undefined') {\n            payload['value'] = value;\n        }\n\n        return await this.client.call('put', apiPath, {\n            'content-type': 'application/json',\n        }, payload);\n    }\n\n    /**\n     * Delete variable\n     *\n     * Delete a variable by its unique ID.\n     *\n     * @param {string} functionId\n     * @param {string} variableId\n     * @throws {AppwriteException}\n     * @returns {Promise}\n     */\n    async deleteVariable(functionId, variableId) {\n        const apiPath = '/functions/{functionId}/variables/{variableId}'.replace('{functionId}', functionId).replace('{variableId}', variableId);\n        let payload = {};\n        if (typeof functionId === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"functionId\"');\n        }\n\n        if (typeof variableId === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"variableId\"');\n        }\n\n\n        return await this.client.call('delete', apiPath, {\n            'content-type': 'application/json',\n        }, payload);\n    }\n}\n\nmodule.exports = Functions;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFjdGlvbi1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9ub2RlLWFwcHdyaXRlL2xpYi9zZXJ2aWNlcy9mdW5jdGlvbnMuanMiLCJtYXBwaW5ncyI6IkFBQUEsZ0JBQWdCLG1CQUFPLENBQUMsbUZBQWU7QUFDdkMsMEJBQTBCLG1CQUFPLENBQUMsdUZBQWlCO0FBQ25ELGtCQUFrQixtQkFBTyxDQUFDLHVGQUFpQjtBQUMzQyxlQUFlLG1CQUFPLENBQUMsaUZBQWM7QUFDckMsZUFBZSxtQkFBTyxDQUFDLHNCQUFRO0FBQy9CLFFBQVEsWUFBWSxFQUFFLG1CQUFPLENBQUMsa0JBQU07QUFDcEMsV0FBVyxtQkFBTyxDQUFDLGNBQUk7QUFDdkIsUUFBUSxPQUFPLEVBQUUsbUJBQU8sQ0FBQyxzQkFBUTtBQUNqQyxjQUFjLG1CQUFPLENBQUMsK0VBQWE7O0FBRW5DOztBQUVBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFVBQVU7QUFDekIsZUFBZSxRQUFRO0FBQ3ZCLGdCQUFnQjtBQUNoQixpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsU0FBUztBQUNUOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkIsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsU0FBUztBQUN4QixlQUFlLFVBQVU7QUFDekIsZUFBZSxVQUFVO0FBQ3pCLGVBQWUsUUFBUTtBQUN2QixlQUFlLFFBQVE7QUFDdkIsZUFBZSxTQUFTO0FBQ3hCLGVBQWUsU0FBUztBQUN4QixlQUFlLFFBQVE7QUFDdkIsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsUUFBUTtBQUN2QixlQUFlLFFBQVE7QUFDdkIsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsU0FBUztBQUN4QixlQUFlLFFBQVE7QUFDdkIsZUFBZSxRQUFRO0FBQ3ZCLGVB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cUMsV0FBVyxZQUFZLFdBQVcsWUFBWSxXQUFXLHlCQUF5QixXQUFXO0FBQ2xJO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBOztBQUVBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vanNtX2JhbmtpbmcvLi9ub2RlX21vZHVsZXMvbm9kZS1hcHB3cml0ZS9saWIvc2VydmljZXMvZnVuY3Rpb25zLmpzPzMzMDciXSwic291cmNlc0NvbnRlbnQiOlsiY29uc3QgU2VydmljZSA9IHJlcXVpcmUoJy4uL3NlcnZpY2UuanMnKTtcbmNvbnN0IEFwcHdyaXRlRXhjZXB0aW9uID0gcmVxdWlyZSgnLi4vZXhjZXB0aW9uLmpzJyk7XG5jb25zdCBJbnB1dEZpbGUgPSByZXF1aXJlKCcuLi9pbnB1dEZpbGUuanMnKTtcbmNvbnN0IGNsaWVudCA9IHJlcXVpcmUoJy4uL2NsaWVudC5qcycpO1xuY29uc3QgU3RyZWFtID0gcmVxdWlyZSgnc3RyZWFtJyk7XG5jb25zdCB7IHByb21pc2lmeSB9ID0gcmVxdWlyZSgndXRpbCcpO1xuY29uc3QgZnMgPSByZXF1aXJlKCdmcycpO1xuY29uc3QgeyBGaWxlIH0gPSByZXF1aXJlKCd1bmRpY2knKTtcbmNvbnN0IFF1ZXJ5ID0gcmVxdWlyZSgnLi4vcXVlcnkuanMnKTtcblxuY2xhc3MgRnVuY3Rpb25zIGV4dGVuZHMgU2VydmljZSB7XG5cbiAgICAgY29uc3RydWN0b3IoY2xpZW50KVxuICAgICB7XG4gICAgICAgIHN1cGVyKGNsaWVudCk7XG4gICAgIH1cblxuXG4gICAgLyoqXG4gICAgICogTGlzdCBmdW5jdGlvbnNcbiAgICAgKlxuICAgICAqIEdldCBhIGxpc3Qgb2YgYWxsIHRoZSBwcm9qZWN0J3MgZnVuY3Rpb25zLiBZb3UgY2FuIHVzZSB0aGUgcXVlcnkgcGFyYW1zIHRvXG4gICAgICogZmlsdGVyIHlvdXIgcmVzdWx0cy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nW119IHF1ZXJpZXNcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gc2VhcmNoXG4gICAgICogQHRocm93cyB7QXBwd3JpdGVFeGNlcHRpb259XG4gICAgICogQHJldHVybnMge1Byb21pc2V9XG4gICAgICovXG4gICAgYXN5bmMgbGlzdChxdWVyaWVzLCBzZWFyY2gpIHtcbiAgICAgICAgY29uc3QgYXBpUGF0aCA9ICcvZnVuY3Rpb25zJztcbiAgICAgICAgbGV0IHBheWxvYWQgPSB7fTtcblxuICAgICAgICBpZiAodHlwZW9mIHF1ZXJpZXMgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICBwYXlsb2FkWydxdWVyaWVzJ10gPSBxdWVyaWVzO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHR5cGVvZiBzZWFyY2ggIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICBwYXlsb2FkWydzZWFyY2gnXSA9IHNlYXJjaDtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBhd2FpdCB0aGlzLmNsaWVudC5jYWxsKCdnZXQnLCBhcGlQYXRoLCB7XG4gICAgICAgICAgICAnY29udGVudC10eXBlJzogJ2FwcGxpY2F0aW9uL2pzb24nLFxuICAgICAgICB9LCBwYXlsb2FkKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGUgZnVuY3Rpb25cbiAgICAgKlxuICAgICAqIENyZWF0ZSBhIG5ldyBmdW5jdGlvbi4gWW91IGNhbiBwYXNzIGEgbGlzdCBvZlxuICAgICAqIFtwZXJtaXNzaW9uc10oaHR0cHM6Ly9hcHB3cml0ZS5pby9kb2NzL3Blcm1pc3Npb25zKSB0byBhbGxvdyBkaWZmZXJlbnRcbiAgICAgKiBwcm9qZWN0IHVzZXJzIG9yIHRlYW0gd2l0aCBhY2Nlc3MgdG8gZXhlY3V0ZSB0aGUgZnVuY3Rpb24gdXNpbmcgdGhlIGNsaWVudFxuICAgICAqIEFQSS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBmdW5jdGlvbklkXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IG5hbWVcbiAgICAgKiBAcGFyYW0ge1J1bnRpbWV9IHJ1bnRpbWVcbiAgICAgKiBAcGFyYW0ge3N0cmluZ1tdfSBleGVjdXRlXG4gICAgICogQHBhcmFtIHtzdHJpbmdbXX0gZXZlbnRzXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHNjaGVkdWxlXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHRpbWVvdXRcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IGVuYWJsZWRcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IGxvZ2dpbmdcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gZW50cnlwb2ludFxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBjb21tYW5kc1xuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBpbnN0YWxsYXRpb25JZFxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBwcm92aWRlclJlcG9zaXRvcnlJZFxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBwcm92aWRlckJyYW5jaFxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gcHJvdmlkZXJTaWxlbnRNb2RlXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHByb3ZpZGVyUm9vdERpcmVjdG9yeVxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSB0ZW1wbGF0ZVJlcG9zaXRvcnlcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gdGVtcGxhdGVPd25lclxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSB0ZW1wbGF0ZVJvb3REaXJlY3RvcnlcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gdGVtcGxhdGVCcmFuY2hcbiAgICAgKiBAdGhyb3dzIHtBcHB3cml0ZUV4Y2VwdGlvbn1cbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZX1cbiAgICAgKi9cbiAgICBhc3luYyBjcmVhdGUoZnVuY3Rpb25JZCwgbmFtZSwgcnVudGltZSwgZXhlY3V0ZSwgZXZlbnRzLCBzY2hlZHVsZSwgdGltZW91dCwgZW5hYmxlZCwgbG9nZ2luZywgZW50cnlwb2ludCwgY29tbWFuZHMsIGluc3RhbGxhdGlvbklkLCBwcm92aWRlclJlcG9zaXRvcnlJZCwgcHJvdmlkZXJCcmFuY2gsIHByb3ZpZGVyU2lsZW50TW9kZSwgcHJvdmlkZXJSb290RGlyZWN0b3J5LCB0ZW1wbGF0ZVJlcG9zaXRvcnksIHRlbXBsYXRlT3duZXIsIHRlbXBsYXRlUm9vdERpcmVjdG9yeSwgdGVtcGxhdGVCcmFuY2gpIHtcbiAgICAgICAgY29uc3QgYXBpUGF0aCA9ICcvZnVuY3Rpb25zJztcbiAgICAgICAgbGV0IHBheWxvYWQgPSB7fTtcbiAgICAgICAgaWYgKHR5cGVvZiBmdW5jdGlvbklkID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEFwcHdyaXRlRXhjZXB0aW9uKCdNaXNzaW5nIHJlcXVpcmVkIHBhcmFtZXRlcjogXCJmdW5jdGlvbklkXCInKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0eXBlb2YgbmFtZSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBBcHB3cml0ZUV4Y2VwdGlvbignTWlzc2luZyByZXF1aXJlZCBwYXJhbWV0ZXI6IFwibmFtZVwiJyk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodHlwZW9mIHJ1bnRpbWUgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgQXBwd3JpdGVFeGNlcHRpb24oJ01pc3NpbmcgcmVxdWlyZWQgcGFyYW1ldGVyOiBcInJ1bnRpbWVcIicpO1xuICAgICAgICB9XG5cblxuICAgICAgICBpZiAodHlwZW9mIGZ1bmN0aW9uSWQgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICBwYXlsb2FkWydmdW5jdGlvbklkJ10gPSBmdW5jdGlvbklkO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHR5cGVvZiBuYW1lICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgcGF5bG9hZFsnbmFtZSddID0gbmFtZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0eXBlb2YgcnVudGltZSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHBheWxvYWRbJ3J1bnRpbWUnXSA9IHJ1bnRpbWU7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodHlwZW9mIGV4ZWN1dGUgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICBwYXlsb2FkWydleGVjdXRlJ10gPSBleGVjdXRlO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHR5cGVvZiBldmVudHMgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICBwYXlsb2FkWydldmVudHMnXSA9IGV2ZW50cztcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0eXBlb2Ygc2NoZWR1bGUgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICBwYXlsb2FkWydzY2hlZHVsZSddID0gc2NoZWR1bGU7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodHlwZW9mIHRpbWVvdXQgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICBwYXlsb2FkWyd0aW1lb3V0J10gPSB0aW1lb3V0O1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHR5cGVvZiBlbmFibGVkICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgcGF5bG9hZFsnZW5hYmxlZCddID0gZW5hYmxlZDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0eXBlb2YgbG9nZ2luZyAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHBheWxvYWRbJ2xvZ2dpbmcnXSA9IGxvZ2dpbmc7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodHlwZW9mIGVudHJ5cG9pbnQgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICBwYXlsb2FkWydlbnRyeXBvaW50J10gPSBlbnRyeXBvaW50O1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHR5cGVvZiBjb21tYW5kcyAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHBheWxvYWRbJ2NvbW1hbmRzJ10gPSBjb21tYW5kcztcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0eXBlb2YgaW5zdGFsbGF0aW9uSWQgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICBwYXlsb2FkWydpbnN0YWxsYXRpb25JZCddID0gaW5zdGFsbGF0aW9uSWQ7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodHlwZW9mIHByb3ZpZGVyUmVwb3NpdG9yeUlkICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgcGF5bG9hZFsncHJvdmlkZXJSZXBvc2l0b3J5SWQnXSA9IHByb3ZpZGVyUmVwb3NpdG9yeUlkO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHR5cGVvZiBwcm92aWRlckJyYW5jaCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHBheWxvYWRbJ3Byb3ZpZGVyQnJhbmNoJ10gPSBwcm92aWRlckJyYW5jaDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0eXBlb2YgcHJvdmlkZXJTaWxlbnRNb2RlICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgcGF5bG9hZFsncHJvdmlkZXJTaWxlbnRNb2RlJ10gPSBwcm92aWRlclNpbGVudE1vZGU7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodHlwZW9mIHByb3ZpZGVyUm9vdERpcmVjdG9yeSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHBheWxvYWRbJ3Byb3ZpZGVyUm9vdERpcmVjdG9yeSddID0gcHJvdmlkZXJSb290RGlyZWN0b3J5O1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHR5cGVvZiB0ZW1wbGF0ZVJlcG9zaXRvcnkgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICBwYXlsb2FkWyd0ZW1wbGF0ZVJlcG9zaXRvcnknXSA9IHRlbXBsYXRlUmVwb3NpdG9yeTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0eXBlb2YgdGVtcGxhdGVPd25lciAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHBheWxvYWRbJ3RlbXBsYXRlT3duZXInXSA9IHRlbXBsYXRlT3duZXI7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodHlwZW9mIHRlbXBsYXRlUm9vdERpcmVjdG9yeSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHBheWxvYWRbJ3RlbXBsYXRlUm9vdERpcmVjdG9yeSddID0gdGVtcGxhdGVSb290RGlyZWN0b3J5O1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHR5cGVvZiB0ZW1wbGF0ZUJyYW5jaCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHBheWxvYWRbJ3RlbXBsYXRlQnJhbmNoJ10gPSB0ZW1wbGF0ZUJyYW5jaDtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBhd2FpdCB0aGlzLmNsaWVudC5jYWxsKCdwb3N0JywgYXBpUGF0aCwge1xuICAgICAgICAgICAgJ2NvbnRlbnQtdHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJyxcbiAgICAgICAgfSwgcGF5bG9hZCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogTGlzdCBydW50aW1lc1xuICAgICAqXG4gICAgICogR2V0IGEgbGlzdCBvZiBhbGwgcnVudGltZXMgdGhhdCBhcmUgY3VycmVudGx5IGFjdGl2ZSBvbiB5b3VyIGluc3RhbmNlLlxuICAgICAqXG4gICAgICogQHRocm93cyB7QXBwd3JpdGVFeGNlcHRpb259XG4gICAgICogQHJldHVybnMge1Byb21pc2V9XG4gICAgICovXG4gICAgYXN5bmMgbGlzdFJ1bnRpbWVzKCkge1xuICAgICAgICBjb25zdCBhcGlQYXRoID0gJy9mdW5jdGlvbnMvcnVudGltZXMnO1xuICAgICAgICBsZXQgcGF5bG9hZCA9IHt9O1xuXG4gICAgICAgIHJldHVybiBhd2FpdCB0aGlzLmNsaWVudC5jYWxsKCdnZXQnLCBhcGlQYXRoLCB7XG4gICAgICAgICAgICAnY29udGVudC10eXBlJzogJ2FwcGxpY2F0aW9uL2pzb24nLFxuICAgICAgICB9LCBwYXlsb2FkKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZXQgZnVuY3Rpb25cbiAgICAgKlxuICAgICAqIEdldCBhIGZ1bmN0aW9uIGJ5IGl0cyB1bmlxdWUgSUQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gZnVuY3Rpb25JZFxuICAgICAqIEB0aHJvd3Mge0FwcHdyaXRlRXhjZXB0aW9ufVxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlfVxuICAgICAqL1xuICAgIGFzeW5jIGdldChmdW5jdGlvbklkKSB7XG4gICAgICAgIGNvbnN0IGFwaVBhdGggPSAnL2Z1bmN0aW9ucy97ZnVuY3Rpb25JZH0nLnJlcGxhY2UoJ3tmdW5jdGlvbklkfScsIGZ1bmN0aW9uSWQpO1xuICAgICAgICBsZXQgcGF5bG9hZCA9IHt9O1xuICAgICAgICBpZiAodHlwZW9mIGZ1bmN0aW9uSWQgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgQXBwd3JpdGVFeGNlcHRpb24oJ01pc3NpbmcgcmVxdWlyZWQgcGFyYW1ldGVyOiBcImZ1bmN0aW9uSWRcIicpO1xuICAgICAgICB9XG5cblxuICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy5jbGllbnQuY2FsbCgnZ2V0JywgYXBpUGF0aCwge1xuICAgICAgICAgICAgJ2NvbnRlbnQtdHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJyxcbiAgICAgICAgfSwgcGF5bG9hZCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVXBkYXRlIGZ1bmN0aW9uXG4gICAgICpcbiAgICAgKiBVcGRhdGUgZnVuY3Rpb24gYnkgaXRzIHVuaXF1ZSBJRC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBmdW5jdGlvbklkXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IG5hbWVcbiAgICAgKiBAcGFyYW0ge1J1bnRpbWV9IHJ1bnRpbWVcbiAgICAgKiBAcGFyYW0ge3N0cmluZ1tdfSBleGVjdXRlXG4gICAgICogQHBhcmFtIHtzdHJpbmdbXX0gZXZlbnRzXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHNjaGVkdWxlXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHRpbWVvdXRcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IGVuYWJsZWRcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IGxvZ2dpbmdcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gZW50cnlwb2ludFxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBjb21tYW5kc1xuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBpbnN0YWxsYXRpb25JZFxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBwcm92aWRlclJlcG9zaXRvcnlJZFxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBwcm92aWRlckJyYW5jaFxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gcHJvdmlkZXJTaWxlbnRNb2RlXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHByb3ZpZGVyUm9vdERpcmVjdG9yeVxuICAgICAqIEB0aHJvd3Mge0FwcHdyaXRlRXhjZXB0aW9ufVxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlfVxuICAgICAqL1xuICAgIGFzeW5jIHVwZGF0ZShmdW5jdGlvbklkLCBuYW1lLCBydW50aW1lLCBleGVjdXRlLCBldmVudHMsIHNjaGVkdWxlLCB0aW1lb3V0LCBlbmFibGVkLCBsb2dnaW5nLCBlbnRyeXBvaW50LCBjb21tYW5kcywgaW5zdGFsbGF0aW9uSWQsIHByb3ZpZGVyUmVwb3NpdG9yeUlkLCBwcm92aWRlckJyYW5jaCwgcHJvdmlkZXJTaWxlbnRNb2RlLCBwcm92aWRlclJvb3REaXJlY3RvcnkpIHtcbiAgICAgICAgY29uc3QgYXBpUGF0aCA9ICcvZnVuY3Rpb25zL3tmdW5jdGlvbklkfScucmVwbGFjZSgne2Z1bmN0aW9uSWR9JywgZnVuY3Rpb25JZCk7XG4gICAgICAgIGxldCBwYXlsb2FkID0ge307XG4gICAgICAgIGlmICh0eXBlb2YgZnVuY3Rpb25JZCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBBcHB3cml0ZUV4Y2VwdGlvbignTWlzc2luZyByZXF1aXJlZCBwYXJhbWV0ZXI6IFwiZnVuY3Rpb25JZFwiJyk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodHlwZW9mIG5hbWUgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgQXBwd3JpdGVFeGNlcHRpb24oJ01pc3NpbmcgcmVxdWlyZWQgcGFyYW1ldGVyOiBcIm5hbWVcIicpO1xuICAgICAgICB9XG5cblxuICAgICAgICBpZiAodHlwZW9mIG5hbWUgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICBwYXlsb2FkWyduYW1lJ10gPSBuYW1lO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHR5cGVvZiBydW50aW1lICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgcGF5bG9hZFsncnVudGltZSddID0gcnVudGltZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0eXBlb2YgZXhlY3V0ZSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHBheWxvYWRbJ2V4ZWN1dGUnXSA9IGV4ZWN1dGU7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodHlwZW9mIGV2ZW50cyAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHBheWxvYWRbJ2V2ZW50cyddID0gZXZlbnRzO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHR5cGVvZiBzY2hlZHVsZSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHBheWxvYWRbJ3NjaGVkdWxlJ10gPSBzY2hlZHVsZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0eXBlb2YgdGltZW91dCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHBheWxvYWRbJ3RpbWVvdXQnXSA9IHRpbWVvdXQ7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodHlwZW9mIGVuYWJsZWQgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICBwYXlsb2FkWydlbmFibGVkJ10gPSBlbmFibGVkO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHR5cGVvZiBsb2dnaW5nICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgcGF5bG9hZFsnbG9nZ2luZyddID0gbG9nZ2luZztcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0eXBlb2YgZW50cnlwb2ludCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHBheWxvYWRbJ2VudHJ5cG9pbnQnXSA9IGVudHJ5cG9pbnQ7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodHlwZW9mIGNvbW1hbmRzICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgcGF5bG9hZFsnY29tbWFuZHMnXSA9IGNvbW1hbmRzO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHR5cGVvZiBpbnN0YWxsYXRpb25JZCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHBheWxvYWRbJ2luc3RhbGxhdGlvbklkJ10gPSBpbnN0YWxsYXRpb25JZDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0eXBlb2YgcHJvdmlkZXJSZXBvc2l0b3J5SWQgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICBwYXlsb2FkWydwcm92aWRlclJlcG9zaXRvcnlJZCddID0gcHJvdmlkZXJSZXBvc2l0b3J5SWQ7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodHlwZW9mIHByb3ZpZGVyQnJhbmNoICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgcGF5bG9hZFsncHJvdmlkZXJCcmFuY2gnXSA9IHByb3ZpZGVyQnJhbmNoO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHR5cGVvZiBwcm92aWRlclNpbGVudE1vZGUgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICBwYXlsb2FkWydwcm92aWRlclNpbGVudE1vZGUnXSA9IHByb3ZpZGVyU2lsZW50TW9kZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0eXBlb2YgcHJvdmlkZXJSb290RGlyZWN0b3J5ICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgcGF5bG9hZFsncHJvdmlkZXJSb290RGlyZWN0b3J5J10gPSBwcm92aWRlclJvb3REaXJlY3Rvcnk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy5jbGllbnQuY2FsbCgncHV0JywgYXBpUGF0aCwge1xuICAgICAgICAgICAgJ2NvbnRlbnQtdHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJyxcbiAgICAgICAgfSwgcGF5bG9hZCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRGVsZXRlIGZ1bmN0aW9uXG4gICAgICpcbiAgICAgKiBEZWxldGUgYSBmdW5jdGlvbiBieSBpdHMgdW5pcXVlIElELlxuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGZ1bmN0aW9uSWRcbiAgICAgKiBAdGhyb3dzIHtBcHB3cml0ZUV4Y2VwdGlvbn1cbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZX1cbiAgICAgKi9cbiAgICBhc3luYyBkZWxldGUoZnVuY3Rpb25JZCkge1xuICAgICAgICBjb25zdCBhcGlQYXRoID0gJy9mdW5jdGlvbnMve2Z1bmN0aW9uSWR9Jy5yZXBsYWNlKCd7ZnVuY3Rpb25JZH0nLCBmdW5jdGlvbklkKTtcbiAgICAgICAgbGV0IHBheWxvYWQgPSB7fTtcbiAgICAgICAgaWYgKHR5cGVvZiBmdW5jdGlvbklkID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEFwcHdyaXRlRXhjZXB0aW9uKCdNaXNzaW5nIHJlcXVpcmVkIHBhcmFtZXRlcjogXCJmdW5jdGlvbklkXCInKTtcbiAgICAgICAgfVxuXG5cbiAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMuY2xpZW50LmNhbGwoJ2RlbGV0ZScsIGFwaVBhdGgsIHtcbiAgICAgICAgICAgICdjb250ZW50LXR5cGUnOiAnYXBwbGljYXRpb24vanNvbicsXG4gICAgICAgIH0sIHBheWxvYWQpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIExpc3QgZGVwbG95bWVudHNcbiAgICAgKlxuICAgICAqIEdldCBhIGxpc3Qgb2YgYWxsIHRoZSBwcm9qZWN0J3MgY29kZSBkZXBsb3ltZW50cy4gWW91IGNhbiB1c2UgdGhlIHF1ZXJ5XG4gICAgICogcGFyYW1zIHRvIGZpbHRlciB5b3VyIHJlc3VsdHMuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gZnVuY3Rpb25JZFxuICAgICAqIEBwYXJhbSB7c3RyaW5nW119IHF1ZXJpZXNcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gc2VhcmNoXG4gICAgICogQHRocm93cyB7QXBwd3JpdGVFeGNlcHRpb259XG4gICAgICogQHJldHVybnMge1Byb21pc2V9XG4gICAgICovXG4gICAgYXN5bmMgbGlzdERlcGxveW1lbnRzKGZ1bmN0aW9uSWQsIHF1ZXJpZXMsIHNlYXJjaCkge1xuICAgICAgICBjb25zdCBhcGlQYXRoID0gJy9mdW5jdGlvbnMve2Z1bmN0aW9uSWR9L2RlcGxveW1lbnRzJy5yZXBsYWNlKCd7ZnVuY3Rpb25JZH0nLCBmdW5jdGlvbklkKTtcbiAgICAgICAgbGV0IHBheWxvYWQgPSB7fTtcbiAgICAgICAgaWYgKHR5cGVvZiBmdW5jdGlvbklkID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEFwcHdyaXRlRXhjZXB0aW9uKCdNaXNzaW5nIHJlcXVpcmVkIHBhcmFtZXRlcjogXCJmdW5jdGlvbklkXCInKTtcbiAgICAgICAgfVxuXG5cbiAgICAgICAgaWYgKHR5cGVvZiBxdWVyaWVzICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgcGF5bG9hZFsncXVlcmllcyddID0gcXVlcmllcztcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0eXBlb2Ygc2VhcmNoICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgcGF5bG9hZFsnc2VhcmNoJ10gPSBzZWFyY2g7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy5jbGllbnQuY2FsbCgnZ2V0JywgYXBpUGF0aCwge1xuICAgICAgICAgICAgJ2NvbnRlbnQtdHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJyxcbiAgICAgICAgfSwgcGF5bG9hZCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlIGRlcGxveW1lbnRcbiAgICAgKlxuICAgICAqIENyZWF0ZSBhIG5ldyBmdW5jdGlvbiBjb2RlIGRlcGxveW1lbnQuIFVzZSB0aGlzIGVuZHBvaW50IHRvIHVwbG9hZCBhIG5ld1xuICAgICAqIHZlcnNpb24gb2YgeW91ciBjb2RlIGZ1bmN0aW9uLiBUbyBleGVjdXRlIHlvdXIgbmV3bHkgdXBsb2FkZWQgY29kZSwgeW91J2xsXG4gICAgICogbmVlZCB0byB1cGRhdGUgdGhlIGZ1bmN0aW9uJ3MgZGVwbG95bWVudCB0byB1c2UgeW91ciBuZXcgZGVwbG95bWVudCBVSUQuXG4gICAgICogXG4gICAgICogVGhpcyBlbmRwb2ludCBhY2NlcHRzIGEgdGFyLmd6IGZpbGUgY29tcHJlc3NlZCB3aXRoIHlvdXIgY29kZS4gTWFrZSBzdXJlIHRvXG4gICAgICogaW5jbHVkZSBhbnkgZGVwZW5kZW5jaWVzIHlvdXIgY29kZSBoYXMgd2l0aGluIHRoZSBjb21wcmVzc2VkIGZpbGUuIFlvdSBjYW5cbiAgICAgKiBsZWFybiBtb3JlIGFib3V0IGNvZGUgcGFja2FnaW5nIGluIHRoZSBbQXBwd3JpdGUgQ2xvdWQgRnVuY3Rpb25zXG4gICAgICogdHV0b3JpYWxdKGh0dHBzOi8vYXBwd3JpdGUuaW8vZG9jcy9mdW5jdGlvbnMpLlxuICAgICAqIFxuICAgICAqIFVzZSB0aGUgXCJjb21tYW5kXCIgcGFyYW0gdG8gc2V0IHRoZSBlbnRyeXBvaW50IHVzZWQgdG8gZXhlY3V0ZSB5b3VyIGNvZGUuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gZnVuY3Rpb25JZFxuICAgICAqIEBwYXJhbSB7SW5wdXRGaWxlfSBjb2RlXG4gICAgICogQHBhcmFtIHtib29sZWFufSBhY3RpdmF0ZVxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBlbnRyeXBvaW50XG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGNvbW1hbmRzXG4gICAgICogQHBhcmFtIHtDYWxsYWJsZUZ1bmN0aW9ufSBvblByb2dyZXNzXG4gICAgICogQHRocm93cyB7QXBwd3JpdGVFeGNlcHRpb259XG4gICAgICogQHJldHVybnMge1Byb21pc2V9XG4gICAgICovXG4gICAgYXN5bmMgY3JlYXRlRGVwbG95bWVudChmdW5jdGlvbklkLCBjb2RlLCBhY3RpdmF0ZSwgZW50cnlwb2ludCwgY29tbWFuZHMsIG9uUHJvZ3Jlc3MgPSAoKSA9PiB7fSkge1xuICAgICAgICBjb25zdCBhcGlQYXRoID0gJy9mdW5jdGlvbnMve2Z1bmN0aW9uSWR9L2RlcGxveW1lbnRzJy5yZXBsYWNlKCd7ZnVuY3Rpb25JZH0nLCBmdW5jdGlvbklkKTtcbiAgICAgICAgbGV0IHBheWxvYWQgPSB7fTtcbiAgICAgICAgaWYgKHR5cGVvZiBmdW5jdGlvbklkID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEFwcHdyaXRlRXhjZXB0aW9uKCdNaXNzaW5nIHJlcXVpcmVkIHBhcmFtZXRlcjogXCJmdW5jdGlvbklkXCInKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0eXBlb2YgY29kZSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBBcHB3cml0ZUV4Y2VwdGlvbignTWlzc2luZyByZXF1aXJlZCBwYXJhbWV0ZXI6IFwiY29kZVwiJyk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodHlwZW9mIGFjdGl2YXRlID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEFwcHdyaXRlRXhjZXB0aW9uKCdNaXNzaW5nIHJlcXVpcmVkIHBhcmFtZXRlcjogXCJhY3RpdmF0ZVwiJyk7XG4gICAgICAgIH1cblxuXG4gICAgICAgIGlmICh0eXBlb2YgZW50cnlwb2ludCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHBheWxvYWRbJ2VudHJ5cG9pbnQnXSA9IGVudHJ5cG9pbnQ7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodHlwZW9mIGNvbW1hbmRzICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgcGF5bG9hZFsnY29tbWFuZHMnXSA9IGNvbW1hbmRzO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHR5cGVvZiBjb2RlICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgcGF5bG9hZFsnY29kZSddID0gY29kZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0eXBlb2YgYWN0aXZhdGUgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICBwYXlsb2FkWydhY3RpdmF0ZSddID0gYWN0aXZhdGUudG9TdHJpbmcoKTtcbiAgICAgICAgfVxuXG5cbiAgICAgICAgY29uc3Qgc2l6ZSA9IGNvZGUuc2l6ZTtcbiAgICAgICAgXG4gICAgICAgIGNvbnN0IGFwaUhlYWRlcnMgPSB7XG4gICAgICAgICAgICAnY29udGVudC10eXBlJzogJ211bHRpcGFydC9mb3JtLWRhdGEnLFxuICAgICAgICB9O1xuXG4gICAgICAgIGxldCBpZCA9IHVuZGVmaW5lZDtcbiAgICAgICAgbGV0IHJlc3BvbnNlID0gdW5kZWZpbmVkO1xuXG4gICAgICAgIGxldCBjaHVua3NVcGxvYWRlZCA9IDA7XG5cblxuICAgICAgICBsZXQgY3VycmVudENodW5rID0gMTtcbiAgICAgICAgbGV0IGN1cnJlbnRQb3NpdGlvbiA9IDA7XG4gICAgICAgIGxldCB1cGxvYWRhYmxlQ2h1bmsgPSBuZXcgVWludDhBcnJheShjbGllbnQuQ0hVTktfU0laRSk7XG4gICAgXG5cbiAgICAgICAgY29uc3QgdXBsb2FkQ2h1bmsgPSBhc3luYyAobGFzdFVwbG9hZCA9IGZhbHNlKSA9PiB7XG4gICAgICAgICAgICBpZihjdXJyZW50Q2h1bmsgPD0gY2h1bmtzVXBsb2FkZWQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGNvbnN0IHN0YXJ0ID0gKChjdXJyZW50Q2h1bmsgLSAxKSAqIGNsaWVudC5DSFVOS19TSVpFKTtcbiAgICAgICAgICAgIGxldCBlbmQgPSBzdGFydCArIGN1cnJlbnRQb3NpdGlvbiAtIDE7XG5cbiAgICAgICAgICAgIGlmKCFsYXN0VXBsb2FkIHx8IGN1cnJlbnRDaHVuayAhPT0gMSkge1xuICAgICAgICAgICAgICAgIGFwaUhlYWRlcnNbJ2NvbnRlbnQtcmFuZ2UnXSA9ICdieXRlcyAnICsgc3RhcnQgKyAnLScgKyBlbmQgKyAnLycgKyBzaXplO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBsZXQgdXBsb2FkYWJsZUNodW5rVHJpbW1lZDtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgaWYoY3VycmVudFBvc2l0aW9uICsgMSA+PSBjbGllbnQuQ0hVTktfU0laRSkge1xuICAgICAgICAgICAgICAgIHVwbG9hZGFibGVDaHVua1RyaW1tZWQgPSB1cGxvYWRhYmxlQ2h1bms7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHVwbG9hZGFibGVDaHVua1RyaW1tZWQgPSBuZXcgVWludDhBcnJheShjdXJyZW50UG9zaXRpb24pO1xuICAgICAgICAgICAgICAgIGZvcihsZXQgaSA9IDA7IGkgPD0gY3VycmVudFBvc2l0aW9uOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgdXBsb2FkYWJsZUNodW5rVHJpbW1lZFtpXSA9IHVwbG9hZGFibGVDaHVua1tpXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChpZCkge1xuICAgICAgICAgICAgICAgIGFwaUhlYWRlcnNbJ3gtYXBwd3JpdGUtaWQnXSA9IGlkO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBwYXlsb2FkWydjb2RlJ10gPSB7IHR5cGU6ICdmaWxlJywgZmlsZTogbmV3IEZpbGUoW3VwbG9hZGFibGVDaHVua1RyaW1tZWRdLCBjb2RlLmZpbGVuYW1lKSwgZmlsZW5hbWU6IGNvZGUuZmlsZW5hbWUgfTtcblxuICAgICAgICAgICAgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLmNsaWVudC5jYWxsKCdwb3N0JywgYXBpUGF0aCwgYXBpSGVhZGVycywgcGF5bG9hZCk7XG5cbiAgICAgICAgICAgIGlmICghaWQpIHtcbiAgICAgICAgICAgICAgICBpZCA9IHJlc3BvbnNlWyckaWQnXTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKG9uUHJvZ3Jlc3MgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICBvblByb2dyZXNzKHtcbiAgICAgICAgICAgICAgICAgICAgJGlkOiByZXNwb25zZVsnJGlkJ10sXG4gICAgICAgICAgICAgICAgICAgIHByb2dyZXNzOiBNYXRoLm1pbigoY3VycmVudENodW5rKSAqIGNsaWVudC5DSFVOS19TSVpFLCBzaXplKSAvIHNpemUgKiAxMDAsXG4gICAgICAgICAgICAgICAgICAgIHNpemVVcGxvYWRlZDogZW5kKzEsXG4gICAgICAgICAgICAgICAgICAgIGNodW5rc1RvdGFsOiByZXNwb25zZVsnY2h1bmtzVG90YWwnXSxcbiAgICAgICAgICAgICAgICAgICAgY2h1bmtzVXBsb2FkZWQ6IHJlc3BvbnNlWydjaHVua3NVcGxvYWRlZCddXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHVwbG9hZGFibGVDaHVuayA9IG5ldyBVaW50OEFycmF5KGNsaWVudC5DSFVOS19TSVpFKTtcbiAgICAgICAgICAgIGN1cnJlbnRDaHVuaysrO1xuICAgICAgICAgICAgY3VycmVudFBvc2l0aW9uID0gMDtcbiAgICAgICAgfVxuXG4gICAgICAgIGZvciBhd2FpdCAoY29uc3QgY2h1bmsgb2YgY29kZS5zdHJlYW0pIHtcbiAgICAgICAgICAgIGZvcihjb25zdCBiIG9mIGNodW5rKSB7XG4gICAgICAgICAgICAgICAgdXBsb2FkYWJsZUNodW5rW2N1cnJlbnRQb3NpdGlvbl0gPSBiO1xuXG4gICAgICAgICAgICAgICAgY3VycmVudFBvc2l0aW9uKys7XG4gICAgICAgICAgICAgICAgaWYoY3VycmVudFBvc2l0aW9uID49IGNsaWVudC5DSFVOS19TSVpFKSB7XG4gICAgICAgICAgICAgICAgICAgIGF3YWl0IHVwbG9hZENodW5rKCk7XG4gICAgICAgICAgICAgICAgICAgIGN1cnJlbnRQb3NpdGlvbiA9IDA7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGN1cnJlbnRQb3NpdGlvbiA+IDApIHsgLy8gQ2hlY2sgaWYgdGhlcmUncyBhbnkgcmVtYWluaW5nIGRhdGEgZm9yIHRoZSBsYXN0IGNodW5rXG4gICAgICAgICAgICBhd2FpdCB1cGxvYWRDaHVuayh0cnVlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiByZXNwb25zZTtcblxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdldCBkZXBsb3ltZW50XG4gICAgICpcbiAgICAgKiBHZXQgYSBjb2RlIGRlcGxveW1lbnQgYnkgaXRzIHVuaXF1ZSBJRC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBmdW5jdGlvbklkXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGRlcGxveW1lbnRJZFxuICAgICAqIEB0aHJvd3Mge0FwcHdyaXRlRXhjZXB0aW9ufVxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlfVxuICAgICAqL1xuICAgIGFzeW5jIGdldERlcGxveW1lbnQoZnVuY3Rpb25JZCwgZGVwbG95bWVudElkKSB7XG4gICAgICAgIGNvbnN0IGFwaVBhdGggPSAnL2Z1bmN0aW9ucy97ZnVuY3Rpb25JZH0vZGVwbG95bWVudHMve2RlcGxveW1lbnRJZH0nLnJlcGxhY2UoJ3tmdW5jdGlvbklkfScsIGZ1bmN0aW9uSWQpLnJlcGxhY2UoJ3tkZXBsb3ltZW50SWR9JywgZGVwbG95bWVudElkKTtcbiAgICAgICAgbGV0IHBheWxvYWQgPSB7fTtcbiAgICAgICAgaWYgKHR5cGVvZiBmdW5jdGlvbklkID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEFwcHdyaXRlRXhjZXB0aW9uKCdNaXNzaW5nIHJlcXVpcmVkIHBhcmFtZXRlcjogXCJmdW5jdGlvbklkXCInKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0eXBlb2YgZGVwbG95bWVudElkID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEFwcHdyaXRlRXhjZXB0aW9uKCdNaXNzaW5nIHJlcXVpcmVkIHBhcmFtZXRlcjogXCJkZXBsb3ltZW50SWRcIicpO1xuICAgICAgICB9XG5cblxuICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy5jbGllbnQuY2FsbCgnZ2V0JywgYXBpUGF0aCwge1xuICAgICAgICAgICAgJ2NvbnRlbnQtdHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJyxcbiAgICAgICAgfSwgcGF5bG9hZCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVXBkYXRlIGZ1bmN0aW9uIGRlcGxveW1lbnRcbiAgICAgKlxuICAgICAqIFVwZGF0ZSB0aGUgZnVuY3Rpb24gY29kZSBkZXBsb3ltZW50IElEIHVzaW5nIHRoZSB1bmlxdWUgZnVuY3Rpb24gSUQuIFVzZVxuICAgICAqIHRoaXMgZW5kcG9pbnQgdG8gc3dpdGNoIHRoZSBjb2RlIGRlcGxveW1lbnQgdGhhdCBzaG91bGQgYmUgZXhlY3V0ZWQgYnkgdGhlXG4gICAgICogZXhlY3V0aW9uIGVuZHBvaW50LlxuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGZ1bmN0aW9uSWRcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gZGVwbG95bWVudElkXG4gICAgICogQHRocm93cyB7QXBwd3JpdGVFeGNlcHRpb259XG4gICAgICogQHJldHVybnMge1Byb21pc2V9XG4gICAgICovXG4gICAgYXN5bmMgdXBkYXRlRGVwbG95bWVudChmdW5jdGlvbklkLCBkZXBsb3ltZW50SWQpIHtcbiAgICAgICAgY29uc3QgYXBpUGF0aCA9ICcvZnVuY3Rpb25zL3tmdW5jdGlvbklkfS9kZXBsb3ltZW50cy97ZGVwbG95bWVudElkfScucmVwbGFjZSgne2Z1bmN0aW9uSWR9JywgZnVuY3Rpb25JZCkucmVwbGFjZSgne2RlcGxveW1lbnRJZH0nLCBkZXBsb3ltZW50SWQpO1xuICAgICAgICBsZXQgcGF5bG9hZCA9IHt9O1xuICAgICAgICBpZiAodHlwZW9mIGZ1bmN0aW9uSWQgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgQXBwd3JpdGVFeGNlcHRpb24oJ01pc3NpbmcgcmVxdWlyZWQgcGFyYW1ldGVyOiBcImZ1bmN0aW9uSWRcIicpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHR5cGVvZiBkZXBsb3ltZW50SWQgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgQXBwd3JpdGVFeGNlcHRpb24oJ01pc3NpbmcgcmVxdWlyZWQgcGFyYW1ldGVyOiBcImRlcGxveW1lbnRJZFwiJyk7XG4gICAgICAgIH1cblxuXG4gICAgICAgIHJldHVybiBhd2FpdCB0aGlzLmNsaWVudC5jYWxsKCdwYXRjaCcsIGFwaVBhdGgsIHtcbiAgICAgICAgICAgICdjb250ZW50LXR5cGUnOiAnYXBwbGljYXRpb24vanNvbicsXG4gICAgICAgIH0sIHBheWxvYWQpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIERlbGV0ZSBkZXBsb3ltZW50XG4gICAgICpcbiAgICAgKiBEZWxldGUgYSBjb2RlIGRlcGxveW1lbnQgYnkgaXRzIHVuaXF1ZSBJRC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBmdW5jdGlvbklkXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGRlcGxveW1lbnRJZFxuICAgICAqIEB0aHJvd3Mge0FwcHdyaXRlRXhjZXB0aW9ufVxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlfVxuICAgICAqL1xuICAgIGFzeW5jIGRlbGV0ZURlcGxveW1lbnQoZnVuY3Rpb25JZCwgZGVwbG95bWVudElkKSB7XG4gICAgICAgIGNvbnN0IGFwaVBhdGggPSAnL2Z1bmN0aW9ucy97ZnVuY3Rpb25JZH0vZGVwbG95bWVudHMve2RlcGxveW1lbnRJZH0nLnJlcGxhY2UoJ3tmdW5jdGlvbklkfScsIGZ1bmN0aW9uSWQpLnJlcGxhY2UoJ3tkZXBsb3ltZW50SWR9JywgZGVwbG95bWVudElkKTtcbiAgICAgICAgbGV0IHBheWxvYWQgPSB7fTtcbiAgICAgICAgaWYgKHR5cGVvZiBmdW5jdGlvbklkID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEFwcHdyaXRlRXhjZXB0aW9uKCdNaXNzaW5nIHJlcXVpcmVkIHBhcmFtZXRlcjogXCJmdW5jdGlvbklkXCInKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0eXBlb2YgZGVwbG95bWVudElkID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEFwcHdyaXRlRXhjZXB0aW9uKCdNaXNzaW5nIHJlcXVpcmVkIHBhcmFtZXRlcjogXCJkZXBsb3ltZW50SWRcIicpO1xuICAgICAgICB9XG5cblxuICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy5jbGllbnQuY2FsbCgnZGVsZXRlJywgYXBpUGF0aCwge1xuICAgICAgICAgICAgJ2NvbnRlbnQtdHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJyxcbiAgICAgICAgfSwgcGF5bG9hZCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlIGJ1aWxkXG4gICAgICpcbiAgICAgKiBDcmVhdGUgYSBuZXcgYnVpbGQgZm9yIGFuIEFwcHdyaXRlIEZ1bmN0aW9uIGRlcGxveW1lbnQuIFRoaXMgZW5kcG9pbnQgY2FuXG4gICAgICogYmUgdXNlZCB0byByZXRyeSBhIGZhaWxlZCBidWlsZC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBmdW5jdGlvbklkXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGRlcGxveW1lbnRJZFxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBidWlsZElkXG4gICAgICogQHRocm93cyB7QXBwd3JpdGVFeGNlcHRpb259XG4gICAgICogQHJldHVybnMge1Byb21pc2V9XG4gICAgICovXG4gICAgYXN5bmMgY3JlYXRlQnVpbGQoZnVuY3Rpb25JZCwgZGVwbG95bWVudElkLCBidWlsZElkKSB7XG4gICAgICAgIGNvbnN0IGFwaVBhdGggPSAnL2Z1bmN0aW9ucy97ZnVuY3Rpb25JZH0vZGVwbG95bWVudHMve2RlcGxveW1lbnRJZH0vYnVpbGRzL3tidWlsZElkfScucmVwbGFjZSgne2Z1bmN0aW9uSWR9JywgZnVuY3Rpb25JZCkucmVwbGFjZSgne2RlcGxveW1lbnRJZH0nLCBkZXBsb3ltZW50SWQpLnJlcGxhY2UoJ3tidWlsZElkfScsIGJ1aWxkSWQpO1xuICAgICAgICBsZXQgcGF5bG9hZCA9IHt9O1xuICAgICAgICBpZiAodHlwZW9mIGZ1bmN0aW9uSWQgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgQXBwd3JpdGVFeGNlcHRpb24oJ01pc3NpbmcgcmVxdWlyZWQgcGFyYW1ldGVyOiBcImZ1bmN0aW9uSWRcIicpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHR5cGVvZiBkZXBsb3ltZW50SWQgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgQXBwd3JpdGVFeGNlcHRpb24oJ01pc3NpbmcgcmVxdWlyZWQgcGFyYW1ldGVyOiBcImRlcGxveW1lbnRJZFwiJyk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodHlwZW9mIGJ1aWxkSWQgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgQXBwd3JpdGVFeGNlcHRpb24oJ01pc3NpbmcgcmVxdWlyZWQgcGFyYW1ldGVyOiBcImJ1aWxkSWRcIicpO1xuICAgICAgICB9XG5cblxuICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy5jbGllbnQuY2FsbCgncG9zdCcsIGFwaVBhdGgsIHtcbiAgICAgICAgICAgICdjb250ZW50LXR5cGUnOiAnYXBwbGljYXRpb24vanNvbicsXG4gICAgICAgIH0sIHBheWxvYWQpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIERvd25sb2FkIERlcGxveW1lbnRcbiAgICAgKlxuICAgICAqIEdldCBhIERlcGxveW1lbnQncyBjb250ZW50cyBieSBpdHMgdW5pcXVlIElELiBUaGlzIGVuZHBvaW50IHN1cHBvcnRzIHJhbmdlXG4gICAgICogcmVxdWVzdHMgZm9yIHBhcnRpYWwgb3Igc3RyZWFtaW5nIGZpbGUgZG93bmxvYWQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gZnVuY3Rpb25JZFxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBkZXBsb3ltZW50SWRcbiAgICAgKiBAdGhyb3dzIHtBcHB3cml0ZUV4Y2VwdGlvbn1cbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZX1cbiAgICAgKi9cbiAgICBhc3luYyBkb3dubG9hZERlcGxveW1lbnQoZnVuY3Rpb25JZCwgZGVwbG95bWVudElkKSB7XG4gICAgICAgIGNvbnN0IGFwaVBhdGggPSAnL2Z1bmN0aW9ucy97ZnVuY3Rpb25JZH0vZGVwbG95bWVudHMve2RlcGxveW1lbnRJZH0vZG93bmxvYWQnLnJlcGxhY2UoJ3tmdW5jdGlvbklkfScsIGZ1bmN0aW9uSWQpLnJlcGxhY2UoJ3tkZXBsb3ltZW50SWR9JywgZGVwbG95bWVudElkKTtcbiAgICAgICAgbGV0IHBheWxvYWQgPSB7fTtcbiAgICAgICAgaWYgKHR5cGVvZiBmdW5jdGlvbklkID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEFwcHdyaXRlRXhjZXB0aW9uKCdNaXNzaW5nIHJlcXVpcmVkIHBhcmFtZXRlcjogXCJmdW5jdGlvbklkXCInKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0eXBlb2YgZGVwbG95bWVudElkID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEFwcHdyaXRlRXhjZXB0aW9uKCdNaXNzaW5nIHJlcXVpcmVkIHBhcmFtZXRlcjogXCJkZXBsb3ltZW50SWRcIicpO1xuICAgICAgICB9XG5cblxuICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy5jbGllbnQuY2FsbCgnZ2V0JywgYXBpUGF0aCwge1xuICAgICAgICAgICAgJ2NvbnRlbnQtdHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJyxcbiAgICAgICAgfSwgcGF5bG9hZCwgJ2FycmF5YnVmZmVyJyk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogTGlzdCBleGVjdXRpb25zXG4gICAgICpcbiAgICAgKiBHZXQgYSBsaXN0IG9mIGFsbCB0aGUgY3VycmVudCB1c2VyIGZ1bmN0aW9uIGV4ZWN1dGlvbiBsb2dzLiBZb3UgY2FuIHVzZSB0aGVcbiAgICAgKiBxdWVyeSBwYXJhbXMgdG8gZmlsdGVyIHlvdXIgcmVzdWx0cy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBmdW5jdGlvbklkXG4gICAgICogQHBhcmFtIHtzdHJpbmdbXX0gcXVlcmllc1xuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBzZWFyY2hcbiAgICAgKiBAdGhyb3dzIHtBcHB3cml0ZUV4Y2VwdGlvbn1cbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZX1cbiAgICAgKi9cbiAgICBhc3luYyBsaXN0RXhlY3V0aW9ucyhmdW5jdGlvbklkLCBxdWVyaWVzLCBzZWFyY2gpIHtcbiAgICAgICAgY29uc3QgYXBpUGF0aCA9ICcvZnVuY3Rpb25zL3tmdW5jdGlvbklkfS9leGVjdXRpb25zJy5yZXBsYWNlKCd7ZnVuY3Rpb25JZH0nLCBmdW5jdGlvbklkKTtcbiAgICAgICAgbGV0IHBheWxvYWQgPSB7fTtcbiAgICAgICAgaWYgKHR5cGVvZiBmdW5jdGlvbklkID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEFwcHdyaXRlRXhjZXB0aW9uKCdNaXNzaW5nIHJlcXVpcmVkIHBhcmFtZXRlcjogXCJmdW5jdGlvbklkXCInKTtcbiAgICAgICAgfVxuXG5cbiAgICAgICAgaWYgKHR5cGVvZiBxdWVyaWVzICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgcGF5bG9hZFsncXVlcmllcyddID0gcXVlcmllcztcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0eXBlb2Ygc2VhcmNoICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgcGF5bG9hZFsnc2VhcmNoJ10gPSBzZWFyY2g7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy5jbGllbnQuY2FsbCgnZ2V0JywgYXBpUGF0aCwge1xuICAgICAgICAgICAgJ2NvbnRlbnQtdHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJyxcbiAgICAgICAgfSwgcGF5bG9hZCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlIGV4ZWN1dGlvblxuICAgICAqXG4gICAgICogVHJpZ2dlciBhIGZ1bmN0aW9uIGV4ZWN1dGlvbi4gVGhlIHJldHVybmVkIG9iamVjdCB3aWxsIHJldHVybiB5b3UgdGhlXG4gICAgICogY3VycmVudCBleGVjdXRpb24gc3RhdHVzLiBZb3UgY2FuIHBpbmcgdGhlIGBHZXQgRXhlY3V0aW9uYCBlbmRwb2ludCB0byBnZXRcbiAgICAgKiB1cGRhdGVzIG9uIHRoZSBjdXJyZW50IGV4ZWN1dGlvbiBzdGF0dXMuIE9uY2UgdGhpcyBlbmRwb2ludCBpcyBjYWxsZWQsIHlvdXJcbiAgICAgKiBmdW5jdGlvbiBleGVjdXRpb24gcHJvY2VzcyB3aWxsIHN0YXJ0IGFzeW5jaHJvbm91c2x5LlxuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGZ1bmN0aW9uSWRcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gYm9keVxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gYXN5bmNcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30geHBhdGhcbiAgICAgKiBAcGFyYW0ge0V4ZWN1dGlvbk1ldGhvZH0gbWV0aG9kXG4gICAgICogQHBhcmFtIHtvYmplY3R9IGhlYWRlcnNcbiAgICAgKiBAdGhyb3dzIHtBcHB3cml0ZUV4Y2VwdGlvbn1cbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZX1cbiAgICAgKi9cbiAgICBhc3luYyBjcmVhdGVFeGVjdXRpb24oZnVuY3Rpb25JZCwgYm9keSwgYXN5bmMsIHhwYXRoLCBtZXRob2QsIGhlYWRlcnMpIHtcbiAgICAgICAgY29uc3QgYXBpUGF0aCA9ICcvZnVuY3Rpb25zL3tmdW5jdGlvbklkfS9leGVjdXRpb25zJy5yZXBsYWNlKCd7ZnVuY3Rpb25JZH0nLCBmdW5jdGlvbklkKTtcbiAgICAgICAgbGV0IHBheWxvYWQgPSB7fTtcbiAgICAgICAgaWYgKHR5cGVvZiBmdW5jdGlvbklkID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEFwcHdyaXRlRXhjZXB0aW9uKCdNaXNzaW5nIHJlcXVpcmVkIHBhcmFtZXRlcjogXCJmdW5jdGlvbklkXCInKTtcbiAgICAgICAgfVxuXG5cbiAgICAgICAgaWYgKHR5cGVvZiBib2R5ICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgcGF5bG9hZFsnYm9keSddID0gYm9keTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0eXBlb2YgYXN5bmMgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICBwYXlsb2FkWydhc3luYyddID0gYXN5bmM7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodHlwZW9mIHhwYXRoICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgcGF5bG9hZFsncGF0aCddID0geHBhdGg7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodHlwZW9mIG1ldGhvZCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHBheWxvYWRbJ21ldGhvZCddID0gbWV0aG9kO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHR5cGVvZiBoZWFkZXJzICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgcGF5bG9hZFsnaGVhZGVycyddID0gaGVhZGVycztcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBhd2FpdCB0aGlzLmNsaWVudC5jYWxsKCdwb3N0JywgYXBpUGF0aCwge1xuICAgICAgICAgICAgJ2NvbnRlbnQtdHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJyxcbiAgICAgICAgfSwgcGF5bG9hZCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2V0IGV4ZWN1dGlvblxuICAgICAqXG4gICAgICogR2V0IGEgZnVuY3Rpb24gZXhlY3V0aW9uIGxvZyBieSBpdHMgdW5pcXVlIElELlxuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGZ1bmN0aW9uSWRcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gZXhlY3V0aW9uSWRcbiAgICAgKiBAdGhyb3dzIHtBcHB3cml0ZUV4Y2VwdGlvbn1cbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZX1cbiAgICAgKi9cbiAgICBhc3luYyBnZXRFeGVjdXRpb24oZnVuY3Rpb25JZCwgZXhlY3V0aW9uSWQpIHtcbiAgICAgICAgY29uc3QgYXBpUGF0aCA9ICcvZnVuY3Rpb25zL3tmdW5jdGlvbklkfS9leGVjdXRpb25zL3tleGVjdXRpb25JZH0nLnJlcGxhY2UoJ3tmdW5jdGlvbklkfScsIGZ1bmN0aW9uSWQpLnJlcGxhY2UoJ3tleGVjdXRpb25JZH0nLCBleGVjdXRpb25JZCk7XG4gICAgICAgIGxldCBwYXlsb2FkID0ge307XG4gICAgICAgIGlmICh0eXBlb2YgZnVuY3Rpb25JZCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBBcHB3cml0ZUV4Y2VwdGlvbignTWlzc2luZyByZXF1aXJlZCBwYXJhbWV0ZXI6IFwiZnVuY3Rpb25JZFwiJyk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodHlwZW9mIGV4ZWN1dGlvbklkID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEFwcHdyaXRlRXhjZXB0aW9uKCdNaXNzaW5nIHJlcXVpcmVkIHBhcmFtZXRlcjogXCJleGVjdXRpb25JZFwiJyk7XG4gICAgICAgIH1cblxuXG4gICAgICAgIHJldHVybiBhd2FpdCB0aGlzLmNsaWVudC5jYWxsKCdnZXQnLCBhcGlQYXRoLCB7XG4gICAgICAgICAgICAnY29udGVudC10eXBlJzogJ2FwcGxpY2F0aW9uL2pzb24nLFxuICAgICAgICB9LCBwYXlsb2FkKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBMaXN0IHZhcmlhYmxlc1xuICAgICAqXG4gICAgICogR2V0IGEgbGlzdCBvZiBhbGwgdmFyaWFibGVzIG9mIGEgc3BlY2lmaWMgZnVuY3Rpb24uXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gZnVuY3Rpb25JZFxuICAgICAqIEB0aHJvd3Mge0FwcHdyaXRlRXhjZXB0aW9ufVxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlfVxuICAgICAqL1xuICAgIGFzeW5jIGxpc3RWYXJpYWJsZXMoZnVuY3Rpb25JZCkge1xuICAgICAgICBjb25zdCBhcGlQYXRoID0gJy9mdW5jdGlvbnMve2Z1bmN0aW9uSWR9L3ZhcmlhYmxlcycucmVwbGFjZSgne2Z1bmN0aW9uSWR9JywgZnVuY3Rpb25JZCk7XG4gICAgICAgIGxldCBwYXlsb2FkID0ge307XG4gICAgICAgIGlmICh0eXBlb2YgZnVuY3Rpb25JZCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBBcHB3cml0ZUV4Y2VwdGlvbignTWlzc2luZyByZXF1aXJlZCBwYXJhbWV0ZXI6IFwiZnVuY3Rpb25JZFwiJyk7XG4gICAgICAgIH1cblxuXG4gICAgICAgIHJldHVybiBhd2FpdCB0aGlzLmNsaWVudC5jYWxsKCdnZXQnLCBhcGlQYXRoLCB7XG4gICAgICAgICAgICAnY29udGVudC10eXBlJzogJ2FwcGxpY2F0aW9uL2pzb24nLFxuICAgICAgICB9LCBwYXlsb2FkKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGUgdmFyaWFibGVcbiAgICAgKlxuICAgICAqIENyZWF0ZSBhIG5ldyBmdW5jdGlvbiBlbnZpcm9ubWVudCB2YXJpYWJsZS4gVGhlc2UgdmFyaWFibGVzIGNhbiBiZSBhY2Nlc3NlZFxuICAgICAqIGluIHRoZSBmdW5jdGlvbiBhdCBydW50aW1lIGFzIGVudmlyb25tZW50IHZhcmlhYmxlcy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBmdW5jdGlvbklkXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGtleVxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSB2YWx1ZVxuICAgICAqIEB0aHJvd3Mge0FwcHdyaXRlRXhjZXB0aW9ufVxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlfVxuICAgICAqL1xuICAgIGFzeW5jIGNyZWF0ZVZhcmlhYmxlKGZ1bmN0aW9uSWQsIGtleSwgdmFsdWUpIHtcbiAgICAgICAgY29uc3QgYXBpUGF0aCA9ICcvZnVuY3Rpb25zL3tmdW5jdGlvbklkfS92YXJpYWJsZXMnLnJlcGxhY2UoJ3tmdW5jdGlvbklkfScsIGZ1bmN0aW9uSWQpO1xuICAgICAgICBsZXQgcGF5bG9hZCA9IHt9O1xuICAgICAgICBpZiAodHlwZW9mIGZ1bmN0aW9uSWQgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgQXBwd3JpdGVFeGNlcHRpb24oJ01pc3NpbmcgcmVxdWlyZWQgcGFyYW1ldGVyOiBcImZ1bmN0aW9uSWRcIicpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHR5cGVvZiBrZXkgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgQXBwd3JpdGVFeGNlcHRpb24oJ01pc3NpbmcgcmVxdWlyZWQgcGFyYW1ldGVyOiBcImtleVwiJyk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodHlwZW9mIHZhbHVlID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEFwcHdyaXRlRXhjZXB0aW9uKCdNaXNzaW5nIHJlcXVpcmVkIHBhcmFtZXRlcjogXCJ2YWx1ZVwiJyk7XG4gICAgICAgIH1cblxuXG4gICAgICAgIGlmICh0eXBlb2Yga2V5ICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgcGF5bG9hZFsna2V5J10gPSBrZXk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodHlwZW9mIHZhbHVlICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgcGF5bG9hZFsndmFsdWUnXSA9IHZhbHVlO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMuY2xpZW50LmNhbGwoJ3Bvc3QnLCBhcGlQYXRoLCB7XG4gICAgICAgICAgICAnY29udGVudC10eXBlJzogJ2FwcGxpY2F0aW9uL2pzb24nLFxuICAgICAgICB9LCBwYXlsb2FkKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZXQgdmFyaWFibGVcbiAgICAgKlxuICAgICAqIEdldCBhIHZhcmlhYmxlIGJ5IGl0cyB1bmlxdWUgSUQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gZnVuY3Rpb25JZFxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSB2YXJpYWJsZUlkXG4gICAgICogQHRocm93cyB7QXBwd3JpdGVFeGNlcHRpb259XG4gICAgICogQHJldHVybnMge1Byb21pc2V9XG4gICAgICovXG4gICAgYXN5bmMgZ2V0VmFyaWFibGUoZnVuY3Rpb25JZCwgdmFyaWFibGVJZCkge1xuICAgICAgICBjb25zdCBhcGlQYXRoID0gJy9mdW5jdGlvbnMve2Z1bmN0aW9uSWR9L3ZhcmlhYmxlcy97dmFyaWFibGVJZH0nLnJlcGxhY2UoJ3tmdW5jdGlvbklkfScsIGZ1bmN0aW9uSWQpLnJlcGxhY2UoJ3t2YXJpYWJsZUlkfScsIHZhcmlhYmxlSWQpO1xuICAgICAgICBsZXQgcGF5bG9hZCA9IHt9O1xuICAgICAgICBpZiAodHlwZW9mIGZ1bmN0aW9uSWQgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgQXBwd3JpdGVFeGNlcHRpb24oJ01pc3NpbmcgcmVxdWlyZWQgcGFyYW1ldGVyOiBcImZ1bmN0aW9uSWRcIicpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHR5cGVvZiB2YXJpYWJsZUlkID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEFwcHdyaXRlRXhjZXB0aW9uKCdNaXNzaW5nIHJlcXVpcmVkIHBhcmFtZXRlcjogXCJ2YXJpYWJsZUlkXCInKTtcbiAgICAgICAgfVxuXG5cbiAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMuY2xpZW50LmNhbGwoJ2dldCcsIGFwaVBhdGgsIHtcbiAgICAgICAgICAgICdjb250ZW50LXR5cGUnOiAnYXBwbGljYXRpb24vanNvbicsXG4gICAgICAgIH0sIHBheWxvYWQpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFVwZGF0ZSB2YXJpYWJsZVxuICAgICAqXG4gICAgICogVXBkYXRlIHZhcmlhYmxlIGJ5IGl0cyB1bmlxdWUgSUQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gZnVuY3Rpb25JZFxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSB2YXJpYWJsZUlkXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGtleVxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSB2YWx1ZVxuICAgICAqIEB0aHJvd3Mge0FwcHdyaXRlRXhjZXB0aW9ufVxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlfVxuICAgICAqL1xuICAgIGFzeW5jIHVwZGF0ZVZhcmlhYmxlKGZ1bmN0aW9uSWQsIHZhcmlhYmxlSWQsIGtleSwgdmFsdWUpIHtcbiAgICAgICAgY29uc3QgYXBpUGF0aCA9ICcvZnVuY3Rpb25zL3tmdW5jdGlvbklkfS92YXJpYWJsZXMve3ZhcmlhYmxlSWR9Jy5yZXBsYWNlKCd7ZnVuY3Rpb25JZH0nLCBmdW5jdGlvbklkKS5yZXBsYWNlKCd7dmFyaWFibGVJZH0nLCB2YXJpYWJsZUlkKTtcbiAgICAgICAgbGV0IHBheWxvYWQgPSB7fTtcbiAgICAgICAgaWYgKHR5cGVvZiBmdW5jdGlvbklkID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEFwcHdyaXRlRXhjZXB0aW9uKCdNaXNzaW5nIHJlcXVpcmVkIHBhcmFtZXRlcjogXCJmdW5jdGlvbklkXCInKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0eXBlb2YgdmFyaWFibGVJZCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBBcHB3cml0ZUV4Y2VwdGlvbignTWlzc2luZyByZXF1aXJlZCBwYXJhbWV0ZXI6IFwidmFyaWFibGVJZFwiJyk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodHlwZW9mIGtleSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBBcHB3cml0ZUV4Y2VwdGlvbignTWlzc2luZyByZXF1aXJlZCBwYXJhbWV0ZXI6IFwia2V5XCInKTtcbiAgICAgICAgfVxuXG5cbiAgICAgICAgaWYgKHR5cGVvZiBrZXkgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICBwYXlsb2FkWydrZXknXSA9IGtleTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0eXBlb2YgdmFsdWUgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICBwYXlsb2FkWyd2YWx1ZSddID0gdmFsdWU7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy5jbGllbnQuY2FsbCgncHV0JywgYXBpUGF0aCwge1xuICAgICAgICAgICAgJ2NvbnRlbnQtdHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJyxcbiAgICAgICAgfSwgcGF5bG9hZCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRGVsZXRlIHZhcmlhYmxlXG4gICAgICpcbiAgICAgKiBEZWxldGUgYSB2YXJpYWJsZSBieSBpdHMgdW5pcXVlIElELlxuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGZ1bmN0aW9uSWRcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gdmFyaWFibGVJZFxuICAgICAqIEB0aHJvd3Mge0FwcHdyaXRlRXhjZXB0aW9ufVxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlfVxuICAgICAqL1xuICAgIGFzeW5jIGRlbGV0ZVZhcmlhYmxlKGZ1bmN0aW9uSWQsIHZhcmlhYmxlSWQpIHtcbiAgICAgICAgY29uc3QgYXBpUGF0aCA9ICcvZnVuY3Rpb25zL3tmdW5jdGlvbklkfS92YXJpYWJsZXMve3ZhcmlhYmxlSWR9Jy5yZXBsYWNlKCd7ZnVuY3Rpb25JZH0nLCBmdW5jdGlvbklkKS5yZXBsYWNlKCd7dmFyaWFibGVJZH0nLCB2YXJpYWJsZUlkKTtcbiAgICAgICAgbGV0IHBheWxvYWQgPSB7fTtcbiAgICAgICAgaWYgKHR5cGVvZiBmdW5jdGlvbklkID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEFwcHdyaXRlRXhjZXB0aW9uKCdNaXNzaW5nIHJlcXVpcmVkIHBhcmFtZXRlcjogXCJmdW5jdGlvbklkXCInKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0eXBlb2YgdmFyaWFibGVJZCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBBcHB3cml0ZUV4Y2VwdGlvbignTWlzc2luZyByZXF1aXJlZCBwYXJhbWV0ZXI6IFwidmFyaWFibGVJZFwiJyk7XG4gICAgICAgIH1cblxuXG4gICAgICAgIHJldHVybiBhd2FpdCB0aGlzLmNsaWVudC5jYWxsKCdkZWxldGUnLCBhcGlQYXRoLCB7XG4gICAgICAgICAgICAnY29udGVudC10eXBlJzogJ2FwcGxpY2F0aW9uL2pzb24nLFxuICAgICAgICB9LCBwYXlsb2FkKTtcbiAgICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gRnVuY3Rpb25zO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(action-browser)/./node_modules/node-appwrite/lib/services/functions.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/node-appwrite/lib/services/functions.js":
/*!**************************************************************!*\
  !*** ./node_modules/node-appwrite/lib/services/functions.js ***!
  \**************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("const Service = __webpack_require__(/*! ../service.js */ \"(rsc)/./node_modules/node-appwrite/lib/service.js\");\nconst AppwriteException = __webpack_require__(/*! ../exception.js */ \"(rsc)/./node_modules/node-appwrite/lib/exception.js\");\nconst InputFile = __webpack_require__(/*! ../inputFile.js */ \"(rsc)/./node_modules/node-appwrite/lib/inputFile.js\");\nconst client = __webpack_require__(/*! ../client.js */ \"(rsc)/./node_modules/node-appwrite/lib/client.js\");\nconst Stream = __webpack_require__(/*! stream */ \"stream\");\nconst { promisify } = __webpack_require__(/*! util */ \"util\");\nconst fs = __webpack_require__(/*! fs */ \"fs\");\nconst { File } = __webpack_require__(/*! undici */ \"undici\");\nconst Query = __webpack_require__(/*! ../query.js */ \"(rsc)/./node_modules/node-appwrite/lib/query.js\");\n\nclass Functions extends Service {\n\n     constructor(client)\n     {\n        super(client);\n     }\n\n\n    /**\n     * List functions\n     *\n     * Get a list of all the project's functions. You can use the query params to\n     * filter your results.\n     *\n     * @param {string[]} queries\n     * @param {string} search\n     * @throws {AppwriteException}\n     * @returns {Promise}\n     */\n    async list(queries, search) {\n        const apiPath = '/functions';\n        let payload = {};\n\n        if (typeof queries !== 'undefined') {\n            payload['queries'] = queries;\n        }\n\n        if (typeof search !== 'undefined') {\n            payload['search'] = search;\n        }\n\n        return await this.client.call('get', apiPath, {\n            'content-type': 'application/json',\n        }, payload);\n    }\n\n    /**\n     * Create function\n     *\n     * Create a new function. You can pass a list of\n     * [permissions](https://appwrite.io/docs/permissions) to allow different\n     * project users or team with access to execute the function using the client\n     * API.\n     *\n     * @param {string} functionId\n     * @param {string} name\n     * @param {Runtime} runtime\n     * @param {string[]} execute\n     * @param {string[]} events\n     * @param {string} schedule\n     * @param {number} timeout\n     * @param {boolean} enabled\n     * @param {boolean} logging\n     * @param {string} entrypoint\n     * @param {string} commands\n     * @param {string} installationId\n     * @param {string} providerRepositoryId\n     * @param {string} providerBranch\n     * @param {boolean} providerSilentMode\n     * @param {string} providerRootDirectory\n     * @param {string} templateRepository\n     * @param {string} templateOwner\n     * @param {string} templateRootDirectory\n     * @param {string} templateBranch\n     * @throws {AppwriteException}\n     * @returns {Promise}\n     */\n    async create(functionId, name, runtime, execute, events, schedule, timeout, enabled, logging, entrypoint, commands, installationId, providerRepositoryId, providerBranch, providerSilentMode, providerRootDirectory, templateRepository, templateOwner, templateRootDirectory, templateBranch) {\n        const apiPath = '/functions';\n        let payload = {};\n        if (typeof functionId === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"functionId\"');\n        }\n\n        if (typeof name === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"name\"');\n        }\n\n        if (typeof runtime === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"runtime\"');\n        }\n\n\n        if (typeof functionId !== 'undefined') {\n            payload['functionId'] = functionId;\n        }\n\n        if (typeof name !== 'undefined') {\n            payload['name'] = name;\n        }\n\n        if (typeof runtime !== 'undefined') {\n            payload['runtime'] = runtime;\n        }\n\n        if (typeof execute !== 'undefined') {\n            payload['execute'] = execute;\n        }\n\n        if (typeof events !== 'undefined') {\n            payload['events'] = events;\n        }\n\n        if (typeof schedule !== 'undefined') {\n            payload['schedule'] = schedule;\n        }\n\n        if (typeof timeout !== 'undefined') {\n            payload['timeout'] = timeout;\n        }\n\n        if (typeof enabled !== 'undefined') {\n            payload['enabled'] = enabled;\n        }\n\n        if (typeof logging !== 'undefined') {\n            payload['logging'] = logging;\n        }\n\n        if (typeof entrypoint !== 'undefined') {\n            payload['entrypoint'] = entrypoint;\n        }\n\n        if (typeof commands !== 'undefined') {\n            payload['commands'] = commands;\n        }\n\n        if (typeof installationId !== 'undefined') {\n            payload['installationId'] = installationId;\n        }\n\n        if (typeof providerRepositoryId !== 'undefined') {\n            payload['providerRepositoryId'] = providerRepositoryId;\n        }\n\n        if (typeof providerBranch !== 'undefined') {\n            payload['providerBranch'] = providerBranch;\n        }\n\n        if (typeof providerSilentMode !== 'undefined') {\n            payload['providerSilentMode'] = providerSilentMode;\n        }\n\n        if (typeof providerRootDirectory !== 'undefined') {\n            payload['providerRootDirectory'] = providerRootDirectory;\n        }\n\n        if (typeof templateRepository !== 'undefined') {\n            payload['templateRepository'] = templateRepository;\n        }\n\n        if (typeof templateOwner !== 'undefined') {\n            payload['templateOwner'] = templateOwner;\n        }\n\n        if (typeof templateRootDirectory !== 'undefined') {\n            payload['templateRootDirectory'] = templateRootDirectory;\n        }\n\n        if (typeof templateBranch !== 'undefined') {\n            payload['templateBranch'] = templateBranch;\n        }\n\n        return await this.client.call('post', apiPath, {\n            'content-type': 'application/json',\n        }, payload);\n    }\n\n    /**\n     * List runtimes\n     *\n     * Get a list of all runtimes that are currently active on your instance.\n     *\n     * @throws {AppwriteException}\n     * @returns {Promise}\n     */\n    async listRuntimes() {\n        const apiPath = '/functions/runtimes';\n        let payload = {};\n\n        return await this.client.call('get', apiPath, {\n            'content-type': 'application/json',\n        }, payload);\n    }\n\n    /**\n     * Get function\n     *\n     * Get a function by its unique ID.\n     *\n     * @param {string} functionId\n     * @throws {AppwriteException}\n     * @returns {Promise}\n     */\n    async get(functionId) {\n        const apiPath = '/functions/{functionId}'.replace('{functionId}', functionId);\n        let payload = {};\n        if (typeof functionId === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"functionId\"');\n        }\n\n\n        return await this.client.call('get', apiPath, {\n            'content-type': 'application/json',\n        }, payload);\n    }\n\n    /**\n     * Update function\n     *\n     * Update function by its unique ID.\n     *\n     * @param {string} functionId\n     * @param {string} name\n     * @param {Runtime} runtime\n     * @param {string[]} execute\n     * @param {string[]} events\n     * @param {string} schedule\n     * @param {number} timeout\n     * @param {boolean} enabled\n     * @param {boolean} logging\n     * @param {string} entrypoint\n     * @param {string} commands\n     * @param {string} installationId\n     * @param {string} providerRepositoryId\n     * @param {string} providerBranch\n     * @param {boolean} providerSilentMode\n     * @param {string} providerRootDirectory\n     * @throws {AppwriteException}\n     * @returns {Promise}\n     */\n    async update(functionId, name, runtime, execute, events, schedule, timeout, enabled, logging, entrypoint, commands, installationId, providerRepositoryId, providerBranch, providerSilentMode, providerRootDirectory) {\n        const apiPath = '/functions/{functionId}'.replace('{functionId}', functionId);\n        let payload = {};\n        if (typeof functionId === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"functionId\"');\n        }\n\n        if (typeof name === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"name\"');\n        }\n\n\n        if (typeof name !== 'undefined') {\n            payload['name'] = name;\n        }\n\n        if (typeof runtime !== 'undefined') {\n            payload['runtime'] = runtime;\n        }\n\n        if (typeof execute !== 'undefined') {\n            payload['execute'] = execute;\n        }\n\n        if (typeof events !== 'undefined') {\n            payload['events'] = events;\n        }\n\n        if (typeof schedule !== 'undefined') {\n            payload['schedule'] = schedule;\n        }\n\n        if (typeof timeout !== 'undefined') {\n            payload['timeout'] = timeout;\n        }\n\n        if (typeof enabled !== 'undefined') {\n            payload['enabled'] = enabled;\n        }\n\n        if (typeof logging !== 'undefined') {\n            payload['logging'] = logging;\n        }\n\n        if (typeof entrypoint !== 'undefined') {\n            payload['entrypoint'] = entrypoint;\n        }\n\n        if (typeof commands !== 'undefined') {\n            payload['commands'] = commands;\n        }\n\n        if (typeof installationId !== 'undefined') {\n            payload['installationId'] = installationId;\n        }\n\n        if (typeof providerRepositoryId !== 'undefined') {\n            payload['providerRepositoryId'] = providerRepositoryId;\n        }\n\n        if (typeof providerBranch !== 'undefined') {\n            payload['providerBranch'] = providerBranch;\n        }\n\n        if (typeof providerSilentMode !== 'undefined') {\n            payload['providerSilentMode'] = providerSilentMode;\n        }\n\n        if (typeof providerRootDirectory !== 'undefined') {\n            payload['providerRootDirectory'] = providerRootDirectory;\n        }\n\n        return await this.client.call('put', apiPath, {\n            'content-type': 'application/json',\n        }, payload);\n    }\n\n    /**\n     * Delete function\n     *\n     * Delete a function by its unique ID.\n     *\n     * @param {string} functionId\n     * @throws {AppwriteException}\n     * @returns {Promise}\n     */\n    async delete(functionId) {\n        const apiPath = '/functions/{functionId}'.replace('{functionId}', functionId);\n        let payload = {};\n        if (typeof functionId === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"functionId\"');\n        }\n\n\n        return await this.client.call('delete', apiPath, {\n            'content-type': 'application/json',\n        }, payload);\n    }\n\n    /**\n     * List deployments\n     *\n     * Get a list of all the project's code deployments. You can use the query\n     * params to filter your results.\n     *\n     * @param {string} functionId\n     * @param {string[]} queries\n     * @param {string} search\n     * @throws {AppwriteException}\n     * @returns {Promise}\n     */\n    async listDeployments(functionId, queries, search) {\n        const apiPath = '/functions/{functionId}/deployments'.replace('{functionId}', functionId);\n        let payload = {};\n        if (typeof functionId === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"functionId\"');\n        }\n\n\n        if (typeof queries !== 'undefined') {\n            payload['queries'] = queries;\n        }\n\n        if (typeof search !== 'undefined') {\n            payload['search'] = search;\n        }\n\n        return await this.client.call('get', apiPath, {\n            'content-type': 'application/json',\n        }, payload);\n    }\n\n    /**\n     * Create deployment\n     *\n     * Create a new function code deployment. Use this endpoint to upload a new\n     * version of your code function. To execute your newly uploaded code, you'll\n     * need to update the function's deployment to use your new deployment UID.\n     * \n     * This endpoint accepts a tar.gz file compressed with your code. Make sure to\n     * include any dependencies your code has within the compressed file. You can\n     * learn more about code packaging in the [Appwrite Cloud Functions\n     * tutorial](https://appwrite.io/docs/functions).\n     * \n     * Use the \"command\" param to set the entrypoint used to execute your code.\n     *\n     * @param {string} functionId\n     * @param {InputFile} code\n     * @param {boolean} activate\n     * @param {string} entrypoint\n     * @param {string} commands\n     * @param {CallableFunction} onProgress\n     * @throws {AppwriteException}\n     * @returns {Promise}\n     */\n    async createDeployment(functionId, code, activate, entrypoint, commands, onProgress = () => {}) {\n        const apiPath = '/functions/{functionId}/deployments'.replace('{functionId}', functionId);\n        let payload = {};\n        if (typeof functionId === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"functionId\"');\n        }\n\n        if (typeof code === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"code\"');\n        }\n\n        if (typeof activate === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"activate\"');\n        }\n\n\n        if (typeof entrypoint !== 'undefined') {\n            payload['entrypoint'] = entrypoint;\n        }\n\n        if (typeof commands !== 'undefined') {\n            payload['commands'] = commands;\n        }\n\n        if (typeof code !== 'undefined') {\n            payload['code'] = code;\n        }\n\n        if (typeof activate !== 'undefined') {\n            payload['activate'] = activate.toString();\n        }\n\n\n        const size = code.size;\n        \n        const apiHeaders = {\n            'content-type': 'multipart/form-data',\n        };\n\n        let id = undefined;\n        let response = undefined;\n\n        let chunksUploaded = 0;\n\n\n        let currentChunk = 1;\n        let currentPosition = 0;\n        let uploadableChunk = new Uint8Array(client.CHUNK_SIZE);\n    \n\n        const uploadChunk = async (lastUpload = false) => {\n            if(currentChunk <= chunksUploaded) {\n                return;\n            }\n\n            const start = ((currentChunk - 1) * client.CHUNK_SIZE);\n            let end = start + currentPosition - 1;\n\n            if(!lastUpload || currentChunk !== 1) {\n                apiHeaders['content-range'] = 'bytes ' + start + '-' + end + '/' + size;\n            }\n\n            let uploadableChunkTrimmed;\n            \n            if(currentPosition + 1 >= client.CHUNK_SIZE) {\n                uploadableChunkTrimmed = uploadableChunk;\n            } else {\n                uploadableChunkTrimmed = new Uint8Array(currentPosition);\n                for(let i = 0; i <= currentPosition; i++) {\n                    uploadableChunkTrimmed[i] = uploadableChunk[i];\n                }\n            }\n\n            if (id) {\n                apiHeaders['x-appwrite-id'] = id;\n            }\n\n            payload['code'] = { type: 'file', file: new File([uploadableChunkTrimmed], code.filename), filename: code.filename };\n\n            response = await this.client.call('post', apiPath, apiHeaders, payload);\n\n            if (!id) {\n                id = response['$id'];\n            }\n\n            if (onProgress !== null) {\n                onProgress({\n                    $id: response['$id'],\n                    progress: Math.min((currentChunk) * client.CHUNK_SIZE, size) / size * 100,\n                    sizeUploaded: end+1,\n                    chunksTotal: response['chunksTotal'],\n                    chunksUploaded: response['chunksUploaded']\n                });\n            }\n\n            uploadableChunk = new Uint8Array(client.CHUNK_SIZE);\n            currentChunk++;\n            currentPosition = 0;\n        }\n\n        for await (const chunk of code.stream) {\n            for(const b of chunk) {\n                uploadableChunk[currentPosition] = b;\n\n                currentPosition++;\n                if(currentPosition >= client.CHUNK_SIZE) {\n                    await uploadChunk();\n                    currentPosition = 0;\n                }\n            }\n        }\n\n        if (currentPosition > 0) { // Check if there's any remaining data for the last chunk\n            await uploadChunk(true);\n        }\n\n        return response;\n\n    }\n\n    /**\n     * Get deployment\n     *\n     * Get a code deployment by its unique ID.\n     *\n     * @param {string} functionId\n     * @param {string} deploymentId\n     * @throws {AppwriteException}\n     * @returns {Promise}\n     */\n    async getDeployment(functionId, deploymentId) {\n        const apiPath = '/functions/{functionId}/deployments/{deploymentId}'.replace('{functionId}', functionId).replace('{deploymentId}', deploymentId);\n        let payload = {};\n        if (typeof functionId === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"functionId\"');\n        }\n\n        if (typeof deploymentId === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"deploymentId\"');\n        }\n\n\n        return await this.client.call('get', apiPath, {\n            'content-type': 'application/json',\n        }, payload);\n    }\n\n    /**\n     * Update function deployment\n     *\n     * Update the function code deployment ID using the unique function ID. Use\n     * this endpoint to switch the code deployment that should be executed by the\n     * execution endpoint.\n     *\n     * @param {string} functionId\n     * @param {string} deploymentId\n     * @throws {AppwriteException}\n     * @returns {Promise}\n     */\n    async updateDeployment(functionId, deploymentId) {\n        const apiPath = '/functions/{functionId}/deployments/{deploymentId}'.replace('{functionId}', functionId).replace('{deploymentId}', deploymentId);\n        let payload = {};\n        if (typeof functionId === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"functionId\"');\n        }\n\n        if (typeof deploymentId === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"deploymentId\"');\n        }\n\n\n        return await this.client.call('patch', apiPath, {\n            'content-type': 'application/json',\n        }, payload);\n    }\n\n    /**\n     * Delete deployment\n     *\n     * Delete a code deployment by its unique ID.\n     *\n     * @param {string} functionId\n     * @param {string} deploymentId\n     * @throws {AppwriteException}\n     * @returns {Promise}\n     */\n    async deleteDeployment(functionId, deploymentId) {\n        const apiPath = '/functions/{functionId}/deployments/{deploymentId}'.replace('{functionId}', functionId).replace('{deploymentId}', deploymentId);\n        let payload = {};\n        if (typeof functionId === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"functionId\"');\n        }\n\n        if (typeof deploymentId === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"deploymentId\"');\n        }\n\n\n        return await this.client.call('delete', apiPath, {\n            'content-type': 'application/json',\n        }, payload);\n    }\n\n    /**\n     * Create build\n     *\n     * Create a new build for an Appwrite Function deployment. This endpoint can\n     * be used to retry a failed build.\n     *\n     * @param {string} functionId\n     * @param {string} deploymentId\n     * @param {string} buildId\n     * @throws {AppwriteException}\n     * @returns {Promise}\n     */\n    async createBuild(functionId, deploymentId, buildId) {\n        const apiPath = '/functions/{functionId}/deployments/{deploymentId}/builds/{buildId}'.replace('{functionId}', functionId).replace('{deploymentId}', deploymentId).replace('{buildId}', buildId);\n        let payload = {};\n        if (typeof functionId === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"functionId\"');\n        }\n\n        if (typeof deploymentId === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"deploymentId\"');\n        }\n\n        if (typeof buildId === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"buildId\"');\n        }\n\n\n        return await this.client.call('post', apiPath, {\n            'content-type': 'application/json',\n        }, payload);\n    }\n\n    /**\n     * Download Deployment\n     *\n     * Get a Deployment's contents by its unique ID. This endpoint supports range\n     * requests for partial or streaming file download.\n     *\n     * @param {string} functionId\n     * @param {string} deploymentId\n     * @throws {AppwriteException}\n     * @returns {Promise}\n     */\n    async downloadDeployment(functionId, deploymentId) {\n        const apiPath = '/functions/{functionId}/deployments/{deploymentId}/download'.replace('{functionId}', functionId).replace('{deploymentId}', deploymentId);\n        let payload = {};\n        if (typeof functionId === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"functionId\"');\n        }\n\n        if (typeof deploymentId === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"deploymentId\"');\n        }\n\n\n        return await this.client.call('get', apiPath, {\n            'content-type': 'application/json',\n        }, payload, 'arraybuffer');\n    }\n\n    /**\n     * List executions\n     *\n     * Get a list of all the current user function execution logs. You can use the\n     * query params to filter your results.\n     *\n     * @param {string} functionId\n     * @param {string[]} queries\n     * @param {string} search\n     * @throws {AppwriteException}\n     * @returns {Promise}\n     */\n    async listExecutions(functionId, queries, search) {\n        const apiPath = '/functions/{functionId}/executions'.replace('{functionId}', functionId);\n        let payload = {};\n        if (typeof functionId === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"functionId\"');\n        }\n\n\n        if (typeof queries !== 'undefined') {\n            payload['queries'] = queries;\n        }\n\n        if (typeof search !== 'undefined') {\n            payload['search'] = search;\n        }\n\n        return await this.client.call('get', apiPath, {\n            'content-type': 'application/json',\n        }, payload);\n    }\n\n    /**\n     * Create execution\n     *\n     * Trigger a function execution. The returned object will return you the\n     * current execution status. You can ping the `Get Execution` endpoint to get\n     * updates on the current execution status. Once this endpoint is called, your\n     * function execution process will start asynchronously.\n     *\n     * @param {string} functionId\n     * @param {string} body\n     * @param {boolean} async\n     * @param {string} xpath\n     * @param {ExecutionMethod} method\n     * @param {object} headers\n     * @throws {AppwriteException}\n     * @returns {Promise}\n     */\n    async createExecution(functionId, body, async, xpath, method, headers) {\n        const apiPath = '/functions/{functionId}/executions'.replace('{functionId}', functionId);\n        let payload = {};\n        if (typeof functionId === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"functionId\"');\n        }\n\n\n        if (typeof body !== 'undefined') {\n            payload['body'] = body;\n        }\n\n        if (typeof async !== 'undefined') {\n            payload['async'] = async;\n        }\n\n        if (typeof xpath !== 'undefined') {\n            payload['path'] = xpath;\n        }\n\n        if (typeof method !== 'undefined') {\n            payload['method'] = method;\n        }\n\n        if (typeof headers !== 'undefined') {\n            payload['headers'] = headers;\n        }\n\n        return await this.client.call('post', apiPath, {\n            'content-type': 'application/json',\n        }, payload);\n    }\n\n    /**\n     * Get execution\n     *\n     * Get a function execution log by its unique ID.\n     *\n     * @param {string} functionId\n     * @param {string} executionId\n     * @throws {AppwriteException}\n     * @returns {Promise}\n     */\n    async getExecution(functionId, executionId) {\n        const apiPath = '/functions/{functionId}/executions/{executionId}'.replace('{functionId}', functionId).replace('{executionId}', executionId);\n        let payload = {};\n        if (typeof functionId === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"functionId\"');\n        }\n\n        if (typeof executionId === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"executionId\"');\n        }\n\n\n        return await this.client.call('get', apiPath, {\n            'content-type': 'application/json',\n        }, payload);\n    }\n\n    /**\n     * List variables\n     *\n     * Get a list of all variables of a specific function.\n     *\n     * @param {string} functionId\n     * @throws {AppwriteException}\n     * @returns {Promise}\n     */\n    async listVariables(functionId) {\n        const apiPath = '/functions/{functionId}/variables'.replace('{functionId}', functionId);\n        let payload = {};\n        if (typeof functionId === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"functionId\"');\n        }\n\n\n        return await this.client.call('get', apiPath, {\n            'content-type': 'application/json',\n        }, payload);\n    }\n\n    /**\n     * Create variable\n     *\n     * Create a new function environment variable. These variables can be accessed\n     * in the function at runtime as environment variables.\n     *\n     * @param {string} functionId\n     * @param {string} key\n     * @param {string} value\n     * @throws {AppwriteException}\n     * @returns {Promise}\n     */\n    async createVariable(functionId, key, value) {\n        const apiPath = '/functions/{functionId}/variables'.replace('{functionId}', functionId);\n        let payload = {};\n        if (typeof functionId === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"functionId\"');\n        }\n\n        if (typeof key === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"key\"');\n        }\n\n        if (typeof value === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"value\"');\n        }\n\n\n        if (typeof key !== 'undefined') {\n            payload['key'] = key;\n        }\n\n        if (typeof value !== 'undefined') {\n            payload['value'] = value;\n        }\n\n        return await this.client.call('post', apiPath, {\n            'content-type': 'application/json',\n        }, payload);\n    }\n\n    /**\n     * Get variable\n     *\n     * Get a variable by its unique ID.\n     *\n     * @param {string} functionId\n     * @param {string} variableId\n     * @throws {AppwriteException}\n     * @returns {Promise}\n     */\n    async getVariable(functionId, variableId) {\n        const apiPath = '/functions/{functionId}/variables/{variableId}'.replace('{functionId}', functionId).replace('{variableId}', variableId);\n        let payload = {};\n        if (typeof functionId === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"functionId\"');\n        }\n\n        if (typeof variableId === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"variableId\"');\n        }\n\n\n        return await this.client.call('get', apiPath, {\n            'content-type': 'application/json',\n        }, payload);\n    }\n\n    /**\n     * Update variable\n     *\n     * Update variable by its unique ID.\n     *\n     * @param {string} functionId\n     * @param {string} variableId\n     * @param {string} key\n     * @param {string} value\n     * @throws {AppwriteException}\n     * @returns {Promise}\n     */\n    async updateVariable(functionId, variableId, key, value) {\n        const apiPath = '/functions/{functionId}/variables/{variableId}'.replace('{functionId}', functionId).replace('{variableId}', variableId);\n        let payload = {};\n        if (typeof functionId === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"functionId\"');\n        }\n\n        if (typeof variableId === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"variableId\"');\n        }\n\n        if (typeof key === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"key\"');\n        }\n\n\n        if (typeof key !== 'undefined') {\n            payload['key'] = key;\n        }\n\n        if (typeof value !== 'undefined') {\n            payload['value'] = value;\n        }\n\n        return await this.client.call('put', apiPath, {\n            'content-type': 'application/json',\n        }, payload);\n    }\n\n    /**\n     * Delete variable\n     *\n     * Delete a variable by its unique ID.\n     *\n     * @param {string} functionId\n     * @param {string} variableId\n     * @throws {AppwriteException}\n     * @returns {Promise}\n     */\n    async deleteVariable(functionId, variableId) {\n        const apiPath = '/functions/{functionId}/variables/{variableId}'.replace('{functionId}', functionId).replace('{variableId}', variableId);\n        let payload = {};\n        if (typeof functionId === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"functionId\"');\n        }\n\n        if (typeof variableId === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"variableId\"');\n        }\n\n\n        return await this.client.call('delete', apiPath, {\n            'content-type': 'application/json',\n        }, payload);\n    }\n}\n\nmodule.exports = Functions;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvbm9kZS1hcHB3cml0ZS9saWIvc2VydmljZXMvZnVuY3Rpb25zLmpzIiwibWFwcGluZ3MiOiJBQUFBLGdCQUFnQixtQkFBTyxDQUFDLHdFQUFlO0FBQ3ZDLDBCQUEwQixtQkFBTyxDQUFDLDRFQUFpQjtBQUNuRCxrQkFBa0IsbUJBQU8sQ0FBQyw0RUFBaUI7QUFDM0MsZUFBZSxtQkFBTyxDQUFDLHNFQUFjO0FBQ3JDLGVBQWUsbUJBQU8sQ0FBQyxzQkFBUTtBQUMvQixRQUFRLFlBQVksRUFBRSxtQkFBTyxDQUFDLGtCQUFNO0FBQ3BDLFdBQVcsbUJBQU8sQ0FBQyxjQUFJO0FBQ3ZCLFFBQVEsT0FBTyxFQUFFLG1CQUFPLENBQUMsc0JBQVE7QUFDakMsY0FBYyxtQkFBTyxDQUFDLG9FQUFhOztBQUVuQzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxVQUFVO0FBQ3pCLGVBQWUsUUFBUTtBQUN2QixnQkFBZ0I7QUFDaEIsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFNBQVM7QUFDVDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsUUFBUTtBQUN2QixlQUFlLFNBQVM7QUFDeEIsZUFBZSxVQUFVO0FBQ3pCLGVBQWUsVUFBVTtBQUN6QixlQUFlLFFBQVE7QUFDdkIsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsU0FBUztBQUN4QixlQUFlLFNBQVM7QUFDeEIsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsUUFBUTtBQUN2QixlQUFlLFFBQVE7QUFDdkIsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsUUFBUTtBQUN2QixlQUFlLFNBQVM7QUFDeEIsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsUUFBUTtBQUN2QixlQUFlLFFBQVE7QUFD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WSxXQUFXLFlBQVksV0FBVyx5QkFBeUIsV0FBVztBQUNsSTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTs7QUFFQSIsInNvdXJjZXMiOlsid2VicGFjazovL2pzbV9iYW5raW5nLy4vbm9kZV9tb2R1bGVzL25vZGUtYXBwd3JpdGUvbGliL3NlcnZpY2VzL2Z1bmN0aW9ucy5qcz9jZTk4Il0sInNvdXJjZXNDb250ZW50IjpbImNvbnN0IFNlcnZpY2UgPSByZXF1aXJlKCcuLi9zZXJ2aWNlLmpzJyk7XG5jb25zdCBBcHB3cml0ZUV4Y2VwdGlvbiA9IHJlcXVpcmUoJy4uL2V4Y2VwdGlvbi5qcycpO1xuY29uc3QgSW5wdXRGaWxlID0gcmVxdWlyZSgnLi4vaW5wdXRGaWxlLmpzJyk7XG5jb25zdCBjbGllbnQgPSByZXF1aXJlKCcuLi9jbGllbnQuanMnKTtcbmNvbnN0IFN0cmVhbSA9IHJlcXVpcmUoJ3N0cmVhbScpO1xuY29uc3QgeyBwcm9taXNpZnkgfSA9IHJlcXVpcmUoJ3V0aWwnKTtcbmNvbnN0IGZzID0gcmVxdWlyZSgnZnMnKTtcbmNvbnN0IHsgRmlsZSB9ID0gcmVxdWlyZSgndW5kaWNpJyk7XG5jb25zdCBRdWVyeSA9IHJlcXVpcmUoJy4uL3F1ZXJ5LmpzJyk7XG5cbmNsYXNzIEZ1bmN0aW9ucyBleHRlbmRzIFNlcnZpY2Uge1xuXG4gICAgIGNvbnN0cnVjdG9yKGNsaWVudClcbiAgICAge1xuICAgICAgICBzdXBlcihjbGllbnQpO1xuICAgICB9XG5cblxuICAgIC8qKlxuICAgICAqIExpc3QgZnVuY3Rpb25zXG4gICAgICpcbiAgICAgKiBHZXQgYSBsaXN0IG9mIGFsbCB0aGUgcHJvamVjdCdzIGZ1bmN0aW9ucy4gWW91IGNhbiB1c2UgdGhlIHF1ZXJ5IHBhcmFtcyB0b1xuICAgICAqIGZpbHRlciB5b3VyIHJlc3VsdHMuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZ1tdfSBxdWVyaWVzXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHNlYXJjaFxuICAgICAqIEB0aHJvd3Mge0FwcHdyaXRlRXhjZXB0aW9ufVxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlfVxuICAgICAqL1xuICAgIGFzeW5jIGxpc3QocXVlcmllcywgc2VhcmNoKSB7XG4gICAgICAgIGNvbnN0IGFwaVBhdGggPSAnL2Z1bmN0aW9ucyc7XG4gICAgICAgIGxldCBwYXlsb2FkID0ge307XG5cbiAgICAgICAgaWYgKHR5cGVvZiBxdWVyaWVzICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgcGF5bG9hZFsncXVlcmllcyddID0gcXVlcmllcztcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0eXBlb2Ygc2VhcmNoICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgcGF5bG9hZFsnc2VhcmNoJ10gPSBzZWFyY2g7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy5jbGllbnQuY2FsbCgnZ2V0JywgYXBpUGF0aCwge1xuICAgICAgICAgICAgJ2NvbnRlbnQtdHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJyxcbiAgICAgICAgfSwgcGF5bG9hZCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlIGZ1bmN0aW9uXG4gICAgICpcbiAgICAgKiBDcmVhdGUgYSBuZXcgZnVuY3Rpb24uIFlvdSBjYW4gcGFzcyBhIGxpc3Qgb2ZcbiAgICAgKiBbcGVybWlzc2lvbnNdKGh0dHBzOi8vYXBwd3JpdGUuaW8vZG9jcy9wZXJtaXNzaW9ucykgdG8gYWxsb3cgZGlmZmVyZW50XG4gICAgICogcHJvamVjdCB1c2VycyBvciB0ZWFtIHdpdGggYWNjZXNzIHRvIGV4ZWN1dGUgdGhlIGZ1bmN0aW9uIHVzaW5nIHRoZSBjbGllbnRcbiAgICAgKiBBUEkuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gZnVuY3Rpb25JZFxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lXG4gICAgICogQHBhcmFtIHtSdW50aW1lfSBydW50aW1lXG4gICAgICogQHBhcmFtIHtzdHJpbmdbXX0gZXhlY3V0ZVxuICAgICAqIEBwYXJhbSB7c3RyaW5nW119IGV2ZW50c1xuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBzY2hlZHVsZVxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB0aW1lb3V0XG4gICAgICogQHBhcmFtIHtib29sZWFufSBlbmFibGVkXG4gICAgICogQHBhcmFtIHtib29sZWFufSBsb2dnaW5nXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGVudHJ5cG9pbnRcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gY29tbWFuZHNcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gaW5zdGFsbGF0aW9uSWRcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gcHJvdmlkZXJSZXBvc2l0b3J5SWRcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gcHJvdmlkZXJCcmFuY2hcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IHByb3ZpZGVyU2lsZW50TW9kZVxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBwcm92aWRlclJvb3REaXJlY3RvcnlcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gdGVtcGxhdGVSZXBvc2l0b3J5XG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHRlbXBsYXRlT3duZXJcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gdGVtcGxhdGVSb290RGlyZWN0b3J5XG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHRlbXBsYXRlQnJhbmNoXG4gICAgICogQHRocm93cyB7QXBwd3JpdGVFeGNlcHRpb259XG4gICAgICogQHJldHVybnMge1Byb21pc2V9XG4gICAgICovXG4gICAgYXN5bmMgY3JlYXRlKGZ1bmN0aW9uSWQsIG5hbWUsIHJ1bnRpbWUsIGV4ZWN1dGUsIGV2ZW50cywgc2NoZWR1bGUsIHRpbWVvdXQsIGVuYWJsZWQsIGxvZ2dpbmcsIGVudHJ5cG9pbnQsIGNvbW1hbmRzLCBpbnN0YWxsYXRpb25JZCwgcHJvdmlkZXJSZXBvc2l0b3J5SWQsIHByb3ZpZGVyQnJhbmNoLCBwcm92aWRlclNpbGVudE1vZGUsIHByb3ZpZGVyUm9vdERpcmVjdG9yeSwgdGVtcGxhdGVSZXBvc2l0b3J5LCB0ZW1wbGF0ZU93bmVyLCB0ZW1wbGF0ZVJvb3REaXJlY3RvcnksIHRlbXBsYXRlQnJhbmNoKSB7XG4gICAgICAgIGNvbnN0IGFwaVBhdGggPSAnL2Z1bmN0aW9ucyc7XG4gICAgICAgIGxldCBwYXlsb2FkID0ge307XG4gICAgICAgIGlmICh0eXBlb2YgZnVuY3Rpb25JZCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBBcHB3cml0ZUV4Y2VwdGlvbignTWlzc2luZyByZXF1aXJlZCBwYXJhbWV0ZXI6IFwiZnVuY3Rpb25JZFwiJyk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodHlwZW9mIG5hbWUgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgQXBwd3JpdGVFeGNlcHRpb24oJ01pc3NpbmcgcmVxdWlyZWQgcGFyYW1ldGVyOiBcIm5hbWVcIicpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHR5cGVvZiBydW50aW1lID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEFwcHdyaXRlRXhjZXB0aW9uKCdNaXNzaW5nIHJlcXVpcmVkIHBhcmFtZXRlcjogXCJydW50aW1lXCInKTtcbiAgICAgICAgfVxuXG5cbiAgICAgICAgaWYgKHR5cGVvZiBmdW5jdGlvbklkICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgcGF5bG9hZFsnZnVuY3Rpb25JZCddID0gZnVuY3Rpb25JZDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0eXBlb2YgbmFtZSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHBheWxvYWRbJ25hbWUnXSA9IG5hbWU7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodHlwZW9mIHJ1bnRpbWUgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICBwYXlsb2FkWydydW50aW1lJ10gPSBydW50aW1lO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHR5cGVvZiBleGVjdXRlICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgcGF5bG9hZFsnZXhlY3V0ZSddID0gZXhlY3V0ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0eXBlb2YgZXZlbnRzICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgcGF5bG9hZFsnZXZlbnRzJ10gPSBldmVudHM7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodHlwZW9mIHNjaGVkdWxlICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgcGF5bG9hZFsnc2NoZWR1bGUnXSA9IHNjaGVkdWxlO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHR5cGVvZiB0aW1lb3V0ICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgcGF5bG9hZFsndGltZW91dCddID0gdGltZW91dDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0eXBlb2YgZW5hYmxlZCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHBheWxvYWRbJ2VuYWJsZWQnXSA9IGVuYWJsZWQ7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodHlwZW9mIGxvZ2dpbmcgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICBwYXlsb2FkWydsb2dnaW5nJ10gPSBsb2dnaW5nO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHR5cGVvZiBlbnRyeXBvaW50ICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgcGF5bG9hZFsnZW50cnlwb2ludCddID0gZW50cnlwb2ludDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0eXBlb2YgY29tbWFuZHMgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICBwYXlsb2FkWydjb21tYW5kcyddID0gY29tbWFuZHM7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodHlwZW9mIGluc3RhbGxhdGlvbklkICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgcGF5bG9hZFsnaW5zdGFsbGF0aW9uSWQnXSA9IGluc3RhbGxhdGlvbklkO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHR5cGVvZiBwcm92aWRlclJlcG9zaXRvcnlJZCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHBheWxvYWRbJ3Byb3ZpZGVyUmVwb3NpdG9yeUlkJ10gPSBwcm92aWRlclJlcG9zaXRvcnlJZDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0eXBlb2YgcHJvdmlkZXJCcmFuY2ggIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICBwYXlsb2FkWydwcm92aWRlckJyYW5jaCddID0gcHJvdmlkZXJCcmFuY2g7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodHlwZW9mIHByb3ZpZGVyU2lsZW50TW9kZSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHBheWxvYWRbJ3Byb3ZpZGVyU2lsZW50TW9kZSddID0gcHJvdmlkZXJTaWxlbnRNb2RlO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHR5cGVvZiBwcm92aWRlclJvb3REaXJlY3RvcnkgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICBwYXlsb2FkWydwcm92aWRlclJvb3REaXJlY3RvcnknXSA9IHByb3ZpZGVyUm9vdERpcmVjdG9yeTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0eXBlb2YgdGVtcGxhdGVSZXBvc2l0b3J5ICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgcGF5bG9hZFsndGVtcGxhdGVSZXBvc2l0b3J5J10gPSB0ZW1wbGF0ZVJlcG9zaXRvcnk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodHlwZW9mIHRlbXBsYXRlT3duZXIgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICBwYXlsb2FkWyd0ZW1wbGF0ZU93bmVyJ10gPSB0ZW1wbGF0ZU93bmVyO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHR5cGVvZiB0ZW1wbGF0ZVJvb3REaXJlY3RvcnkgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICBwYXlsb2FkWyd0ZW1wbGF0ZVJvb3REaXJlY3RvcnknXSA9IHRlbXBsYXRlUm9vdERpcmVjdG9yeTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0eXBlb2YgdGVtcGxhdGVCcmFuY2ggIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICBwYXlsb2FkWyd0ZW1wbGF0ZUJyYW5jaCddID0gdGVtcGxhdGVCcmFuY2g7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy5jbGllbnQuY2FsbCgncG9zdCcsIGFwaVBhdGgsIHtcbiAgICAgICAgICAgICdjb250ZW50LXR5cGUnOiAnYXBwbGljYXRpb24vanNvbicsXG4gICAgICAgIH0sIHBheWxvYWQpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIExpc3QgcnVudGltZXNcbiAgICAgKlxuICAgICAqIEdldCBhIGxpc3Qgb2YgYWxsIHJ1bnRpbWVzIHRoYXQgYXJlIGN1cnJlbnRseSBhY3RpdmUgb24geW91ciBpbnN0YW5jZS5cbiAgICAgKlxuICAgICAqIEB0aHJvd3Mge0FwcHdyaXRlRXhjZXB0aW9ufVxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlfVxuICAgICAqL1xuICAgIGFzeW5jIGxpc3RSdW50aW1lcygpIHtcbiAgICAgICAgY29uc3QgYXBpUGF0aCA9ICcvZnVuY3Rpb25zL3J1bnRpbWVzJztcbiAgICAgICAgbGV0IHBheWxvYWQgPSB7fTtcblxuICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy5jbGllbnQuY2FsbCgnZ2V0JywgYXBpUGF0aCwge1xuICAgICAgICAgICAgJ2NvbnRlbnQtdHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJyxcbiAgICAgICAgfSwgcGF5bG9hZCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2V0IGZ1bmN0aW9uXG4gICAgICpcbiAgICAgKiBHZXQgYSBmdW5jdGlvbiBieSBpdHMgdW5pcXVlIElELlxuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGZ1bmN0aW9uSWRcbiAgICAgKiBAdGhyb3dzIHtBcHB3cml0ZUV4Y2VwdGlvbn1cbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZX1cbiAgICAgKi9cbiAgICBhc3luYyBnZXQoZnVuY3Rpb25JZCkge1xuICAgICAgICBjb25zdCBhcGlQYXRoID0gJy9mdW5jdGlvbnMve2Z1bmN0aW9uSWR9Jy5yZXBsYWNlKCd7ZnVuY3Rpb25JZH0nLCBmdW5jdGlvbklkKTtcbiAgICAgICAgbGV0IHBheWxvYWQgPSB7fTtcbiAgICAgICAgaWYgKHR5cGVvZiBmdW5jdGlvbklkID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEFwcHdyaXRlRXhjZXB0aW9uKCdNaXNzaW5nIHJlcXVpcmVkIHBhcmFtZXRlcjogXCJmdW5jdGlvbklkXCInKTtcbiAgICAgICAgfVxuXG5cbiAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMuY2xpZW50LmNhbGwoJ2dldCcsIGFwaVBhdGgsIHtcbiAgICAgICAgICAgICdjb250ZW50LXR5cGUnOiAnYXBwbGljYXRpb24vanNvbicsXG4gICAgICAgIH0sIHBheWxvYWQpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFVwZGF0ZSBmdW5jdGlvblxuICAgICAqXG4gICAgICogVXBkYXRlIGZ1bmN0aW9uIGJ5IGl0cyB1bmlxdWUgSUQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gZnVuY3Rpb25JZFxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lXG4gICAgICogQHBhcmFtIHtSdW50aW1lfSBydW50aW1lXG4gICAgICogQHBhcmFtIHtzdHJpbmdbXX0gZXhlY3V0ZVxuICAgICAqIEBwYXJhbSB7c3RyaW5nW119IGV2ZW50c1xuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBzY2hlZHVsZVxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB0aW1lb3V0XG4gICAgICogQHBhcmFtIHtib29sZWFufSBlbmFibGVkXG4gICAgICogQHBhcmFtIHtib29sZWFufSBsb2dnaW5nXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGVudHJ5cG9pbnRcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gY29tbWFuZHNcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gaW5zdGFsbGF0aW9uSWRcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gcHJvdmlkZXJSZXBvc2l0b3J5SWRcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gcHJvdmlkZXJCcmFuY2hcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IHByb3ZpZGVyU2lsZW50TW9kZVxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBwcm92aWRlclJvb3REaXJlY3RvcnlcbiAgICAgKiBAdGhyb3dzIHtBcHB3cml0ZUV4Y2VwdGlvbn1cbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZX1cbiAgICAgKi9cbiAgICBhc3luYyB1cGRhdGUoZnVuY3Rpb25JZCwgbmFtZSwgcnVudGltZSwgZXhlY3V0ZSwgZXZlbnRzLCBzY2hlZHVsZSwgdGltZW91dCwgZW5hYmxlZCwgbG9nZ2luZywgZW50cnlwb2ludCwgY29tbWFuZHMsIGluc3RhbGxhdGlvbklkLCBwcm92aWRlclJlcG9zaXRvcnlJZCwgcHJvdmlkZXJCcmFuY2gsIHByb3ZpZGVyU2lsZW50TW9kZSwgcHJvdmlkZXJSb290RGlyZWN0b3J5KSB7XG4gICAgICAgIGNvbnN0IGFwaVBhdGggPSAnL2Z1bmN0aW9ucy97ZnVuY3Rpb25JZH0nLnJlcGxhY2UoJ3tmdW5jdGlvbklkfScsIGZ1bmN0aW9uSWQpO1xuICAgICAgICBsZXQgcGF5bG9hZCA9IHt9O1xuICAgICAgICBpZiAodHlwZW9mIGZ1bmN0aW9uSWQgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgQXBwd3JpdGVFeGNlcHRpb24oJ01pc3NpbmcgcmVxdWlyZWQgcGFyYW1ldGVyOiBcImZ1bmN0aW9uSWRcIicpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHR5cGVvZiBuYW1lID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEFwcHdyaXRlRXhjZXB0aW9uKCdNaXNzaW5nIHJlcXVpcmVkIHBhcmFtZXRlcjogXCJuYW1lXCInKTtcbiAgICAgICAgfVxuXG5cbiAgICAgICAgaWYgKHR5cGVvZiBuYW1lICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgcGF5bG9hZFsnbmFtZSddID0gbmFtZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0eXBlb2YgcnVudGltZSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHBheWxvYWRbJ3J1bnRpbWUnXSA9IHJ1bnRpbWU7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodHlwZW9mIGV4ZWN1dGUgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICBwYXlsb2FkWydleGVjdXRlJ10gPSBleGVjdXRlO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHR5cGVvZiBldmVudHMgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICBwYXlsb2FkWydldmVudHMnXSA9IGV2ZW50cztcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0eXBlb2Ygc2NoZWR1bGUgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICBwYXlsb2FkWydzY2hlZHVsZSddID0gc2NoZWR1bGU7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodHlwZW9mIHRpbWVvdXQgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICBwYXlsb2FkWyd0aW1lb3V0J10gPSB0aW1lb3V0O1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHR5cGVvZiBlbmFibGVkICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgcGF5bG9hZFsnZW5hYmxlZCddID0gZW5hYmxlZDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0eXBlb2YgbG9nZ2luZyAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHBheWxvYWRbJ2xvZ2dpbmcnXSA9IGxvZ2dpbmc7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodHlwZW9mIGVudHJ5cG9pbnQgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICBwYXlsb2FkWydlbnRyeXBvaW50J10gPSBlbnRyeXBvaW50O1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHR5cGVvZiBjb21tYW5kcyAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHBheWxvYWRbJ2NvbW1hbmRzJ10gPSBjb21tYW5kcztcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0eXBlb2YgaW5zdGFsbGF0aW9uSWQgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICBwYXlsb2FkWydpbnN0YWxsYXRpb25JZCddID0gaW5zdGFsbGF0aW9uSWQ7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodHlwZW9mIHByb3ZpZGVyUmVwb3NpdG9yeUlkICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgcGF5bG9hZFsncHJvdmlkZXJSZXBvc2l0b3J5SWQnXSA9IHByb3ZpZGVyUmVwb3NpdG9yeUlkO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHR5cGVvZiBwcm92aWRlckJyYW5jaCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHBheWxvYWRbJ3Byb3ZpZGVyQnJhbmNoJ10gPSBwcm92aWRlckJyYW5jaDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0eXBlb2YgcHJvdmlkZXJTaWxlbnRNb2RlICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgcGF5bG9hZFsncHJvdmlkZXJTaWxlbnRNb2RlJ10gPSBwcm92aWRlclNpbGVudE1vZGU7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodHlwZW9mIHByb3ZpZGVyUm9vdERpcmVjdG9yeSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHBheWxvYWRbJ3Byb3ZpZGVyUm9vdERpcmVjdG9yeSddID0gcHJvdmlkZXJSb290RGlyZWN0b3J5O1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMuY2xpZW50LmNhbGwoJ3B1dCcsIGFwaVBhdGgsIHtcbiAgICAgICAgICAgICdjb250ZW50LXR5cGUnOiAnYXBwbGljYXRpb24vanNvbicsXG4gICAgICAgIH0sIHBheWxvYWQpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIERlbGV0ZSBmdW5jdGlvblxuICAgICAqXG4gICAgICogRGVsZXRlIGEgZnVuY3Rpb24gYnkgaXRzIHVuaXF1ZSBJRC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBmdW5jdGlvbklkXG4gICAgICogQHRocm93cyB7QXBwd3JpdGVFeGNlcHRpb259XG4gICAgICogQHJldHVybnMge1Byb21pc2V9XG4gICAgICovXG4gICAgYXN5bmMgZGVsZXRlKGZ1bmN0aW9uSWQpIHtcbiAgICAgICAgY29uc3QgYXBpUGF0aCA9ICcvZnVuY3Rpb25zL3tmdW5jdGlvbklkfScucmVwbGFjZSgne2Z1bmN0aW9uSWR9JywgZnVuY3Rpb25JZCk7XG4gICAgICAgIGxldCBwYXlsb2FkID0ge307XG4gICAgICAgIGlmICh0eXBlb2YgZnVuY3Rpb25JZCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBBcHB3cml0ZUV4Y2VwdGlvbignTWlzc2luZyByZXF1aXJlZCBwYXJhbWV0ZXI6IFwiZnVuY3Rpb25JZFwiJyk7XG4gICAgICAgIH1cblxuXG4gICAgICAgIHJldHVybiBhd2FpdCB0aGlzLmNsaWVudC5jYWxsKCdkZWxldGUnLCBhcGlQYXRoLCB7XG4gICAgICAgICAgICAnY29udGVudC10eXBlJzogJ2FwcGxpY2F0aW9uL2pzb24nLFxuICAgICAgICB9LCBwYXlsb2FkKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBMaXN0IGRlcGxveW1lbnRzXG4gICAgICpcbiAgICAgKiBHZXQgYSBsaXN0IG9mIGFsbCB0aGUgcHJvamVjdCdzIGNvZGUgZGVwbG95bWVudHMuIFlvdSBjYW4gdXNlIHRoZSBxdWVyeVxuICAgICAqIHBhcmFtcyB0byBmaWx0ZXIgeW91ciByZXN1bHRzLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGZ1bmN0aW9uSWRcbiAgICAgKiBAcGFyYW0ge3N0cmluZ1tdfSBxdWVyaWVzXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHNlYXJjaFxuICAgICAqIEB0aHJvd3Mge0FwcHdyaXRlRXhjZXB0aW9ufVxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlfVxuICAgICAqL1xuICAgIGFzeW5jIGxpc3REZXBsb3ltZW50cyhmdW5jdGlvbklkLCBxdWVyaWVzLCBzZWFyY2gpIHtcbiAgICAgICAgY29uc3QgYXBpUGF0aCA9ICcvZnVuY3Rpb25zL3tmdW5jdGlvbklkfS9kZXBsb3ltZW50cycucmVwbGFjZSgne2Z1bmN0aW9uSWR9JywgZnVuY3Rpb25JZCk7XG4gICAgICAgIGxldCBwYXlsb2FkID0ge307XG4gICAgICAgIGlmICh0eXBlb2YgZnVuY3Rpb25JZCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBBcHB3cml0ZUV4Y2VwdGlvbignTWlzc2luZyByZXF1aXJlZCBwYXJhbWV0ZXI6IFwiZnVuY3Rpb25JZFwiJyk7XG4gICAgICAgIH1cblxuXG4gICAgICAgIGlmICh0eXBlb2YgcXVlcmllcyAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHBheWxvYWRbJ3F1ZXJpZXMnXSA9IHF1ZXJpZXM7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodHlwZW9mIHNlYXJjaCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHBheWxvYWRbJ3NlYXJjaCddID0gc2VhcmNoO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMuY2xpZW50LmNhbGwoJ2dldCcsIGFwaVBhdGgsIHtcbiAgICAgICAgICAgICdjb250ZW50LXR5cGUnOiAnYXBwbGljYXRpb24vanNvbicsXG4gICAgICAgIH0sIHBheWxvYWQpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZSBkZXBsb3ltZW50XG4gICAgICpcbiAgICAgKiBDcmVhdGUgYSBuZXcgZnVuY3Rpb24gY29kZSBkZXBsb3ltZW50LiBVc2UgdGhpcyBlbmRwb2ludCB0byB1cGxvYWQgYSBuZXdcbiAgICAgKiB2ZXJzaW9uIG9mIHlvdXIgY29kZSBmdW5jdGlvbi4gVG8gZXhlY3V0ZSB5b3VyIG5ld2x5IHVwbG9hZGVkIGNvZGUsIHlvdSdsbFxuICAgICAqIG5lZWQgdG8gdXBkYXRlIHRoZSBmdW5jdGlvbidzIGRlcGxveW1lbnQgdG8gdXNlIHlvdXIgbmV3IGRlcGxveW1lbnQgVUlELlxuICAgICAqIFxuICAgICAqIFRoaXMgZW5kcG9pbnQgYWNjZXB0cyBhIHRhci5neiBmaWxlIGNvbXByZXNzZWQgd2l0aCB5b3VyIGNvZGUuIE1ha2Ugc3VyZSB0b1xuICAgICAqIGluY2x1ZGUgYW55IGRlcGVuZGVuY2llcyB5b3VyIGNvZGUgaGFzIHdpdGhpbiB0aGUgY29tcHJlc3NlZCBmaWxlLiBZb3UgY2FuXG4gICAgICogbGVhcm4gbW9yZSBhYm91dCBjb2RlIHBhY2thZ2luZyBpbiB0aGUgW0FwcHdyaXRlIENsb3VkIEZ1bmN0aW9uc1xuICAgICAqIHR1dG9yaWFsXShodHRwczovL2FwcHdyaXRlLmlvL2RvY3MvZnVuY3Rpb25zKS5cbiAgICAgKiBcbiAgICAgKiBVc2UgdGhlIFwiY29tbWFuZFwiIHBhcmFtIHRvIHNldCB0aGUgZW50cnlwb2ludCB1c2VkIHRvIGV4ZWN1dGUgeW91ciBjb2RlLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGZ1bmN0aW9uSWRcbiAgICAgKiBAcGFyYW0ge0lucHV0RmlsZX0gY29kZVxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gYWN0aXZhdGVcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gZW50cnlwb2ludFxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBjb21tYW5kc1xuICAgICAqIEBwYXJhbSB7Q2FsbGFibGVGdW5jdGlvbn0gb25Qcm9ncmVzc1xuICAgICAqIEB0aHJvd3Mge0FwcHdyaXRlRXhjZXB0aW9ufVxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlfVxuICAgICAqL1xuICAgIGFzeW5jIGNyZWF0ZURlcGxveW1lbnQoZnVuY3Rpb25JZCwgY29kZSwgYWN0aXZhdGUsIGVudHJ5cG9pbnQsIGNvbW1hbmRzLCBvblByb2dyZXNzID0gKCkgPT4ge30pIHtcbiAgICAgICAgY29uc3QgYXBpUGF0aCA9ICcvZnVuY3Rpb25zL3tmdW5jdGlvbklkfS9kZXBsb3ltZW50cycucmVwbGFjZSgne2Z1bmN0aW9uSWR9JywgZnVuY3Rpb25JZCk7XG4gICAgICAgIGxldCBwYXlsb2FkID0ge307XG4gICAgICAgIGlmICh0eXBlb2YgZnVuY3Rpb25JZCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBBcHB3cml0ZUV4Y2VwdGlvbignTWlzc2luZyByZXF1aXJlZCBwYXJhbWV0ZXI6IFwiZnVuY3Rpb25JZFwiJyk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodHlwZW9mIGNvZGUgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgQXBwd3JpdGVFeGNlcHRpb24oJ01pc3NpbmcgcmVxdWlyZWQgcGFyYW1ldGVyOiBcImNvZGVcIicpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHR5cGVvZiBhY3RpdmF0ZSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBBcHB3cml0ZUV4Y2VwdGlvbignTWlzc2luZyByZXF1aXJlZCBwYXJhbWV0ZXI6IFwiYWN0aXZhdGVcIicpO1xuICAgICAgICB9XG5cblxuICAgICAgICBpZiAodHlwZW9mIGVudHJ5cG9pbnQgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICBwYXlsb2FkWydlbnRyeXBvaW50J10gPSBlbnRyeXBvaW50O1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHR5cGVvZiBjb21tYW5kcyAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHBheWxvYWRbJ2NvbW1hbmRzJ10gPSBjb21tYW5kcztcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0eXBlb2YgY29kZSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHBheWxvYWRbJ2NvZGUnXSA9IGNvZGU7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodHlwZW9mIGFjdGl2YXRlICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgcGF5bG9hZFsnYWN0aXZhdGUnXSA9IGFjdGl2YXRlLnRvU3RyaW5nKCk7XG4gICAgICAgIH1cblxuXG4gICAgICAgIGNvbnN0IHNpemUgPSBjb2RlLnNpemU7XG4gICAgICAgIFxuICAgICAgICBjb25zdCBhcGlIZWFkZXJzID0ge1xuICAgICAgICAgICAgJ2NvbnRlbnQtdHlwZSc6ICdtdWx0aXBhcnQvZm9ybS1kYXRhJyxcbiAgICAgICAgfTtcblxuICAgICAgICBsZXQgaWQgPSB1bmRlZmluZWQ7XG4gICAgICAgIGxldCByZXNwb25zZSA9IHVuZGVmaW5lZDtcblxuICAgICAgICBsZXQgY2h1bmtzVXBsb2FkZWQgPSAwO1xuXG5cbiAgICAgICAgbGV0IGN1cnJlbnRDaHVuayA9IDE7XG4gICAgICAgIGxldCBjdXJyZW50UG9zaXRpb24gPSAwO1xuICAgICAgICBsZXQgdXBsb2FkYWJsZUNodW5rID0gbmV3IFVpbnQ4QXJyYXkoY2xpZW50LkNIVU5LX1NJWkUpO1xuICAgIFxuXG4gICAgICAgIGNvbnN0IHVwbG9hZENodW5rID0gYXN5bmMgKGxhc3RVcGxvYWQgPSBmYWxzZSkgPT4ge1xuICAgICAgICAgICAgaWYoY3VycmVudENodW5rIDw9IGNodW5rc1VwbG9hZGVkKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBjb25zdCBzdGFydCA9ICgoY3VycmVudENodW5rIC0gMSkgKiBjbGllbnQuQ0hVTktfU0laRSk7XG4gICAgICAgICAgICBsZXQgZW5kID0gc3RhcnQgKyBjdXJyZW50UG9zaXRpb24gLSAxO1xuXG4gICAgICAgICAgICBpZighbGFzdFVwbG9hZCB8fCBjdXJyZW50Q2h1bmsgIT09IDEpIHtcbiAgICAgICAgICAgICAgICBhcGlIZWFkZXJzWydjb250ZW50LXJhbmdlJ10gPSAnYnl0ZXMgJyArIHN0YXJ0ICsgJy0nICsgZW5kICsgJy8nICsgc2l6ZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgbGV0IHVwbG9hZGFibGVDaHVua1RyaW1tZWQ7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIGlmKGN1cnJlbnRQb3NpdGlvbiArIDEgPj0gY2xpZW50LkNIVU5LX1NJWkUpIHtcbiAgICAgICAgICAgICAgICB1cGxvYWRhYmxlQ2h1bmtUcmltbWVkID0gdXBsb2FkYWJsZUNodW5rO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB1cGxvYWRhYmxlQ2h1bmtUcmltbWVkID0gbmV3IFVpbnQ4QXJyYXkoY3VycmVudFBvc2l0aW9uKTtcbiAgICAgICAgICAgICAgICBmb3IobGV0IGkgPSAwOyBpIDw9IGN1cnJlbnRQb3NpdGlvbjsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIHVwbG9hZGFibGVDaHVua1RyaW1tZWRbaV0gPSB1cGxvYWRhYmxlQ2h1bmtbaV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoaWQpIHtcbiAgICAgICAgICAgICAgICBhcGlIZWFkZXJzWyd4LWFwcHdyaXRlLWlkJ10gPSBpZDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcGF5bG9hZFsnY29kZSddID0geyB0eXBlOiAnZmlsZScsIGZpbGU6IG5ldyBGaWxlKFt1cGxvYWRhYmxlQ2h1bmtUcmltbWVkXSwgY29kZS5maWxlbmFtZSksIGZpbGVuYW1lOiBjb2RlLmZpbGVuYW1lIH07XG5cbiAgICAgICAgICAgIHJlc3BvbnNlID0gYXdhaXQgdGhpcy5jbGllbnQuY2FsbCgncG9zdCcsIGFwaVBhdGgsIGFwaUhlYWRlcnMsIHBheWxvYWQpO1xuXG4gICAgICAgICAgICBpZiAoIWlkKSB7XG4gICAgICAgICAgICAgICAgaWQgPSByZXNwb25zZVsnJGlkJ107XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChvblByb2dyZXNzICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgb25Qcm9ncmVzcyh7XG4gICAgICAgICAgICAgICAgICAgICRpZDogcmVzcG9uc2VbJyRpZCddLFxuICAgICAgICAgICAgICAgICAgICBwcm9ncmVzczogTWF0aC5taW4oKGN1cnJlbnRDaHVuaykgKiBjbGllbnQuQ0hVTktfU0laRSwgc2l6ZSkgLyBzaXplICogMTAwLFxuICAgICAgICAgICAgICAgICAgICBzaXplVXBsb2FkZWQ6IGVuZCsxLFxuICAgICAgICAgICAgICAgICAgICBjaHVua3NUb3RhbDogcmVzcG9uc2VbJ2NodW5rc1RvdGFsJ10sXG4gICAgICAgICAgICAgICAgICAgIGNodW5rc1VwbG9hZGVkOiByZXNwb25zZVsnY2h1bmtzVXBsb2FkZWQnXVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB1cGxvYWRhYmxlQ2h1bmsgPSBuZXcgVWludDhBcnJheShjbGllbnQuQ0hVTktfU0laRSk7XG4gICAgICAgICAgICBjdXJyZW50Q2h1bmsrKztcbiAgICAgICAgICAgIGN1cnJlbnRQb3NpdGlvbiA9IDA7XG4gICAgICAgIH1cblxuICAgICAgICBmb3IgYXdhaXQgKGNvbnN0IGNodW5rIG9mIGNvZGUuc3RyZWFtKSB7XG4gICAgICAgICAgICBmb3IoY29uc3QgYiBvZiBjaHVuaykge1xuICAgICAgICAgICAgICAgIHVwbG9hZGFibGVDaHVua1tjdXJyZW50UG9zaXRpb25dID0gYjtcblxuICAgICAgICAgICAgICAgIGN1cnJlbnRQb3NpdGlvbisrO1xuICAgICAgICAgICAgICAgIGlmKGN1cnJlbnRQb3NpdGlvbiA+PSBjbGllbnQuQ0hVTktfU0laRSkge1xuICAgICAgICAgICAgICAgICAgICBhd2FpdCB1cGxvYWRDaHVuaygpO1xuICAgICAgICAgICAgICAgICAgICBjdXJyZW50UG9zaXRpb24gPSAwO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChjdXJyZW50UG9zaXRpb24gPiAwKSB7IC8vIENoZWNrIGlmIHRoZXJlJ3MgYW55IHJlbWFpbmluZyBkYXRhIGZvciB0aGUgbGFzdCBjaHVua1xuICAgICAgICAgICAgYXdhaXQgdXBsb2FkQ2h1bmsodHJ1ZSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcmVzcG9uc2U7XG5cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZXQgZGVwbG95bWVudFxuICAgICAqXG4gICAgICogR2V0IGEgY29kZSBkZXBsb3ltZW50IGJ5IGl0cyB1bmlxdWUgSUQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gZnVuY3Rpb25JZFxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBkZXBsb3ltZW50SWRcbiAgICAgKiBAdGhyb3dzIHtBcHB3cml0ZUV4Y2VwdGlvbn1cbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZX1cbiAgICAgKi9cbiAgICBhc3luYyBnZXREZXBsb3ltZW50KGZ1bmN0aW9uSWQsIGRlcGxveW1lbnRJZCkge1xuICAgICAgICBjb25zdCBhcGlQYXRoID0gJy9mdW5jdGlvbnMve2Z1bmN0aW9uSWR9L2RlcGxveW1lbnRzL3tkZXBsb3ltZW50SWR9Jy5yZXBsYWNlKCd7ZnVuY3Rpb25JZH0nLCBmdW5jdGlvbklkKS5yZXBsYWNlKCd7ZGVwbG95bWVudElkfScsIGRlcGxveW1lbnRJZCk7XG4gICAgICAgIGxldCBwYXlsb2FkID0ge307XG4gICAgICAgIGlmICh0eXBlb2YgZnVuY3Rpb25JZCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBBcHB3cml0ZUV4Y2VwdGlvbignTWlzc2luZyByZXF1aXJlZCBwYXJhbWV0ZXI6IFwiZnVuY3Rpb25JZFwiJyk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodHlwZW9mIGRlcGxveW1lbnRJZCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBBcHB3cml0ZUV4Y2VwdGlvbignTWlzc2luZyByZXF1aXJlZCBwYXJhbWV0ZXI6IFwiZGVwbG95bWVudElkXCInKTtcbiAgICAgICAgfVxuXG5cbiAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMuY2xpZW50LmNhbGwoJ2dldCcsIGFwaVBhdGgsIHtcbiAgICAgICAgICAgICdjb250ZW50LXR5cGUnOiAnYXBwbGljYXRpb24vanNvbicsXG4gICAgICAgIH0sIHBheWxvYWQpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFVwZGF0ZSBmdW5jdGlvbiBkZXBsb3ltZW50XG4gICAgICpcbiAgICAgKiBVcGRhdGUgdGhlIGZ1bmN0aW9uIGNvZGUgZGVwbG95bWVudCBJRCB1c2luZyB0aGUgdW5pcXVlIGZ1bmN0aW9uIElELiBVc2VcbiAgICAgKiB0aGlzIGVuZHBvaW50IHRvIHN3aXRjaCB0aGUgY29kZSBkZXBsb3ltZW50IHRoYXQgc2hvdWxkIGJlIGV4ZWN1dGVkIGJ5IHRoZVxuICAgICAqIGV4ZWN1dGlvbiBlbmRwb2ludC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBmdW5jdGlvbklkXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGRlcGxveW1lbnRJZFxuICAgICAqIEB0aHJvd3Mge0FwcHdyaXRlRXhjZXB0aW9ufVxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlfVxuICAgICAqL1xuICAgIGFzeW5jIHVwZGF0ZURlcGxveW1lbnQoZnVuY3Rpb25JZCwgZGVwbG95bWVudElkKSB7XG4gICAgICAgIGNvbnN0IGFwaVBhdGggPSAnL2Z1bmN0aW9ucy97ZnVuY3Rpb25JZH0vZGVwbG95bWVudHMve2RlcGxveW1lbnRJZH0nLnJlcGxhY2UoJ3tmdW5jdGlvbklkfScsIGZ1bmN0aW9uSWQpLnJlcGxhY2UoJ3tkZXBsb3ltZW50SWR9JywgZGVwbG95bWVudElkKTtcbiAgICAgICAgbGV0IHBheWxvYWQgPSB7fTtcbiAgICAgICAgaWYgKHR5cGVvZiBmdW5jdGlvbklkID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEFwcHdyaXRlRXhjZXB0aW9uKCdNaXNzaW5nIHJlcXVpcmVkIHBhcmFtZXRlcjogXCJmdW5jdGlvbklkXCInKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0eXBlb2YgZGVwbG95bWVudElkID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEFwcHdyaXRlRXhjZXB0aW9uKCdNaXNzaW5nIHJlcXVpcmVkIHBhcmFtZXRlcjogXCJkZXBsb3ltZW50SWRcIicpO1xuICAgICAgICB9XG5cblxuICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy5jbGllbnQuY2FsbCgncGF0Y2gnLCBhcGlQYXRoLCB7XG4gICAgICAgICAgICAnY29udGVudC10eXBlJzogJ2FwcGxpY2F0aW9uL2pzb24nLFxuICAgICAgICB9LCBwYXlsb2FkKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBEZWxldGUgZGVwbG95bWVudFxuICAgICAqXG4gICAgICogRGVsZXRlIGEgY29kZSBkZXBsb3ltZW50IGJ5IGl0cyB1bmlxdWUgSUQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gZnVuY3Rpb25JZFxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBkZXBsb3ltZW50SWRcbiAgICAgKiBAdGhyb3dzIHtBcHB3cml0ZUV4Y2VwdGlvbn1cbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZX1cbiAgICAgKi9cbiAgICBhc3luYyBkZWxldGVEZXBsb3ltZW50KGZ1bmN0aW9uSWQsIGRlcGxveW1lbnRJZCkge1xuICAgICAgICBjb25zdCBhcGlQYXRoID0gJy9mdW5jdGlvbnMve2Z1bmN0aW9uSWR9L2RlcGxveW1lbnRzL3tkZXBsb3ltZW50SWR9Jy5yZXBsYWNlKCd7ZnVuY3Rpb25JZH0nLCBmdW5jdGlvbklkKS5yZXBsYWNlKCd7ZGVwbG95bWVudElkfScsIGRlcGxveW1lbnRJZCk7XG4gICAgICAgIGxldCBwYXlsb2FkID0ge307XG4gICAgICAgIGlmICh0eXBlb2YgZnVuY3Rpb25JZCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBBcHB3cml0ZUV4Y2VwdGlvbignTWlzc2luZyByZXF1aXJlZCBwYXJhbWV0ZXI6IFwiZnVuY3Rpb25JZFwiJyk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodHlwZW9mIGRlcGxveW1lbnRJZCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBBcHB3cml0ZUV4Y2VwdGlvbignTWlzc2luZyByZXF1aXJlZCBwYXJhbWV0ZXI6IFwiZGVwbG95bWVudElkXCInKTtcbiAgICAgICAgfVxuXG5cbiAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMuY2xpZW50LmNhbGwoJ2RlbGV0ZScsIGFwaVBhdGgsIHtcbiAgICAgICAgICAgICdjb250ZW50LXR5cGUnOiAnYXBwbGljYXRpb24vanNvbicsXG4gICAgICAgIH0sIHBheWxvYWQpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZSBidWlsZFxuICAgICAqXG4gICAgICogQ3JlYXRlIGEgbmV3IGJ1aWxkIGZvciBhbiBBcHB3cml0ZSBGdW5jdGlvbiBkZXBsb3ltZW50LiBUaGlzIGVuZHBvaW50IGNhblxuICAgICAqIGJlIHVzZWQgdG8gcmV0cnkgYSBmYWlsZWQgYnVpbGQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gZnVuY3Rpb25JZFxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBkZXBsb3ltZW50SWRcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gYnVpbGRJZFxuICAgICAqIEB0aHJvd3Mge0FwcHdyaXRlRXhjZXB0aW9ufVxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlfVxuICAgICAqL1xuICAgIGFzeW5jIGNyZWF0ZUJ1aWxkKGZ1bmN0aW9uSWQsIGRlcGxveW1lbnRJZCwgYnVpbGRJZCkge1xuICAgICAgICBjb25zdCBhcGlQYXRoID0gJy9mdW5jdGlvbnMve2Z1bmN0aW9uSWR9L2RlcGxveW1lbnRzL3tkZXBsb3ltZW50SWR9L2J1aWxkcy97YnVpbGRJZH0nLnJlcGxhY2UoJ3tmdW5jdGlvbklkfScsIGZ1bmN0aW9uSWQpLnJlcGxhY2UoJ3tkZXBsb3ltZW50SWR9JywgZGVwbG95bWVudElkKS5yZXBsYWNlKCd7YnVpbGRJZH0nLCBidWlsZElkKTtcbiAgICAgICAgbGV0IHBheWxvYWQgPSB7fTtcbiAgICAgICAgaWYgKHR5cGVvZiBmdW5jdGlvbklkID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEFwcHdyaXRlRXhjZXB0aW9uKCdNaXNzaW5nIHJlcXVpcmVkIHBhcmFtZXRlcjogXCJmdW5jdGlvbklkXCInKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0eXBlb2YgZGVwbG95bWVudElkID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEFwcHdyaXRlRXhjZXB0aW9uKCdNaXNzaW5nIHJlcXVpcmVkIHBhcmFtZXRlcjogXCJkZXBsb3ltZW50SWRcIicpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHR5cGVvZiBidWlsZElkID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEFwcHdyaXRlRXhjZXB0aW9uKCdNaXNzaW5nIHJlcXVpcmVkIHBhcmFtZXRlcjogXCJidWlsZElkXCInKTtcbiAgICAgICAgfVxuXG5cbiAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMuY2xpZW50LmNhbGwoJ3Bvc3QnLCBhcGlQYXRoLCB7XG4gICAgICAgICAgICAnY29udGVudC10eXBlJzogJ2FwcGxpY2F0aW9uL2pzb24nLFxuICAgICAgICB9LCBwYXlsb2FkKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBEb3dubG9hZCBEZXBsb3ltZW50XG4gICAgICpcbiAgICAgKiBHZXQgYSBEZXBsb3ltZW50J3MgY29udGVudHMgYnkgaXRzIHVuaXF1ZSBJRC4gVGhpcyBlbmRwb2ludCBzdXBwb3J0cyByYW5nZVxuICAgICAqIHJlcXVlc3RzIGZvciBwYXJ0aWFsIG9yIHN0cmVhbWluZyBmaWxlIGRvd25sb2FkLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGZ1bmN0aW9uSWRcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gZGVwbG95bWVudElkXG4gICAgICogQHRocm93cyB7QXBwd3JpdGVFeGNlcHRpb259XG4gICAgICogQHJldHVybnMge1Byb21pc2V9XG4gICAgICovXG4gICAgYXN5bmMgZG93bmxvYWREZXBsb3ltZW50KGZ1bmN0aW9uSWQsIGRlcGxveW1lbnRJZCkge1xuICAgICAgICBjb25zdCBhcGlQYXRoID0gJy9mdW5jdGlvbnMve2Z1bmN0aW9uSWR9L2RlcGxveW1lbnRzL3tkZXBsb3ltZW50SWR9L2Rvd25sb2FkJy5yZXBsYWNlKCd7ZnVuY3Rpb25JZH0nLCBmdW5jdGlvbklkKS5yZXBsYWNlKCd7ZGVwbG95bWVudElkfScsIGRlcGxveW1lbnRJZCk7XG4gICAgICAgIGxldCBwYXlsb2FkID0ge307XG4gICAgICAgIGlmICh0eXBlb2YgZnVuY3Rpb25JZCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBBcHB3cml0ZUV4Y2VwdGlvbignTWlzc2luZyByZXF1aXJlZCBwYXJhbWV0ZXI6IFwiZnVuY3Rpb25JZFwiJyk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodHlwZW9mIGRlcGxveW1lbnRJZCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBBcHB3cml0ZUV4Y2VwdGlvbignTWlzc2luZyByZXF1aXJlZCBwYXJhbWV0ZXI6IFwiZGVwbG95bWVudElkXCInKTtcbiAgICAgICAgfVxuXG5cbiAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMuY2xpZW50LmNhbGwoJ2dldCcsIGFwaVBhdGgsIHtcbiAgICAgICAgICAgICdjb250ZW50LXR5cGUnOiAnYXBwbGljYXRpb24vanNvbicsXG4gICAgICAgIH0sIHBheWxvYWQsICdhcnJheWJ1ZmZlcicpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIExpc3QgZXhlY3V0aW9uc1xuICAgICAqXG4gICAgICogR2V0IGEgbGlzdCBvZiBhbGwgdGhlIGN1cnJlbnQgdXNlciBmdW5jdGlvbiBleGVjdXRpb24gbG9ncy4gWW91IGNhbiB1c2UgdGhlXG4gICAgICogcXVlcnkgcGFyYW1zIHRvIGZpbHRlciB5b3VyIHJlc3VsdHMuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gZnVuY3Rpb25JZFxuICAgICAqIEBwYXJhbSB7c3RyaW5nW119IHF1ZXJpZXNcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gc2VhcmNoXG4gICAgICogQHRocm93cyB7QXBwd3JpdGVFeGNlcHRpb259XG4gICAgICogQHJldHVybnMge1Byb21pc2V9XG4gICAgICovXG4gICAgYXN5bmMgbGlzdEV4ZWN1dGlvbnMoZnVuY3Rpb25JZCwgcXVlcmllcywgc2VhcmNoKSB7XG4gICAgICAgIGNvbnN0IGFwaVBhdGggPSAnL2Z1bmN0aW9ucy97ZnVuY3Rpb25JZH0vZXhlY3V0aW9ucycucmVwbGFjZSgne2Z1bmN0aW9uSWR9JywgZnVuY3Rpb25JZCk7XG4gICAgICAgIGxldCBwYXlsb2FkID0ge307XG4gICAgICAgIGlmICh0eXBlb2YgZnVuY3Rpb25JZCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBBcHB3cml0ZUV4Y2VwdGlvbignTWlzc2luZyByZXF1aXJlZCBwYXJhbWV0ZXI6IFwiZnVuY3Rpb25JZFwiJyk7XG4gICAgICAgIH1cblxuXG4gICAgICAgIGlmICh0eXBlb2YgcXVlcmllcyAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHBheWxvYWRbJ3F1ZXJpZXMnXSA9IHF1ZXJpZXM7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodHlwZW9mIHNlYXJjaCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHBheWxvYWRbJ3NlYXJjaCddID0gc2VhcmNoO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMuY2xpZW50LmNhbGwoJ2dldCcsIGFwaVBhdGgsIHtcbiAgICAgICAgICAgICdjb250ZW50LXR5cGUnOiAnYXBwbGljYXRpb24vanNvbicsXG4gICAgICAgIH0sIHBheWxvYWQpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZSBleGVjdXRpb25cbiAgICAgKlxuICAgICAqIFRyaWdnZXIgYSBmdW5jdGlvbiBleGVjdXRpb24uIFRoZSByZXR1cm5lZCBvYmplY3Qgd2lsbCByZXR1cm4geW91IHRoZVxuICAgICAqIGN1cnJlbnQgZXhlY3V0aW9uIHN0YXR1cy4gWW91IGNhbiBwaW5nIHRoZSBgR2V0IEV4ZWN1dGlvbmAgZW5kcG9pbnQgdG8gZ2V0XG4gICAgICogdXBkYXRlcyBvbiB0aGUgY3VycmVudCBleGVjdXRpb24gc3RhdHVzLiBPbmNlIHRoaXMgZW5kcG9pbnQgaXMgY2FsbGVkLCB5b3VyXG4gICAgICogZnVuY3Rpb24gZXhlY3V0aW9uIHByb2Nlc3Mgd2lsbCBzdGFydCBhc3luY2hyb25vdXNseS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBmdW5jdGlvbklkXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGJvZHlcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IGFzeW5jXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHhwYXRoXG4gICAgICogQHBhcmFtIHtFeGVjdXRpb25NZXRob2R9IG1ldGhvZFxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBoZWFkZXJzXG4gICAgICogQHRocm93cyB7QXBwd3JpdGVFeGNlcHRpb259XG4gICAgICogQHJldHVybnMge1Byb21pc2V9XG4gICAgICovXG4gICAgYXN5bmMgY3JlYXRlRXhlY3V0aW9uKGZ1bmN0aW9uSWQsIGJvZHksIGFzeW5jLCB4cGF0aCwgbWV0aG9kLCBoZWFkZXJzKSB7XG4gICAgICAgIGNvbnN0IGFwaVBhdGggPSAnL2Z1bmN0aW9ucy97ZnVuY3Rpb25JZH0vZXhlY3V0aW9ucycucmVwbGFjZSgne2Z1bmN0aW9uSWR9JywgZnVuY3Rpb25JZCk7XG4gICAgICAgIGxldCBwYXlsb2FkID0ge307XG4gICAgICAgIGlmICh0eXBlb2YgZnVuY3Rpb25JZCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBBcHB3cml0ZUV4Y2VwdGlvbignTWlzc2luZyByZXF1aXJlZCBwYXJhbWV0ZXI6IFwiZnVuY3Rpb25JZFwiJyk7XG4gICAgICAgIH1cblxuXG4gICAgICAgIGlmICh0eXBlb2YgYm9keSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHBheWxvYWRbJ2JvZHknXSA9IGJvZHk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodHlwZW9mIGFzeW5jICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgcGF5bG9hZFsnYXN5bmMnXSA9IGFzeW5jO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHR5cGVvZiB4cGF0aCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHBheWxvYWRbJ3BhdGgnXSA9IHhwYXRoO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHR5cGVvZiBtZXRob2QgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICBwYXlsb2FkWydtZXRob2QnXSA9IG1ldGhvZDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0eXBlb2YgaGVhZGVycyAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHBheWxvYWRbJ2hlYWRlcnMnXSA9IGhlYWRlcnM7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy5jbGllbnQuY2FsbCgncG9zdCcsIGFwaVBhdGgsIHtcbiAgICAgICAgICAgICdjb250ZW50LXR5cGUnOiAnYXBwbGljYXRpb24vanNvbicsXG4gICAgICAgIH0sIHBheWxvYWQpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdldCBleGVjdXRpb25cbiAgICAgKlxuICAgICAqIEdldCBhIGZ1bmN0aW9uIGV4ZWN1dGlvbiBsb2cgYnkgaXRzIHVuaXF1ZSBJRC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBmdW5jdGlvbklkXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGV4ZWN1dGlvbklkXG4gICAgICogQHRocm93cyB7QXBwd3JpdGVFeGNlcHRpb259XG4gICAgICogQHJldHVybnMge1Byb21pc2V9XG4gICAgICovXG4gICAgYXN5bmMgZ2V0RXhlY3V0aW9uKGZ1bmN0aW9uSWQsIGV4ZWN1dGlvbklkKSB7XG4gICAgICAgIGNvbnN0IGFwaVBhdGggPSAnL2Z1bmN0aW9ucy97ZnVuY3Rpb25JZH0vZXhlY3V0aW9ucy97ZXhlY3V0aW9uSWR9Jy5yZXBsYWNlKCd7ZnVuY3Rpb25JZH0nLCBmdW5jdGlvbklkKS5yZXBsYWNlKCd7ZXhlY3V0aW9uSWR9JywgZXhlY3V0aW9uSWQpO1xuICAgICAgICBsZXQgcGF5bG9hZCA9IHt9O1xuICAgICAgICBpZiAodHlwZW9mIGZ1bmN0aW9uSWQgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgQXBwd3JpdGVFeGNlcHRpb24oJ01pc3NpbmcgcmVxdWlyZWQgcGFyYW1ldGVyOiBcImZ1bmN0aW9uSWRcIicpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHR5cGVvZiBleGVjdXRpb25JZCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBBcHB3cml0ZUV4Y2VwdGlvbignTWlzc2luZyByZXF1aXJlZCBwYXJhbWV0ZXI6IFwiZXhlY3V0aW9uSWRcIicpO1xuICAgICAgICB9XG5cblxuICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy5jbGllbnQuY2FsbCgnZ2V0JywgYXBpUGF0aCwge1xuICAgICAgICAgICAgJ2NvbnRlbnQtdHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJyxcbiAgICAgICAgfSwgcGF5bG9hZCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogTGlzdCB2YXJpYWJsZXNcbiAgICAgKlxuICAgICAqIEdldCBhIGxpc3Qgb2YgYWxsIHZhcmlhYmxlcyBvZiBhIHNwZWNpZmljIGZ1bmN0aW9uLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGZ1bmN0aW9uSWRcbiAgICAgKiBAdGhyb3dzIHtBcHB3cml0ZUV4Y2VwdGlvbn1cbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZX1cbiAgICAgKi9cbiAgICBhc3luYyBsaXN0VmFyaWFibGVzKGZ1bmN0aW9uSWQpIHtcbiAgICAgICAgY29uc3QgYXBpUGF0aCA9ICcvZnVuY3Rpb25zL3tmdW5jdGlvbklkfS92YXJpYWJsZXMnLnJlcGxhY2UoJ3tmdW5jdGlvbklkfScsIGZ1bmN0aW9uSWQpO1xuICAgICAgICBsZXQgcGF5bG9hZCA9IHt9O1xuICAgICAgICBpZiAodHlwZW9mIGZ1bmN0aW9uSWQgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgQXBwd3JpdGVFeGNlcHRpb24oJ01pc3NpbmcgcmVxdWlyZWQgcGFyYW1ldGVyOiBcImZ1bmN0aW9uSWRcIicpO1xuICAgICAgICB9XG5cblxuICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy5jbGllbnQuY2FsbCgnZ2V0JywgYXBpUGF0aCwge1xuICAgICAgICAgICAgJ2NvbnRlbnQtdHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJyxcbiAgICAgICAgfSwgcGF5bG9hZCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlIHZhcmlhYmxlXG4gICAgICpcbiAgICAgKiBDcmVhdGUgYSBuZXcgZnVuY3Rpb24gZW52aXJvbm1lbnQgdmFyaWFibGUuIFRoZXNlIHZhcmlhYmxlcyBjYW4gYmUgYWNjZXNzZWRcbiAgICAgKiBpbiB0aGUgZnVuY3Rpb24gYXQgcnVudGltZSBhcyBlbnZpcm9ubWVudCB2YXJpYWJsZXMuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gZnVuY3Rpb25JZFxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBrZXlcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gdmFsdWVcbiAgICAgKiBAdGhyb3dzIHtBcHB3cml0ZUV4Y2VwdGlvbn1cbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZX1cbiAgICAgKi9cbiAgICBhc3luYyBjcmVhdGVWYXJpYWJsZShmdW5jdGlvbklkLCBrZXksIHZhbHVlKSB7XG4gICAgICAgIGNvbnN0IGFwaVBhdGggPSAnL2Z1bmN0aW9ucy97ZnVuY3Rpb25JZH0vdmFyaWFibGVzJy5yZXBsYWNlKCd7ZnVuY3Rpb25JZH0nLCBmdW5jdGlvbklkKTtcbiAgICAgICAgbGV0IHBheWxvYWQgPSB7fTtcbiAgICAgICAgaWYgKHR5cGVvZiBmdW5jdGlvbklkID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEFwcHdyaXRlRXhjZXB0aW9uKCdNaXNzaW5nIHJlcXVpcmVkIHBhcmFtZXRlcjogXCJmdW5jdGlvbklkXCInKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0eXBlb2Yga2V5ID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEFwcHdyaXRlRXhjZXB0aW9uKCdNaXNzaW5nIHJlcXVpcmVkIHBhcmFtZXRlcjogXCJrZXlcIicpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBBcHB3cml0ZUV4Y2VwdGlvbignTWlzc2luZyByZXF1aXJlZCBwYXJhbWV0ZXI6IFwidmFsdWVcIicpO1xuICAgICAgICB9XG5cblxuICAgICAgICBpZiAodHlwZW9mIGtleSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHBheWxvYWRbJ2tleSddID0ga2V5O1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHBheWxvYWRbJ3ZhbHVlJ10gPSB2YWx1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBhd2FpdCB0aGlzLmNsaWVudC5jYWxsKCdwb3N0JywgYXBpUGF0aCwge1xuICAgICAgICAgICAgJ2NvbnRlbnQtdHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJyxcbiAgICAgICAgfSwgcGF5bG9hZCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2V0IHZhcmlhYmxlXG4gICAgICpcbiAgICAgKiBHZXQgYSB2YXJpYWJsZSBieSBpdHMgdW5pcXVlIElELlxuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGZ1bmN0aW9uSWRcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gdmFyaWFibGVJZFxuICAgICAqIEB0aHJvd3Mge0FwcHdyaXRlRXhjZXB0aW9ufVxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlfVxuICAgICAqL1xuICAgIGFzeW5jIGdldFZhcmlhYmxlKGZ1bmN0aW9uSWQsIHZhcmlhYmxlSWQpIHtcbiAgICAgICAgY29uc3QgYXBpUGF0aCA9ICcvZnVuY3Rpb25zL3tmdW5jdGlvbklkfS92YXJpYWJsZXMve3ZhcmlhYmxlSWR9Jy5yZXBsYWNlKCd7ZnVuY3Rpb25JZH0nLCBmdW5jdGlvbklkKS5yZXBsYWNlKCd7dmFyaWFibGVJZH0nLCB2YXJpYWJsZUlkKTtcbiAgICAgICAgbGV0IHBheWxvYWQgPSB7fTtcbiAgICAgICAgaWYgKHR5cGVvZiBmdW5jdGlvbklkID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEFwcHdyaXRlRXhjZXB0aW9uKCdNaXNzaW5nIHJlcXVpcmVkIHBhcmFtZXRlcjogXCJmdW5jdGlvbklkXCInKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0eXBlb2YgdmFyaWFibGVJZCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBBcHB3cml0ZUV4Y2VwdGlvbignTWlzc2luZyByZXF1aXJlZCBwYXJhbWV0ZXI6IFwidmFyaWFibGVJZFwiJyk7XG4gICAgICAgIH1cblxuXG4gICAgICAgIHJldHVybiBhd2FpdCB0aGlzLmNsaWVudC5jYWxsKCdnZXQnLCBhcGlQYXRoLCB7XG4gICAgICAgICAgICAnY29udGVudC10eXBlJzogJ2FwcGxpY2F0aW9uL2pzb24nLFxuICAgICAgICB9LCBwYXlsb2FkKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBVcGRhdGUgdmFyaWFibGVcbiAgICAgKlxuICAgICAqIFVwZGF0ZSB2YXJpYWJsZSBieSBpdHMgdW5pcXVlIElELlxuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGZ1bmN0aW9uSWRcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gdmFyaWFibGVJZFxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBrZXlcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gdmFsdWVcbiAgICAgKiBAdGhyb3dzIHtBcHB3cml0ZUV4Y2VwdGlvbn1cbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZX1cbiAgICAgKi9cbiAgICBhc3luYyB1cGRhdGVWYXJpYWJsZShmdW5jdGlvbklkLCB2YXJpYWJsZUlkLCBrZXksIHZhbHVlKSB7XG4gICAgICAgIGNvbnN0IGFwaVBhdGggPSAnL2Z1bmN0aW9ucy97ZnVuY3Rpb25JZH0vdmFyaWFibGVzL3t2YXJpYWJsZUlkfScucmVwbGFjZSgne2Z1bmN0aW9uSWR9JywgZnVuY3Rpb25JZCkucmVwbGFjZSgne3ZhcmlhYmxlSWR9JywgdmFyaWFibGVJZCk7XG4gICAgICAgIGxldCBwYXlsb2FkID0ge307XG4gICAgICAgIGlmICh0eXBlb2YgZnVuY3Rpb25JZCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBBcHB3cml0ZUV4Y2VwdGlvbignTWlzc2luZyByZXF1aXJlZCBwYXJhbWV0ZXI6IFwiZnVuY3Rpb25JZFwiJyk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodHlwZW9mIHZhcmlhYmxlSWQgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgQXBwd3JpdGVFeGNlcHRpb24oJ01pc3NpbmcgcmVxdWlyZWQgcGFyYW1ldGVyOiBcInZhcmlhYmxlSWRcIicpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHR5cGVvZiBrZXkgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgQXBwd3JpdGVFeGNlcHRpb24oJ01pc3NpbmcgcmVxdWlyZWQgcGFyYW1ldGVyOiBcImtleVwiJyk7XG4gICAgICAgIH1cblxuXG4gICAgICAgIGlmICh0eXBlb2Yga2V5ICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgcGF5bG9hZFsna2V5J10gPSBrZXk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodHlwZW9mIHZhbHVlICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgcGF5bG9hZFsndmFsdWUnXSA9IHZhbHVlO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMuY2xpZW50LmNhbGwoJ3B1dCcsIGFwaVBhdGgsIHtcbiAgICAgICAgICAgICdjb250ZW50LXR5cGUnOiAnYXBwbGljYXRpb24vanNvbicsXG4gICAgICAgIH0sIHBheWxvYWQpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIERlbGV0ZSB2YXJpYWJsZVxuICAgICAqXG4gICAgICogRGVsZXRlIGEgdmFyaWFibGUgYnkgaXRzIHVuaXF1ZSBJRC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBmdW5jdGlvbklkXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHZhcmlhYmxlSWRcbiAgICAgKiBAdGhyb3dzIHtBcHB3cml0ZUV4Y2VwdGlvbn1cbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZX1cbiAgICAgKi9cbiAgICBhc3luYyBkZWxldGVWYXJpYWJsZShmdW5jdGlvbklkLCB2YXJpYWJsZUlkKSB7XG4gICAgICAgIGNvbnN0IGFwaVBhdGggPSAnL2Z1bmN0aW9ucy97ZnVuY3Rpb25JZH0vdmFyaWFibGVzL3t2YXJpYWJsZUlkfScucmVwbGFjZSgne2Z1bmN0aW9uSWR9JywgZnVuY3Rpb25JZCkucmVwbGFjZSgne3ZhcmlhYmxlSWR9JywgdmFyaWFibGVJZCk7XG4gICAgICAgIGxldCBwYXlsb2FkID0ge307XG4gICAgICAgIGlmICh0eXBlb2YgZnVuY3Rpb25JZCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBBcHB3cml0ZUV4Y2VwdGlvbignTWlzc2luZyByZXF1aXJlZCBwYXJhbWV0ZXI6IFwiZnVuY3Rpb25JZFwiJyk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodHlwZW9mIHZhcmlhYmxlSWQgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgQXBwd3JpdGVFeGNlcHRpb24oJ01pc3NpbmcgcmVxdWlyZWQgcGFyYW1ldGVyOiBcInZhcmlhYmxlSWRcIicpO1xuICAgICAgICB9XG5cblxuICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy5jbGllbnQuY2FsbCgnZGVsZXRlJywgYXBpUGF0aCwge1xuICAgICAgICAgICAgJ2NvbnRlbnQtdHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJyxcbiAgICAgICAgfSwgcGF5bG9hZCk7XG4gICAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IEZ1bmN0aW9ucztcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/node-appwrite/lib/services/functions.js\n");

/***/ }),

/***/ "(action-browser)/./node_modules/node-appwrite/lib/services/graphql.js":
/*!************************************************************!*\
  !*** ./node_modules/node-appwrite/lib/services/graphql.js ***!
  \************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("const Service = __webpack_require__(/*! ../service.js */ \"(action-browser)/./node_modules/node-appwrite/lib/service.js\");\nconst AppwriteException = __webpack_require__(/*! ../exception.js */ \"(action-browser)/./node_modules/node-appwrite/lib/exception.js\");\nconst InputFile = __webpack_require__(/*! ../inputFile.js */ \"(action-browser)/./node_modules/node-appwrite/lib/inputFile.js\");\nconst client = __webpack_require__(/*! ../client.js */ \"(action-browser)/./node_modules/node-appwrite/lib/client.js\");\nconst Stream = __webpack_require__(/*! stream */ \"stream\");\nconst { promisify } = __webpack_require__(/*! util */ \"util\");\nconst fs = __webpack_require__(/*! fs */ \"fs\");\nconst { File } = __webpack_require__(/*! undici */ \"undici\");\nconst Query = __webpack_require__(/*! ../query.js */ \"(action-browser)/./node_modules/node-appwrite/lib/query.js\");\n\nclass Graphql extends Service {\n\n     constructor(client)\n     {\n        super(client);\n     }\n\n\n    /**\n     * GraphQL endpoint\n     *\n     * Execute a GraphQL mutation.\n     *\n     * @param {object} query\n     * @throws {AppwriteException}\n     * @returns {Promise}\n     */\n    async query(query) {\n        const apiPath = '/graphql';\n        let payload = {};\n        if (typeof query === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"query\"');\n        }\n\n\n        if (typeof query !== 'undefined') {\n            payload['query'] = query;\n        }\n\n        return await this.client.call('post', apiPath, {\n            'x-sdk-graphql': 'true',\n            'content-type': 'application/json',\n        }, payload);\n    }\n\n    /**\n     * GraphQL endpoint\n     *\n     * Execute a GraphQL mutation.\n     *\n     * @param {object} query\n     * @throws {AppwriteException}\n     * @returns {Promise}\n     */\n    async mutation(query) {\n        const apiPath = '/graphql/mutation';\n        let payload = {};\n        if (typeof query === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"query\"');\n        }\n\n\n        if (typeof query !== 'undefined') {\n            payload['query'] = query;\n        }\n\n        return await this.client.call('post', apiPath, {\n            'x-sdk-graphql': 'true',\n            'content-type': 'application/json',\n        }, payload);\n    }\n}\n\nmodule.exports = Graphql;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFjdGlvbi1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9ub2RlLWFwcHdyaXRlL2xpYi9zZXJ2aWNlcy9ncmFwaHFsLmpzIiwibWFwcGluZ3MiOiJBQUFBLGdCQUFnQixtQkFBTyxDQUFDLG1GQUFlO0FBQ3ZDLDBCQUEwQixtQkFBTyxDQUFDLHVGQUFpQjtBQUNuRCxrQkFBa0IsbUJBQU8sQ0FBQyx1RkFBaUI7QUFDM0MsZUFBZSxtQkFBTyxDQUFDLGlGQUFjO0FBQ3JDLGVBQWUsbUJBQU8sQ0FBQyxzQkFBUTtBQUMvQixRQUFRLFlBQVksRUFBRSxtQkFBTyxDQUFDLGtCQUFNO0FBQ3BDLFdBQVcsbUJBQU8sQ0FBQyxjQUFJO0FBQ3ZCLFFBQVEsT0FBTyxFQUFFLG1CQUFPLENBQUMsc0JBQVE7QUFDakMsY0FBYyxtQkFBTyxDQUFDLCtFQUFhOztBQUVuQzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QixnQkFBZ0I7QUFDaEIsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkIsZ0JBQWdCO0FBQ2hCLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBOztBQUVBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vanNtX2JhbmtpbmcvLi9ub2RlX21vZHVsZXMvbm9kZS1hcHB3cml0ZS9saWIvc2VydmljZXMvZ3JhcGhxbC5qcz9kMWIzIl0sInNvdXJjZXNDb250ZW50IjpbImNvbnN0IFNlcnZpY2UgPSByZXF1aXJlKCcuLi9zZXJ2aWNlLmpzJyk7XG5jb25zdCBBcHB3cml0ZUV4Y2VwdGlvbiA9IHJlcXVpcmUoJy4uL2V4Y2VwdGlvbi5qcycpO1xuY29uc3QgSW5wdXRGaWxlID0gcmVxdWlyZSgnLi4vaW5wdXRGaWxlLmpzJyk7XG5jb25zdCBjbGllbnQgPSByZXF1aXJlKCcuLi9jbGllbnQuanMnKTtcbmNvbnN0IFN0cmVhbSA9IHJlcXVpcmUoJ3N0cmVhbScpO1xuY29uc3QgeyBwcm9taXNpZnkgfSA9IHJlcXVpcmUoJ3V0aWwnKTtcbmNvbnN0IGZzID0gcmVxdWlyZSgnZnMnKTtcbmNvbnN0IHsgRmlsZSB9ID0gcmVxdWlyZSgndW5kaWNpJyk7XG5jb25zdCBRdWVyeSA9IHJlcXVpcmUoJy4uL3F1ZXJ5LmpzJyk7XG5cbmNsYXNzIEdyYXBocWwgZXh0ZW5kcyBTZXJ2aWNlIHtcblxuICAgICBjb25zdHJ1Y3RvcihjbGllbnQpXG4gICAgIHtcbiAgICAgICAgc3VwZXIoY2xpZW50KTtcbiAgICAgfVxuXG5cbiAgICAvKipcbiAgICAgKiBHcmFwaFFMIGVuZHBvaW50XG4gICAgICpcbiAgICAgKiBFeGVjdXRlIGEgR3JhcGhRTCBtdXRhdGlvbi5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBxdWVyeVxuICAgICAqIEB0aHJvd3Mge0FwcHdyaXRlRXhjZXB0aW9ufVxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlfVxuICAgICAqL1xuICAgIGFzeW5jIHF1ZXJ5KHF1ZXJ5KSB7XG4gICAgICAgIGNvbnN0IGFwaVBhdGggPSAnL2dyYXBocWwnO1xuICAgICAgICBsZXQgcGF5bG9hZCA9IHt9O1xuICAgICAgICBpZiAodHlwZW9mIHF1ZXJ5ID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEFwcHdyaXRlRXhjZXB0aW9uKCdNaXNzaW5nIHJlcXVpcmVkIHBhcmFtZXRlcjogXCJxdWVyeVwiJyk7XG4gICAgICAgIH1cblxuXG4gICAgICAgIGlmICh0eXBlb2YgcXVlcnkgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICBwYXlsb2FkWydxdWVyeSddID0gcXVlcnk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy5jbGllbnQuY2FsbCgncG9zdCcsIGFwaVBhdGgsIHtcbiAgICAgICAgICAgICd4LXNkay1ncmFwaHFsJzogJ3RydWUnLFxuICAgICAgICAgICAgJ2NvbnRlbnQtdHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJyxcbiAgICAgICAgfSwgcGF5bG9hZCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR3JhcGhRTCBlbmRwb2ludFxuICAgICAqXG4gICAgICogRXhlY3V0ZSBhIEdyYXBoUUwgbXV0YXRpb24uXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gcXVlcnlcbiAgICAgKiBAdGhyb3dzIHtBcHB3cml0ZUV4Y2VwdGlvbn1cbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZX1cbiAgICAgKi9cbiAgICBhc3luYyBtdXRhdGlvbihxdWVyeSkge1xuICAgICAgICBjb25zdCBhcGlQYXRoID0gJy9ncmFwaHFsL211dGF0aW9uJztcbiAgICAgICAgbGV0IHBheWxvYWQgPSB7fTtcbiAgICAgICAgaWYgKHR5cGVvZiBxdWVyeSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBBcHB3cml0ZUV4Y2VwdGlvbignTWlzc2luZyByZXF1aXJlZCBwYXJhbWV0ZXI6IFwicXVlcnlcIicpO1xuICAgICAgICB9XG5cblxuICAgICAgICBpZiAodHlwZW9mIHF1ZXJ5ICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgcGF5bG9hZFsncXVlcnknXSA9IHF1ZXJ5O1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMuY2xpZW50LmNhbGwoJ3Bvc3QnLCBhcGlQYXRoLCB7XG4gICAgICAgICAgICAneC1zZGstZ3JhcGhxbCc6ICd0cnVlJyxcbiAgICAgICAgICAgICdjb250ZW50LXR5cGUnOiAnYXBwbGljYXRpb24vanNvbicsXG4gICAgICAgIH0sIHBheWxvYWQpO1xuICAgIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBHcmFwaHFsO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(action-browser)/./node_modules/node-appwrite/lib/services/graphql.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/node-appwrite/lib/services/graphql.js":
/*!************************************************************!*\
  !*** ./node_modules/node-appwrite/lib/services/graphql.js ***!
  \************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("const Service = __webpack_require__(/*! ../service.js */ \"(rsc)/./node_modules/node-appwrite/lib/service.js\");\nconst AppwriteException = __webpack_require__(/*! ../exception.js */ \"(rsc)/./node_modules/node-appwrite/lib/exception.js\");\nconst InputFile = __webpack_require__(/*! ../inputFile.js */ \"(rsc)/./node_modules/node-appwrite/lib/inputFile.js\");\nconst client = __webpack_require__(/*! ../client.js */ \"(rsc)/./node_modules/node-appwrite/lib/client.js\");\nconst Stream = __webpack_require__(/*! stream */ \"stream\");\nconst { promisify } = __webpack_require__(/*! util */ \"util\");\nconst fs = __webpack_require__(/*! fs */ \"fs\");\nconst { File } = __webpack_require__(/*! undici */ \"undici\");\nconst Query = __webpack_require__(/*! ../query.js */ \"(rsc)/./node_modules/node-appwrite/lib/query.js\");\n\nclass Graphql extends Service {\n\n     constructor(client)\n     {\n        super(client);\n     }\n\n\n    /**\n     * GraphQL endpoint\n     *\n     * Execute a GraphQL mutation.\n     *\n     * @param {object} query\n     * @throws {AppwriteException}\n     * @returns {Promise}\n     */\n    async query(query) {\n        const apiPath = '/graphql';\n        let payload = {};\n        if (typeof query === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"query\"');\n        }\n\n\n        if (typeof query !== 'undefined') {\n            payload['query'] = query;\n        }\n\n        return await this.client.call('post', apiPath, {\n            'x-sdk-graphql': 'true',\n            'content-type': 'application/json',\n        }, payload);\n    }\n\n    /**\n     * GraphQL endpoint\n     *\n     * Execute a GraphQL mutation.\n     *\n     * @param {object} query\n     * @throws {AppwriteException}\n     * @returns {Promise}\n     */\n    async mutation(query) {\n        const apiPath = '/graphql/mutation';\n        let payload = {};\n        if (typeof query === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"query\"');\n        }\n\n\n        if (typeof query !== 'undefined') {\n            payload['query'] = query;\n        }\n\n        return await this.client.call('post', apiPath, {\n            'x-sdk-graphql': 'true',\n            'content-type': 'application/json',\n        }, payload);\n    }\n}\n\nmodule.exports = Graphql;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvbm9kZS1hcHB3cml0ZS9saWIvc2VydmljZXMvZ3JhcGhxbC5qcyIsIm1hcHBpbmdzIjoiQUFBQSxnQkFBZ0IsbUJBQU8sQ0FBQyx3RUFBZTtBQUN2QywwQkFBMEIsbUJBQU8sQ0FBQyw0RUFBaUI7QUFDbkQsa0JBQWtCLG1CQUFPLENBQUMsNEVBQWlCO0FBQzNDLGVBQWUsbUJBQU8sQ0FBQyxzRUFBYztBQUNyQyxlQUFlLG1CQUFPLENBQUMsc0JBQVE7QUFDL0IsUUFBUSxZQUFZLEVBQUUsbUJBQU8sQ0FBQyxrQkFBTTtBQUNwQyxXQUFXLG1CQUFPLENBQUMsY0FBSTtBQUN2QixRQUFRLE9BQU8sRUFBRSxtQkFBTyxDQUFDLHNCQUFRO0FBQ2pDLGNBQWMsbUJBQU8sQ0FBQyxvRUFBYTs7QUFFbkM7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkIsZ0JBQWdCO0FBQ2hCLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCLGdCQUFnQjtBQUNoQixpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTs7QUFFQSIsInNvdXJjZXMiOlsid2VicGFjazovL2pzbV9iYW5raW5nLy4vbm9kZV9tb2R1bGVzL25vZGUtYXBwd3JpdGUvbGliL3NlcnZpY2VzL2dyYXBocWwuanM/Y2M2YSJdLCJzb3VyY2VzQ29udGVudCI6WyJjb25zdCBTZXJ2aWNlID0gcmVxdWlyZSgnLi4vc2VydmljZS5qcycpO1xuY29uc3QgQXBwd3JpdGVFeGNlcHRpb24gPSByZXF1aXJlKCcuLi9leGNlcHRpb24uanMnKTtcbmNvbnN0IElucHV0RmlsZSA9IHJlcXVpcmUoJy4uL2lucHV0RmlsZS5qcycpO1xuY29uc3QgY2xpZW50ID0gcmVxdWlyZSgnLi4vY2xpZW50LmpzJyk7XG5jb25zdCBTdHJlYW0gPSByZXF1aXJlKCdzdHJlYW0nKTtcbmNvbnN0IHsgcHJvbWlzaWZ5IH0gPSByZXF1aXJlKCd1dGlsJyk7XG5jb25zdCBmcyA9IHJlcXVpcmUoJ2ZzJyk7XG5jb25zdCB7IEZpbGUgfSA9IHJlcXVpcmUoJ3VuZGljaScpO1xuY29uc3QgUXVlcnkgPSByZXF1aXJlKCcuLi9xdWVyeS5qcycpO1xuXG5jbGFzcyBHcmFwaHFsIGV4dGVuZHMgU2VydmljZSB7XG5cbiAgICAgY29uc3RydWN0b3IoY2xpZW50KVxuICAgICB7XG4gICAgICAgIHN1cGVyKGNsaWVudCk7XG4gICAgIH1cblxuXG4gICAgLyoqXG4gICAgICogR3JhcGhRTCBlbmRwb2ludFxuICAgICAqXG4gICAgICogRXhlY3V0ZSBhIEdyYXBoUUwgbXV0YXRpb24uXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gcXVlcnlcbiAgICAgKiBAdGhyb3dzIHtBcHB3cml0ZUV4Y2VwdGlvbn1cbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZX1cbiAgICAgKi9cbiAgICBhc3luYyBxdWVyeShxdWVyeSkge1xuICAgICAgICBjb25zdCBhcGlQYXRoID0gJy9ncmFwaHFsJztcbiAgICAgICAgbGV0IHBheWxvYWQgPSB7fTtcbiAgICAgICAgaWYgKHR5cGVvZiBxdWVyeSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBBcHB3cml0ZUV4Y2VwdGlvbignTWlzc2luZyByZXF1aXJlZCBwYXJhbWV0ZXI6IFwicXVlcnlcIicpO1xuICAgICAgICB9XG5cblxuICAgICAgICBpZiAodHlwZW9mIHF1ZXJ5ICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgcGF5bG9hZFsncXVlcnknXSA9IHF1ZXJ5O1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMuY2xpZW50LmNhbGwoJ3Bvc3QnLCBhcGlQYXRoLCB7XG4gICAgICAgICAgICAneC1zZGstZ3JhcGhxbCc6ICd0cnVlJyxcbiAgICAgICAgICAgICdjb250ZW50LXR5cGUnOiAnYXBwbGljYXRpb24vanNvbicsXG4gICAgICAgIH0sIHBheWxvYWQpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdyYXBoUUwgZW5kcG9pbnRcbiAgICAgKlxuICAgICAqIEV4ZWN1dGUgYSBHcmFwaFFMIG11dGF0aW9uLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtvYmplY3R9IHF1ZXJ5XG4gICAgICogQHRocm93cyB7QXBwd3JpdGVFeGNlcHRpb259XG4gICAgICogQHJldHVybnMge1Byb21pc2V9XG4gICAgICovXG4gICAgYXN5bmMgbXV0YXRpb24ocXVlcnkpIHtcbiAgICAgICAgY29uc3QgYXBpUGF0aCA9ICcvZ3JhcGhxbC9tdXRhdGlvbic7XG4gICAgICAgIGxldCBwYXlsb2FkID0ge307XG4gICAgICAgIGlmICh0eXBlb2YgcXVlcnkgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgQXBwd3JpdGVFeGNlcHRpb24oJ01pc3NpbmcgcmVxdWlyZWQgcGFyYW1ldGVyOiBcInF1ZXJ5XCInKTtcbiAgICAgICAgfVxuXG5cbiAgICAgICAgaWYgKHR5cGVvZiBxdWVyeSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHBheWxvYWRbJ3F1ZXJ5J10gPSBxdWVyeTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBhd2FpdCB0aGlzLmNsaWVudC5jYWxsKCdwb3N0JywgYXBpUGF0aCwge1xuICAgICAgICAgICAgJ3gtc2RrLWdyYXBocWwnOiAndHJ1ZScsXG4gICAgICAgICAgICAnY29udGVudC10eXBlJzogJ2FwcGxpY2F0aW9uL2pzb24nLFxuICAgICAgICB9LCBwYXlsb2FkKTtcbiAgICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gR3JhcGhxbDtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/node-appwrite/lib/services/graphql.js\n");

/***/ }),

/***/ "(action-browser)/./node_modules/node-appwrite/lib/services/health.js":
/*!***********************************************************!*\
  !*** ./node_modules/node-appwrite/lib/services/health.js ***!
  \***********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("const Service = __webpack_require__(/*! ../service.js */ \"(action-browser)/./node_modules/node-appwrite/lib/service.js\");\nconst AppwriteException = __webpack_require__(/*! ../exception.js */ \"(action-browser)/./node_modules/node-appwrite/lib/exception.js\");\nconst InputFile = __webpack_require__(/*! ../inputFile.js */ \"(action-browser)/./node_modules/node-appwrite/lib/inputFile.js\");\nconst client = __webpack_require__(/*! ../client.js */ \"(action-browser)/./node_modules/node-appwrite/lib/client.js\");\nconst Stream = __webpack_require__(/*! stream */ \"stream\");\nconst { promisify } = __webpack_require__(/*! util */ \"util\");\nconst fs = __webpack_require__(/*! fs */ \"fs\");\nconst { File } = __webpack_require__(/*! undici */ \"undici\");\nconst Query = __webpack_require__(/*! ../query.js */ \"(action-browser)/./node_modules/node-appwrite/lib/query.js\");\n\nclass Health extends Service {\n\n     constructor(client)\n     {\n        super(client);\n     }\n\n\n    /**\n     * Get HTTP\n     *\n     * Check the Appwrite HTTP server is up and responsive.\n     *\n     * @throws {AppwriteException}\n     * @returns {Promise}\n     */\n    async get() {\n        const apiPath = '/health';\n        let payload = {};\n\n        return await this.client.call('get', apiPath, {\n            'content-type': 'application/json',\n        }, payload);\n    }\n\n    /**\n     * Get antivirus\n     *\n     * Check the Appwrite Antivirus server is up and connection is successful.\n     *\n     * @throws {AppwriteException}\n     * @returns {Promise}\n     */\n    async getAntivirus() {\n        const apiPath = '/health/anti-virus';\n        let payload = {};\n\n        return await this.client.call('get', apiPath, {\n            'content-type': 'application/json',\n        }, payload);\n    }\n\n    /**\n     * Get cache\n     *\n     * Check the Appwrite in-memory cache servers are up and connection is\n     * successful.\n     *\n     * @throws {AppwriteException}\n     * @returns {Promise}\n     */\n    async getCache() {\n        const apiPath = '/health/cache';\n        let payload = {};\n\n        return await this.client.call('get', apiPath, {\n            'content-type': 'application/json',\n        }, payload);\n    }\n\n    /**\n     * Get the SSL certificate for a domain\n     *\n     * Get the SSL certificate for a domain\n     *\n     * @param {string} domain\n     * @throws {AppwriteException}\n     * @returns {Promise}\n     */\n    async getCertificate(domain) {\n        const apiPath = '/health/certificate';\n        let payload = {};\n\n        if (typeof domain !== 'undefined') {\n            payload['domain'] = domain;\n        }\n\n        return await this.client.call('get', apiPath, {\n            'content-type': 'application/json',\n        }, payload);\n    }\n\n    /**\n     * Get DB\n     *\n     * Check the Appwrite database servers are up and connection is successful.\n     *\n     * @throws {AppwriteException}\n     * @returns {Promise}\n     */\n    async getDB() {\n        const apiPath = '/health/db';\n        let payload = {};\n\n        return await this.client.call('get', apiPath, {\n            'content-type': 'application/json',\n        }, payload);\n    }\n\n    /**\n     * Get pubsub\n     *\n     * Check the Appwrite pub-sub servers are up and connection is successful.\n     *\n     * @throws {AppwriteException}\n     * @returns {Promise}\n     */\n    async getPubSub() {\n        const apiPath = '/health/pubsub';\n        let payload = {};\n\n        return await this.client.call('get', apiPath, {\n            'content-type': 'application/json',\n        }, payload);\n    }\n\n    /**\n     * Get queue\n     *\n     * Check the Appwrite queue messaging servers are up and connection is\n     * successful.\n     *\n     * @throws {AppwriteException}\n     * @returns {Promise}\n     */\n    async getQueue() {\n        const apiPath = '/health/queue';\n        let payload = {};\n\n        return await this.client.call('get', apiPath, {\n            'content-type': 'application/json',\n        }, payload);\n    }\n\n    /**\n     * Get builds queue\n     *\n     * Get the number of builds that are waiting to be processed in the Appwrite\n     * internal queue server.\n     *\n     * @param {number} threshold\n     * @throws {AppwriteException}\n     * @returns {Promise}\n     */\n    async getQueueBuilds(threshold) {\n        const apiPath = '/health/queue/builds';\n        let payload = {};\n\n        if (typeof threshold !== 'undefined') {\n            payload['threshold'] = threshold;\n        }\n\n        return await this.client.call('get', apiPath, {\n            'content-type': 'application/json',\n        }, payload);\n    }\n\n    /**\n     * Get certificates queue\n     *\n     * Get the number of certificates that are waiting to be issued against\n     * [Letsencrypt](https://letsencrypt.org/) in the Appwrite internal queue\n     * server.\n     *\n     * @param {number} threshold\n     * @throws {AppwriteException}\n     * @returns {Promise}\n     */\n    async getQueueCertificates(threshold) {\n        const apiPath = '/health/queue/certificates';\n        let payload = {};\n\n        if (typeof threshold !== 'undefined') {\n            payload['threshold'] = threshold;\n        }\n\n        return await this.client.call('get', apiPath, {\n            'content-type': 'application/json',\n        }, payload);\n    }\n\n    /**\n     * Get databases queue\n     *\n     * Get the number of database changes that are waiting to be processed in the\n     * Appwrite internal queue server.\n     *\n     * @param {string} name\n     * @param {number} threshold\n     * @throws {AppwriteException}\n     * @returns {Promise}\n     */\n    async getQueueDatabases(name, threshold) {\n        const apiPath = '/health/queue/databases';\n        let payload = {};\n\n        if (typeof name !== 'undefined') {\n            payload['name'] = name;\n        }\n\n        if (typeof threshold !== 'undefined') {\n            payload['threshold'] = threshold;\n        }\n\n        return await this.client.call('get', apiPath, {\n            'content-type': 'application/json',\n        }, payload);\n    }\n\n    /**\n     * Get deletes queue\n     *\n     * Get the number of background destructive changes that are waiting to be\n     * processed in the Appwrite internal queue server.\n     *\n     * @param {number} threshold\n     * @throws {AppwriteException}\n     * @returns {Promise}\n     */\n    async getQueueDeletes(threshold) {\n        const apiPath = '/health/queue/deletes';\n        let payload = {};\n\n        if (typeof threshold !== 'undefined') {\n            payload['threshold'] = threshold;\n        }\n\n        return await this.client.call('get', apiPath, {\n            'content-type': 'application/json',\n        }, payload);\n    }\n\n    /**\n     * Get number of failed queue jobs\n     *\n     * Returns the amount of failed jobs in a given queue.\n     * \n     *\n     * @param {Name} name\n     * @param {number} threshold\n     * @throws {AppwriteException}\n     * @returns {Promise}\n     */\n    async getFailedJobs(name, threshold) {\n        const apiPath = '/health/queue/failed/{name}'.replace('{name}', name);\n        let payload = {};\n        if (typeof name === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"name\"');\n        }\n\n\n        if (typeof threshold !== 'undefined') {\n            payload['threshold'] = threshold;\n        }\n\n        return await this.client.call('get', apiPath, {\n            'content-type': 'application/json',\n        }, payload);\n    }\n\n    /**\n     * Get functions queue\n     *\n     * Get the number of function executions that are waiting to be processed in\n     * the Appwrite internal queue server.\n     *\n     * @param {number} threshold\n     * @throws {AppwriteException}\n     * @returns {Promise}\n     */\n    async getQueueFunctions(threshold) {\n        const apiPath = '/health/queue/functions';\n        let payload = {};\n\n        if (typeof threshold !== 'undefined') {\n            payload['threshold'] = threshold;\n        }\n\n        return await this.client.call('get', apiPath, {\n            'content-type': 'application/json',\n        }, payload);\n    }\n\n    /**\n     * Get logs queue\n     *\n     * Get the number of logs that are waiting to be processed in the Appwrite\n     * internal queue server.\n     *\n     * @param {number} threshold\n     * @throws {AppwriteException}\n     * @returns {Promise}\n     */\n    async getQueueLogs(threshold) {\n        const apiPath = '/health/queue/logs';\n        let payload = {};\n\n        if (typeof threshold !== 'undefined') {\n            payload['threshold'] = threshold;\n        }\n\n        return await this.client.call('get', apiPath, {\n            'content-type': 'application/json',\n        }, payload);\n    }\n\n    /**\n     * Get mails queue\n     *\n     * Get the number of mails that are waiting to be processed in the Appwrite\n     * internal queue server.\n     *\n     * @param {number} threshold\n     * @throws {AppwriteException}\n     * @returns {Promise}\n     */\n    async getQueueMails(threshold) {\n        const apiPath = '/health/queue/mails';\n        let payload = {};\n\n        if (typeof threshold !== 'undefined') {\n            payload['threshold'] = threshold;\n        }\n\n        return await this.client.call('get', apiPath, {\n            'content-type': 'application/json',\n        }, payload);\n    }\n\n    /**\n     * Get messaging queue\n     *\n     * Get the number of messages that are waiting to be processed in the Appwrite\n     * internal queue server.\n     *\n     * @param {number} threshold\n     * @throws {AppwriteException}\n     * @returns {Promise}\n     */\n    async getQueueMessaging(threshold) {\n        const apiPath = '/health/queue/messaging';\n        let payload = {};\n\n        if (typeof threshold !== 'undefined') {\n            payload['threshold'] = threshold;\n        }\n\n        return await this.client.call('get', apiPath, {\n            'content-type': 'application/json',\n        }, payload);\n    }\n\n    /**\n     * Get migrations queue\n     *\n     * Get the number of migrations that are waiting to be processed in the\n     * Appwrite internal queue server.\n     *\n     * @param {number} threshold\n     * @throws {AppwriteException}\n     * @returns {Promise}\n     */\n    async getQueueMigrations(threshold) {\n        const apiPath = '/health/queue/migrations';\n        let payload = {};\n\n        if (typeof threshold !== 'undefined') {\n            payload['threshold'] = threshold;\n        }\n\n        return await this.client.call('get', apiPath, {\n            'content-type': 'application/json',\n        }, payload);\n    }\n\n    /**\n     * Get usage queue\n     *\n     * Get the number of metrics that are waiting to be processed in the Appwrite\n     * internal queue server.\n     *\n     * @param {number} threshold\n     * @throws {AppwriteException}\n     * @returns {Promise}\n     */\n    async getQueueUsage(threshold) {\n        const apiPath = '/health/queue/usage';\n        let payload = {};\n\n        if (typeof threshold !== 'undefined') {\n            payload['threshold'] = threshold;\n        }\n\n        return await this.client.call('get', apiPath, {\n            'content-type': 'application/json',\n        }, payload);\n    }\n\n    /**\n     * Get usage dump queue\n     *\n     * Get the number of projects containing metrics that are waiting to be\n     * processed in the Appwrite internal queue server.\n     *\n     * @param {number} threshold\n     * @throws {AppwriteException}\n     * @returns {Promise}\n     */\n    async getQueueUsageDump(threshold) {\n        const apiPath = '/health/queue/usage-dump';\n        let payload = {};\n\n        if (typeof threshold !== 'undefined') {\n            payload['threshold'] = threshold;\n        }\n\n        return await this.client.call('get', apiPath, {\n            'content-type': 'application/json',\n        }, payload);\n    }\n\n    /**\n     * Get webhooks queue\n     *\n     * Get the number of webhooks that are waiting to be processed in the Appwrite\n     * internal queue server.\n     *\n     * @param {number} threshold\n     * @throws {AppwriteException}\n     * @returns {Promise}\n     */\n    async getQueueWebhooks(threshold) {\n        const apiPath = '/health/queue/webhooks';\n        let payload = {};\n\n        if (typeof threshold !== 'undefined') {\n            payload['threshold'] = threshold;\n        }\n\n        return await this.client.call('get', apiPath, {\n            'content-type': 'application/json',\n        }, payload);\n    }\n\n    /**\n     * Get storage\n     *\n     * Check the Appwrite storage device is up and connection is successful.\n     *\n     * @throws {AppwriteException}\n     * @returns {Promise}\n     */\n    async getStorage() {\n        const apiPath = '/health/storage';\n        let payload = {};\n\n        return await this.client.call('get', apiPath, {\n            'content-type': 'application/json',\n        }, payload);\n    }\n\n    /**\n     * Get local storage\n     *\n     * Check the Appwrite local storage device is up and connection is successful.\n     *\n     * @throws {AppwriteException}\n     * @returns {Promise}\n     */\n    async getStorageLocal() {\n        const apiPath = '/health/storage/local';\n        let payload = {};\n\n        return await this.client.call('get', apiPath, {\n            'content-type': 'application/json',\n        }, payload);\n    }\n\n    /**\n     * Get time\n     *\n     * Check the Appwrite server time is synced with Google remote NTP server. We\n     * use this technology to smoothly handle leap seconds with no disruptive\n     * events. The [Network Time\n     * Protocol](https://en.wikipedia.org/wiki/Network_Time_Protocol) (NTP) is\n     * used by hundreds of millions of computers and devices to synchronize their\n     * clocks over the Internet. If your computer sets its own clock, it likely\n     * uses NTP.\n     *\n     * @throws {AppwriteException}\n     * @returns {Promise}\n     */\n    async getTime() {\n        const apiPath = '/health/time';\n        let payload = {};\n\n        return await this.client.call('get', apiPath, {\n            'content-type': 'application/json',\n        }, payload);\n    }\n}\n\nmodule.exports = Health;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFjdGlvbi1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9ub2RlLWFwcHdyaXRlL2xpYi9zZXJ2aWNlcy9oZWFsdGguanMiLCJtYXBwaW5ncyI6IkFBQUEsZ0JBQWdCLG1CQUFPLENBQUMsbUZBQWU7QUFDdkMsMEJBQTBCLG1CQUFPLENBQUMsdUZBQWlCO0FBQ25ELGtCQUFrQixtQkFBTyxDQUFDLHVGQUFpQjtBQUMzQyxlQUFlLG1CQUFPLENBQUMsaUZBQWM7QUFDckMsZUFBZSxtQkFBTyxDQUFDLHNCQUFRO0FBQy9CLFFBQVEsWUFBWSxFQUFFLG1CQUFPLENBQUMsa0JBQU07QUFDcEMsV0FBVyxtQkFBTyxDQUFDLGNBQUk7QUFDdkIsUUFBUSxPQUFPLEVBQUUsbUJBQU8sQ0FBQyxzQkFBUTtBQUNqQyxjQUFjLG1CQUFPLENBQUMsK0VBQWE7O0FBRW5DOztBQUVBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsU0FBUztBQUNUOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEIsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsU0FBUztBQUNUOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkIsZ0JBQWdCO0FBQ2hCLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFNBQVM7QUFDVDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsU0FBUztBQUNUOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEIsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsU0FBUztBQUNUOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QixnQkFBZ0I7QUFDaEIsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsU0FBUztBQUNUOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCLGdCQUFnQjtBQUNoQixpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsUUFBUTtBQUN2QixnQkFBZ0I7QUFDaEIsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFNBQVM7QUFDVDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkIsZ0JBQWdCO0FBQ2hCLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFNBQVM7QUFDVDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLE1BQU07QUFDckIsZUFBZSxRQUFRO0FBQ3ZCLGdCQUFnQjtBQUNoQixpQkFBaUI7QUFDakI7QUFDQTtBQUNBLCtDQUErQyxLQUFLLFlBQVksS0FBSztBQUNyRTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCLGdCQUFnQjtBQUNoQixpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCLGdCQUFnQjtBQUNoQixpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCLGdCQUFnQjtBQUNoQixpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCLGdCQUFnQjtBQUNoQixpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCLGdCQUFnQjtBQUNoQixpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCLGdCQUFnQjtBQUNoQixpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCLGdCQUFnQjtBQUNoQixpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCLGdCQUFnQjtBQUNoQixpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQixpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFNBQVM7QUFDVDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsU0FBUztBQUNUOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEIsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTs7QUFFQSIsInNvdXJjZXMiOlsid2VicGFjazovL2pzbV9iYW5raW5nLy4vbm9kZV9tb2R1bGVzL25vZGUtYXBwd3JpdGUvbGliL3NlcnZpY2VzL2hlYWx0aC5qcz82M2RjIl0sInNvdXJjZXNDb250ZW50IjpbImNvbnN0IFNlcnZpY2UgPSByZXF1aXJlKCcuLi9zZXJ2aWNlLmpzJyk7XG5jb25zdCBBcHB3cml0ZUV4Y2VwdGlvbiA9IHJlcXVpcmUoJy4uL2V4Y2VwdGlvbi5qcycpO1xuY29uc3QgSW5wdXRGaWxlID0gcmVxdWlyZSgnLi4vaW5wdXRGaWxlLmpzJyk7XG5jb25zdCBjbGllbnQgPSByZXF1aXJlKCcuLi9jbGllbnQuanMnKTtcbmNvbnN0IFN0cmVhbSA9IHJlcXVpcmUoJ3N0cmVhbScpO1xuY29uc3QgeyBwcm9taXNpZnkgfSA9IHJlcXVpcmUoJ3V0aWwnKTtcbmNvbnN0IGZzID0gcmVxdWlyZSgnZnMnKTtcbmNvbnN0IHsgRmlsZSB9ID0gcmVxdWlyZSgndW5kaWNpJyk7XG5jb25zdCBRdWVyeSA9IHJlcXVpcmUoJy4uL3F1ZXJ5LmpzJyk7XG5cbmNsYXNzIEhlYWx0aCBleHRlbmRzIFNlcnZpY2Uge1xuXG4gICAgIGNvbnN0cnVjdG9yKGNsaWVudClcbiAgICAge1xuICAgICAgICBzdXBlcihjbGllbnQpO1xuICAgICB9XG5cblxuICAgIC8qKlxuICAgICAqIEdldCBIVFRQXG4gICAgICpcbiAgICAgKiBDaGVjayB0aGUgQXBwd3JpdGUgSFRUUCBzZXJ2ZXIgaXMgdXAgYW5kIHJlc3BvbnNpdmUuXG4gICAgICpcbiAgICAgKiBAdGhyb3dzIHtBcHB3cml0ZUV4Y2VwdGlvbn1cbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZX1cbiAgICAgKi9cbiAgICBhc3luYyBnZXQoKSB7XG4gICAgICAgIGNvbnN0IGFwaVBhdGggPSAnL2hlYWx0aCc7XG4gICAgICAgIGxldCBwYXlsb2FkID0ge307XG5cbiAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMuY2xpZW50LmNhbGwoJ2dldCcsIGFwaVBhdGgsIHtcbiAgICAgICAgICAgICdjb250ZW50LXR5cGUnOiAnYXBwbGljYXRpb24vanNvbicsXG4gICAgICAgIH0sIHBheWxvYWQpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdldCBhbnRpdmlydXNcbiAgICAgKlxuICAgICAqIENoZWNrIHRoZSBBcHB3cml0ZSBBbnRpdmlydXMgc2VydmVyIGlzIHVwIGFuZCBjb25uZWN0aW9uIGlzIHN1Y2Nlc3NmdWwuXG4gICAgICpcbiAgICAgKiBAdGhyb3dzIHtBcHB3cml0ZUV4Y2VwdGlvbn1cbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZX1cbiAgICAgKi9cbiAgICBhc3luYyBnZXRBbnRpdmlydXMoKSB7XG4gICAgICAgIGNvbnN0IGFwaVBhdGggPSAnL2hlYWx0aC9hbnRpLXZpcnVzJztcbiAgICAgICAgbGV0IHBheWxvYWQgPSB7fTtcblxuICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy5jbGllbnQuY2FsbCgnZ2V0JywgYXBpUGF0aCwge1xuICAgICAgICAgICAgJ2NvbnRlbnQtdHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJyxcbiAgICAgICAgfSwgcGF5bG9hZCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2V0IGNhY2hlXG4gICAgICpcbiAgICAgKiBDaGVjayB0aGUgQXBwd3JpdGUgaW4tbWVtb3J5IGNhY2hlIHNlcnZlcnMgYXJlIHVwIGFuZCBjb25uZWN0aW9uIGlzXG4gICAgICogc3VjY2Vzc2Z1bC5cbiAgICAgKlxuICAgICAqIEB0aHJvd3Mge0FwcHdyaXRlRXhjZXB0aW9ufVxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlfVxuICAgICAqL1xuICAgIGFzeW5jIGdldENhY2hlKCkge1xuICAgICAgICBjb25zdCBhcGlQYXRoID0gJy9oZWFsdGgvY2FjaGUnO1xuICAgICAgICBsZXQgcGF5bG9hZCA9IHt9O1xuXG4gICAgICAgIHJldHVybiBhd2FpdCB0aGlzLmNsaWVudC5jYWxsKCdnZXQnLCBhcGlQYXRoLCB7XG4gICAgICAgICAgICAnY29udGVudC10eXBlJzogJ2FwcGxpY2F0aW9uL2pzb24nLFxuICAgICAgICB9LCBwYXlsb2FkKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZXQgdGhlIFNTTCBjZXJ0aWZpY2F0ZSBmb3IgYSBkb21haW5cbiAgICAgKlxuICAgICAqIEdldCB0aGUgU1NMIGNlcnRpZmljYXRlIGZvciBhIGRvbWFpblxuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGRvbWFpblxuICAgICAqIEB0aHJvd3Mge0FwcHdyaXRlRXhjZXB0aW9ufVxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlfVxuICAgICAqL1xuICAgIGFzeW5jIGdldENlcnRpZmljYXRlKGRvbWFpbikge1xuICAgICAgICBjb25zdCBhcGlQYXRoID0gJy9oZWFsdGgvY2VydGlmaWNhdGUnO1xuICAgICAgICBsZXQgcGF5bG9hZCA9IHt9O1xuXG4gICAgICAgIGlmICh0eXBlb2YgZG9tYWluICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgcGF5bG9hZFsnZG9tYWluJ10gPSBkb21haW47XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy5jbGllbnQuY2FsbCgnZ2V0JywgYXBpUGF0aCwge1xuICAgICAgICAgICAgJ2NvbnRlbnQtdHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJyxcbiAgICAgICAgfSwgcGF5bG9hZCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2V0IERCXG4gICAgICpcbiAgICAgKiBDaGVjayB0aGUgQXBwd3JpdGUgZGF0YWJhc2Ugc2VydmVycyBhcmUgdXAgYW5kIGNvbm5lY3Rpb24gaXMgc3VjY2Vzc2Z1bC5cbiAgICAgKlxuICAgICAqIEB0aHJvd3Mge0FwcHdyaXRlRXhjZXB0aW9ufVxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlfVxuICAgICAqL1xuICAgIGFzeW5jIGdldERCKCkge1xuICAgICAgICBjb25zdCBhcGlQYXRoID0gJy9oZWFsdGgvZGInO1xuICAgICAgICBsZXQgcGF5bG9hZCA9IHt9O1xuXG4gICAgICAgIHJldHVybiBhd2FpdCB0aGlzLmNsaWVudC5jYWxsKCdnZXQnLCBhcGlQYXRoLCB7XG4gICAgICAgICAgICAnY29udGVudC10eXBlJzogJ2FwcGxpY2F0aW9uL2pzb24nLFxuICAgICAgICB9LCBwYXlsb2FkKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZXQgcHVic3ViXG4gICAgICpcbiAgICAgKiBDaGVjayB0aGUgQXBwd3JpdGUgcHViLXN1YiBzZXJ2ZXJzIGFyZSB1cCBhbmQgY29ubmVjdGlvbiBpcyBzdWNjZXNzZnVsLlxuICAgICAqXG4gICAgICogQHRocm93cyB7QXBwd3JpdGVFeGNlcHRpb259XG4gICAgICogQHJldHVybnMge1Byb21pc2V9XG4gICAgICovXG4gICAgYXN5bmMgZ2V0UHViU3ViKCkge1xuICAgICAgICBjb25zdCBhcGlQYXRoID0gJy9oZWFsdGgvcHVic3ViJztcbiAgICAgICAgbGV0IHBheWxvYWQgPSB7fTtcblxuICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy5jbGllbnQuY2FsbCgnZ2V0JywgYXBpUGF0aCwge1xuICAgICAgICAgICAgJ2NvbnRlbnQtdHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJyxcbiAgICAgICAgfSwgcGF5bG9hZCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2V0IHF1ZXVlXG4gICAgICpcbiAgICAgKiBDaGVjayB0aGUgQXBwd3JpdGUgcXVldWUgbWVzc2FnaW5nIHNlcnZlcnMgYXJlIHVwIGFuZCBjb25uZWN0aW9uIGlzXG4gICAgICogc3VjY2Vzc2Z1bC5cbiAgICAgKlxuICAgICAqIEB0aHJvd3Mge0FwcHdyaXRlRXhjZXB0aW9ufVxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlfVxuICAgICAqL1xuICAgIGFzeW5jIGdldFF1ZXVlKCkge1xuICAgICAgICBjb25zdCBhcGlQYXRoID0gJy9oZWFsdGgvcXVldWUnO1xuICAgICAgICBsZXQgcGF5bG9hZCA9IHt9O1xuXG4gICAgICAgIHJldHVybiBhd2FpdCB0aGlzLmNsaWVudC5jYWxsKCdnZXQnLCBhcGlQYXRoLCB7XG4gICAgICAgICAgICAnY29udGVudC10eXBlJzogJ2FwcGxpY2F0aW9uL2pzb24nLFxuICAgICAgICB9LCBwYXlsb2FkKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZXQgYnVpbGRzIHF1ZXVlXG4gICAgICpcbiAgICAgKiBHZXQgdGhlIG51bWJlciBvZiBidWlsZHMgdGhhdCBhcmUgd2FpdGluZyB0byBiZSBwcm9jZXNzZWQgaW4gdGhlIEFwcHdyaXRlXG4gICAgICogaW50ZXJuYWwgcXVldWUgc2VydmVyLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHRocmVzaG9sZFxuICAgICAqIEB0aHJvd3Mge0FwcHdyaXRlRXhjZXB0aW9ufVxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlfVxuICAgICAqL1xuICAgIGFzeW5jIGdldFF1ZXVlQnVpbGRzKHRocmVzaG9sZCkge1xuICAgICAgICBjb25zdCBhcGlQYXRoID0gJy9oZWFsdGgvcXVldWUvYnVpbGRzJztcbiAgICAgICAgbGV0IHBheWxvYWQgPSB7fTtcblxuICAgICAgICBpZiAodHlwZW9mIHRocmVzaG9sZCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHBheWxvYWRbJ3RocmVzaG9sZCddID0gdGhyZXNob2xkO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMuY2xpZW50LmNhbGwoJ2dldCcsIGFwaVBhdGgsIHtcbiAgICAgICAgICAgICdjb250ZW50LXR5cGUnOiAnYXBwbGljYXRpb24vanNvbicsXG4gICAgICAgIH0sIHBheWxvYWQpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdldCBjZXJ0aWZpY2F0ZXMgcXVldWVcbiAgICAgKlxuICAgICAqIEdldCB0aGUgbnVtYmVyIG9mIGNlcnRpZmljYXRlcyB0aGF0IGFyZSB3YWl0aW5nIHRvIGJlIGlzc3VlZCBhZ2FpbnN0XG4gICAgICogW0xldHNlbmNyeXB0XShodHRwczovL2xldHNlbmNyeXB0Lm9yZy8pIGluIHRoZSBBcHB3cml0ZSBpbnRlcm5hbCBxdWV1ZVxuICAgICAqIHNlcnZlci5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB0aHJlc2hvbGRcbiAgICAgKiBAdGhyb3dzIHtBcHB3cml0ZUV4Y2VwdGlvbn1cbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZX1cbiAgICAgKi9cbiAgICBhc3luYyBnZXRRdWV1ZUNlcnRpZmljYXRlcyh0aHJlc2hvbGQpIHtcbiAgICAgICAgY29uc3QgYXBpUGF0aCA9ICcvaGVhbHRoL3F1ZXVlL2NlcnRpZmljYXRlcyc7XG4gICAgICAgIGxldCBwYXlsb2FkID0ge307XG5cbiAgICAgICAgaWYgKHR5cGVvZiB0aHJlc2hvbGQgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICBwYXlsb2FkWyd0aHJlc2hvbGQnXSA9IHRocmVzaG9sZDtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBhd2FpdCB0aGlzLmNsaWVudC5jYWxsKCdnZXQnLCBhcGlQYXRoLCB7XG4gICAgICAgICAgICAnY29udGVudC10eXBlJzogJ2FwcGxpY2F0aW9uL2pzb24nLFxuICAgICAgICB9LCBwYXlsb2FkKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZXQgZGF0YWJhc2VzIHF1ZXVlXG4gICAgICpcbiAgICAgKiBHZXQgdGhlIG51bWJlciBvZiBkYXRhYmFzZSBjaGFuZ2VzIHRoYXQgYXJlIHdhaXRpbmcgdG8gYmUgcHJvY2Vzc2VkIGluIHRoZVxuICAgICAqIEFwcHdyaXRlIGludGVybmFsIHF1ZXVlIHNlcnZlci5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHRocmVzaG9sZFxuICAgICAqIEB0aHJvd3Mge0FwcHdyaXRlRXhjZXB0aW9ufVxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlfVxuICAgICAqL1xuICAgIGFzeW5jIGdldFF1ZXVlRGF0YWJhc2VzKG5hbWUsIHRocmVzaG9sZCkge1xuICAgICAgICBjb25zdCBhcGlQYXRoID0gJy9oZWFsdGgvcXVldWUvZGF0YWJhc2VzJztcbiAgICAgICAgbGV0IHBheWxvYWQgPSB7fTtcblxuICAgICAgICBpZiAodHlwZW9mIG5hbWUgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICBwYXlsb2FkWyduYW1lJ10gPSBuYW1lO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHR5cGVvZiB0aHJlc2hvbGQgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICBwYXlsb2FkWyd0aHJlc2hvbGQnXSA9IHRocmVzaG9sZDtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBhd2FpdCB0aGlzLmNsaWVudC5jYWxsKCdnZXQnLCBhcGlQYXRoLCB7XG4gICAgICAgICAgICAnY29udGVudC10eXBlJzogJ2FwcGxpY2F0aW9uL2pzb24nLFxuICAgICAgICB9LCBwYXlsb2FkKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZXQgZGVsZXRlcyBxdWV1ZVxuICAgICAqXG4gICAgICogR2V0IHRoZSBudW1iZXIgb2YgYmFja2dyb3VuZCBkZXN0cnVjdGl2ZSBjaGFuZ2VzIHRoYXQgYXJlIHdhaXRpbmcgdG8gYmVcbiAgICAgKiBwcm9jZXNzZWQgaW4gdGhlIEFwcHdyaXRlIGludGVybmFsIHF1ZXVlIHNlcnZlci5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB0aHJlc2hvbGRcbiAgICAgKiBAdGhyb3dzIHtBcHB3cml0ZUV4Y2VwdGlvbn1cbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZX1cbiAgICAgKi9cbiAgICBhc3luYyBnZXRRdWV1ZURlbGV0ZXModGhyZXNob2xkKSB7XG4gICAgICAgIGNvbnN0IGFwaVBhdGggPSAnL2hlYWx0aC9xdWV1ZS9kZWxldGVzJztcbiAgICAgICAgbGV0IHBheWxvYWQgPSB7fTtcblxuICAgICAgICBpZiAodHlwZW9mIHRocmVzaG9sZCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHBheWxvYWRbJ3RocmVzaG9sZCddID0gdGhyZXNob2xkO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMuY2xpZW50LmNhbGwoJ2dldCcsIGFwaVBhdGgsIHtcbiAgICAgICAgICAgICdjb250ZW50LXR5cGUnOiAnYXBwbGljYXRpb24vanNvbicsXG4gICAgICAgIH0sIHBheWxvYWQpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdldCBudW1iZXIgb2YgZmFpbGVkIHF1ZXVlIGpvYnNcbiAgICAgKlxuICAgICAqIFJldHVybnMgdGhlIGFtb3VudCBvZiBmYWlsZWQgam9icyBpbiBhIGdpdmVuIHF1ZXVlLlxuICAgICAqIFxuICAgICAqXG4gICAgICogQHBhcmFtIHtOYW1lfSBuYW1lXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHRocmVzaG9sZFxuICAgICAqIEB0aHJvd3Mge0FwcHdyaXRlRXhjZXB0aW9ufVxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlfVxuICAgICAqL1xuICAgIGFzeW5jIGdldEZhaWxlZEpvYnMobmFtZSwgdGhyZXNob2xkKSB7XG4gICAgICAgIGNvbnN0IGFwaVBhdGggPSAnL2hlYWx0aC9xdWV1ZS9mYWlsZWQve25hbWV9Jy5yZXBsYWNlKCd7bmFtZX0nLCBuYW1lKTtcbiAgICAgICAgbGV0IHBheWxvYWQgPSB7fTtcbiAgICAgICAgaWYgKHR5cGVvZiBuYW1lID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEFwcHdyaXRlRXhjZXB0aW9uKCdNaXNzaW5nIHJlcXVpcmVkIHBhcmFtZXRlcjogXCJuYW1lXCInKTtcbiAgICAgICAgfVxuXG5cbiAgICAgICAgaWYgKHR5cGVvZiB0aHJlc2hvbGQgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICBwYXlsb2FkWyd0aHJlc2hvbGQnXSA9IHRocmVzaG9sZDtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBhd2FpdCB0aGlzLmNsaWVudC5jYWxsKCdnZXQnLCBhcGlQYXRoLCB7XG4gICAgICAgICAgICAnY29udGVudC10eXBlJzogJ2FwcGxpY2F0aW9uL2pzb24nLFxuICAgICAgICB9LCBwYXlsb2FkKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZXQgZnVuY3Rpb25zIHF1ZXVlXG4gICAgICpcbiAgICAgKiBHZXQgdGhlIG51bWJlciBvZiBmdW5jdGlvbiBleGVjdXRpb25zIHRoYXQgYXJlIHdhaXRpbmcgdG8gYmUgcHJvY2Vzc2VkIGluXG4gICAgICogdGhlIEFwcHdyaXRlIGludGVybmFsIHF1ZXVlIHNlcnZlci5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB0aHJlc2hvbGRcbiAgICAgKiBAdGhyb3dzIHtBcHB3cml0ZUV4Y2VwdGlvbn1cbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZX1cbiAgICAgKi9cbiAgICBhc3luYyBnZXRRdWV1ZUZ1bmN0aW9ucyh0aHJlc2hvbGQpIHtcbiAgICAgICAgY29uc3QgYXBpUGF0aCA9ICcvaGVhbHRoL3F1ZXVlL2Z1bmN0aW9ucyc7XG4gICAgICAgIGxldCBwYXlsb2FkID0ge307XG5cbiAgICAgICAgaWYgKHR5cGVvZiB0aHJlc2hvbGQgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICBwYXlsb2FkWyd0aHJlc2hvbGQnXSA9IHRocmVzaG9sZDtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBhd2FpdCB0aGlzLmNsaWVudC5jYWxsKCdnZXQnLCBhcGlQYXRoLCB7XG4gICAgICAgICAgICAnY29udGVudC10eXBlJzogJ2FwcGxpY2F0aW9uL2pzb24nLFxuICAgICAgICB9LCBwYXlsb2FkKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZXQgbG9ncyBxdWV1ZVxuICAgICAqXG4gICAgICogR2V0IHRoZSBudW1iZXIgb2YgbG9ncyB0aGF0IGFyZSB3YWl0aW5nIHRvIGJlIHByb2Nlc3NlZCBpbiB0aGUgQXBwd3JpdGVcbiAgICAgKiBpbnRlcm5hbCBxdWV1ZSBzZXJ2ZXIuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gdGhyZXNob2xkXG4gICAgICogQHRocm93cyB7QXBwd3JpdGVFeGNlcHRpb259XG4gICAgICogQHJldHVybnMge1Byb21pc2V9XG4gICAgICovXG4gICAgYXN5bmMgZ2V0UXVldWVMb2dzKHRocmVzaG9sZCkge1xuICAgICAgICBjb25zdCBhcGlQYXRoID0gJy9oZWFsdGgvcXVldWUvbG9ncyc7XG4gICAgICAgIGxldCBwYXlsb2FkID0ge307XG5cbiAgICAgICAgaWYgKHR5cGVvZiB0aHJlc2hvbGQgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICBwYXlsb2FkWyd0aHJlc2hvbGQnXSA9IHRocmVzaG9sZDtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBhd2FpdCB0aGlzLmNsaWVudC5jYWxsKCdnZXQnLCBhcGlQYXRoLCB7XG4gICAgICAgICAgICAnY29udGVudC10eXBlJzogJ2FwcGxpY2F0aW9uL2pzb24nLFxuICAgICAgICB9LCBwYXlsb2FkKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZXQgbWFpbHMgcXVldWVcbiAgICAgKlxuICAgICAqIEdldCB0aGUgbnVtYmVyIG9mIG1haWxzIHRoYXQgYXJlIHdhaXRpbmcgdG8gYmUgcHJvY2Vzc2VkIGluIHRoZSBBcHB3cml0ZVxuICAgICAqIGludGVybmFsIHF1ZXVlIHNlcnZlci5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB0aHJlc2hvbGRcbiAgICAgKiBAdGhyb3dzIHtBcHB3cml0ZUV4Y2VwdGlvbn1cbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZX1cbiAgICAgKi9cbiAgICBhc3luYyBnZXRRdWV1ZU1haWxzKHRocmVzaG9sZCkge1xuICAgICAgICBjb25zdCBhcGlQYXRoID0gJy9oZWFsdGgvcXVldWUvbWFpbHMnO1xuICAgICAgICBsZXQgcGF5bG9hZCA9IHt9O1xuXG4gICAgICAgIGlmICh0eXBlb2YgdGhyZXNob2xkICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgcGF5bG9hZFsndGhyZXNob2xkJ10gPSB0aHJlc2hvbGQ7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy5jbGllbnQuY2FsbCgnZ2V0JywgYXBpUGF0aCwge1xuICAgICAgICAgICAgJ2NvbnRlbnQtdHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJyxcbiAgICAgICAgfSwgcGF5bG9hZCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2V0IG1lc3NhZ2luZyBxdWV1ZVxuICAgICAqXG4gICAgICogR2V0IHRoZSBudW1iZXIgb2YgbWVzc2FnZXMgdGhhdCBhcmUgd2FpdGluZyB0byBiZSBwcm9jZXNzZWQgaW4gdGhlIEFwcHdyaXRlXG4gICAgICogaW50ZXJuYWwgcXVldWUgc2VydmVyLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHRocmVzaG9sZFxuICAgICAqIEB0aHJvd3Mge0FwcHdyaXRlRXhjZXB0aW9ufVxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlfVxuICAgICAqL1xuICAgIGFzeW5jIGdldFF1ZXVlTWVzc2FnaW5nKHRocmVzaG9sZCkge1xuICAgICAgICBjb25zdCBhcGlQYXRoID0gJy9oZWFsdGgvcXVldWUvbWVzc2FnaW5nJztcbiAgICAgICAgbGV0IHBheWxvYWQgPSB7fTtcblxuICAgICAgICBpZiAodHlwZW9mIHRocmVzaG9sZCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHBheWxvYWRbJ3RocmVzaG9sZCddID0gdGhyZXNob2xkO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMuY2xpZW50LmNhbGwoJ2dldCcsIGFwaVBhdGgsIHtcbiAgICAgICAgICAgICdjb250ZW50LXR5cGUnOiAnYXBwbGljYXRpb24vanNvbicsXG4gICAgICAgIH0sIHBheWxvYWQpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdldCBtaWdyYXRpb25zIHF1ZXVlXG4gICAgICpcbiAgICAgKiBHZXQgdGhlIG51bWJlciBvZiBtaWdyYXRpb25zIHRoYXQgYXJlIHdhaXRpbmcgdG8gYmUgcHJvY2Vzc2VkIGluIHRoZVxuICAgICAqIEFwcHdyaXRlIGludGVybmFsIHF1ZXVlIHNlcnZlci5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB0aHJlc2hvbGRcbiAgICAgKiBAdGhyb3dzIHtBcHB3cml0ZUV4Y2VwdGlvbn1cbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZX1cbiAgICAgKi9cbiAgICBhc3luYyBnZXRRdWV1ZU1pZ3JhdGlvbnModGhyZXNob2xkKSB7XG4gICAgICAgIGNvbnN0IGFwaVBhdGggPSAnL2hlYWx0aC9xdWV1ZS9taWdyYXRpb25zJztcbiAgICAgICAgbGV0IHBheWxvYWQgPSB7fTtcblxuICAgICAgICBpZiAodHlwZW9mIHRocmVzaG9sZCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHBheWxvYWRbJ3RocmVzaG9sZCddID0gdGhyZXNob2xkO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMuY2xpZW50LmNhbGwoJ2dldCcsIGFwaVBhdGgsIHtcbiAgICAgICAgICAgICdjb250ZW50LXR5cGUnOiAnYXBwbGljYXRpb24vanNvbicsXG4gICAgICAgIH0sIHBheWxvYWQpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdldCB1c2FnZSBxdWV1ZVxuICAgICAqXG4gICAgICogR2V0IHRoZSBudW1iZXIgb2YgbWV0cmljcyB0aGF0IGFyZSB3YWl0aW5nIHRvIGJlIHByb2Nlc3NlZCBpbiB0aGUgQXBwd3JpdGVcbiAgICAgKiBpbnRlcm5hbCBxdWV1ZSBzZXJ2ZXIuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gdGhyZXNob2xkXG4gICAgICogQHRocm93cyB7QXBwd3JpdGVFeGNlcHRpb259XG4gICAgICogQHJldHVybnMge1Byb21pc2V9XG4gICAgICovXG4gICAgYXN5bmMgZ2V0UXVldWVVc2FnZSh0aHJlc2hvbGQpIHtcbiAgICAgICAgY29uc3QgYXBpUGF0aCA9ICcvaGVhbHRoL3F1ZXVlL3VzYWdlJztcbiAgICAgICAgbGV0IHBheWxvYWQgPSB7fTtcblxuICAgICAgICBpZiAodHlwZW9mIHRocmVzaG9sZCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHBheWxvYWRbJ3RocmVzaG9sZCddID0gdGhyZXNob2xkO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMuY2xpZW50LmNhbGwoJ2dldCcsIGFwaVBhdGgsIHtcbiAgICAgICAgICAgICdjb250ZW50LXR5cGUnOiAnYXBwbGljYXRpb24vanNvbicsXG4gICAgICAgIH0sIHBheWxvYWQpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdldCB1c2FnZSBkdW1wIHF1ZXVlXG4gICAgICpcbiAgICAgKiBHZXQgdGhlIG51bWJlciBvZiBwcm9qZWN0cyBjb250YWluaW5nIG1ldHJpY3MgdGhhdCBhcmUgd2FpdGluZyB0byBiZVxuICAgICAqIHByb2Nlc3NlZCBpbiB0aGUgQXBwd3JpdGUgaW50ZXJuYWwgcXVldWUgc2VydmVyLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHRocmVzaG9sZFxuICAgICAqIEB0aHJvd3Mge0FwcHdyaXRlRXhjZXB0aW9ufVxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlfVxuICAgICAqL1xuICAgIGFzeW5jIGdldFF1ZXVlVXNhZ2VEdW1wKHRocmVzaG9sZCkge1xuICAgICAgICBjb25zdCBhcGlQYXRoID0gJy9oZWFsdGgvcXVldWUvdXNhZ2UtZHVtcCc7XG4gICAgICAgIGxldCBwYXlsb2FkID0ge307XG5cbiAgICAgICAgaWYgKHR5cGVvZiB0aHJlc2hvbGQgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICBwYXlsb2FkWyd0aHJlc2hvbGQnXSA9IHRocmVzaG9sZDtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBhd2FpdCB0aGlzLmNsaWVudC5jYWxsKCdnZXQnLCBhcGlQYXRoLCB7XG4gICAgICAgICAgICAnY29udGVudC10eXBlJzogJ2FwcGxpY2F0aW9uL2pzb24nLFxuICAgICAgICB9LCBwYXlsb2FkKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZXQgd2ViaG9va3MgcXVldWVcbiAgICAgKlxuICAgICAqIEdldCB0aGUgbnVtYmVyIG9mIHdlYmhvb2tzIHRoYXQgYXJlIHdhaXRpbmcgdG8gYmUgcHJvY2Vzc2VkIGluIHRoZSBBcHB3cml0ZVxuICAgICAqIGludGVybmFsIHF1ZXVlIHNlcnZlci5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB0aHJlc2hvbGRcbiAgICAgKiBAdGhyb3dzIHtBcHB3cml0ZUV4Y2VwdGlvbn1cbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZX1cbiAgICAgKi9cbiAgICBhc3luYyBnZXRRdWV1ZVdlYmhvb2tzKHRocmVzaG9sZCkge1xuICAgICAgICBjb25zdCBhcGlQYXRoID0gJy9oZWFsdGgvcXVldWUvd2ViaG9va3MnO1xuICAgICAgICBsZXQgcGF5bG9hZCA9IHt9O1xuXG4gICAgICAgIGlmICh0eXBlb2YgdGhyZXNob2xkICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgcGF5bG9hZFsndGhyZXNob2xkJ10gPSB0aHJlc2hvbGQ7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy5jbGllbnQuY2FsbCgnZ2V0JywgYXBpUGF0aCwge1xuICAgICAgICAgICAgJ2NvbnRlbnQtdHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJyxcbiAgICAgICAgfSwgcGF5bG9hZCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2V0IHN0b3JhZ2VcbiAgICAgKlxuICAgICAqIENoZWNrIHRoZSBBcHB3cml0ZSBzdG9yYWdlIGRldmljZSBpcyB1cCBhbmQgY29ubmVjdGlvbiBpcyBzdWNjZXNzZnVsLlxuICAgICAqXG4gICAgICogQHRocm93cyB7QXBwd3JpdGVFeGNlcHRpb259XG4gICAgICogQHJldHVybnMge1Byb21pc2V9XG4gICAgICovXG4gICAgYXN5bmMgZ2V0U3RvcmFnZSgpIHtcbiAgICAgICAgY29uc3QgYXBpUGF0aCA9ICcvaGVhbHRoL3N0b3JhZ2UnO1xuICAgICAgICBsZXQgcGF5bG9hZCA9IHt9O1xuXG4gICAgICAgIHJldHVybiBhd2FpdCB0aGlzLmNsaWVudC5jYWxsKCdnZXQnLCBhcGlQYXRoLCB7XG4gICAgICAgICAgICAnY29udGVudC10eXBlJzogJ2FwcGxpY2F0aW9uL2pzb24nLFxuICAgICAgICB9LCBwYXlsb2FkKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZXQgbG9jYWwgc3RvcmFnZVxuICAgICAqXG4gICAgICogQ2hlY2sgdGhlIEFwcHdyaXRlIGxvY2FsIHN0b3JhZ2UgZGV2aWNlIGlzIHVwIGFuZCBjb25uZWN0aW9uIGlzIHN1Y2Nlc3NmdWwuXG4gICAgICpcbiAgICAgKiBAdGhyb3dzIHtBcHB3cml0ZUV4Y2VwdGlvbn1cbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZX1cbiAgICAgKi9cbiAgICBhc3luYyBnZXRTdG9yYWdlTG9jYWwoKSB7XG4gICAgICAgIGNvbnN0IGFwaVBhdGggPSAnL2hlYWx0aC9zdG9yYWdlL2xvY2FsJztcbiAgICAgICAgbGV0IHBheWxvYWQgPSB7fTtcblxuICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy5jbGllbnQuY2FsbCgnZ2V0JywgYXBpUGF0aCwge1xuICAgICAgICAgICAgJ2NvbnRlbnQtdHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJyxcbiAgICAgICAgfSwgcGF5bG9hZCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2V0IHRpbWVcbiAgICAgKlxuICAgICAqIENoZWNrIHRoZSBBcHB3cml0ZSBzZXJ2ZXIgdGltZSBpcyBzeW5jZWQgd2l0aCBHb29nbGUgcmVtb3RlIE5UUCBzZXJ2ZXIuIFdlXG4gICAgICogdXNlIHRoaXMgdGVjaG5vbG9neSB0byBzbW9vdGhseSBoYW5kbGUgbGVhcCBzZWNvbmRzIHdpdGggbm8gZGlzcnVwdGl2ZVxuICAgICAqIGV2ZW50cy4gVGhlIFtOZXR3b3JrIFRpbWVcbiAgICAgKiBQcm90b2NvbF0oaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvTmV0d29ya19UaW1lX1Byb3RvY29sKSAoTlRQKSBpc1xuICAgICAqIHVzZWQgYnkgaHVuZHJlZHMgb2YgbWlsbGlvbnMgb2YgY29tcHV0ZXJzIGFuZCBkZXZpY2VzIHRvIHN5bmNocm9uaXplIHRoZWlyXG4gICAgICogY2xvY2tzIG92ZXIgdGhlIEludGVybmV0LiBJZiB5b3VyIGNvbXB1dGVyIHNldHMgaXRzIG93biBjbG9jaywgaXQgbGlrZWx5XG4gICAgICogdXNlcyBOVFAuXG4gICAgICpcbiAgICAgKiBAdGhyb3dzIHtBcHB3cml0ZUV4Y2VwdGlvbn1cbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZX1cbiAgICAgKi9cbiAgICBhc3luYyBnZXRUaW1lKCkge1xuICAgICAgICBjb25zdCBhcGlQYXRoID0gJy9oZWFsdGgvdGltZSc7XG4gICAgICAgIGxldCBwYXlsb2FkID0ge307XG5cbiAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMuY2xpZW50LmNhbGwoJ2dldCcsIGFwaVBhdGgsIHtcbiAgICAgICAgICAgICdjb250ZW50LXR5cGUnOiAnYXBwbGljYXRpb24vanNvbicsXG4gICAgICAgIH0sIHBheWxvYWQpO1xuICAgIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBIZWFsdGg7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(action-browser)/./node_modules/node-appwrite/lib/services/health.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/node-appwrite/lib/services/health.js":
/*!***********************************************************!*\
  !*** ./node_modules/node-appwrite/lib/services/health.js ***!
  \***********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("const Service = __webpack_require__(/*! ../service.js */ \"(rsc)/./node_modules/node-appwrite/lib/service.js\");\nconst AppwriteException = __webpack_require__(/*! ../exception.js */ \"(rsc)/./node_modules/node-appwrite/lib/exception.js\");\nconst InputFile = __webpack_require__(/*! ../inputFile.js */ \"(rsc)/./node_modules/node-appwrite/lib/inputFile.js\");\nconst client = __webpack_require__(/*! ../client.js */ \"(rsc)/./node_modules/node-appwrite/lib/client.js\");\nconst Stream = __webpack_require__(/*! stream */ \"stream\");\nconst { promisify } = __webpack_require__(/*! util */ \"util\");\nconst fs = __webpack_require__(/*! fs */ \"fs\");\nconst { File } = __webpack_require__(/*! undici */ \"undici\");\nconst Query = __webpack_require__(/*! ../query.js */ \"(rsc)/./node_modules/node-appwrite/lib/query.js\");\n\nclass Health extends Service {\n\n     constructor(client)\n     {\n        super(client);\n     }\n\n\n    /**\n     * Get HTTP\n     *\n     * Check the Appwrite HTTP server is up and responsive.\n     *\n     * @throws {AppwriteException}\n     * @returns {Promise}\n     */\n    async get() {\n        const apiPath = '/health';\n        let payload = {};\n\n        return await this.client.call('get', apiPath, {\n            'content-type': 'application/json',\n        }, payload);\n    }\n\n    /**\n     * Get antivirus\n     *\n     * Check the Appwrite Antivirus server is up and connection is successful.\n     *\n     * @throws {AppwriteException}\n     * @returns {Promise}\n     */\n    async getAntivirus() {\n        const apiPath = '/health/anti-virus';\n        let payload = {};\n\n        return await this.client.call('get', apiPath, {\n            'content-type': 'application/json',\n        }, payload);\n    }\n\n    /**\n     * Get cache\n     *\n     * Check the Appwrite in-memory cache servers are up and connection is\n     * successful.\n     *\n     * @throws {AppwriteException}\n     * @returns {Promise}\n     */\n    async getCache() {\n        const apiPath = '/health/cache';\n        let payload = {};\n\n        return await this.client.call('get', apiPath, {\n            'content-type': 'application/json',\n        }, payload);\n    }\n\n    /**\n     * Get the SSL certificate for a domain\n     *\n     * Get the SSL certificate for a domain\n     *\n     * @param {string} domain\n     * @throws {AppwriteException}\n     * @returns {Promise}\n     */\n    async getCertificate(domain) {\n        const apiPath = '/health/certificate';\n        let payload = {};\n\n        if (typeof domain !== 'undefined') {\n            payload['domain'] = domain;\n        }\n\n        return await this.client.call('get', apiPath, {\n            'content-type': 'application/json',\n        }, payload);\n    }\n\n    /**\n     * Get DB\n     *\n     * Check the Appwrite database servers are up and connection is successful.\n     *\n     * @throws {AppwriteException}\n     * @returns {Promise}\n     */\n    async getDB() {\n        const apiPath = '/health/db';\n        let payload = {};\n\n        return await this.client.call('get', apiPath, {\n            'content-type': 'application/json',\n        }, payload);\n    }\n\n    /**\n     * Get pubsub\n     *\n     * Check the Appwrite pub-sub servers are up and connection is successful.\n     *\n     * @throws {AppwriteException}\n     * @returns {Promise}\n     */\n    async getPubSub() {\n        const apiPath = '/health/pubsub';\n        let payload = {};\n\n        return await this.client.call('get', apiPath, {\n            'content-type': 'application/json',\n        }, payload);\n    }\n\n    /**\n     * Get queue\n     *\n     * Check the Appwrite queue messaging servers are up and connection is\n     * successful.\n     *\n     * @throws {AppwriteException}\n     * @returns {Promise}\n     */\n    async getQueue() {\n        const apiPath = '/health/queue';\n        let payload = {};\n\n        return await this.client.call('get', apiPath, {\n            'content-type': 'application/json',\n        }, payload);\n    }\n\n    /**\n     * Get builds queue\n     *\n     * Get the number of builds that are waiting to be processed in the Appwrite\n     * internal queue server.\n     *\n     * @param {number} threshold\n     * @throws {AppwriteException}\n     * @returns {Promise}\n     */\n    async getQueueBuilds(threshold) {\n        const apiPath = '/health/queue/builds';\n        let payload = {};\n\n        if (typeof threshold !== 'undefined') {\n            payload['threshold'] = threshold;\n        }\n\n        return await this.client.call('get', apiPath, {\n            'content-type': 'application/json',\n        }, payload);\n    }\n\n    /**\n     * Get certificates queue\n     *\n     * Get the number of certificates that are waiting to be issued against\n     * [Letsencrypt](https://letsencrypt.org/) in the Appwrite internal queue\n     * server.\n     *\n     * @param {number} threshold\n     * @throws {AppwriteException}\n     * @returns {Promise}\n     */\n    async getQueueCertificates(threshold) {\n        const apiPath = '/health/queue/certificates';\n        let payload = {};\n\n        if (typeof threshold !== 'undefined') {\n            payload['threshold'] = threshold;\n        }\n\n        return await this.client.call('get', apiPath, {\n            'content-type': 'application/json',\n        }, payload);\n    }\n\n    /**\n     * Get databases queue\n     *\n     * Get the number of database changes that are waiting to be processed in the\n     * Appwrite internal queue server.\n     *\n     * @param {string} name\n     * @param {number} threshold\n     * @throws {AppwriteException}\n     * @returns {Promise}\n     */\n    async getQueueDatabases(name, threshold) {\n        const apiPath = '/health/queue/databases';\n        let payload = {};\n\n        if (typeof name !== 'undefined') {\n            payload['name'] = name;\n        }\n\n        if (typeof threshold !== 'undefined') {\n            payload['threshold'] = threshold;\n        }\n\n        return await this.client.call('get', apiPath, {\n            'content-type': 'application/json',\n        }, payload);\n    }\n\n    /**\n     * Get deletes queue\n     *\n     * Get the number of background destructive changes that are waiting to be\n     * processed in the Appwrite internal queue server.\n     *\n     * @param {number} threshold\n     * @throws {AppwriteException}\n     * @returns {Promise}\n     */\n    async getQueueDeletes(threshold) {\n        const apiPath = '/health/queue/deletes';\n        let payload = {};\n\n        if (typeof threshold !== 'undefined') {\n            payload['threshold'] = threshold;\n        }\n\n        return await this.client.call('get', apiPath, {\n            'content-type': 'application/json',\n        }, payload);\n    }\n\n    /**\n     * Get number of failed queue jobs\n     *\n     * Returns the amount of failed jobs in a given queue.\n     * \n     *\n     * @param {Name} name\n     * @param {number} threshold\n     * @throws {AppwriteException}\n     * @returns {Promise}\n     */\n    async getFailedJobs(name, threshold) {\n        const apiPath = '/health/queue/failed/{name}'.replace('{name}', name);\n        let payload = {};\n        if (typeof name === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"name\"');\n        }\n\n\n        if (typeof threshold !== 'undefined') {\n            payload['threshold'] = threshold;\n        }\n\n        return await this.client.call('get', apiPath, {\n            'content-type': 'application/json',\n        }, payload);\n    }\n\n    /**\n     * Get functions queue\n     *\n     * Get the number of function executions that are waiting to be processed in\n     * the Appwrite internal queue server.\n     *\n     * @param {number} threshold\n     * @throws {AppwriteException}\n     * @returns {Promise}\n     */\n    async getQueueFunctions(threshold) {\n        const apiPath = '/health/queue/functions';\n        let payload = {};\n\n        if (typeof threshold !== 'undefined') {\n            payload['threshold'] = threshold;\n        }\n\n        return await this.client.call('get', apiPath, {\n            'content-type': 'application/json',\n        }, payload);\n    }\n\n    /**\n     * Get logs queue\n     *\n     * Get the number of logs that are waiting to be processed in the Appwrite\n     * internal queue server.\n     *\n     * @param {number} threshold\n     * @throws {AppwriteException}\n     * @returns {Promise}\n     */\n    async getQueueLogs(threshold) {\n        const apiPath = '/health/queue/logs';\n        let payload = {};\n\n        if (typeof threshold !== 'undefined') {\n            payload['threshold'] = threshold;\n        }\n\n        return await this.client.call('get', apiPath, {\n            'content-type': 'application/json',\n        }, payload);\n    }\n\n    /**\n     * Get mails queue\n     *\n     * Get the number of mails that are waiting to be processed in the Appwrite\n     * internal queue server.\n     *\n     * @param {number} threshold\n     * @throws {AppwriteException}\n     * @returns {Promise}\n     */\n    async getQueueMails(threshold) {\n        const apiPath = '/health/queue/mails';\n        let payload = {};\n\n        if (typeof threshold !== 'undefined') {\n            payload['threshold'] = threshold;\n        }\n\n        return await this.client.call('get', apiPath, {\n            'content-type': 'application/json',\n        }, payload);\n    }\n\n    /**\n     * Get messaging queue\n     *\n     * Get the number of messages that are waiting to be processed in the Appwrite\n     * internal queue server.\n     *\n     * @param {number} threshold\n     * @throws {AppwriteException}\n     * @returns {Promise}\n     */\n    async getQueueMessaging(threshold) {\n        const apiPath = '/health/queue/messaging';\n        let payload = {};\n\n        if (typeof threshold !== 'undefined') {\n            payload['threshold'] = threshold;\n        }\n\n        return await this.client.call('get', apiPath, {\n            'content-type': 'application/json',\n        }, payload);\n    }\n\n    /**\n     * Get migrations queue\n     *\n     * Get the number of migrations that are waiting to be processed in the\n     * Appwrite internal queue server.\n     *\n     * @param {number} threshold\n     * @throws {AppwriteException}\n     * @returns {Promise}\n     */\n    async getQueueMigrations(threshold) {\n        const apiPath = '/health/queue/migrations';\n        let payload = {};\n\n        if (typeof threshold !== 'undefined') {\n            payload['threshold'] = threshold;\n        }\n\n        return await this.client.call('get', apiPath, {\n            'content-type': 'application/json',\n        }, payload);\n    }\n\n    /**\n     * Get usage queue\n     *\n     * Get the number of metrics that are waiting to be processed in the Appwrite\n     * internal queue server.\n     *\n     * @param {number} threshold\n     * @throws {AppwriteException}\n     * @returns {Promise}\n     */\n    async getQueueUsage(threshold) {\n        const apiPath = '/health/queue/usage';\n        let payload = {};\n\n        if (typeof threshold !== 'undefined') {\n            payload['threshold'] = threshold;\n        }\n\n        return await this.client.call('get', apiPath, {\n            'content-type': 'application/json',\n        }, payload);\n    }\n\n    /**\n     * Get usage dump queue\n     *\n     * Get the number of projects containing metrics that are waiting to be\n     * processed in the Appwrite internal queue server.\n     *\n     * @param {number} threshold\n     * @throws {AppwriteException}\n     * @returns {Promise}\n     */\n    async getQueueUsageDump(threshold) {\n        const apiPath = '/health/queue/usage-dump';\n        let payload = {};\n\n        if (typeof threshold !== 'undefined') {\n            payload['threshold'] = threshold;\n        }\n\n        return await this.client.call('get', apiPath, {\n            'content-type': 'application/json',\n        }, payload);\n    }\n\n    /**\n     * Get webhooks queue\n     *\n     * Get the number of webhooks that are waiting to be processed in the Appwrite\n     * internal queue server.\n     *\n     * @param {number} threshold\n     * @throws {AppwriteException}\n     * @returns {Promise}\n     */\n    async getQueueWebhooks(threshold) {\n        const apiPath = '/health/queue/webhooks';\n        let payload = {};\n\n        if (typeof threshold !== 'undefined') {\n            payload['threshold'] = threshold;\n        }\n\n        return await this.client.call('get', apiPath, {\n            'content-type': 'application/json',\n        }, payload);\n    }\n\n    /**\n     * Get storage\n     *\n     * Check the Appwrite storage device is up and connection is successful.\n     *\n     * @throws {AppwriteException}\n     * @returns {Promise}\n     */\n    async getStorage() {\n        const apiPath = '/health/storage';\n        let payload = {};\n\n        return await this.client.call('get', apiPath, {\n            'content-type': 'application/json',\n        }, payload);\n    }\n\n    /**\n     * Get local storage\n     *\n     * Check the Appwrite local storage device is up and connection is successful.\n     *\n     * @throws {AppwriteException}\n     * @returns {Promise}\n     */\n    async getStorageLocal() {\n        const apiPath = '/health/storage/local';\n        let payload = {};\n\n        return await this.client.call('get', apiPath, {\n            'content-type': 'application/json',\n        }, payload);\n    }\n\n    /**\n     * Get time\n     *\n     * Check the Appwrite server time is synced with Google remote NTP server. We\n     * use this technology to smoothly handle leap seconds with no disruptive\n     * events. The [Network Time\n     * Protocol](https://en.wikipedia.org/wiki/Network_Time_Protocol) (NTP) is\n     * used by hundreds of millions of computers and devices to synchronize their\n     * clocks over the Internet. If your computer sets its own clock, it likely\n     * uses NTP.\n     *\n     * @throws {AppwriteException}\n     * @returns {Promise}\n     */\n    async getTime() {\n        const apiPath = '/health/time';\n        let payload = {};\n\n        return await this.client.call('get', apiPath, {\n            'content-type': 'application/json',\n        }, payload);\n    }\n}\n\nmodule.exports = Health;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvbm9kZS1hcHB3cml0ZS9saWIvc2VydmljZXMvaGVhbHRoLmpzIiwibWFwcGluZ3MiOiJBQUFBLGdCQUFnQixtQkFBTyxDQUFDLHdFQUFlO0FBQ3ZDLDBCQUEwQixtQkFBTyxDQUFDLDRFQUFpQjtBQUNuRCxrQkFBa0IsbUJBQU8sQ0FBQyw0RUFBaUI7QUFDM0MsZUFBZSxtQkFBTyxDQUFDLHNFQUFjO0FBQ3JDLGVBQWUsbUJBQU8sQ0FBQyxzQkFBUTtBQUMvQixRQUFRLFlBQVksRUFBRSxtQkFBTyxDQUFDLGtCQUFNO0FBQ3BDLFdBQVcsbUJBQU8sQ0FBQyxjQUFJO0FBQ3ZCLFFBQVEsT0FBTyxFQUFFLG1CQUFPLENBQUMsc0JBQVE7QUFDakMsY0FBYyxtQkFBTyxDQUFDLG9FQUFhOztBQUVuQzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQixpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFNBQVM7QUFDVDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsU0FBUztBQUNUOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQixpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFNBQVM7QUFDVDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCLGdCQUFnQjtBQUNoQixpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQixpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFNBQVM7QUFDVDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsU0FBUztBQUNUOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQixpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFNBQVM7QUFDVDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkIsZ0JBQWdCO0FBQ2hCLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFNBQVM7QUFDVDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QixnQkFBZ0I7QUFDaEIsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsU0FBUztBQUNUOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QixlQUFlLFFBQVE7QUFDdkIsZ0JBQWdCO0FBQ2hCLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCLGdCQUFnQjtBQUNoQixpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxNQUFNO0FBQ3JCLGVBQWUsUUFBUTtBQUN2QixnQkFBZ0I7QUFDaEIsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQSwrQ0FBK0MsS0FBSyxZQUFZLEtBQUs7QUFDckU7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsU0FBUztBQUNUOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QixnQkFBZ0I7QUFDaEIsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsU0FBUztBQUNUOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QixnQkFBZ0I7QUFDaEIsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsU0FBUztBQUNUOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QixnQkFBZ0I7QUFDaEIsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsU0FBUztBQUNUOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QixnQkFBZ0I7QUFDaEIsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsU0FBUztBQUNUOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QixnQkFBZ0I7QUFDaEIsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsU0FBUztBQUNUOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QixnQkFBZ0I7QUFDaEIsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsU0FBUztBQUNUOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QixnQkFBZ0I7QUFDaEIsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsU0FBUztBQUNUOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QixnQkFBZ0I7QUFDaEIsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsU0FBUztBQUNUOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEIsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQixpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFNBQVM7QUFDVDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7O0FBRUEiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9qc21fYmFua2luZy8uL25vZGVfbW9kdWxlcy9ub2RlLWFwcHdyaXRlL2xpYi9zZXJ2aWNlcy9oZWFsdGguanM/Mzk0NSJdLCJzb3VyY2VzQ29udGVudCI6WyJjb25zdCBTZXJ2aWNlID0gcmVxdWlyZSgnLi4vc2VydmljZS5qcycpO1xuY29uc3QgQXBwd3JpdGVFeGNlcHRpb24gPSByZXF1aXJlKCcuLi9leGNlcHRpb24uanMnKTtcbmNvbnN0IElucHV0RmlsZSA9IHJlcXVpcmUoJy4uL2lucHV0RmlsZS5qcycpO1xuY29uc3QgY2xpZW50ID0gcmVxdWlyZSgnLi4vY2xpZW50LmpzJyk7XG5jb25zdCBTdHJlYW0gPSByZXF1aXJlKCdzdHJlYW0nKTtcbmNvbnN0IHsgcHJvbWlzaWZ5IH0gPSByZXF1aXJlKCd1dGlsJyk7XG5jb25zdCBmcyA9IHJlcXVpcmUoJ2ZzJyk7XG5jb25zdCB7IEZpbGUgfSA9IHJlcXVpcmUoJ3VuZGljaScpO1xuY29uc3QgUXVlcnkgPSByZXF1aXJlKCcuLi9xdWVyeS5qcycpO1xuXG5jbGFzcyBIZWFsdGggZXh0ZW5kcyBTZXJ2aWNlIHtcblxuICAgICBjb25zdHJ1Y3RvcihjbGllbnQpXG4gICAgIHtcbiAgICAgICAgc3VwZXIoY2xpZW50KTtcbiAgICAgfVxuXG5cbiAgICAvKipcbiAgICAgKiBHZXQgSFRUUFxuICAgICAqXG4gICAgICogQ2hlY2sgdGhlIEFwcHdyaXRlIEhUVFAgc2VydmVyIGlzIHVwIGFuZCByZXNwb25zaXZlLlxuICAgICAqXG4gICAgICogQHRocm93cyB7QXBwd3JpdGVFeGNlcHRpb259XG4gICAgICogQHJldHVybnMge1Byb21pc2V9XG4gICAgICovXG4gICAgYXN5bmMgZ2V0KCkge1xuICAgICAgICBjb25zdCBhcGlQYXRoID0gJy9oZWFsdGgnO1xuICAgICAgICBsZXQgcGF5bG9hZCA9IHt9O1xuXG4gICAgICAgIHJldHVybiBhd2FpdCB0aGlzLmNsaWVudC5jYWxsKCdnZXQnLCBhcGlQYXRoLCB7XG4gICAgICAgICAgICAnY29udGVudC10eXBlJzogJ2FwcGxpY2F0aW9uL2pzb24nLFxuICAgICAgICB9LCBwYXlsb2FkKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZXQgYW50aXZpcnVzXG4gICAgICpcbiAgICAgKiBDaGVjayB0aGUgQXBwd3JpdGUgQW50aXZpcnVzIHNlcnZlciBpcyB1cCBhbmQgY29ubmVjdGlvbiBpcyBzdWNjZXNzZnVsLlxuICAgICAqXG4gICAgICogQHRocm93cyB7QXBwd3JpdGVFeGNlcHRpb259XG4gICAgICogQHJldHVybnMge1Byb21pc2V9XG4gICAgICovXG4gICAgYXN5bmMgZ2V0QW50aXZpcnVzKCkge1xuICAgICAgICBjb25zdCBhcGlQYXRoID0gJy9oZWFsdGgvYW50aS12aXJ1cyc7XG4gICAgICAgIGxldCBwYXlsb2FkID0ge307XG5cbiAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMuY2xpZW50LmNhbGwoJ2dldCcsIGFwaVBhdGgsIHtcbiAgICAgICAgICAgICdjb250ZW50LXR5cGUnOiAnYXBwbGljYXRpb24vanNvbicsXG4gICAgICAgIH0sIHBheWxvYWQpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdldCBjYWNoZVxuICAgICAqXG4gICAgICogQ2hlY2sgdGhlIEFwcHdyaXRlIGluLW1lbW9yeSBjYWNoZSBzZXJ2ZXJzIGFyZSB1cCBhbmQgY29ubmVjdGlvbiBpc1xuICAgICAqIHN1Y2Nlc3NmdWwuXG4gICAgICpcbiAgICAgKiBAdGhyb3dzIHtBcHB3cml0ZUV4Y2VwdGlvbn1cbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZX1cbiAgICAgKi9cbiAgICBhc3luYyBnZXRDYWNoZSgpIHtcbiAgICAgICAgY29uc3QgYXBpUGF0aCA9ICcvaGVhbHRoL2NhY2hlJztcbiAgICAgICAgbGV0IHBheWxvYWQgPSB7fTtcblxuICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy5jbGllbnQuY2FsbCgnZ2V0JywgYXBpUGF0aCwge1xuICAgICAgICAgICAgJ2NvbnRlbnQtdHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJyxcbiAgICAgICAgfSwgcGF5bG9hZCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2V0IHRoZSBTU0wgY2VydGlmaWNhdGUgZm9yIGEgZG9tYWluXG4gICAgICpcbiAgICAgKiBHZXQgdGhlIFNTTCBjZXJ0aWZpY2F0ZSBmb3IgYSBkb21haW5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBkb21haW5cbiAgICAgKiBAdGhyb3dzIHtBcHB3cml0ZUV4Y2VwdGlvbn1cbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZX1cbiAgICAgKi9cbiAgICBhc3luYyBnZXRDZXJ0aWZpY2F0ZShkb21haW4pIHtcbiAgICAgICAgY29uc3QgYXBpUGF0aCA9ICcvaGVhbHRoL2NlcnRpZmljYXRlJztcbiAgICAgICAgbGV0IHBheWxvYWQgPSB7fTtcblxuICAgICAgICBpZiAodHlwZW9mIGRvbWFpbiAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHBheWxvYWRbJ2RvbWFpbiddID0gZG9tYWluO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMuY2xpZW50LmNhbGwoJ2dldCcsIGFwaVBhdGgsIHtcbiAgICAgICAgICAgICdjb250ZW50LXR5cGUnOiAnYXBwbGljYXRpb24vanNvbicsXG4gICAgICAgIH0sIHBheWxvYWQpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdldCBEQlxuICAgICAqXG4gICAgICogQ2hlY2sgdGhlIEFwcHdyaXRlIGRhdGFiYXNlIHNlcnZlcnMgYXJlIHVwIGFuZCBjb25uZWN0aW9uIGlzIHN1Y2Nlc3NmdWwuXG4gICAgICpcbiAgICAgKiBAdGhyb3dzIHtBcHB3cml0ZUV4Y2VwdGlvbn1cbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZX1cbiAgICAgKi9cbiAgICBhc3luYyBnZXREQigpIHtcbiAgICAgICAgY29uc3QgYXBpUGF0aCA9ICcvaGVhbHRoL2RiJztcbiAgICAgICAgbGV0IHBheWxvYWQgPSB7fTtcblxuICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy5jbGllbnQuY2FsbCgnZ2V0JywgYXBpUGF0aCwge1xuICAgICAgICAgICAgJ2NvbnRlbnQtdHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJyxcbiAgICAgICAgfSwgcGF5bG9hZCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2V0IHB1YnN1YlxuICAgICAqXG4gICAgICogQ2hlY2sgdGhlIEFwcHdyaXRlIHB1Yi1zdWIgc2VydmVycyBhcmUgdXAgYW5kIGNvbm5lY3Rpb24gaXMgc3VjY2Vzc2Z1bC5cbiAgICAgKlxuICAgICAqIEB0aHJvd3Mge0FwcHdyaXRlRXhjZXB0aW9ufVxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlfVxuICAgICAqL1xuICAgIGFzeW5jIGdldFB1YlN1YigpIHtcbiAgICAgICAgY29uc3QgYXBpUGF0aCA9ICcvaGVhbHRoL3B1YnN1Yic7XG4gICAgICAgIGxldCBwYXlsb2FkID0ge307XG5cbiAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMuY2xpZW50LmNhbGwoJ2dldCcsIGFwaVBhdGgsIHtcbiAgICAgICAgICAgICdjb250ZW50LXR5cGUnOiAnYXBwbGljYXRpb24vanNvbicsXG4gICAgICAgIH0sIHBheWxvYWQpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdldCBxdWV1ZVxuICAgICAqXG4gICAgICogQ2hlY2sgdGhlIEFwcHdyaXRlIHF1ZXVlIG1lc3NhZ2luZyBzZXJ2ZXJzIGFyZSB1cCBhbmQgY29ubmVjdGlvbiBpc1xuICAgICAqIHN1Y2Nlc3NmdWwuXG4gICAgICpcbiAgICAgKiBAdGhyb3dzIHtBcHB3cml0ZUV4Y2VwdGlvbn1cbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZX1cbiAgICAgKi9cbiAgICBhc3luYyBnZXRRdWV1ZSgpIHtcbiAgICAgICAgY29uc3QgYXBpUGF0aCA9ICcvaGVhbHRoL3F1ZXVlJztcbiAgICAgICAgbGV0IHBheWxvYWQgPSB7fTtcblxuICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy5jbGllbnQuY2FsbCgnZ2V0JywgYXBpUGF0aCwge1xuICAgICAgICAgICAgJ2NvbnRlbnQtdHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJyxcbiAgICAgICAgfSwgcGF5bG9hZCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2V0IGJ1aWxkcyBxdWV1ZVxuICAgICAqXG4gICAgICogR2V0IHRoZSBudW1iZXIgb2YgYnVpbGRzIHRoYXQgYXJlIHdhaXRpbmcgdG8gYmUgcHJvY2Vzc2VkIGluIHRoZSBBcHB3cml0ZVxuICAgICAqIGludGVybmFsIHF1ZXVlIHNlcnZlci5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB0aHJlc2hvbGRcbiAgICAgKiBAdGhyb3dzIHtBcHB3cml0ZUV4Y2VwdGlvbn1cbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZX1cbiAgICAgKi9cbiAgICBhc3luYyBnZXRRdWV1ZUJ1aWxkcyh0aHJlc2hvbGQpIHtcbiAgICAgICAgY29uc3QgYXBpUGF0aCA9ICcvaGVhbHRoL3F1ZXVlL2J1aWxkcyc7XG4gICAgICAgIGxldCBwYXlsb2FkID0ge307XG5cbiAgICAgICAgaWYgKHR5cGVvZiB0aHJlc2hvbGQgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICBwYXlsb2FkWyd0aHJlc2hvbGQnXSA9IHRocmVzaG9sZDtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBhd2FpdCB0aGlzLmNsaWVudC5jYWxsKCdnZXQnLCBhcGlQYXRoLCB7XG4gICAgICAgICAgICAnY29udGVudC10eXBlJzogJ2FwcGxpY2F0aW9uL2pzb24nLFxuICAgICAgICB9LCBwYXlsb2FkKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZXQgY2VydGlmaWNhdGVzIHF1ZXVlXG4gICAgICpcbiAgICAgKiBHZXQgdGhlIG51bWJlciBvZiBjZXJ0aWZpY2F0ZXMgdGhhdCBhcmUgd2FpdGluZyB0byBiZSBpc3N1ZWQgYWdhaW5zdFxuICAgICAqIFtMZXRzZW5jcnlwdF0oaHR0cHM6Ly9sZXRzZW5jcnlwdC5vcmcvKSBpbiB0aGUgQXBwd3JpdGUgaW50ZXJuYWwgcXVldWVcbiAgICAgKiBzZXJ2ZXIuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gdGhyZXNob2xkXG4gICAgICogQHRocm93cyB7QXBwd3JpdGVFeGNlcHRpb259XG4gICAgICogQHJldHVybnMge1Byb21pc2V9XG4gICAgICovXG4gICAgYXN5bmMgZ2V0UXVldWVDZXJ0aWZpY2F0ZXModGhyZXNob2xkKSB7XG4gICAgICAgIGNvbnN0IGFwaVBhdGggPSAnL2hlYWx0aC9xdWV1ZS9jZXJ0aWZpY2F0ZXMnO1xuICAgICAgICBsZXQgcGF5bG9hZCA9IHt9O1xuXG4gICAgICAgIGlmICh0eXBlb2YgdGhyZXNob2xkICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgcGF5bG9hZFsndGhyZXNob2xkJ10gPSB0aHJlc2hvbGQ7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy5jbGllbnQuY2FsbCgnZ2V0JywgYXBpUGF0aCwge1xuICAgICAgICAgICAgJ2NvbnRlbnQtdHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJyxcbiAgICAgICAgfSwgcGF5bG9hZCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2V0IGRhdGFiYXNlcyBxdWV1ZVxuICAgICAqXG4gICAgICogR2V0IHRoZSBudW1iZXIgb2YgZGF0YWJhc2UgY2hhbmdlcyB0aGF0IGFyZSB3YWl0aW5nIHRvIGJlIHByb2Nlc3NlZCBpbiB0aGVcbiAgICAgKiBBcHB3cml0ZSBpbnRlcm5hbCBxdWV1ZSBzZXJ2ZXIuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gbmFtZVxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB0aHJlc2hvbGRcbiAgICAgKiBAdGhyb3dzIHtBcHB3cml0ZUV4Y2VwdGlvbn1cbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZX1cbiAgICAgKi9cbiAgICBhc3luYyBnZXRRdWV1ZURhdGFiYXNlcyhuYW1lLCB0aHJlc2hvbGQpIHtcbiAgICAgICAgY29uc3QgYXBpUGF0aCA9ICcvaGVhbHRoL3F1ZXVlL2RhdGFiYXNlcyc7XG4gICAgICAgIGxldCBwYXlsb2FkID0ge307XG5cbiAgICAgICAgaWYgKHR5cGVvZiBuYW1lICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgcGF5bG9hZFsnbmFtZSddID0gbmFtZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0eXBlb2YgdGhyZXNob2xkICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgcGF5bG9hZFsndGhyZXNob2xkJ10gPSB0aHJlc2hvbGQ7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy5jbGllbnQuY2FsbCgnZ2V0JywgYXBpUGF0aCwge1xuICAgICAgICAgICAgJ2NvbnRlbnQtdHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJyxcbiAgICAgICAgfSwgcGF5bG9hZCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2V0IGRlbGV0ZXMgcXVldWVcbiAgICAgKlxuICAgICAqIEdldCB0aGUgbnVtYmVyIG9mIGJhY2tncm91bmQgZGVzdHJ1Y3RpdmUgY2hhbmdlcyB0aGF0IGFyZSB3YWl0aW5nIHRvIGJlXG4gICAgICogcHJvY2Vzc2VkIGluIHRoZSBBcHB3cml0ZSBpbnRlcm5hbCBxdWV1ZSBzZXJ2ZXIuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gdGhyZXNob2xkXG4gICAgICogQHRocm93cyB7QXBwd3JpdGVFeGNlcHRpb259XG4gICAgICogQHJldHVybnMge1Byb21pc2V9XG4gICAgICovXG4gICAgYXN5bmMgZ2V0UXVldWVEZWxldGVzKHRocmVzaG9sZCkge1xuICAgICAgICBjb25zdCBhcGlQYXRoID0gJy9oZWFsdGgvcXVldWUvZGVsZXRlcyc7XG4gICAgICAgIGxldCBwYXlsb2FkID0ge307XG5cbiAgICAgICAgaWYgKHR5cGVvZiB0aHJlc2hvbGQgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICBwYXlsb2FkWyd0aHJlc2hvbGQnXSA9IHRocmVzaG9sZDtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBhd2FpdCB0aGlzLmNsaWVudC5jYWxsKCdnZXQnLCBhcGlQYXRoLCB7XG4gICAgICAgICAgICAnY29udGVudC10eXBlJzogJ2FwcGxpY2F0aW9uL2pzb24nLFxuICAgICAgICB9LCBwYXlsb2FkKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZXQgbnVtYmVyIG9mIGZhaWxlZCBxdWV1ZSBqb2JzXG4gICAgICpcbiAgICAgKiBSZXR1cm5zIHRoZSBhbW91bnQgb2YgZmFpbGVkIGpvYnMgaW4gYSBnaXZlbiBxdWV1ZS5cbiAgICAgKiBcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7TmFtZX0gbmFtZVxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB0aHJlc2hvbGRcbiAgICAgKiBAdGhyb3dzIHtBcHB3cml0ZUV4Y2VwdGlvbn1cbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZX1cbiAgICAgKi9cbiAgICBhc3luYyBnZXRGYWlsZWRKb2JzKG5hbWUsIHRocmVzaG9sZCkge1xuICAgICAgICBjb25zdCBhcGlQYXRoID0gJy9oZWFsdGgvcXVldWUvZmFpbGVkL3tuYW1lfScucmVwbGFjZSgne25hbWV9JywgbmFtZSk7XG4gICAgICAgIGxldCBwYXlsb2FkID0ge307XG4gICAgICAgIGlmICh0eXBlb2YgbmFtZSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBBcHB3cml0ZUV4Y2VwdGlvbignTWlzc2luZyByZXF1aXJlZCBwYXJhbWV0ZXI6IFwibmFtZVwiJyk7XG4gICAgICAgIH1cblxuXG4gICAgICAgIGlmICh0eXBlb2YgdGhyZXNob2xkICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgcGF5bG9hZFsndGhyZXNob2xkJ10gPSB0aHJlc2hvbGQ7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy5jbGllbnQuY2FsbCgnZ2V0JywgYXBpUGF0aCwge1xuICAgICAgICAgICAgJ2NvbnRlbnQtdHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJyxcbiAgICAgICAgfSwgcGF5bG9hZCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2V0IGZ1bmN0aW9ucyBxdWV1ZVxuICAgICAqXG4gICAgICogR2V0IHRoZSBudW1iZXIgb2YgZnVuY3Rpb24gZXhlY3V0aW9ucyB0aGF0IGFyZSB3YWl0aW5nIHRvIGJlIHByb2Nlc3NlZCBpblxuICAgICAqIHRoZSBBcHB3cml0ZSBpbnRlcm5hbCBxdWV1ZSBzZXJ2ZXIuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gdGhyZXNob2xkXG4gICAgICogQHRocm93cyB7QXBwd3JpdGVFeGNlcHRpb259XG4gICAgICogQHJldHVybnMge1Byb21pc2V9XG4gICAgICovXG4gICAgYXN5bmMgZ2V0UXVldWVGdW5jdGlvbnModGhyZXNob2xkKSB7XG4gICAgICAgIGNvbnN0IGFwaVBhdGggPSAnL2hlYWx0aC9xdWV1ZS9mdW5jdGlvbnMnO1xuICAgICAgICBsZXQgcGF5bG9hZCA9IHt9O1xuXG4gICAgICAgIGlmICh0eXBlb2YgdGhyZXNob2xkICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgcGF5bG9hZFsndGhyZXNob2xkJ10gPSB0aHJlc2hvbGQ7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy5jbGllbnQuY2FsbCgnZ2V0JywgYXBpUGF0aCwge1xuICAgICAgICAgICAgJ2NvbnRlbnQtdHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJyxcbiAgICAgICAgfSwgcGF5bG9hZCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2V0IGxvZ3MgcXVldWVcbiAgICAgKlxuICAgICAqIEdldCB0aGUgbnVtYmVyIG9mIGxvZ3MgdGhhdCBhcmUgd2FpdGluZyB0byBiZSBwcm9jZXNzZWQgaW4gdGhlIEFwcHdyaXRlXG4gICAgICogaW50ZXJuYWwgcXVldWUgc2VydmVyLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHRocmVzaG9sZFxuICAgICAqIEB0aHJvd3Mge0FwcHdyaXRlRXhjZXB0aW9ufVxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlfVxuICAgICAqL1xuICAgIGFzeW5jIGdldFF1ZXVlTG9ncyh0aHJlc2hvbGQpIHtcbiAgICAgICAgY29uc3QgYXBpUGF0aCA9ICcvaGVhbHRoL3F1ZXVlL2xvZ3MnO1xuICAgICAgICBsZXQgcGF5bG9hZCA9IHt9O1xuXG4gICAgICAgIGlmICh0eXBlb2YgdGhyZXNob2xkICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgcGF5bG9hZFsndGhyZXNob2xkJ10gPSB0aHJlc2hvbGQ7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy5jbGllbnQuY2FsbCgnZ2V0JywgYXBpUGF0aCwge1xuICAgICAgICAgICAgJ2NvbnRlbnQtdHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJyxcbiAgICAgICAgfSwgcGF5bG9hZCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2V0IG1haWxzIHF1ZXVlXG4gICAgICpcbiAgICAgKiBHZXQgdGhlIG51bWJlciBvZiBtYWlscyB0aGF0IGFyZSB3YWl0aW5nIHRvIGJlIHByb2Nlc3NlZCBpbiB0aGUgQXBwd3JpdGVcbiAgICAgKiBpbnRlcm5hbCBxdWV1ZSBzZXJ2ZXIuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gdGhyZXNob2xkXG4gICAgICogQHRocm93cyB7QXBwd3JpdGVFeGNlcHRpb259XG4gICAgICogQHJldHVybnMge1Byb21pc2V9XG4gICAgICovXG4gICAgYXN5bmMgZ2V0UXVldWVNYWlscyh0aHJlc2hvbGQpIHtcbiAgICAgICAgY29uc3QgYXBpUGF0aCA9ICcvaGVhbHRoL3F1ZXVlL21haWxzJztcbiAgICAgICAgbGV0IHBheWxvYWQgPSB7fTtcblxuICAgICAgICBpZiAodHlwZW9mIHRocmVzaG9sZCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHBheWxvYWRbJ3RocmVzaG9sZCddID0gdGhyZXNob2xkO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMuY2xpZW50LmNhbGwoJ2dldCcsIGFwaVBhdGgsIHtcbiAgICAgICAgICAgICdjb250ZW50LXR5cGUnOiAnYXBwbGljYXRpb24vanNvbicsXG4gICAgICAgIH0sIHBheWxvYWQpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdldCBtZXNzYWdpbmcgcXVldWVcbiAgICAgKlxuICAgICAqIEdldCB0aGUgbnVtYmVyIG9mIG1lc3NhZ2VzIHRoYXQgYXJlIHdhaXRpbmcgdG8gYmUgcHJvY2Vzc2VkIGluIHRoZSBBcHB3cml0ZVxuICAgICAqIGludGVybmFsIHF1ZXVlIHNlcnZlci5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB0aHJlc2hvbGRcbiAgICAgKiBAdGhyb3dzIHtBcHB3cml0ZUV4Y2VwdGlvbn1cbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZX1cbiAgICAgKi9cbiAgICBhc3luYyBnZXRRdWV1ZU1lc3NhZ2luZyh0aHJlc2hvbGQpIHtcbiAgICAgICAgY29uc3QgYXBpUGF0aCA9ICcvaGVhbHRoL3F1ZXVlL21lc3NhZ2luZyc7XG4gICAgICAgIGxldCBwYXlsb2FkID0ge307XG5cbiAgICAgICAgaWYgKHR5cGVvZiB0aHJlc2hvbGQgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICBwYXlsb2FkWyd0aHJlc2hvbGQnXSA9IHRocmVzaG9sZDtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBhd2FpdCB0aGlzLmNsaWVudC5jYWxsKCdnZXQnLCBhcGlQYXRoLCB7XG4gICAgICAgICAgICAnY29udGVudC10eXBlJzogJ2FwcGxpY2F0aW9uL2pzb24nLFxuICAgICAgICB9LCBwYXlsb2FkKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZXQgbWlncmF0aW9ucyBxdWV1ZVxuICAgICAqXG4gICAgICogR2V0IHRoZSBudW1iZXIgb2YgbWlncmF0aW9ucyB0aGF0IGFyZSB3YWl0aW5nIHRvIGJlIHByb2Nlc3NlZCBpbiB0aGVcbiAgICAgKiBBcHB3cml0ZSBpbnRlcm5hbCBxdWV1ZSBzZXJ2ZXIuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gdGhyZXNob2xkXG4gICAgICogQHRocm93cyB7QXBwd3JpdGVFeGNlcHRpb259XG4gICAgICogQHJldHVybnMge1Byb21pc2V9XG4gICAgICovXG4gICAgYXN5bmMgZ2V0UXVldWVNaWdyYXRpb25zKHRocmVzaG9sZCkge1xuICAgICAgICBjb25zdCBhcGlQYXRoID0gJy9oZWFsdGgvcXVldWUvbWlncmF0aW9ucyc7XG4gICAgICAgIGxldCBwYXlsb2FkID0ge307XG5cbiAgICAgICAgaWYgKHR5cGVvZiB0aHJlc2hvbGQgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICBwYXlsb2FkWyd0aHJlc2hvbGQnXSA9IHRocmVzaG9sZDtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBhd2FpdCB0aGlzLmNsaWVudC5jYWxsKCdnZXQnLCBhcGlQYXRoLCB7XG4gICAgICAgICAgICAnY29udGVudC10eXBlJzogJ2FwcGxpY2F0aW9uL2pzb24nLFxuICAgICAgICB9LCBwYXlsb2FkKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZXQgdXNhZ2UgcXVldWVcbiAgICAgKlxuICAgICAqIEdldCB0aGUgbnVtYmVyIG9mIG1ldHJpY3MgdGhhdCBhcmUgd2FpdGluZyB0byBiZSBwcm9jZXNzZWQgaW4gdGhlIEFwcHdyaXRlXG4gICAgICogaW50ZXJuYWwgcXVldWUgc2VydmVyLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHRocmVzaG9sZFxuICAgICAqIEB0aHJvd3Mge0FwcHdyaXRlRXhjZXB0aW9ufVxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlfVxuICAgICAqL1xuICAgIGFzeW5jIGdldFF1ZXVlVXNhZ2UodGhyZXNob2xkKSB7XG4gICAgICAgIGNvbnN0IGFwaVBhdGggPSAnL2hlYWx0aC9xdWV1ZS91c2FnZSc7XG4gICAgICAgIGxldCBwYXlsb2FkID0ge307XG5cbiAgICAgICAgaWYgKHR5cGVvZiB0aHJlc2hvbGQgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICBwYXlsb2FkWyd0aHJlc2hvbGQnXSA9IHRocmVzaG9sZDtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBhd2FpdCB0aGlzLmNsaWVudC5jYWxsKCdnZXQnLCBhcGlQYXRoLCB7XG4gICAgICAgICAgICAnY29udGVudC10eXBlJzogJ2FwcGxpY2F0aW9uL2pzb24nLFxuICAgICAgICB9LCBwYXlsb2FkKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZXQgdXNhZ2UgZHVtcCBxdWV1ZVxuICAgICAqXG4gICAgICogR2V0IHRoZSBudW1iZXIgb2YgcHJvamVjdHMgY29udGFpbmluZyBtZXRyaWNzIHRoYXQgYXJlIHdhaXRpbmcgdG8gYmVcbiAgICAgKiBwcm9jZXNzZWQgaW4gdGhlIEFwcHdyaXRlIGludGVybmFsIHF1ZXVlIHNlcnZlci5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB0aHJlc2hvbGRcbiAgICAgKiBAdGhyb3dzIHtBcHB3cml0ZUV4Y2VwdGlvbn1cbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZX1cbiAgICAgKi9cbiAgICBhc3luYyBnZXRRdWV1ZVVzYWdlRHVtcCh0aHJlc2hvbGQpIHtcbiAgICAgICAgY29uc3QgYXBpUGF0aCA9ICcvaGVhbHRoL3F1ZXVlL3VzYWdlLWR1bXAnO1xuICAgICAgICBsZXQgcGF5bG9hZCA9IHt9O1xuXG4gICAgICAgIGlmICh0eXBlb2YgdGhyZXNob2xkICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgcGF5bG9hZFsndGhyZXNob2xkJ10gPSB0aHJlc2hvbGQ7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy5jbGllbnQuY2FsbCgnZ2V0JywgYXBpUGF0aCwge1xuICAgICAgICAgICAgJ2NvbnRlbnQtdHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJyxcbiAgICAgICAgfSwgcGF5bG9hZCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2V0IHdlYmhvb2tzIHF1ZXVlXG4gICAgICpcbiAgICAgKiBHZXQgdGhlIG51bWJlciBvZiB3ZWJob29rcyB0aGF0IGFyZSB3YWl0aW5nIHRvIGJlIHByb2Nlc3NlZCBpbiB0aGUgQXBwd3JpdGVcbiAgICAgKiBpbnRlcm5hbCBxdWV1ZSBzZXJ2ZXIuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gdGhyZXNob2xkXG4gICAgICogQHRocm93cyB7QXBwd3JpdGVFeGNlcHRpb259XG4gICAgICogQHJldHVybnMge1Byb21pc2V9XG4gICAgICovXG4gICAgYXN5bmMgZ2V0UXVldWVXZWJob29rcyh0aHJlc2hvbGQpIHtcbiAgICAgICAgY29uc3QgYXBpUGF0aCA9ICcvaGVhbHRoL3F1ZXVlL3dlYmhvb2tzJztcbiAgICAgICAgbGV0IHBheWxvYWQgPSB7fTtcblxuICAgICAgICBpZiAodHlwZW9mIHRocmVzaG9sZCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHBheWxvYWRbJ3RocmVzaG9sZCddID0gdGhyZXNob2xkO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMuY2xpZW50LmNhbGwoJ2dldCcsIGFwaVBhdGgsIHtcbiAgICAgICAgICAgICdjb250ZW50LXR5cGUnOiAnYXBwbGljYXRpb24vanNvbicsXG4gICAgICAgIH0sIHBheWxvYWQpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdldCBzdG9yYWdlXG4gICAgICpcbiAgICAgKiBDaGVjayB0aGUgQXBwd3JpdGUgc3RvcmFnZSBkZXZpY2UgaXMgdXAgYW5kIGNvbm5lY3Rpb24gaXMgc3VjY2Vzc2Z1bC5cbiAgICAgKlxuICAgICAqIEB0aHJvd3Mge0FwcHdyaXRlRXhjZXB0aW9ufVxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlfVxuICAgICAqL1xuICAgIGFzeW5jIGdldFN0b3JhZ2UoKSB7XG4gICAgICAgIGNvbnN0IGFwaVBhdGggPSAnL2hlYWx0aC9zdG9yYWdlJztcbiAgICAgICAgbGV0IHBheWxvYWQgPSB7fTtcblxuICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy5jbGllbnQuY2FsbCgnZ2V0JywgYXBpUGF0aCwge1xuICAgICAgICAgICAgJ2NvbnRlbnQtdHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJyxcbiAgICAgICAgfSwgcGF5bG9hZCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2V0IGxvY2FsIHN0b3JhZ2VcbiAgICAgKlxuICAgICAqIENoZWNrIHRoZSBBcHB3cml0ZSBsb2NhbCBzdG9yYWdlIGRldmljZSBpcyB1cCBhbmQgY29ubmVjdGlvbiBpcyBzdWNjZXNzZnVsLlxuICAgICAqXG4gICAgICogQHRocm93cyB7QXBwd3JpdGVFeGNlcHRpb259XG4gICAgICogQHJldHVybnMge1Byb21pc2V9XG4gICAgICovXG4gICAgYXN5bmMgZ2V0U3RvcmFnZUxvY2FsKCkge1xuICAgICAgICBjb25zdCBhcGlQYXRoID0gJy9oZWFsdGgvc3RvcmFnZS9sb2NhbCc7XG4gICAgICAgIGxldCBwYXlsb2FkID0ge307XG5cbiAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMuY2xpZW50LmNhbGwoJ2dldCcsIGFwaVBhdGgsIHtcbiAgICAgICAgICAgICdjb250ZW50LXR5cGUnOiAnYXBwbGljYXRpb24vanNvbicsXG4gICAgICAgIH0sIHBheWxvYWQpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdldCB0aW1lXG4gICAgICpcbiAgICAgKiBDaGVjayB0aGUgQXBwd3JpdGUgc2VydmVyIHRpbWUgaXMgc3luY2VkIHdpdGggR29vZ2xlIHJlbW90ZSBOVFAgc2VydmVyLiBXZVxuICAgICAqIHVzZSB0aGlzIHRlY2hub2xvZ3kgdG8gc21vb3RobHkgaGFuZGxlIGxlYXAgc2Vjb25kcyB3aXRoIG5vIGRpc3J1cHRpdmVcbiAgICAgKiBldmVudHMuIFRoZSBbTmV0d29yayBUaW1lXG4gICAgICogUHJvdG9jb2xdKGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL05ldHdvcmtfVGltZV9Qcm90b2NvbCkgKE5UUCkgaXNcbiAgICAgKiB1c2VkIGJ5IGh1bmRyZWRzIG9mIG1pbGxpb25zIG9mIGNvbXB1dGVycyBhbmQgZGV2aWNlcyB0byBzeW5jaHJvbml6ZSB0aGVpclxuICAgICAqIGNsb2NrcyBvdmVyIHRoZSBJbnRlcm5ldC4gSWYgeW91ciBjb21wdXRlciBzZXRzIGl0cyBvd24gY2xvY2ssIGl0IGxpa2VseVxuICAgICAqIHVzZXMgTlRQLlxuICAgICAqXG4gICAgICogQHRocm93cyB7QXBwd3JpdGVFeGNlcHRpb259XG4gICAgICogQHJldHVybnMge1Byb21pc2V9XG4gICAgICovXG4gICAgYXN5bmMgZ2V0VGltZSgpIHtcbiAgICAgICAgY29uc3QgYXBpUGF0aCA9ICcvaGVhbHRoL3RpbWUnO1xuICAgICAgICBsZXQgcGF5bG9hZCA9IHt9O1xuXG4gICAgICAgIHJldHVybiBhd2FpdCB0aGlzLmNsaWVudC5jYWxsKCdnZXQnLCBhcGlQYXRoLCB7XG4gICAgICAgICAgICAnY29udGVudC10eXBlJzogJ2FwcGxpY2F0aW9uL2pzb24nLFxuICAgICAgICB9LCBwYXlsb2FkKTtcbiAgICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gSGVhbHRoO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/node-appwrite/lib/services/health.js\n");

/***/ }),

/***/ "(action-browser)/./node_modules/node-appwrite/lib/services/locale.js":
/*!***********************************************************!*\
  !*** ./node_modules/node-appwrite/lib/services/locale.js ***!
  \***********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("const Service = __webpack_require__(/*! ../service.js */ \"(action-browser)/./node_modules/node-appwrite/lib/service.js\");\nconst AppwriteException = __webpack_require__(/*! ../exception.js */ \"(action-browser)/./node_modules/node-appwrite/lib/exception.js\");\nconst InputFile = __webpack_require__(/*! ../inputFile.js */ \"(action-browser)/./node_modules/node-appwrite/lib/inputFile.js\");\nconst client = __webpack_require__(/*! ../client.js */ \"(action-browser)/./node_modules/node-appwrite/lib/client.js\");\nconst Stream = __webpack_require__(/*! stream */ \"stream\");\nconst { promisify } = __webpack_require__(/*! util */ \"util\");\nconst fs = __webpack_require__(/*! fs */ \"fs\");\nconst { File } = __webpack_require__(/*! undici */ \"undici\");\nconst Query = __webpack_require__(/*! ../query.js */ \"(action-browser)/./node_modules/node-appwrite/lib/query.js\");\n\nclass Locale extends Service {\n\n     constructor(client)\n     {\n        super(client);\n     }\n\n\n    /**\n     * Get user locale\n     *\n     * Get the current user location based on IP. Returns an object with user\n     * country code, country name, continent name, continent code, ip address and\n     * suggested currency. You can use the locale header to get the data in a\n     * supported language.\n     * \n     * ([IP Geolocation by DB-IP](https://db-ip.com))\n     *\n     * @throws {AppwriteException}\n     * @returns {Promise}\n     */\n    async get() {\n        const apiPath = '/locale';\n        let payload = {};\n\n        return await this.client.call('get', apiPath, {\n            'content-type': 'application/json',\n        }, payload);\n    }\n\n    /**\n     * List Locale Codes\n     *\n     * List of all locale codes in [ISO\n     * 639-1](https://en.wikipedia.org/wiki/List_of_ISO_639-1_codes).\n     *\n     * @throws {AppwriteException}\n     * @returns {Promise}\n     */\n    async listCodes() {\n        const apiPath = '/locale/codes';\n        let payload = {};\n\n        return await this.client.call('get', apiPath, {\n            'content-type': 'application/json',\n        }, payload);\n    }\n\n    /**\n     * List continents\n     *\n     * List of all continents. You can use the locale header to get the data in a\n     * supported language.\n     *\n     * @throws {AppwriteException}\n     * @returns {Promise}\n     */\n    async listContinents() {\n        const apiPath = '/locale/continents';\n        let payload = {};\n\n        return await this.client.call('get', apiPath, {\n            'content-type': 'application/json',\n        }, payload);\n    }\n\n    /**\n     * List countries\n     *\n     * List of all countries. You can use the locale header to get the data in a\n     * supported language.\n     *\n     * @throws {AppwriteException}\n     * @returns {Promise}\n     */\n    async listCountries() {\n        const apiPath = '/locale/countries';\n        let payload = {};\n\n        return await this.client.call('get', apiPath, {\n            'content-type': 'application/json',\n        }, payload);\n    }\n\n    /**\n     * List EU countries\n     *\n     * List of all countries that are currently members of the EU. You can use the\n     * locale header to get the data in a supported language.\n     *\n     * @throws {AppwriteException}\n     * @returns {Promise}\n     */\n    async listCountriesEU() {\n        const apiPath = '/locale/countries/eu';\n        let payload = {};\n\n        return await this.client.call('get', apiPath, {\n            'content-type': 'application/json',\n        }, payload);\n    }\n\n    /**\n     * List countries phone codes\n     *\n     * List of all countries phone codes. You can use the locale header to get the\n     * data in a supported language.\n     *\n     * @throws {AppwriteException}\n     * @returns {Promise}\n     */\n    async listCountriesPhones() {\n        const apiPath = '/locale/countries/phones';\n        let payload = {};\n\n        return await this.client.call('get', apiPath, {\n            'content-type': 'application/json',\n        }, payload);\n    }\n\n    /**\n     * List currencies\n     *\n     * List of all currencies, including currency symbol, name, plural, and\n     * decimal digits for all major and minor currencies. You can use the locale\n     * header to get the data in a supported language.\n     *\n     * @throws {AppwriteException}\n     * @returns {Promise}\n     */\n    async listCurrencies() {\n        const apiPath = '/locale/currencies';\n        let payload = {};\n\n        return await this.client.call('get', apiPath, {\n            'content-type': 'application/json',\n        }, payload);\n    }\n\n    /**\n     * List languages\n     *\n     * List of all languages classified by ISO 639-1 including 2-letter code, name\n     * in English, and name in the respective language.\n     *\n     * @throws {AppwriteException}\n     * @returns {Promise}\n     */\n    async listLanguages() {\n        const apiPath = '/locale/languages';\n        let payload = {};\n\n        return await this.client.call('get', apiPath, {\n            'content-type': 'application/json',\n        }, payload);\n    }\n}\n\nmodule.exports = Locale;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFjdGlvbi1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9ub2RlLWFwcHdyaXRlL2xpYi9zZXJ2aWNlcy9sb2NhbGUuanMiLCJtYXBwaW5ncyI6IkFBQUEsZ0JBQWdCLG1CQUFPLENBQUMsbUZBQWU7QUFDdkMsMEJBQTBCLG1CQUFPLENBQUMsdUZBQWlCO0FBQ25ELGtCQUFrQixtQkFBTyxDQUFDLHVGQUFpQjtBQUMzQyxlQUFlLG1CQUFPLENBQUMsaUZBQWM7QUFDckMsZUFBZSxtQkFBTyxDQUFDLHNCQUFRO0FBQy9CLFFBQVEsWUFBWSxFQUFFLG1CQUFPLENBQUMsa0JBQU07QUFDcEMsV0FBVyxtQkFBTyxDQUFDLGNBQUk7QUFDdkIsUUFBUSxPQUFPLEVBQUUsbUJBQU8sQ0FBQyxzQkFBUTtBQUNqQyxjQUFjLG1CQUFPLENBQUMsK0VBQWE7O0FBRW5DOztBQUVBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQixpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFNBQVM7QUFDVDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEIsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsU0FBUztBQUNUOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQixpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFNBQVM7QUFDVDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEIsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsU0FBUztBQUNUOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsU0FBUztBQUNUOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQixpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBOztBQUVBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vanNtX2JhbmtpbmcvLi9ub2RlX21vZHVsZXMvbm9kZS1hcHB3cml0ZS9saWIvc2VydmljZXMvbG9jYWxlLmpzP2EwNDUiXSwic291cmNlc0NvbnRlbnQiOlsiY29uc3QgU2VydmljZSA9IHJlcXVpcmUoJy4uL3NlcnZpY2UuanMnKTtcbmNvbnN0IEFwcHdyaXRlRXhjZXB0aW9uID0gcmVxdWlyZSgnLi4vZXhjZXB0aW9uLmpzJyk7XG5jb25zdCBJbnB1dEZpbGUgPSByZXF1aXJlKCcuLi9pbnB1dEZpbGUuanMnKTtcbmNvbnN0IGNsaWVudCA9IHJlcXVpcmUoJy4uL2NsaWVudC5qcycpO1xuY29uc3QgU3RyZWFtID0gcmVxdWlyZSgnc3RyZWFtJyk7XG5jb25zdCB7IHByb21pc2lmeSB9ID0gcmVxdWlyZSgndXRpbCcpO1xuY29uc3QgZnMgPSByZXF1aXJlKCdmcycpO1xuY29uc3QgeyBGaWxlIH0gPSByZXF1aXJlKCd1bmRpY2knKTtcbmNvbnN0IFF1ZXJ5ID0gcmVxdWlyZSgnLi4vcXVlcnkuanMnKTtcblxuY2xhc3MgTG9jYWxlIGV4dGVuZHMgU2VydmljZSB7XG5cbiAgICAgY29uc3RydWN0b3IoY2xpZW50KVxuICAgICB7XG4gICAgICAgIHN1cGVyKGNsaWVudCk7XG4gICAgIH1cblxuXG4gICAgLyoqXG4gICAgICogR2V0IHVzZXIgbG9jYWxlXG4gICAgICpcbiAgICAgKiBHZXQgdGhlIGN1cnJlbnQgdXNlciBsb2NhdGlvbiBiYXNlZCBvbiBJUC4gUmV0dXJucyBhbiBvYmplY3Qgd2l0aCB1c2VyXG4gICAgICogY291bnRyeSBjb2RlLCBjb3VudHJ5IG5hbWUsIGNvbnRpbmVudCBuYW1lLCBjb250aW5lbnQgY29kZSwgaXAgYWRkcmVzcyBhbmRcbiAgICAgKiBzdWdnZXN0ZWQgY3VycmVuY3kuIFlvdSBjYW4gdXNlIHRoZSBsb2NhbGUgaGVhZGVyIHRvIGdldCB0aGUgZGF0YSBpbiBhXG4gICAgICogc3VwcG9ydGVkIGxhbmd1YWdlLlxuICAgICAqIFxuICAgICAqIChbSVAgR2VvbG9jYXRpb24gYnkgREItSVBdKGh0dHBzOi8vZGItaXAuY29tKSlcbiAgICAgKlxuICAgICAqIEB0aHJvd3Mge0FwcHdyaXRlRXhjZXB0aW9ufVxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlfVxuICAgICAqL1xuICAgIGFzeW5jIGdldCgpIHtcbiAgICAgICAgY29uc3QgYXBpUGF0aCA9ICcvbG9jYWxlJztcbiAgICAgICAgbGV0IHBheWxvYWQgPSB7fTtcblxuICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy5jbGllbnQuY2FsbCgnZ2V0JywgYXBpUGF0aCwge1xuICAgICAgICAgICAgJ2NvbnRlbnQtdHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJyxcbiAgICAgICAgfSwgcGF5bG9hZCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogTGlzdCBMb2NhbGUgQ29kZXNcbiAgICAgKlxuICAgICAqIExpc3Qgb2YgYWxsIGxvY2FsZSBjb2RlcyBpbiBbSVNPXG4gICAgICogNjM5LTFdKGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0xpc3Rfb2ZfSVNPXzYzOS0xX2NvZGVzKS5cbiAgICAgKlxuICAgICAqIEB0aHJvd3Mge0FwcHdyaXRlRXhjZXB0aW9ufVxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlfVxuICAgICAqL1xuICAgIGFzeW5jIGxpc3RDb2RlcygpIHtcbiAgICAgICAgY29uc3QgYXBpUGF0aCA9ICcvbG9jYWxlL2NvZGVzJztcbiAgICAgICAgbGV0IHBheWxvYWQgPSB7fTtcblxuICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy5jbGllbnQuY2FsbCgnZ2V0JywgYXBpUGF0aCwge1xuICAgICAgICAgICAgJ2NvbnRlbnQtdHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJyxcbiAgICAgICAgfSwgcGF5bG9hZCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogTGlzdCBjb250aW5lbnRzXG4gICAgICpcbiAgICAgKiBMaXN0IG9mIGFsbCBjb250aW5lbnRzLiBZb3UgY2FuIHVzZSB0aGUgbG9jYWxlIGhlYWRlciB0byBnZXQgdGhlIGRhdGEgaW4gYVxuICAgICAqIHN1cHBvcnRlZCBsYW5ndWFnZS5cbiAgICAgKlxuICAgICAqIEB0aHJvd3Mge0FwcHdyaXRlRXhjZXB0aW9ufVxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlfVxuICAgICAqL1xuICAgIGFzeW5jIGxpc3RDb250aW5lbnRzKCkge1xuICAgICAgICBjb25zdCBhcGlQYXRoID0gJy9sb2NhbGUvY29udGluZW50cyc7XG4gICAgICAgIGxldCBwYXlsb2FkID0ge307XG5cbiAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMuY2xpZW50LmNhbGwoJ2dldCcsIGFwaVBhdGgsIHtcbiAgICAgICAgICAgICdjb250ZW50LXR5cGUnOiAnYXBwbGljYXRpb24vanNvbicsXG4gICAgICAgIH0sIHBheWxvYWQpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIExpc3QgY291bnRyaWVzXG4gICAgICpcbiAgICAgKiBMaXN0IG9mIGFsbCBjb3VudHJpZXMuIFlvdSBjYW4gdXNlIHRoZSBsb2NhbGUgaGVhZGVyIHRvIGdldCB0aGUgZGF0YSBpbiBhXG4gICAgICogc3VwcG9ydGVkIGxhbmd1YWdlLlxuICAgICAqXG4gICAgICogQHRocm93cyB7QXBwd3JpdGVFeGNlcHRpb259XG4gICAgICogQHJldHVybnMge1Byb21pc2V9XG4gICAgICovXG4gICAgYXN5bmMgbGlzdENvdW50cmllcygpIHtcbiAgICAgICAgY29uc3QgYXBpUGF0aCA9ICcvbG9jYWxlL2NvdW50cmllcyc7XG4gICAgICAgIGxldCBwYXlsb2FkID0ge307XG5cbiAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMuY2xpZW50LmNhbGwoJ2dldCcsIGFwaVBhdGgsIHtcbiAgICAgICAgICAgICdjb250ZW50LXR5cGUnOiAnYXBwbGljYXRpb24vanNvbicsXG4gICAgICAgIH0sIHBheWxvYWQpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIExpc3QgRVUgY291bnRyaWVzXG4gICAgICpcbiAgICAgKiBMaXN0IG9mIGFsbCBjb3VudHJpZXMgdGhhdCBhcmUgY3VycmVudGx5IG1lbWJlcnMgb2YgdGhlIEVVLiBZb3UgY2FuIHVzZSB0aGVcbiAgICAgKiBsb2NhbGUgaGVhZGVyIHRvIGdldCB0aGUgZGF0YSBpbiBhIHN1cHBvcnRlZCBsYW5ndWFnZS5cbiAgICAgKlxuICAgICAqIEB0aHJvd3Mge0FwcHdyaXRlRXhjZXB0aW9ufVxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlfVxuICAgICAqL1xuICAgIGFzeW5jIGxpc3RDb3VudHJpZXNFVSgpIHtcbiAgICAgICAgY29uc3QgYXBpUGF0aCA9ICcvbG9jYWxlL2NvdW50cmllcy9ldSc7XG4gICAgICAgIGxldCBwYXlsb2FkID0ge307XG5cbiAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMuY2xpZW50LmNhbGwoJ2dldCcsIGFwaVBhdGgsIHtcbiAgICAgICAgICAgICdjb250ZW50LXR5cGUnOiAnYXBwbGljYXRpb24vanNvbicsXG4gICAgICAgIH0sIHBheWxvYWQpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIExpc3QgY291bnRyaWVzIHBob25lIGNvZGVzXG4gICAgICpcbiAgICAgKiBMaXN0IG9mIGFsbCBjb3VudHJpZXMgcGhvbmUgY29kZXMuIFlvdSBjYW4gdXNlIHRoZSBsb2NhbGUgaGVhZGVyIHRvIGdldCB0aGVcbiAgICAgKiBkYXRhIGluIGEgc3VwcG9ydGVkIGxhbmd1YWdlLlxuICAgICAqXG4gICAgICogQHRocm93cyB7QXBwd3JpdGVFeGNlcHRpb259XG4gICAgICogQHJldHVybnMge1Byb21pc2V9XG4gICAgICovXG4gICAgYXN5bmMgbGlzdENvdW50cmllc1Bob25lcygpIHtcbiAgICAgICAgY29uc3QgYXBpUGF0aCA9ICcvbG9jYWxlL2NvdW50cmllcy9waG9uZXMnO1xuICAgICAgICBsZXQgcGF5bG9hZCA9IHt9O1xuXG4gICAgICAgIHJldHVybiBhd2FpdCB0aGlzLmNsaWVudC5jYWxsKCdnZXQnLCBhcGlQYXRoLCB7XG4gICAgICAgICAgICAnY29udGVudC10eXBlJzogJ2FwcGxpY2F0aW9uL2pzb24nLFxuICAgICAgICB9LCBwYXlsb2FkKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBMaXN0IGN1cnJlbmNpZXNcbiAgICAgKlxuICAgICAqIExpc3Qgb2YgYWxsIGN1cnJlbmNpZXMsIGluY2x1ZGluZyBjdXJyZW5jeSBzeW1ib2wsIG5hbWUsIHBsdXJhbCwgYW5kXG4gICAgICogZGVjaW1hbCBkaWdpdHMgZm9yIGFsbCBtYWpvciBhbmQgbWlub3IgY3VycmVuY2llcy4gWW91IGNhbiB1c2UgdGhlIGxvY2FsZVxuICAgICAqIGhlYWRlciB0byBnZXQgdGhlIGRhdGEgaW4gYSBzdXBwb3J0ZWQgbGFuZ3VhZ2UuXG4gICAgICpcbiAgICAgKiBAdGhyb3dzIHtBcHB3cml0ZUV4Y2VwdGlvbn1cbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZX1cbiAgICAgKi9cbiAgICBhc3luYyBsaXN0Q3VycmVuY2llcygpIHtcbiAgICAgICAgY29uc3QgYXBpUGF0aCA9ICcvbG9jYWxlL2N1cnJlbmNpZXMnO1xuICAgICAgICBsZXQgcGF5bG9hZCA9IHt9O1xuXG4gICAgICAgIHJldHVybiBhd2FpdCB0aGlzLmNsaWVudC5jYWxsKCdnZXQnLCBhcGlQYXRoLCB7XG4gICAgICAgICAgICAnY29udGVudC10eXBlJzogJ2FwcGxpY2F0aW9uL2pzb24nLFxuICAgICAgICB9LCBwYXlsb2FkKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBMaXN0IGxhbmd1YWdlc1xuICAgICAqXG4gICAgICogTGlzdCBvZiBhbGwgbGFuZ3VhZ2VzIGNsYXNzaWZpZWQgYnkgSVNPIDYzOS0xIGluY2x1ZGluZyAyLWxldHRlciBjb2RlLCBuYW1lXG4gICAgICogaW4gRW5nbGlzaCwgYW5kIG5hbWUgaW4gdGhlIHJlc3BlY3RpdmUgbGFuZ3VhZ2UuXG4gICAgICpcbiAgICAgKiBAdGhyb3dzIHtBcHB3cml0ZUV4Y2VwdGlvbn1cbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZX1cbiAgICAgKi9cbiAgICBhc3luYyBsaXN0TGFuZ3VhZ2VzKCkge1xuICAgICAgICBjb25zdCBhcGlQYXRoID0gJy9sb2NhbGUvbGFuZ3VhZ2VzJztcbiAgICAgICAgbGV0IHBheWxvYWQgPSB7fTtcblxuICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy5jbGllbnQuY2FsbCgnZ2V0JywgYXBpUGF0aCwge1xuICAgICAgICAgICAgJ2NvbnRlbnQtdHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJyxcbiAgICAgICAgfSwgcGF5bG9hZCk7XG4gICAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IExvY2FsZTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(action-browser)/./node_modules/node-appwrite/lib/services/locale.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/node-appwrite/lib/services/locale.js":
/*!***********************************************************!*\
  !*** ./node_modules/node-appwrite/lib/services/locale.js ***!
  \***********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("const Service = __webpack_require__(/*! ../service.js */ \"(rsc)/./node_modules/node-appwrite/lib/service.js\");\nconst AppwriteException = __webpack_require__(/*! ../exception.js */ \"(rsc)/./node_modules/node-appwrite/lib/exception.js\");\nconst InputFile = __webpack_require__(/*! ../inputFile.js */ \"(rsc)/./node_modules/node-appwrite/lib/inputFile.js\");\nconst client = __webpack_require__(/*! ../client.js */ \"(rsc)/./node_modules/node-appwrite/lib/client.js\");\nconst Stream = __webpack_require__(/*! stream */ \"stream\");\nconst { promisify } = __webpack_require__(/*! util */ \"util\");\nconst fs = __webpack_require__(/*! fs */ \"fs\");\nconst { File } = __webpack_require__(/*! undici */ \"undici\");\nconst Query = __webpack_require__(/*! ../query.js */ \"(rsc)/./node_modules/node-appwrite/lib/query.js\");\n\nclass Locale extends Service {\n\n     constructor(client)\n     {\n        super(client);\n     }\n\n\n    /**\n     * Get user locale\n     *\n     * Get the current user location based on IP. Returns an object with user\n     * country code, country name, continent name, continent code, ip address and\n     * suggested currency. You can use the locale header to get the data in a\n     * supported language.\n     * \n     * ([IP Geolocation by DB-IP](https://db-ip.com))\n     *\n     * @throws {AppwriteException}\n     * @returns {Promise}\n     */\n    async get() {\n        const apiPath = '/locale';\n        let payload = {};\n\n        return await this.client.call('get', apiPath, {\n            'content-type': 'application/json',\n        }, payload);\n    }\n\n    /**\n     * List Locale Codes\n     *\n     * List of all locale codes in [ISO\n     * 639-1](https://en.wikipedia.org/wiki/List_of_ISO_639-1_codes).\n     *\n     * @throws {AppwriteException}\n     * @returns {Promise}\n     */\n    async listCodes() {\n        const apiPath = '/locale/codes';\n        let payload = {};\n\n        return await this.client.call('get', apiPath, {\n            'content-type': 'application/json',\n        }, payload);\n    }\n\n    /**\n     * List continents\n     *\n     * List of all continents. You can use the locale header to get the data in a\n     * supported language.\n     *\n     * @throws {AppwriteException}\n     * @returns {Promise}\n     */\n    async listContinents() {\n        const apiPath = '/locale/continents';\n        let payload = {};\n\n        return await this.client.call('get', apiPath, {\n            'content-type': 'application/json',\n        }, payload);\n    }\n\n    /**\n     * List countries\n     *\n     * List of all countries. You can use the locale header to get the data in a\n     * supported language.\n     *\n     * @throws {AppwriteException}\n     * @returns {Promise}\n     */\n    async listCountries() {\n        const apiPath = '/locale/countries';\n        let payload = {};\n\n        return await this.client.call('get', apiPath, {\n            'content-type': 'application/json',\n        }, payload);\n    }\n\n    /**\n     * List EU countries\n     *\n     * List of all countries that are currently members of the EU. You can use the\n     * locale header to get the data in a supported language.\n     *\n     * @throws {AppwriteException}\n     * @returns {Promise}\n     */\n    async listCountriesEU() {\n        const apiPath = '/locale/countries/eu';\n        let payload = {};\n\n        return await this.client.call('get', apiPath, {\n            'content-type': 'application/json',\n        }, payload);\n    }\n\n    /**\n     * List countries phone codes\n     *\n     * List of all countries phone codes. You can use the locale header to get the\n     * data in a supported language.\n     *\n     * @throws {AppwriteException}\n     * @returns {Promise}\n     */\n    async listCountriesPhones() {\n        const apiPath = '/locale/countries/phones';\n        let payload = {};\n\n        return await this.client.call('get', apiPath, {\n            'content-type': 'application/json',\n        }, payload);\n    }\n\n    /**\n     * List currencies\n     *\n     * List of all currencies, including currency symbol, name, plural, and\n     * decimal digits for all major and minor currencies. You can use the locale\n     * header to get the data in a supported language.\n     *\n     * @throws {AppwriteException}\n     * @returns {Promise}\n     */\n    async listCurrencies() {\n        const apiPath = '/locale/currencies';\n        let payload = {};\n\n        return await this.client.call('get', apiPath, {\n            'content-type': 'application/json',\n        }, payload);\n    }\n\n    /**\n     * List languages\n     *\n     * List of all languages classified by ISO 639-1 including 2-letter code, name\n     * in English, and name in the respective language.\n     *\n     * @throws {AppwriteException}\n     * @returns {Promise}\n     */\n    async listLanguages() {\n        const apiPath = '/locale/languages';\n        let payload = {};\n\n        return await this.client.call('get', apiPath, {\n            'content-type': 'application/json',\n        }, payload);\n    }\n}\n\nmodule.exports = Locale;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvbm9kZS1hcHB3cml0ZS9saWIvc2VydmljZXMvbG9jYWxlLmpzIiwibWFwcGluZ3MiOiJBQUFBLGdCQUFnQixtQkFBTyxDQUFDLHdFQUFlO0FBQ3ZDLDBCQUEwQixtQkFBTyxDQUFDLDRFQUFpQjtBQUNuRCxrQkFBa0IsbUJBQU8sQ0FBQyw0RUFBaUI7QUFDM0MsZUFBZSxtQkFBTyxDQUFDLHNFQUFjO0FBQ3JDLGVBQWUsbUJBQU8sQ0FBQyxzQkFBUTtBQUMvQixRQUFRLFlBQVksRUFBRSxtQkFBTyxDQUFDLGtCQUFNO0FBQ3BDLFdBQVcsbUJBQU8sQ0FBQyxjQUFJO0FBQ3ZCLFFBQVEsT0FBTyxFQUFFLG1CQUFPLENBQUMsc0JBQVE7QUFDakMsY0FBYyxtQkFBTyxDQUFDLG9FQUFhOztBQUVuQzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEIsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsU0FBUztBQUNUOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQixpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFNBQVM7QUFDVDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEIsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsU0FBUztBQUNUOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQixpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFNBQVM7QUFDVDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQixpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFNBQVM7QUFDVDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEIsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTs7QUFFQSIsInNvdXJjZXMiOlsid2VicGFjazovL2pzbV9iYW5raW5nLy4vbm9kZV9tb2R1bGVzL25vZGUtYXBwd3JpdGUvbGliL3NlcnZpY2VzL2xvY2FsZS5qcz9hOGM2Il0sInNvdXJjZXNDb250ZW50IjpbImNvbnN0IFNlcnZpY2UgPSByZXF1aXJlKCcuLi9zZXJ2aWNlLmpzJyk7XG5jb25zdCBBcHB3cml0ZUV4Y2VwdGlvbiA9IHJlcXVpcmUoJy4uL2V4Y2VwdGlvbi5qcycpO1xuY29uc3QgSW5wdXRGaWxlID0gcmVxdWlyZSgnLi4vaW5wdXRGaWxlLmpzJyk7XG5jb25zdCBjbGllbnQgPSByZXF1aXJlKCcuLi9jbGllbnQuanMnKTtcbmNvbnN0IFN0cmVhbSA9IHJlcXVpcmUoJ3N0cmVhbScpO1xuY29uc3QgeyBwcm9taXNpZnkgfSA9IHJlcXVpcmUoJ3V0aWwnKTtcbmNvbnN0IGZzID0gcmVxdWlyZSgnZnMnKTtcbmNvbnN0IHsgRmlsZSB9ID0gcmVxdWlyZSgndW5kaWNpJyk7XG5jb25zdCBRdWVyeSA9IHJlcXVpcmUoJy4uL3F1ZXJ5LmpzJyk7XG5cbmNsYXNzIExvY2FsZSBleHRlbmRzIFNlcnZpY2Uge1xuXG4gICAgIGNvbnN0cnVjdG9yKGNsaWVudClcbiAgICAge1xuICAgICAgICBzdXBlcihjbGllbnQpO1xuICAgICB9XG5cblxuICAgIC8qKlxuICAgICAqIEdldCB1c2VyIGxvY2FsZVxuICAgICAqXG4gICAgICogR2V0IHRoZSBjdXJyZW50IHVzZXIgbG9jYXRpb24gYmFzZWQgb24gSVAuIFJldHVybnMgYW4gb2JqZWN0IHdpdGggdXNlclxuICAgICAqIGNvdW50cnkgY29kZSwgY291bnRyeSBuYW1lLCBjb250aW5lbnQgbmFtZSwgY29udGluZW50IGNvZGUsIGlwIGFkZHJlc3MgYW5kXG4gICAgICogc3VnZ2VzdGVkIGN1cnJlbmN5LiBZb3UgY2FuIHVzZSB0aGUgbG9jYWxlIGhlYWRlciB0byBnZXQgdGhlIGRhdGEgaW4gYVxuICAgICAqIHN1cHBvcnRlZCBsYW5ndWFnZS5cbiAgICAgKiBcbiAgICAgKiAoW0lQIEdlb2xvY2F0aW9uIGJ5IERCLUlQXShodHRwczovL2RiLWlwLmNvbSkpXG4gICAgICpcbiAgICAgKiBAdGhyb3dzIHtBcHB3cml0ZUV4Y2VwdGlvbn1cbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZX1cbiAgICAgKi9cbiAgICBhc3luYyBnZXQoKSB7XG4gICAgICAgIGNvbnN0IGFwaVBhdGggPSAnL2xvY2FsZSc7XG4gICAgICAgIGxldCBwYXlsb2FkID0ge307XG5cbiAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMuY2xpZW50LmNhbGwoJ2dldCcsIGFwaVBhdGgsIHtcbiAgICAgICAgICAgICdjb250ZW50LXR5cGUnOiAnYXBwbGljYXRpb24vanNvbicsXG4gICAgICAgIH0sIHBheWxvYWQpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIExpc3QgTG9jYWxlIENvZGVzXG4gICAgICpcbiAgICAgKiBMaXN0IG9mIGFsbCBsb2NhbGUgY29kZXMgaW4gW0lTT1xuICAgICAqIDYzOS0xXShodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9MaXN0X29mX0lTT182MzktMV9jb2RlcykuXG4gICAgICpcbiAgICAgKiBAdGhyb3dzIHtBcHB3cml0ZUV4Y2VwdGlvbn1cbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZX1cbiAgICAgKi9cbiAgICBhc3luYyBsaXN0Q29kZXMoKSB7XG4gICAgICAgIGNvbnN0IGFwaVBhdGggPSAnL2xvY2FsZS9jb2Rlcyc7XG4gICAgICAgIGxldCBwYXlsb2FkID0ge307XG5cbiAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMuY2xpZW50LmNhbGwoJ2dldCcsIGFwaVBhdGgsIHtcbiAgICAgICAgICAgICdjb250ZW50LXR5cGUnOiAnYXBwbGljYXRpb24vanNvbicsXG4gICAgICAgIH0sIHBheWxvYWQpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIExpc3QgY29udGluZW50c1xuICAgICAqXG4gICAgICogTGlzdCBvZiBhbGwgY29udGluZW50cy4gWW91IGNhbiB1c2UgdGhlIGxvY2FsZSBoZWFkZXIgdG8gZ2V0IHRoZSBkYXRhIGluIGFcbiAgICAgKiBzdXBwb3J0ZWQgbGFuZ3VhZ2UuXG4gICAgICpcbiAgICAgKiBAdGhyb3dzIHtBcHB3cml0ZUV4Y2VwdGlvbn1cbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZX1cbiAgICAgKi9cbiAgICBhc3luYyBsaXN0Q29udGluZW50cygpIHtcbiAgICAgICAgY29uc3QgYXBpUGF0aCA9ICcvbG9jYWxlL2NvbnRpbmVudHMnO1xuICAgICAgICBsZXQgcGF5bG9hZCA9IHt9O1xuXG4gICAgICAgIHJldHVybiBhd2FpdCB0aGlzLmNsaWVudC5jYWxsKCdnZXQnLCBhcGlQYXRoLCB7XG4gICAgICAgICAgICAnY29udGVudC10eXBlJzogJ2FwcGxpY2F0aW9uL2pzb24nLFxuICAgICAgICB9LCBwYXlsb2FkKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBMaXN0IGNvdW50cmllc1xuICAgICAqXG4gICAgICogTGlzdCBvZiBhbGwgY291bnRyaWVzLiBZb3UgY2FuIHVzZSB0aGUgbG9jYWxlIGhlYWRlciB0byBnZXQgdGhlIGRhdGEgaW4gYVxuICAgICAqIHN1cHBvcnRlZCBsYW5ndWFnZS5cbiAgICAgKlxuICAgICAqIEB0aHJvd3Mge0FwcHdyaXRlRXhjZXB0aW9ufVxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlfVxuICAgICAqL1xuICAgIGFzeW5jIGxpc3RDb3VudHJpZXMoKSB7XG4gICAgICAgIGNvbnN0IGFwaVBhdGggPSAnL2xvY2FsZS9jb3VudHJpZXMnO1xuICAgICAgICBsZXQgcGF5bG9hZCA9IHt9O1xuXG4gICAgICAgIHJldHVybiBhd2FpdCB0aGlzLmNsaWVudC5jYWxsKCdnZXQnLCBhcGlQYXRoLCB7XG4gICAgICAgICAgICAnY29udGVudC10eXBlJzogJ2FwcGxpY2F0aW9uL2pzb24nLFxuICAgICAgICB9LCBwYXlsb2FkKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBMaXN0IEVVIGNvdW50cmllc1xuICAgICAqXG4gICAgICogTGlzdCBvZiBhbGwgY291bnRyaWVzIHRoYXQgYXJlIGN1cnJlbnRseSBtZW1iZXJzIG9mIHRoZSBFVS4gWW91IGNhbiB1c2UgdGhlXG4gICAgICogbG9jYWxlIGhlYWRlciB0byBnZXQgdGhlIGRhdGEgaW4gYSBzdXBwb3J0ZWQgbGFuZ3VhZ2UuXG4gICAgICpcbiAgICAgKiBAdGhyb3dzIHtBcHB3cml0ZUV4Y2VwdGlvbn1cbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZX1cbiAgICAgKi9cbiAgICBhc3luYyBsaXN0Q291bnRyaWVzRVUoKSB7XG4gICAgICAgIGNvbnN0IGFwaVBhdGggPSAnL2xvY2FsZS9jb3VudHJpZXMvZXUnO1xuICAgICAgICBsZXQgcGF5bG9hZCA9IHt9O1xuXG4gICAgICAgIHJldHVybiBhd2FpdCB0aGlzLmNsaWVudC5jYWxsKCdnZXQnLCBhcGlQYXRoLCB7XG4gICAgICAgICAgICAnY29udGVudC10eXBlJzogJ2FwcGxpY2F0aW9uL2pzb24nLFxuICAgICAgICB9LCBwYXlsb2FkKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBMaXN0IGNvdW50cmllcyBwaG9uZSBjb2Rlc1xuICAgICAqXG4gICAgICogTGlzdCBvZiBhbGwgY291bnRyaWVzIHBob25lIGNvZGVzLiBZb3UgY2FuIHVzZSB0aGUgbG9jYWxlIGhlYWRlciB0byBnZXQgdGhlXG4gICAgICogZGF0YSBpbiBhIHN1cHBvcnRlZCBsYW5ndWFnZS5cbiAgICAgKlxuICAgICAqIEB0aHJvd3Mge0FwcHdyaXRlRXhjZXB0aW9ufVxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlfVxuICAgICAqL1xuICAgIGFzeW5jIGxpc3RDb3VudHJpZXNQaG9uZXMoKSB7XG4gICAgICAgIGNvbnN0IGFwaVBhdGggPSAnL2xvY2FsZS9jb3VudHJpZXMvcGhvbmVzJztcbiAgICAgICAgbGV0IHBheWxvYWQgPSB7fTtcblxuICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy5jbGllbnQuY2FsbCgnZ2V0JywgYXBpUGF0aCwge1xuICAgICAgICAgICAgJ2NvbnRlbnQtdHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJyxcbiAgICAgICAgfSwgcGF5bG9hZCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogTGlzdCBjdXJyZW5jaWVzXG4gICAgICpcbiAgICAgKiBMaXN0IG9mIGFsbCBjdXJyZW5jaWVzLCBpbmNsdWRpbmcgY3VycmVuY3kgc3ltYm9sLCBuYW1lLCBwbHVyYWwsIGFuZFxuICAgICAqIGRlY2ltYWwgZGlnaXRzIGZvciBhbGwgbWFqb3IgYW5kIG1pbm9yIGN1cnJlbmNpZXMuIFlvdSBjYW4gdXNlIHRoZSBsb2NhbGVcbiAgICAgKiBoZWFkZXIgdG8gZ2V0IHRoZSBkYXRhIGluIGEgc3VwcG9ydGVkIGxhbmd1YWdlLlxuICAgICAqXG4gICAgICogQHRocm93cyB7QXBwd3JpdGVFeGNlcHRpb259XG4gICAgICogQHJldHVybnMge1Byb21pc2V9XG4gICAgICovXG4gICAgYXN5bmMgbGlzdEN1cnJlbmNpZXMoKSB7XG4gICAgICAgIGNvbnN0IGFwaVBhdGggPSAnL2xvY2FsZS9jdXJyZW5jaWVzJztcbiAgICAgICAgbGV0IHBheWxvYWQgPSB7fTtcblxuICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy5jbGllbnQuY2FsbCgnZ2V0JywgYXBpUGF0aCwge1xuICAgICAgICAgICAgJ2NvbnRlbnQtdHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJyxcbiAgICAgICAgfSwgcGF5bG9hZCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogTGlzdCBsYW5ndWFnZXNcbiAgICAgKlxuICAgICAqIExpc3Qgb2YgYWxsIGxhbmd1YWdlcyBjbGFzc2lmaWVkIGJ5IElTTyA2MzktMSBpbmNsdWRpbmcgMi1sZXR0ZXIgY29kZSwgbmFtZVxuICAgICAqIGluIEVuZ2xpc2gsIGFuZCBuYW1lIGluIHRoZSByZXNwZWN0aXZlIGxhbmd1YWdlLlxuICAgICAqXG4gICAgICogQHRocm93cyB7QXBwd3JpdGVFeGNlcHRpb259XG4gICAgICogQHJldHVybnMge1Byb21pc2V9XG4gICAgICovXG4gICAgYXN5bmMgbGlzdExhbmd1YWdlcygpIHtcbiAgICAgICAgY29uc3QgYXBpUGF0aCA9ICcvbG9jYWxlL2xhbmd1YWdlcyc7XG4gICAgICAgIGxldCBwYXlsb2FkID0ge307XG5cbiAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMuY2xpZW50LmNhbGwoJ2dldCcsIGFwaVBhdGgsIHtcbiAgICAgICAgICAgICdjb250ZW50LXR5cGUnOiAnYXBwbGljYXRpb24vanNvbicsXG4gICAgICAgIH0sIHBheWxvYWQpO1xuICAgIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBMb2NhbGU7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/node-appwrite/lib/services/locale.js\n");

/***/ }),

/***/ "(action-browser)/./node_modules/node-appwrite/lib/services/messaging.js":
/*!**************************************************************!*\
  !*** ./node_modules/node-appwrite/lib/services/messaging.js ***!
  \**************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("const Service = __webpack_require__(/*! ../service.js */ \"(action-browser)/./node_modules/node-appwrite/lib/service.js\");\nconst AppwriteException = __webpack_require__(/*! ../exception.js */ \"(action-browser)/./node_modules/node-appwrite/lib/exception.js\");\nconst InputFile = __webpack_require__(/*! ../inputFile.js */ \"(action-browser)/./node_modules/node-appwrite/lib/inputFile.js\");\nconst client = __webpack_require__(/*! ../client.js */ \"(action-browser)/./node_modules/node-appwrite/lib/client.js\");\nconst Stream = __webpack_require__(/*! stream */ \"stream\");\nconst { promisify } = __webpack_require__(/*! util */ \"util\");\nconst fs = __webpack_require__(/*! fs */ \"fs\");\nconst { File } = __webpack_require__(/*! undici */ \"undici\");\nconst Query = __webpack_require__(/*! ../query.js */ \"(action-browser)/./node_modules/node-appwrite/lib/query.js\");\n\nclass Messaging extends Service {\n\n     constructor(client)\n     {\n        super(client);\n     }\n\n\n    /**\n     * List messages\n     *\n     * Get a list of all messages from the current Appwrite project.\n     *\n     * @param {string[]} queries\n     * @param {string} search\n     * @throws {AppwriteException}\n     * @returns {Promise}\n     */\n    async listMessages(queries, search) {\n        const apiPath = '/messaging/messages';\n        let payload = {};\n\n        if (typeof queries !== 'undefined') {\n            payload['queries'] = queries;\n        }\n\n        if (typeof search !== 'undefined') {\n            payload['search'] = search;\n        }\n\n        return await this.client.call('get', apiPath, {\n            'content-type': 'application/json',\n        }, payload);\n    }\n\n    /**\n     * Create email\n     *\n     * Create a new email message.\n     *\n     * @param {string} messageId\n     * @param {string} subject\n     * @param {string} content\n     * @param {string[]} topics\n     * @param {string[]} users\n     * @param {string[]} targets\n     * @param {string[]} cc\n     * @param {string[]} bcc\n     * @param {string[]} attachments\n     * @param {boolean} draft\n     * @param {boolean} html\n     * @param {string} scheduledAt\n     * @throws {AppwriteException}\n     * @returns {Promise}\n     */\n    async createEmail(messageId, subject, content, topics, users, targets, cc, bcc, attachments, draft, html, scheduledAt) {\n        const apiPath = '/messaging/messages/email';\n        let payload = {};\n        if (typeof messageId === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"messageId\"');\n        }\n\n        if (typeof subject === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"subject\"');\n        }\n\n        if (typeof content === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"content\"');\n        }\n\n\n        if (typeof messageId !== 'undefined') {\n            payload['messageId'] = messageId;\n        }\n\n        if (typeof subject !== 'undefined') {\n            payload['subject'] = subject;\n        }\n\n        if (typeof content !== 'undefined') {\n            payload['content'] = content;\n        }\n\n        if (typeof topics !== 'undefined') {\n            payload['topics'] = topics;\n        }\n\n        if (typeof users !== 'undefined') {\n            payload['users'] = users;\n        }\n\n        if (typeof targets !== 'undefined') {\n            payload['targets'] = targets;\n        }\n\n        if (typeof cc !== 'undefined') {\n            payload['cc'] = cc;\n        }\n\n        if (typeof bcc !== 'undefined') {\n            payload['bcc'] = bcc;\n        }\n\n        if (typeof attachments !== 'undefined') {\n            payload['attachments'] = attachments;\n        }\n\n        if (typeof draft !== 'undefined') {\n            payload['draft'] = draft;\n        }\n\n        if (typeof html !== 'undefined') {\n            payload['html'] = html;\n        }\n\n        if (typeof scheduledAt !== 'undefined') {\n            payload['scheduledAt'] = scheduledAt;\n        }\n\n        return await this.client.call('post', apiPath, {\n            'content-type': 'application/json',\n        }, payload);\n    }\n\n    /**\n     * Update email\n     *\n     * Update an email message by its unique ID.\n     * \n     *\n     * @param {string} messageId\n     * @param {string[]} topics\n     * @param {string[]} users\n     * @param {string[]} targets\n     * @param {string} subject\n     * @param {string} content\n     * @param {boolean} draft\n     * @param {boolean} html\n     * @param {string[]} cc\n     * @param {string[]} bcc\n     * @param {string} scheduledAt\n     * @throws {AppwriteException}\n     * @returns {Promise}\n     */\n    async updateEmail(messageId, topics, users, targets, subject, content, draft, html, cc, bcc, scheduledAt) {\n        const apiPath = '/messaging/messages/email/{messageId}'.replace('{messageId}', messageId);\n        let payload = {};\n        if (typeof messageId === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"messageId\"');\n        }\n\n\n        if (typeof topics !== 'undefined') {\n            payload['topics'] = topics;\n        }\n\n        if (typeof users !== 'undefined') {\n            payload['users'] = users;\n        }\n\n        if (typeof targets !== 'undefined') {\n            payload['targets'] = targets;\n        }\n\n        if (typeof subject !== 'undefined') {\n            payload['subject'] = subject;\n        }\n\n        if (typeof content !== 'undefined') {\n            payload['content'] = content;\n        }\n\n        if (typeof draft !== 'undefined') {\n            payload['draft'] = draft;\n        }\n\n        if (typeof html !== 'undefined') {\n            payload['html'] = html;\n        }\n\n        if (typeof cc !== 'undefined') {\n            payload['cc'] = cc;\n        }\n\n        if (typeof bcc !== 'undefined') {\n            payload['bcc'] = bcc;\n        }\n\n        if (typeof scheduledAt !== 'undefined') {\n            payload['scheduledAt'] = scheduledAt;\n        }\n\n        return await this.client.call('patch', apiPath, {\n            'content-type': 'application/json',\n        }, payload);\n    }\n\n    /**\n     * Create push notification\n     *\n     * Create a new push notification.\n     *\n     * @param {string} messageId\n     * @param {string} title\n     * @param {string} body\n     * @param {string[]} topics\n     * @param {string[]} users\n     * @param {string[]} targets\n     * @param {object} data\n     * @param {string} action\n     * @param {string} image\n     * @param {string} icon\n     * @param {string} sound\n     * @param {string} color\n     * @param {string} tag\n     * @param {string} badge\n     * @param {boolean} draft\n     * @param {string} scheduledAt\n     * @throws {AppwriteException}\n     * @returns {Promise}\n     */\n    async createPush(messageId, title, body, topics, users, targets, data, action, image, icon, sound, color, tag, badge, draft, scheduledAt) {\n        const apiPath = '/messaging/messages/push';\n        let payload = {};\n        if (typeof messageId === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"messageId\"');\n        }\n\n        if (typeof title === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"title\"');\n        }\n\n        if (typeof body === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"body\"');\n        }\n\n\n        if (typeof messageId !== 'undefined') {\n            payload['messageId'] = messageId;\n        }\n\n        if (typeof title !== 'undefined') {\n            payload['title'] = title;\n        }\n\n        if (typeof body !== 'undefined') {\n            payload['body'] = body;\n        }\n\n        if (typeof topics !== 'undefined') {\n            payload['topics'] = topics;\n        }\n\n        if (typeof users !== 'undefined') {\n            payload['users'] = users;\n        }\n\n        if (typeof targets !== 'undefined') {\n            payload['targets'] = targets;\n        }\n\n        if (typeof data !== 'undefined') {\n            payload['data'] = data;\n        }\n\n        if (typeof action !== 'undefined') {\n            payload['action'] = action;\n        }\n\n        if (typeof image !== 'undefined') {\n            payload['image'] = image;\n        }\n\n        if (typeof icon !== 'undefined') {\n            payload['icon'] = icon;\n        }\n\n        if (typeof sound !== 'undefined') {\n            payload['sound'] = sound;\n        }\n\n        if (typeof color !== 'undefined') {\n            payload['color'] = color;\n        }\n\n        if (typeof tag !== 'undefined') {\n            payload['tag'] = tag;\n        }\n\n        if (typeof badge !== 'undefined') {\n            payload['badge'] = badge;\n        }\n\n        if (typeof draft !== 'undefined') {\n            payload['draft'] = draft;\n        }\n\n        if (typeof scheduledAt !== 'undefined') {\n            payload['scheduledAt'] = scheduledAt;\n        }\n\n        return await this.client.call('post', apiPath, {\n            'content-type': 'application/json',\n        }, payload);\n    }\n\n    /**\n     * Update push notification\n     *\n     * Update a push notification by its unique ID.\n     * \n     *\n     * @param {string} messageId\n     * @param {string[]} topics\n     * @param {string[]} users\n     * @param {string[]} targets\n     * @param {string} title\n     * @param {string} body\n     * @param {object} data\n     * @param {string} action\n     * @param {string} image\n     * @param {string} icon\n     * @param {string} sound\n     * @param {string} color\n     * @param {string} tag\n     * @param {number} badge\n     * @param {boolean} draft\n     * @param {string} scheduledAt\n     * @throws {AppwriteException}\n     * @returns {Promise}\n     */\n    async updatePush(messageId, topics, users, targets, title, body, data, action, image, icon, sound, color, tag, badge, draft, scheduledAt) {\n        const apiPath = '/messaging/messages/push/{messageId}'.replace('{messageId}', messageId);\n        let payload = {};\n        if (typeof messageId === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"messageId\"');\n        }\n\n\n        if (typeof topics !== 'undefined') {\n            payload['topics'] = topics;\n        }\n\n        if (typeof users !== 'undefined') {\n            payload['users'] = users;\n        }\n\n        if (typeof targets !== 'undefined') {\n            payload['targets'] = targets;\n        }\n\n        if (typeof title !== 'undefined') {\n            payload['title'] = title;\n        }\n\n        if (typeof body !== 'undefined') {\n            payload['body'] = body;\n        }\n\n        if (typeof data !== 'undefined') {\n            payload['data'] = data;\n        }\n\n        if (typeof action !== 'undefined') {\n            payload['action'] = action;\n        }\n\n        if (typeof image !== 'undefined') {\n            payload['image'] = image;\n        }\n\n        if (typeof icon !== 'undefined') {\n            payload['icon'] = icon;\n        }\n\n        if (typeof sound !== 'undefined') {\n            payload['sound'] = sound;\n        }\n\n        if (typeof color !== 'undefined') {\n            payload['color'] = color;\n        }\n\n        if (typeof tag !== 'undefined') {\n            payload['tag'] = tag;\n        }\n\n        if (typeof badge !== 'undefined') {\n            payload['badge'] = badge;\n        }\n\n        if (typeof draft !== 'undefined') {\n            payload['draft'] = draft;\n        }\n\n        if (typeof scheduledAt !== 'undefined') {\n            payload['scheduledAt'] = scheduledAt;\n        }\n\n        return await this.client.call('patch', apiPath, {\n            'content-type': 'application/json',\n        }, payload);\n    }\n\n    /**\n     * Create SMS\n     *\n     * Create a new SMS message.\n     *\n     * @param {string} messageId\n     * @param {string} content\n     * @param {string[]} topics\n     * @param {string[]} users\n     * @param {string[]} targets\n     * @param {boolean} draft\n     * @param {string} scheduledAt\n     * @throws {AppwriteException}\n     * @returns {Promise}\n     */\n    async createSms(messageId, content, topics, users, targets, draft, scheduledAt) {\n        const apiPath = '/messaging/messages/sms';\n        let payload = {};\n        if (typeof messageId === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"messageId\"');\n        }\n\n        if (typeof content === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"content\"');\n        }\n\n\n        if (typeof messageId !== 'undefined') {\n            payload['messageId'] = messageId;\n        }\n\n        if (typeof content !== 'undefined') {\n            payload['content'] = content;\n        }\n\n        if (typeof topics !== 'undefined') {\n            payload['topics'] = topics;\n        }\n\n        if (typeof users !== 'undefined') {\n            payload['users'] = users;\n        }\n\n        if (typeof targets !== 'undefined') {\n            payload['targets'] = targets;\n        }\n\n        if (typeof draft !== 'undefined') {\n            payload['draft'] = draft;\n        }\n\n        if (typeof scheduledAt !== 'undefined') {\n            payload['scheduledAt'] = scheduledAt;\n        }\n\n        return await this.client.call('post', apiPath, {\n            'content-type': 'application/json',\n        }, payload);\n    }\n\n    /**\n     * Update SMS\n     *\n     * Update an email message by its unique ID.\n     * \n     *\n     * @param {string} messageId\n     * @param {string[]} topics\n     * @param {string[]} users\n     * @param {string[]} targets\n     * @param {string} content\n     * @param {boolean} draft\n     * @param {string} scheduledAt\n     * @throws {AppwriteException}\n     * @returns {Promise}\n     */\n    async updateSms(messageId, topics, users, targets, content, draft, scheduledAt) {\n        const apiPath = '/messaging/messages/sms/{messageId}'.replace('{messageId}', messageId);\n        let payload = {};\n        if (typeof messageId === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"messageId\"');\n        }\n\n\n        if (typeof topics !== 'undefined') {\n            payload['topics'] = topics;\n        }\n\n        if (typeof users !== 'undefined') {\n            payload['users'] = users;\n        }\n\n        if (typeof targets !== 'undefined') {\n            payload['targets'] = targets;\n        }\n\n        if (typeof content !== 'undefined') {\n            payload['content'] = content;\n        }\n\n        if (typeof draft !== 'undefined') {\n            payload['draft'] = draft;\n        }\n\n        if (typeof scheduledAt !== 'undefined') {\n            payload['scheduledAt'] = scheduledAt;\n        }\n\n        return await this.client.call('patch', apiPath, {\n            'content-type': 'application/json',\n        }, payload);\n    }\n\n    /**\n     * Get message\n     *\n     * Get a message by its unique ID.\n     * \n     *\n     * @param {string} messageId\n     * @throws {AppwriteException}\n     * @returns {Promise}\n     */\n    async getMessage(messageId) {\n        const apiPath = '/messaging/messages/{messageId}'.replace('{messageId}', messageId);\n        let payload = {};\n        if (typeof messageId === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"messageId\"');\n        }\n\n\n        return await this.client.call('get', apiPath, {\n            'content-type': 'application/json',\n        }, payload);\n    }\n\n    /**\n     * Delete message\n     *\n     * Delete a message. If the message is not a draft or scheduled, but has been\n     * sent, this will not recall the message.\n     *\n     * @param {string} messageId\n     * @throws {AppwriteException}\n     * @returns {Promise}\n     */\n    async delete(messageId) {\n        const apiPath = '/messaging/messages/{messageId}'.replace('{messageId}', messageId);\n        let payload = {};\n        if (typeof messageId === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"messageId\"');\n        }\n\n\n        return await this.client.call('delete', apiPath, {\n            'content-type': 'application/json',\n        }, payload);\n    }\n\n    /**\n     * List message logs\n     *\n     * Get the message activity logs listed by its unique ID.\n     *\n     * @param {string} messageId\n     * @param {string[]} queries\n     * @throws {AppwriteException}\n     * @returns {Promise}\n     */\n    async listMessageLogs(messageId, queries) {\n        const apiPath = '/messaging/messages/{messageId}/logs'.replace('{messageId}', messageId);\n        let payload = {};\n        if (typeof messageId === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"messageId\"');\n        }\n\n\n        if (typeof queries !== 'undefined') {\n            payload['queries'] = queries;\n        }\n\n        return await this.client.call('get', apiPath, {\n            'content-type': 'application/json',\n        }, payload);\n    }\n\n    /**\n     * List message targets\n     *\n     * Get a list of the targets associated with a message.\n     *\n     * @param {string} messageId\n     * @param {string[]} queries\n     * @throws {AppwriteException}\n     * @returns {Promise}\n     */\n    async listTargets(messageId, queries) {\n        const apiPath = '/messaging/messages/{messageId}/targets'.replace('{messageId}', messageId);\n        let payload = {};\n        if (typeof messageId === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"messageId\"');\n        }\n\n\n        if (typeof queries !== 'undefined') {\n            payload['queries'] = queries;\n        }\n\n        return await this.client.call('get', apiPath, {\n            'content-type': 'application/json',\n        }, payload);\n    }\n\n    /**\n     * List providers\n     *\n     * Get a list of all providers from the current Appwrite project.\n     *\n     * @param {string[]} queries\n     * @param {string} search\n     * @throws {AppwriteException}\n     * @returns {Promise}\n     */\n    async listProviders(queries, search) {\n        const apiPath = '/messaging/providers';\n        let payload = {};\n\n        if (typeof queries !== 'undefined') {\n            payload['queries'] = queries;\n        }\n\n        if (typeof search !== 'undefined') {\n            payload['search'] = search;\n        }\n\n        return await this.client.call('get', apiPath, {\n            'content-type': 'application/json',\n        }, payload);\n    }\n\n    /**\n     * Create APNS provider\n     *\n     * Create a new Apple Push Notification service provider.\n     *\n     * @param {string} providerId\n     * @param {string} name\n     * @param {string} authKey\n     * @param {string} authKeyId\n     * @param {string} teamId\n     * @param {string} bundleId\n     * @param {boolean} sandbox\n     * @param {boolean} enabled\n     * @throws {AppwriteException}\n     * @returns {Promise}\n     */\n    async createApnsProvider(providerId, name, authKey, authKeyId, teamId, bundleId, sandbox, enabled) {\n        const apiPath = '/messaging/providers/apns';\n        let payload = {};\n        if (typeof providerId === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"providerId\"');\n        }\n\n        if (typeof name === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"name\"');\n        }\n\n\n        if (typeof providerId !== 'undefined') {\n            payload['providerId'] = providerId;\n        }\n\n        if (typeof name !== 'undefined') {\n            payload['name'] = name;\n        }\n\n        if (typeof authKey !== 'undefined') {\n            payload['authKey'] = authKey;\n        }\n\n        if (typeof authKeyId !== 'undefined') {\n            payload['authKeyId'] = authKeyId;\n        }\n\n        if (typeof teamId !== 'undefined') {\n            payload['teamId'] = teamId;\n        }\n\n        if (typeof bundleId !== 'undefined') {\n            payload['bundleId'] = bundleId;\n        }\n\n        if (typeof sandbox !== 'undefined') {\n            payload['sandbox'] = sandbox;\n        }\n\n        if (typeof enabled !== 'undefined') {\n            payload['enabled'] = enabled;\n        }\n\n        return await this.client.call('post', apiPath, {\n            'content-type': 'application/json',\n        }, payload);\n    }\n\n    /**\n     * Update APNS provider\n     *\n     * Update a Apple Push Notification service provider by its unique ID.\n     *\n     * @param {string} providerId\n     * @param {string} name\n     * @param {boolean} enabled\n     * @param {string} authKey\n     * @param {string} authKeyId\n     * @param {string} teamId\n     * @param {string} bundleId\n     * @param {boolean} sandbox\n     * @throws {AppwriteException}\n     * @returns {Promise}\n     */\n    async updateApnsProvider(providerId, name, enabled, authKey, authKeyId, teamId, bundleId, sandbox) {\n        const apiPath = '/messaging/providers/apns/{providerId}'.replace('{providerId}', providerId);\n        let payload = {};\n        if (typeof providerId === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"providerId\"');\n        }\n\n\n        if (typeof name !== 'undefined') {\n            payload['name'] = name;\n        }\n\n        if (typeof enabled !== 'undefined') {\n            payload['enabled'] = enabled;\n        }\n\n        if (typeof authKey !== 'undefined') {\n            payload['authKey'] = authKey;\n        }\n\n        if (typeof authKeyId !== 'undefined') {\n            payload['authKeyId'] = authKeyId;\n        }\n\n        if (typeof teamId !== 'undefined') {\n            payload['teamId'] = teamId;\n        }\n\n        if (typeof bundleId !== 'undefined') {\n            payload['bundleId'] = bundleId;\n        }\n\n        if (typeof sandbox !== 'undefined') {\n            payload['sandbox'] = sandbox;\n        }\n\n        return await this.client.call('patch', apiPath, {\n            'content-type': 'application/json',\n        }, payload);\n    }\n\n    /**\n     * Create FCM provider\n     *\n     * Create a new Firebase Cloud Messaging provider.\n     *\n     * @param {string} providerId\n     * @param {string} name\n     * @param {object} serviceAccountJSON\n     * @param {boolean} enabled\n     * @throws {AppwriteException}\n     * @returns {Promise}\n     */\n    async createFcmProvider(providerId, name, serviceAccountJSON, enabled) {\n        const apiPath = '/messaging/providers/fcm';\n        let payload = {};\n        if (typeof providerId === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"providerId\"');\n        }\n\n        if (typeof name === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"name\"');\n        }\n\n\n        if (typeof providerId !== 'undefined') {\n            payload['providerId'] = providerId;\n        }\n\n        if (typeof name !== 'undefined') {\n            payload['name'] = name;\n        }\n\n        if (typeof serviceAccountJSON !== 'undefined') {\n            payload['serviceAccountJSON'] = serviceAccountJSON;\n        }\n\n        if (typeof enabled !== 'undefined') {\n            payload['enabled'] = enabled;\n        }\n\n        return await this.client.call('post', apiPath, {\n            'content-type': 'application/json',\n        }, payload);\n    }\n\n    /**\n     * Update FCM provider\n     *\n     * Update a Firebase Cloud Messaging provider by its unique ID.\n     *\n     * @param {string} providerId\n     * @param {string} name\n     * @param {boolean} enabled\n     * @param {object} serviceAccountJSON\n     * @throws {AppwriteException}\n     * @returns {Promise}\n     */\n    async updateFcmProvider(providerId, name, enabled, serviceAccountJSON) {\n        const apiPath = '/messaging/providers/fcm/{providerId}'.replace('{providerId}', providerId);\n        let payload = {};\n        if (typeof providerId === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"providerId\"');\n        }\n\n\n        if (typeof name !== 'undefined') {\n            payload['name'] = name;\n        }\n\n        if (typeof enabled !== 'undefined') {\n            payload['enabled'] = enabled;\n        }\n\n        if (typeof serviceAccountJSON !== 'undefined') {\n            payload['serviceAccountJSON'] = serviceAccountJSON;\n        }\n\n        return await this.client.call('patch', apiPath, {\n            'content-type': 'application/json',\n        }, payload);\n    }\n\n    /**\n     * Create Mailgun provider\n     *\n     * Create a new Mailgun provider.\n     *\n     * @param {string} providerId\n     * @param {string} name\n     * @param {string} apiKey\n     * @param {string} domain\n     * @param {boolean} isEuRegion\n     * @param {string} fromName\n     * @param {string} fromEmail\n     * @param {string} replyToName\n     * @param {string} replyToEmail\n     * @param {boolean} enabled\n     * @throws {AppwriteException}\n     * @returns {Promise}\n     */\n    async createMailgunProvider(providerId, name, apiKey, domain, isEuRegion, fromName, fromEmail, replyToName, replyToEmail, enabled) {\n        const apiPath = '/messaging/providers/mailgun';\n        let payload = {};\n        if (typeof providerId === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"providerId\"');\n        }\n\n        if (typeof name === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"name\"');\n        }\n\n\n        if (typeof providerId !== 'undefined') {\n            payload['providerId'] = providerId;\n        }\n\n        if (typeof name !== 'undefined') {\n            payload['name'] = name;\n        }\n\n        if (typeof apiKey !== 'undefined') {\n            payload['apiKey'] = apiKey;\n        }\n\n        if (typeof domain !== 'undefined') {\n            payload['domain'] = domain;\n        }\n\n        if (typeof isEuRegion !== 'undefined') {\n            payload['isEuRegion'] = isEuRegion;\n        }\n\n        if (typeof fromName !== 'undefined') {\n            payload['fromName'] = fromName;\n        }\n\n        if (typeof fromEmail !== 'undefined') {\n            payload['fromEmail'] = fromEmail;\n        }\n\n        if (typeof replyToName !== 'undefined') {\n            payload['replyToName'] = replyToName;\n        }\n\n        if (typeof replyToEmail !== 'undefined') {\n            payload['replyToEmail'] = replyToEmail;\n        }\n\n        if (typeof enabled !== 'undefined') {\n            payload['enabled'] = enabled;\n        }\n\n        return await this.client.call('post', apiPath, {\n            'content-type': 'application/json',\n        }, payload);\n    }\n\n    /**\n     * Update Mailgun provider\n     *\n     * Update a Mailgun provider by its unique ID.\n     *\n     * @param {string} providerId\n     * @param {string} name\n     * @param {string} apiKey\n     * @param {string} domain\n     * @param {boolean} isEuRegion\n     * @param {boolean} enabled\n     * @param {string} fromName\n     * @param {string} fromEmail\n     * @param {string} replyToName\n     * @param {string} replyToEmail\n     * @throws {AppwriteException}\n     * @returns {Promise}\n     */\n    async updateMailgunProvider(providerId, name, apiKey, domain, isEuRegion, enabled, fromName, fromEmail, replyToName, replyToEmail) {\n        const apiPath = '/messaging/providers/mailgun/{providerId}'.replace('{providerId}', providerId);\n        let payload = {};\n        if (typeof providerId === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"providerId\"');\n        }\n\n\n        if (typeof name !== 'undefined') {\n            payload['name'] = name;\n        }\n\n        if (typeof apiKey !== 'undefined') {\n            payload['apiKey'] = apiKey;\n        }\n\n        if (typeof domain !== 'undefined') {\n            payload['domain'] = domain;\n        }\n\n        if (typeof isEuRegion !== 'undefined') {\n            payload['isEuRegion'] = isEuRegion;\n        }\n\n        if (typeof enabled !== 'undefined') {\n            payload['enabled'] = enabled;\n        }\n\n        if (typeof fromName !== 'undefined') {\n            payload['fromName'] = fromName;\n        }\n\n        if (typeof fromEmail !== 'undefined') {\n            payload['fromEmail'] = fromEmail;\n        }\n\n        if (typeof replyToName !== 'undefined') {\n            payload['replyToName'] = replyToName;\n        }\n\n        if (typeof replyToEmail !== 'undefined') {\n            payload['replyToEmail'] = replyToEmail;\n        }\n\n        return await this.client.call('patch', apiPath, {\n            'content-type': 'application/json',\n        }, payload);\n    }\n\n    /**\n     * Create Msg91 provider\n     *\n     * Create a new MSG91 provider.\n     *\n     * @param {string} providerId\n     * @param {string} name\n     * @param {string} templateId\n     * @param {string} senderId\n     * @param {string} authKey\n     * @param {boolean} enabled\n     * @throws {AppwriteException}\n     * @returns {Promise}\n     */\n    async createMsg91Provider(providerId, name, templateId, senderId, authKey, enabled) {\n        const apiPath = '/messaging/providers/msg91';\n        let payload = {};\n        if (typeof providerId === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"providerId\"');\n        }\n\n        if (typeof name === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"name\"');\n        }\n\n\n        if (typeof providerId !== 'undefined') {\n            payload['providerId'] = providerId;\n        }\n\n        if (typeof name !== 'undefined') {\n            payload['name'] = name;\n        }\n\n        if (typeof templateId !== 'undefined') {\n            payload['templateId'] = templateId;\n        }\n\n        if (typeof senderId !== 'undefined') {\n            payload['senderId'] = senderId;\n        }\n\n        if (typeof authKey !== 'undefined') {\n            payload['authKey'] = authKey;\n        }\n\n        if (typeof enabled !== 'undefined') {\n            payload['enabled'] = enabled;\n        }\n\n        return await this.client.call('post', apiPath, {\n            'content-type': 'application/json',\n        }, payload);\n    }\n\n    /**\n     * Update Msg91 provider\n     *\n     * Update a MSG91 provider by its unique ID.\n     *\n     * @param {string} providerId\n     * @param {string} name\n     * @param {boolean} enabled\n     * @param {string} templateId\n     * @param {string} senderId\n     * @param {string} authKey\n     * @throws {AppwriteException}\n     * @returns {Promise}\n     */\n    async updateMsg91Provider(providerId, name, enabled, templateId, senderId, authKey) {\n        const apiPath = '/messaging/providers/msg91/{providerId}'.replace('{providerId}', providerId);\n        let payload = {};\n        if (typeof providerId === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"providerId\"');\n        }\n\n\n        if (typeof name !== 'undefined') {\n            payload['name'] = name;\n        }\n\n        if (typeof enabled !== 'undefined') {\n            payload['enabled'] = enabled;\n        }\n\n        if (typeof templateId !== 'undefined') {\n            payload['templateId'] = templateId;\n        }\n\n        if (typeof senderId !== 'undefined') {\n            payload['senderId'] = senderId;\n        }\n\n        if (typeof authKey !== 'undefined') {\n            payload['authKey'] = authKey;\n        }\n\n        return await this.client.call('patch', apiPath, {\n            'content-type': 'application/json',\n        }, payload);\n    }\n\n    /**\n     * Create Sendgrid provider\n     *\n     * Create a new Sendgrid provider.\n     *\n     * @param {string} providerId\n     * @param {string} name\n     * @param {string} apiKey\n     * @param {string} fromName\n     * @param {string} fromEmail\n     * @param {string} replyToName\n     * @param {string} replyToEmail\n     * @param {boolean} enabled\n     * @throws {AppwriteException}\n     * @returns {Promise}\n     */\n    async createSendgridProvider(providerId, name, apiKey, fromName, fromEmail, replyToName, replyToEmail, enabled) {\n        const apiPath = '/messaging/providers/sendgrid';\n        let payload = {};\n        if (typeof providerId === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"providerId\"');\n        }\n\n        if (typeof name === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"name\"');\n        }\n\n\n        if (typeof providerId !== 'undefined') {\n            payload['providerId'] = providerId;\n        }\n\n        if (typeof name !== 'undefined') {\n            payload['name'] = name;\n        }\n\n        if (typeof apiKey !== 'undefined') {\n            payload['apiKey'] = apiKey;\n        }\n\n        if (typeof fromName !== 'undefined') {\n            payload['fromName'] = fromName;\n        }\n\n        if (typeof fromEmail !== 'undefined') {\n            payload['fromEmail'] = fromEmail;\n        }\n\n        if (typeof replyToName !== 'undefined') {\n            payload['replyToName'] = replyToName;\n        }\n\n        if (typeof replyToEmail !== 'undefined') {\n            payload['replyToEmail'] = replyToEmail;\n        }\n\n        if (typeof enabled !== 'undefined') {\n            payload['enabled'] = enabled;\n        }\n\n        return await this.client.call('post', apiPath, {\n            'content-type': 'application/json',\n        }, payload);\n    }\n\n    /**\n     * Update Sendgrid provider\n     *\n     * Update a Sendgrid provider by its unique ID.\n     *\n     * @param {string} providerId\n     * @param {string} name\n     * @param {boolean} enabled\n     * @param {string} apiKey\n     * @param {string} fromName\n     * @param {string} fromEmail\n     * @param {string} replyToName\n     * @param {string} replyToEmail\n     * @throws {AppwriteException}\n     * @returns {Promise}\n     */\n    async updateSendgridProvider(providerId, name, enabled, apiKey, fromName, fromEmail, replyToName, replyToEmail) {\n        const apiPath = '/messaging/providers/sendgrid/{providerId}'.replace('{providerId}', providerId);\n        let payload = {};\n        if (typeof providerId === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"providerId\"');\n        }\n\n\n        if (typeof name !== 'undefined') {\n            payload['name'] = name;\n        }\n\n        if (typeof enabled !== 'undefined') {\n            payload['enabled'] = enabled;\n        }\n\n        if (typeof apiKey !== 'undefined') {\n            payload['apiKey'] = apiKey;\n        }\n\n        if (typeof fromName !== 'undefined') {\n            payload['fromName'] = fromName;\n        }\n\n        if (typeof fromEmail !== 'undefined') {\n            payload['fromEmail'] = fromEmail;\n        }\n\n        if (typeof replyToName !== 'undefined') {\n            payload['replyToName'] = replyToName;\n        }\n\n        if (typeof replyToEmail !== 'undefined') {\n            payload['replyToEmail'] = replyToEmail;\n        }\n\n        return await this.client.call('patch', apiPath, {\n            'content-type': 'application/json',\n        }, payload);\n    }\n\n    /**\n     * Create SMTP provider\n     *\n     * Create a new SMTP provider.\n     *\n     * @param {string} providerId\n     * @param {string} name\n     * @param {string} host\n     * @param {number} port\n     * @param {string} username\n     * @param {string} password\n     * @param {SmtpEncryption} encryption\n     * @param {boolean} autoTLS\n     * @param {string} mailer\n     * @param {string} fromName\n     * @param {string} fromEmail\n     * @param {string} replyToName\n     * @param {string} replyToEmail\n     * @param {boolean} enabled\n     * @throws {AppwriteException}\n     * @returns {Promise}\n     */\n    async createSmtpProvider(providerId, name, host, port, username, password, encryption, autoTLS, mailer, fromName, fromEmail, replyToName, replyToEmail, enabled) {\n        const apiPath = '/messaging/providers/smtp';\n        let payload = {};\n        if (typeof providerId === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"providerId\"');\n        }\n\n        if (typeof name === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"name\"');\n        }\n\n        if (typeof host === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"host\"');\n        }\n\n\n        if (typeof providerId !== 'undefined') {\n            payload['providerId'] = providerId;\n        }\n\n        if (typeof name !== 'undefined') {\n            payload['name'] = name;\n        }\n\n        if (typeof host !== 'undefined') {\n            payload['host'] = host;\n        }\n\n        if (typeof port !== 'undefined') {\n            payload['port'] = port;\n        }\n\n        if (typeof username !== 'undefined') {\n            payload['username'] = username;\n        }\n\n        if (typeof password !== 'undefined') {\n            payload['password'] = password;\n        }\n\n        if (typeof encryption !== 'undefined') {\n            payload['encryption'] = encryption;\n        }\n\n        if (typeof autoTLS !== 'undefined') {\n            payload['autoTLS'] = autoTLS;\n        }\n\n        if (typeof mailer !== 'undefined') {\n            payload['mailer'] = mailer;\n        }\n\n        if (typeof fromName !== 'undefined') {\n            payload['fromName'] = fromName;\n        }\n\n        if (typeof fromEmail !== 'undefined') {\n            payload['fromEmail'] = fromEmail;\n        }\n\n        if (typeof replyToName !== 'undefined') {\n            payload['replyToName'] = replyToName;\n        }\n\n        if (typeof replyToEmail !== 'undefined') {\n            payload['replyToEmail'] = replyToEmail;\n        }\n\n        if (typeof enabled !== 'undefined') {\n            payload['enabled'] = enabled;\n        }\n\n        return await this.client.call('post', apiPath, {\n            'content-type': 'application/json',\n        }, payload);\n    }\n\n    /**\n     * Update SMTP provider\n     *\n     * Update a SMTP provider by its unique ID.\n     *\n     * @param {string} providerId\n     * @param {string} name\n     * @param {string} host\n     * @param {number} port\n     * @param {string} username\n     * @param {string} password\n     * @param {SmtpEncryption} encryption\n     * @param {boolean} autoTLS\n     * @param {string} mailer\n     * @param {string} fromName\n     * @param {string} fromEmail\n     * @param {string} replyToName\n     * @param {string} replyToEmail\n     * @param {boolean} enabled\n     * @throws {AppwriteException}\n     * @returns {Promise}\n     */\n    async updateSmtpProvider(providerId, name, host, port, username, password, encryption, autoTLS, mailer, fromName, fromEmail, replyToName, replyToEmail, enabled) {\n        const apiPath = '/messaging/providers/smtp/{providerId}'.replace('{providerId}', providerId);\n        let payload = {};\n        if (typeof providerId === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"providerId\"');\n        }\n\n\n        if (typeof name !== 'undefined') {\n            payload['name'] = name;\n        }\n\n        if (typeof host !== 'undefined') {\n            payload['host'] = host;\n        }\n\n        if (typeof port !== 'undefined') {\n            payload['port'] = port;\n        }\n\n        if (typeof username !== 'undefined') {\n            payload['username'] = username;\n        }\n\n        if (typeof password !== 'undefined') {\n            payload['password'] = password;\n        }\n\n        if (typeof encryption !== 'undefined') {\n            payload['encryption'] = encryption;\n        }\n\n        if (typeof autoTLS !== 'undefined') {\n            payload['autoTLS'] = autoTLS;\n        }\n\n        if (typeof mailer !== 'undefined') {\n            payload['mailer'] = mailer;\n        }\n\n        if (typeof fromName !== 'undefined') {\n            payload['fromName'] = fromName;\n        }\n\n        if (typeof fromEmail !== 'undefined') {\n            payload['fromEmail'] = fromEmail;\n        }\n\n        if (typeof replyToName !== 'undefined') {\n            payload['replyToName'] = replyToName;\n        }\n\n        if (typeof replyToEmail !== 'undefined') {\n            payload['replyToEmail'] = replyToEmail;\n        }\n\n        if (typeof enabled !== 'undefined') {\n            payload['enabled'] = enabled;\n        }\n\n        return await this.client.call('patch', apiPath, {\n            'content-type': 'application/json',\n        }, payload);\n    }\n\n    /**\n     * Create Telesign provider\n     *\n     * Create a new Telesign provider.\n     *\n     * @param {string} providerId\n     * @param {string} name\n     * @param {string} from\n     * @param {string} customerId\n     * @param {string} apiKey\n     * @param {boolean} enabled\n     * @throws {AppwriteException}\n     * @returns {Promise}\n     */\n    async createTelesignProvider(providerId, name, from, customerId, apiKey, enabled) {\n        const apiPath = '/messaging/providers/telesign';\n        let payload = {};\n        if (typeof providerId === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"providerId\"');\n        }\n\n        if (typeof name === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"name\"');\n        }\n\n\n        if (typeof providerId !== 'undefined') {\n            payload['providerId'] = providerId;\n        }\n\n        if (typeof name !== 'undefined') {\n            payload['name'] = name;\n        }\n\n        if (typeof from !== 'undefined') {\n            payload['from'] = from;\n        }\n\n        if (typeof customerId !== 'undefined') {\n            payload['customerId'] = customerId;\n        }\n\n        if (typeof apiKey !== 'undefined') {\n            payload['apiKey'] = apiKey;\n        }\n\n        if (typeof enabled !== 'undefined') {\n            payload['enabled'] = enabled;\n        }\n\n        return await this.client.call('post', apiPath, {\n            'content-type': 'application/json',\n        }, payload);\n    }\n\n    /**\n     * Update Telesign provider\n     *\n     * Update a Telesign provider by its unique ID.\n     *\n     * @param {string} providerId\n     * @param {string} name\n     * @param {boolean} enabled\n     * @param {string} customerId\n     * @param {string} apiKey\n     * @param {string} from\n     * @throws {AppwriteException}\n     * @returns {Promise}\n     */\n    async updateTelesignProvider(providerId, name, enabled, customerId, apiKey, from) {\n        const apiPath = '/messaging/providers/telesign/{providerId}'.replace('{providerId}', providerId);\n        let payload = {};\n        if (typeof providerId === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"providerId\"');\n        }\n\n\n        if (typeof name !== 'undefined') {\n            payload['name'] = name;\n        }\n\n        if (typeof enabled !== 'undefined') {\n            payload['enabled'] = enabled;\n        }\n\n        if (typeof customerId !== 'undefined') {\n            payload['customerId'] = customerId;\n        }\n\n        if (typeof apiKey !== 'undefined') {\n            payload['apiKey'] = apiKey;\n        }\n\n        if (typeof from !== 'undefined') {\n            payload['from'] = from;\n        }\n\n        return await this.client.call('patch', apiPath, {\n            'content-type': 'application/json',\n        }, payload);\n    }\n\n    /**\n     * Create Textmagic provider\n     *\n     * Create a new Textmagic provider.\n     *\n     * @param {string} providerId\n     * @param {string} name\n     * @param {string} from\n     * @param {string} username\n     * @param {string} apiKey\n     * @param {boolean} enabled\n     * @throws {AppwriteException}\n     * @returns {Promise}\n     */\n    async createTextmagicProvider(providerId, name, from, username, apiKey, enabled) {\n        const apiPath = '/messaging/providers/textmagic';\n        let payload = {};\n        if (typeof providerId === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"providerId\"');\n        }\n\n        if (typeof name === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"name\"');\n        }\n\n\n        if (typeof providerId !== 'undefined') {\n            payload['providerId'] = providerId;\n        }\n\n        if (typeof name !== 'undefined') {\n            payload['name'] = name;\n        }\n\n        if (typeof from !== 'undefined') {\n            payload['from'] = from;\n        }\n\n        if (typeof username !== 'undefined') {\n            payload['username'] = username;\n        }\n\n        if (typeof apiKey !== 'undefined') {\n            payload['apiKey'] = apiKey;\n        }\n\n        if (typeof enabled !== 'undefined') {\n            payload['enabled'] = enabled;\n        }\n\n        return await this.client.call('post', apiPath, {\n            'content-type': 'application/json',\n        }, payload);\n    }\n\n    /**\n     * Update Textmagic provider\n     *\n     * Update a Textmagic provider by its unique ID.\n     *\n     * @param {string} providerId\n     * @param {string} name\n     * @param {boolean} enabled\n     * @param {string} username\n     * @param {string} apiKey\n     * @param {string} from\n     * @throws {AppwriteException}\n     * @returns {Promise}\n     */\n    async updateTextmagicProvider(providerId, name, enabled, username, apiKey, from) {\n        const apiPath = '/messaging/providers/textmagic/{providerId}'.replace('{providerId}', providerId);\n        let payload = {};\n        if (typeof providerId === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"providerId\"');\n        }\n\n\n        if (typeof name !== 'undefined') {\n            payload['name'] = name;\n        }\n\n        if (typeof enabled !== 'undefined') {\n            payload['enabled'] = enabled;\n        }\n\n        if (typeof username !== 'undefined') {\n            payload['username'] = username;\n        }\n\n        if (typeof apiKey !== 'undefined') {\n            payload['apiKey'] = apiKey;\n        }\n\n        if (typeof from !== 'undefined') {\n            payload['from'] = from;\n        }\n\n        return await this.client.call('patch', apiPath, {\n            'content-type': 'application/json',\n        }, payload);\n    }\n\n    /**\n     * Create Twilio provider\n     *\n     * Create a new Twilio provider.\n     *\n     * @param {string} providerId\n     * @param {string} name\n     * @param {string} from\n     * @param {string} accountSid\n     * @param {string} authToken\n     * @param {boolean} enabled\n     * @throws {AppwriteException}\n     * @returns {Promise}\n     */\n    async createTwilioProvider(providerId, name, from, accountSid, authToken, enabled) {\n        const apiPath = '/messaging/providers/twilio';\n        let payload = {};\n        if (typeof providerId === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"providerId\"');\n        }\n\n        if (typeof name === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"name\"');\n        }\n\n\n        if (typeof providerId !== 'undefined') {\n            payload['providerId'] = providerId;\n        }\n\n        if (typeof name !== 'undefined') {\n            payload['name'] = name;\n        }\n\n        if (typeof from !== 'undefined') {\n            payload['from'] = from;\n        }\n\n        if (typeof accountSid !== 'undefined') {\n            payload['accountSid'] = accountSid;\n        }\n\n        if (typeof authToken !== 'undefined') {\n            payload['authToken'] = authToken;\n        }\n\n        if (typeof enabled !== 'undefined') {\n            payload['enabled'] = enabled;\n        }\n\n        return await this.client.call('post', apiPath, {\n            'content-type': 'application/json',\n        }, payload);\n    }\n\n    /**\n     * Update Twilio provider\n     *\n     * Update a Twilio provider by its unique ID.\n     *\n     * @param {string} providerId\n     * @param {string} name\n     * @param {boolean} enabled\n     * @param {string} accountSid\n     * @param {string} authToken\n     * @param {string} from\n     * @throws {AppwriteException}\n     * @returns {Promise}\n     */\n    async updateTwilioProvider(providerId, name, enabled, accountSid, authToken, from) {\n        const apiPath = '/messaging/providers/twilio/{providerId}'.replace('{providerId}', providerId);\n        let payload = {};\n        if (typeof providerId === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"providerId\"');\n        }\n\n\n        if (typeof name !== 'undefined') {\n            payload['name'] = name;\n        }\n\n        if (typeof enabled !== 'undefined') {\n            payload['enabled'] = enabled;\n        }\n\n        if (typeof accountSid !== 'undefined') {\n            payload['accountSid'] = accountSid;\n        }\n\n        if (typeof authToken !== 'undefined') {\n            payload['authToken'] = authToken;\n        }\n\n        if (typeof from !== 'undefined') {\n            payload['from'] = from;\n        }\n\n        return await this.client.call('patch', apiPath, {\n            'content-type': 'application/json',\n        }, payload);\n    }\n\n    /**\n     * Create Vonage provider\n     *\n     * Create a new Vonage provider.\n     *\n     * @param {string} providerId\n     * @param {string} name\n     * @param {string} from\n     * @param {string} apiKey\n     * @param {string} apiSecret\n     * @param {boolean} enabled\n     * @throws {AppwriteException}\n     * @returns {Promise}\n     */\n    async createVonageProvider(providerId, name, from, apiKey, apiSecret, enabled) {\n        const apiPath = '/messaging/providers/vonage';\n        let payload = {};\n        if (typeof providerId === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"providerId\"');\n        }\n\n        if (typeof name === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"name\"');\n        }\n\n\n        if (typeof providerId !== 'undefined') {\n            payload['providerId'] = providerId;\n        }\n\n        if (typeof name !== 'undefined') {\n            payload['name'] = name;\n        }\n\n        if (typeof from !== 'undefined') {\n            payload['from'] = from;\n        }\n\n        if (typeof apiKey !== 'undefined') {\n            payload['apiKey'] = apiKey;\n        }\n\n        if (typeof apiSecret !== 'undefined') {\n            payload['apiSecret'] = apiSecret;\n        }\n\n        if (typeof enabled !== 'undefined') {\n            payload['enabled'] = enabled;\n        }\n\n        return await this.client.call('post', apiPath, {\n            'content-type': 'application/json',\n        }, payload);\n    }\n\n    /**\n     * Update Vonage provider\n     *\n     * Update a Vonage provider by its unique ID.\n     *\n     * @param {string} providerId\n     * @param {string} name\n     * @param {boolean} enabled\n     * @param {string} apiKey\n     * @param {string} apiSecret\n     * @param {string} from\n     * @throws {AppwriteException}\n     * @returns {Promise}\n     */\n    async updateVonageProvider(providerId, name, enabled, apiKey, apiSecret, from) {\n        const apiPath = '/messaging/providers/vonage/{providerId}'.replace('{providerId}', providerId);\n        let payload = {};\n        if (typeof providerId === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"providerId\"');\n        }\n\n\n        if (typeof name !== 'undefined') {\n            payload['name'] = name;\n        }\n\n        if (typeof enabled !== 'undefined') {\n            payload['enabled'] = enabled;\n        }\n\n        if (typeof apiKey !== 'undefined') {\n            payload['apiKey'] = apiKey;\n        }\n\n        if (typeof apiSecret !== 'undefined') {\n            payload['apiSecret'] = apiSecret;\n        }\n\n        if (typeof from !== 'undefined') {\n            payload['from'] = from;\n        }\n\n        return await this.client.call('patch', apiPath, {\n            'content-type': 'application/json',\n        }, payload);\n    }\n\n    /**\n     * Get provider\n     *\n     * Get a provider by its unique ID.\n     * \n     *\n     * @param {string} providerId\n     * @throws {AppwriteException}\n     * @returns {Promise}\n     */\n    async getProvider(providerId) {\n        const apiPath = '/messaging/providers/{providerId}'.replace('{providerId}', providerId);\n        let payload = {};\n        if (typeof providerId === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"providerId\"');\n        }\n\n\n        return await this.client.call('get', apiPath, {\n            'content-type': 'application/json',\n        }, payload);\n    }\n\n    /**\n     * Delete provider\n     *\n     * Delete a provider by its unique ID.\n     *\n     * @param {string} providerId\n     * @throws {AppwriteException}\n     * @returns {Promise}\n     */\n    async deleteProvider(providerId) {\n        const apiPath = '/messaging/providers/{providerId}'.replace('{providerId}', providerId);\n        let payload = {};\n        if (typeof providerId === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"providerId\"');\n        }\n\n\n        return await this.client.call('delete', apiPath, {\n            'content-type': 'application/json',\n        }, payload);\n    }\n\n    /**\n     * List provider logs\n     *\n     * Get the provider activity logs listed by its unique ID.\n     *\n     * @param {string} providerId\n     * @param {string[]} queries\n     * @throws {AppwriteException}\n     * @returns {Promise}\n     */\n    async listProviderLogs(providerId, queries) {\n        const apiPath = '/messaging/providers/{providerId}/logs'.replace('{providerId}', providerId);\n        let payload = {};\n        if (typeof providerId === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"providerId\"');\n        }\n\n\n        if (typeof queries !== 'undefined') {\n            payload['queries'] = queries;\n        }\n\n        return await this.client.call('get', apiPath, {\n            'content-type': 'application/json',\n        }, payload);\n    }\n\n    /**\n     * List subscriber logs\n     *\n     * Get the subscriber activity logs listed by its unique ID.\n     *\n     * @param {string} subscriberId\n     * @param {string[]} queries\n     * @throws {AppwriteException}\n     * @returns {Promise}\n     */\n    async listSubscriberLogs(subscriberId, queries) {\n        const apiPath = '/messaging/subscribers/{subscriberId}/logs'.replace('{subscriberId}', subscriberId);\n        let payload = {};\n        if (typeof subscriberId === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"subscriberId\"');\n        }\n\n\n        if (typeof queries !== 'undefined') {\n            payload['queries'] = queries;\n        }\n\n        return await this.client.call('get', apiPath, {\n            'content-type': 'application/json',\n        }, payload);\n    }\n\n    /**\n     * List topics\n     *\n     * Get a list of all topics from the current Appwrite project.\n     *\n     * @param {string[]} queries\n     * @param {string} search\n     * @throws {AppwriteException}\n     * @returns {Promise}\n     */\n    async listTopics(queries, search) {\n        const apiPath = '/messaging/topics';\n        let payload = {};\n\n        if (typeof queries !== 'undefined') {\n            payload['queries'] = queries;\n        }\n\n        if (typeof search !== 'undefined') {\n            payload['search'] = search;\n        }\n\n        return await this.client.call('get', apiPath, {\n            'content-type': 'application/json',\n        }, payload);\n    }\n\n    /**\n     * Create topic\n     *\n     * Create a new topic.\n     *\n     * @param {string} topicId\n     * @param {string} name\n     * @param {string[]} subscribe\n     * @throws {AppwriteException}\n     * @returns {Promise}\n     */\n    async createTopic(topicId, name, subscribe) {\n        const apiPath = '/messaging/topics';\n        let payload = {};\n        if (typeof topicId === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"topicId\"');\n        }\n\n        if (typeof name === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"name\"');\n        }\n\n\n        if (typeof topicId !== 'undefined') {\n            payload['topicId'] = topicId;\n        }\n\n        if (typeof name !== 'undefined') {\n            payload['name'] = name;\n        }\n\n        if (typeof subscribe !== 'undefined') {\n            payload['subscribe'] = subscribe;\n        }\n\n        return await this.client.call('post', apiPath, {\n            'content-type': 'application/json',\n        }, payload);\n    }\n\n    /**\n     * Get topic\n     *\n     * Get a topic by its unique ID.\n     * \n     *\n     * @param {string} topicId\n     * @throws {AppwriteException}\n     * @returns {Promise}\n     */\n    async getTopic(topicId) {\n        const apiPath = '/messaging/topics/{topicId}'.replace('{topicId}', topicId);\n        let payload = {};\n        if (typeof topicId === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"topicId\"');\n        }\n\n\n        return await this.client.call('get', apiPath, {\n            'content-type': 'application/json',\n        }, payload);\n    }\n\n    /**\n     * Update topic\n     *\n     * Update a topic by its unique ID.\n     * \n     *\n     * @param {string} topicId\n     * @param {string} name\n     * @param {string[]} subscribe\n     * @throws {AppwriteException}\n     * @returns {Promise}\n     */\n    async updateTopic(topicId, name, subscribe) {\n        const apiPath = '/messaging/topics/{topicId}'.replace('{topicId}', topicId);\n        let payload = {};\n        if (typeof topicId === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"topicId\"');\n        }\n\n\n        if (typeof name !== 'undefined') {\n            payload['name'] = name;\n        }\n\n        if (typeof subscribe !== 'undefined') {\n            payload['subscribe'] = subscribe;\n        }\n\n        return await this.client.call('patch', apiPath, {\n            'content-type': 'application/json',\n        }, payload);\n    }\n\n    /**\n     * Delete topic\n     *\n     * Delete a topic by its unique ID.\n     *\n     * @param {string} topicId\n     * @throws {AppwriteException}\n     * @returns {Promise}\n     */\n    async deleteTopic(topicId) {\n        const apiPath = '/messaging/topics/{topicId}'.replace('{topicId}', topicId);\n        let payload = {};\n        if (typeof topicId === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"topicId\"');\n        }\n\n\n        return await this.client.call('delete', apiPath, {\n            'content-type': 'application/json',\n        }, payload);\n    }\n\n    /**\n     * List topic logs\n     *\n     * Get the topic activity logs listed by its unique ID.\n     *\n     * @param {string} topicId\n     * @param {string[]} queries\n     * @throws {AppwriteException}\n     * @returns {Promise}\n     */\n    async listTopicLogs(topicId, queries) {\n        const apiPath = '/messaging/topics/{topicId}/logs'.replace('{topicId}', topicId);\n        let payload = {};\n        if (typeof topicId === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"topicId\"');\n        }\n\n\n        if (typeof queries !== 'undefined') {\n            payload['queries'] = queries;\n        }\n\n        return await this.client.call('get', apiPath, {\n            'content-type': 'application/json',\n        }, payload);\n    }\n\n    /**\n     * List subscribers\n     *\n     * Get a list of all subscribers from the current Appwrite project.\n     *\n     * @param {string} topicId\n     * @param {string[]} queries\n     * @param {string} search\n     * @throws {AppwriteException}\n     * @returns {Promise}\n     */\n    async listSubscribers(topicId, queries, search) {\n        const apiPath = '/messaging/topics/{topicId}/subscribers'.replace('{topicId}', topicId);\n        let payload = {};\n        if (typeof topicId === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"topicId\"');\n        }\n\n\n        if (typeof queries !== 'undefined') {\n            payload['queries'] = queries;\n        }\n\n        if (typeof search !== 'undefined') {\n            payload['search'] = search;\n        }\n\n        return await this.client.call('get', apiPath, {\n            'content-type': 'application/json',\n        }, payload);\n    }\n\n    /**\n     * Create subscriber\n     *\n     * Create a new subscriber.\n     *\n     * @param {string} topicId\n     * @param {string} subscriberId\n     * @param {string} targetId\n     * @throws {AppwriteException}\n     * @returns {Promise}\n     */\n    async createSubscriber(topicId, subscriberId, targetId) {\n        const apiPath = '/messaging/topics/{topicId}/subscribers'.replace('{topicId}', topicId);\n        let payload = {};\n        if (typeof topicId === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"topicId\"');\n        }\n\n        if (typeof subscriberId === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"subscriberId\"');\n        }\n\n        if (typeof targetId === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"targetId\"');\n        }\n\n\n        if (typeof subscriberId !== 'undefined') {\n            payload['subscriberId'] = subscriberId;\n        }\n\n        if (typeof targetId !== 'undefined') {\n            payload['targetId'] = targetId;\n        }\n\n        return await this.client.call('post', apiPath, {\n            'content-type': 'application/json',\n        }, payload);\n    }\n\n    /**\n     * Get subscriber\n     *\n     * Get a subscriber by its unique ID.\n     * \n     *\n     * @param {string} topicId\n     * @param {string} subscriberId\n     * @throws {AppwriteException}\n     * @returns {Promise}\n     */\n    async getSubscriber(topicId, subscriberId) {\n        const apiPath = '/messaging/topics/{topicId}/subscribers/{subscriberId}'.replace('{topicId}', topicId).replace('{subscriberId}', subscriberId);\n        let payload = {};\n        if (typeof topicId === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"topicId\"');\n        }\n\n        if (typeof subscriberId === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"subscriberId\"');\n        }\n\n\n        return await this.client.call('get', apiPath, {\n            'content-type': 'application/json',\n        }, payload);\n    }\n\n    /**\n     * Delete subscriber\n     *\n     * Delete a subscriber by its unique ID.\n     *\n     * @param {string} topicId\n     * @param {string} subscriberId\n     * @throws {AppwriteException}\n     * @returns {Promise}\n     */\n    async deleteSubscriber(topicId, subscriberId) {\n        const apiPath = '/messaging/topics/{topicId}/subscribers/{subscriberId}'.replace('{topicId}', topicId).replace('{subscriberId}', subscriberId);\n        let payload = {};\n        if (typeof topicId === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"topicId\"');\n        }\n\n        if (typeof subscriberId === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"subscriberId\"');\n        }\n\n\n        return await this.client.call('delete', apiPath, {\n            'content-type': 'application/json',\n        }, payload);\n    }\n}\n\nmodule.exports = Messaging;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFjdGlvbi1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9ub2RlLWFwcHdyaXRlL2xpYi9zZXJ2aWNlcy9tZXNzYWdpbmcuanMiLCJtYXBwaW5ncyI6IkFBQUEsZ0JBQWdCLG1CQUFPLENBQUMsbUZBQWU7QUFDdkMsMEJBQTBCLG1CQUFPLENBQUMsdUZBQWlCO0FBQ25ELGtCQUFrQixtQkFBTyxDQUFDLHVGQUFpQjtBQUMzQyxlQUFlLG1CQUFPLENBQUMsaUZBQWM7QUFDckMsZUFBZSxtQkFBTyxDQUFDLHNCQUFRO0FBQy9CLFFBQVEsWUFBWSxFQUFFLG1CQUFPLENBQUMsa0JBQU07QUFDcEMsV0FBVyxtQkFBTyxDQUFDLGNBQUk7QUFDdkIsUUFBUSxPQUFPLEVBQUUsbUJBQU8sQ0FBQyxzQkFBUTtBQUNqQyxjQUFjLG1CQUFPLENBQUMsK0VBQWE7O0FBRW5DOztBQUVBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxVQUFVO0FBQ3pCLGVBQWUsUUFBUTtBQUN2QixnQkFBZ0I7QUFDaEIsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFNBQVM7QUFDVDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsUUFBUTtBQUN2QixlQUFlLFFBQVE7QUFDdkIsZUFBZSxVQUFVO0FBQ3pCLGVBQWUsVUFBVTtBQUN6QixlQUFlLFVBQVU7QUFDekIsZUFBZSxVQUFVO0FBQ3pCLGVBQWUsVUFBVTtBQUN6QixlQUFlLFVBQVU7QUFDekIsZUFBZSxTQUFTO0FBQ3hCLGVBQWUsU0FBUztBQUN4QixlQUFlLFFBQVE7QUFDdkIsZ0JBQWdCO0FBQ2hCLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FB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Y2VzIjpbIndlYnBhY2s6Ly9qc21fYmFua2luZy8uL25vZGVfbW9kdWxlcy9ub2RlLWFwcHdyaXRlL2xpYi9zZXJ2aWNlcy9tZXNzYWdpbmcuanM/M2Q1NSJdLCJzb3VyY2VzQ29udGVudCI6WyJjb25zdCBTZXJ2aWNlID0gcmVxdWlyZSgnLi4vc2VydmljZS5qcycpO1xuY29uc3QgQXBwd3JpdGVFeGNlcHRpb24gPSByZXF1aXJlKCcuLi9leGNlcHRpb24uanMnKTtcbmNvbnN0IElucHV0RmlsZSA9IHJlcXVpcmUoJy4uL2lucHV0RmlsZS5qcycpO1xuY29uc3QgY2xpZW50ID0gcmVxdWlyZSgnLi4vY2xpZW50LmpzJyk7XG5jb25zdCBTdHJlYW0gPSByZXF1aXJlKCdzdHJlYW0nKTtcbmNvbnN0IHsgcHJvbWlzaWZ5IH0gPSByZXF1aXJlKCd1dGlsJyk7XG5jb25zdCBmcyA9IHJlcXVpcmUoJ2ZzJyk7XG5jb25zdCB7IEZpbGUgfSA9IHJlcXVpcmUoJ3VuZGljaScpO1xuY29uc3QgUXVlcnkgPSByZXF1aXJlKCcuLi9xdWVyeS5qcycpO1xuXG5jbGFzcyBNZXNzYWdpbmcgZXh0ZW5kcyBTZXJ2aWNlIHtcblxuICAgICBjb25zdHJ1Y3RvcihjbGllbnQpXG4gICAgIHtcbiAgICAgICAgc3VwZXIoY2xpZW50KTtcbiAgICAgfVxuXG5cbiAgICAvKipcbiAgICAgKiBMaXN0IG1lc3NhZ2VzXG4gICAgICpcbiAgICAgKiBHZXQgYSBsaXN0IG9mIGFsbCBtZXNzYWdlcyBmcm9tIHRoZSBjdXJyZW50IEFwcHdyaXRlIHByb2plY3QuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZ1tdfSBxdWVyaWVzXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHNlYXJjaFxuICAgICAqIEB0aHJvd3Mge0FwcHdyaXRlRXhjZXB0aW9ufVxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlfVxuICAgICAqL1xuICAgIGFzeW5jIGxpc3RNZXNzYWdlcyhxdWVyaWVzLCBzZWFyY2gpIHtcbiAgICAgICAgY29uc3QgYXBpUGF0aCA9ICcvbWVzc2FnaW5nL21lc3NhZ2VzJztcbiAgICAgICAgbGV0IHBheWxvYWQgPSB7fTtcblxuICAgICAgICBpZiAodHlwZW9mIHF1ZXJpZXMgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICBwYXlsb2FkWydxdWVyaWVzJ10gPSBxdWVyaWVzO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHR5cGVvZiBzZWFyY2ggIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICBwYXlsb2FkWydzZWFyY2gnXSA9IHNlYXJjaDtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBhd2FpdCB0aGlzLmNsaWVudC5jYWxsKCdnZXQnLCBhcGlQYXRoLCB7XG4gICAgICAgICAgICAnY29udGVudC10eXBlJzogJ2FwcGxpY2F0aW9uL2pzb24nLFxuICAgICAgICB9LCBwYXlsb2FkKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGUgZW1haWxcbiAgICAgKlxuICAgICAqIENyZWF0ZSBhIG5ldyBlbWFpbCBtZXNzYWdlLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IG1lc3NhZ2VJZFxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBzdWJqZWN0XG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGNvbnRlbnRcbiAgICAgKiBAcGFyYW0ge3N0cmluZ1tdfSB0b3BpY3NcbiAgICAgKiBAcGFyYW0ge3N0cmluZ1tdfSB1c2Vyc1xuICAgICAqIEBwYXJhbSB7c3RyaW5nW119IHRhcmdldHNcbiAgICAgKiBAcGFyYW0ge3N0cmluZ1tdfSBjY1xuICAgICAqIEBwYXJhbSB7c3RyaW5nW119IGJjY1xuICAgICAqIEBwYXJhbSB7c3RyaW5nW119IGF0dGFjaG1lbnRzXG4gICAgICogQHBhcmFtIHtib29sZWFufSBkcmFmdFxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gaHRtbFxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBzY2hlZHVsZWRBdFxuICAgICAqIEB0aHJvd3Mge0FwcHdyaXRlRXhjZXB0aW9ufVxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlfVxuICAgICAqL1xuICAgIGFzeW5jIGNyZWF0ZUVtYWlsKG1lc3NhZ2VJZCwgc3ViamVjdCwgY29udGVudCwgdG9waWNzLCB1c2VycywgdGFyZ2V0cywgY2MsIGJjYywgYXR0YWNobWVudHMsIGRyYWZ0LCBodG1sLCBzY2hlZHVsZWRBdCkge1xuICAgICAgICBjb25zdCBhcGlQYXRoID0gJy9tZXNzYWdpbmcvbWVzc2FnZXMvZW1haWwnO1xuICAgICAgICBsZXQgcGF5bG9hZCA9IHt9O1xuICAgICAgICBpZiAodHlwZW9mIG1lc3NhZ2VJZCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBBcHB3cml0ZUV4Y2VwdGlvbignTWlzc2luZyByZXF1aXJlZCBwYXJhbWV0ZXI6IFwibWVzc2FnZUlkXCInKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0eXBlb2Ygc3ViamVjdCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBBcHB3cml0ZUV4Y2VwdGlvbignTWlzc2luZyByZXF1aXJlZCBwYXJhbWV0ZXI6IFwic3ViamVjdFwiJyk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodHlwZW9mIGNvbnRlbnQgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgQXBwd3JpdGVFeGNlcHRpb24oJ01pc3NpbmcgcmVxdWlyZWQgcGFyYW1ldGVyOiBcImNvbnRlbnRcIicpO1xuICAgICAgICB9XG5cblxuICAgICAgICBpZiAodHlwZW9mIG1lc3NhZ2VJZCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHBheWxvYWRbJ21lc3NhZ2VJZCddID0gbWVzc2FnZUlkO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHR5cGVvZiBzdWJqZWN0ICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgcGF5bG9hZFsnc3ViamVjdCddID0gc3ViamVjdDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0eXBlb2YgY29udGVudCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHBheWxvYWRbJ2NvbnRlbnQnXSA9IGNvbnRlbnQ7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodHlwZW9mIHRvcGljcyAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHBheWxvYWRbJ3RvcGljcyddID0gdG9waWNzO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHR5cGVvZiB1c2VycyAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHBheWxvYWRbJ3VzZXJzJ10gPSB1c2VycztcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0eXBlb2YgdGFyZ2V0cyAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHBheWxvYWRbJ3RhcmdldHMnXSA9IHRhcmdldHM7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodHlwZW9mIGNjICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgcGF5bG9hZFsnY2MnXSA9IGNjO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHR5cGVvZiBiY2MgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICBwYXlsb2FkWydiY2MnXSA9IGJjYztcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0eXBlb2YgYXR0YWNobWVudHMgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICBwYXlsb2FkWydhdHRhY2htZW50cyddID0gYXR0YWNobWVudHM7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodHlwZW9mIGRyYWZ0ICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgcGF5bG9hZFsnZHJhZnQnXSA9IGRyYWZ0O1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHR5cGVvZiBodG1sICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgcGF5bG9hZFsnaHRtbCddID0gaHRtbDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0eXBlb2Ygc2NoZWR1bGVkQXQgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICBwYXlsb2FkWydzY2hlZHVsZWRBdCddID0gc2NoZWR1bGVkQXQ7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy5jbGllbnQuY2FsbCgncG9zdCcsIGFwaVBhdGgsIHtcbiAgICAgICAgICAgICdjb250ZW50LXR5cGUnOiAnYXBwbGljYXRpb24vanNvbicsXG4gICAgICAgIH0sIHBheWxvYWQpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFVwZGF0ZSBlbWFpbFxuICAgICAqXG4gICAgICogVXBkYXRlIGFuIGVtYWlsIG1lc3NhZ2UgYnkgaXRzIHVuaXF1ZSBJRC5cbiAgICAgKiBcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBtZXNzYWdlSWRcbiAgICAgKiBAcGFyYW0ge3N0cmluZ1tdfSB0b3BpY3NcbiAgICAgKiBAcGFyYW0ge3N0cmluZ1tdfSB1c2Vyc1xuICAgICAqIEBwYXJhbSB7c3RyaW5nW119IHRhcmdldHNcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gc3ViamVjdFxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBjb250ZW50XG4gICAgICogQHBhcmFtIHtib29sZWFufSBkcmFmdFxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gaHRtbFxuICAgICAqIEBwYXJhbSB7c3RyaW5nW119IGNjXG4gICAgICogQHBhcmFtIHtzdHJpbmdbXX0gYmNjXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHNjaGVkdWxlZEF0XG4gICAgICogQHRocm93cyB7QXBwd3JpdGVFeGNlcHRpb259XG4gICAgICogQHJldHVybnMge1Byb21pc2V9XG4gICAgICovXG4gICAgYXN5bmMgdXBkYXRlRW1haWwobWVzc2FnZUlkLCB0b3BpY3MsIHVzZXJzLCB0YXJnZXRzLCBzdWJqZWN0LCBjb250ZW50LCBkcmFmdCwgaHRtbCwgY2MsIGJjYywgc2NoZWR1bGVkQXQpIHtcbiAgICAgICAgY29uc3QgYXBpUGF0aCA9ICcvbWVzc2FnaW5nL21lc3NhZ2VzL2VtYWlsL3ttZXNzYWdlSWR9Jy5yZXBsYWNlKCd7bWVzc2FnZUlkfScsIG1lc3NhZ2VJZCk7XG4gICAgICAgIGxldCBwYXlsb2FkID0ge307XG4gICAgICAgIGlmICh0eXBlb2YgbWVzc2FnZUlkID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEFwcHdyaXRlRXhjZXB0aW9uKCdNaXNzaW5nIHJlcXVpcmVkIHBhcmFtZXRlcjogXCJtZXNzYWdlSWRcIicpO1xuICAgICAgICB9XG5cblxuICAgICAgICBpZiAodHlwZW9mIHRvcGljcyAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHBheWxvYWRbJ3RvcGljcyddID0gdG9waWNzO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHR5cGVvZiB1c2VycyAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHBheWxvYWRbJ3VzZXJzJ10gPSB1c2VycztcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0eXBlb2YgdGFyZ2V0cyAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHBheWxvYWRbJ3RhcmdldHMnXSA9IHRhcmdldHM7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodHlwZW9mIHN1YmplY3QgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICBwYXlsb2FkWydzdWJqZWN0J10gPSBzdWJqZWN0O1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHR5cGVvZiBjb250ZW50ICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgcGF5bG9hZFsnY29udGVudCddID0gY29udGVudDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0eXBlb2YgZHJhZnQgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICBwYXlsb2FkWydkcmFmdCddID0gZHJhZnQ7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodHlwZW9mIGh0bWwgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICBwYXlsb2FkWydodG1sJ10gPSBodG1sO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHR5cGVvZiBjYyAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHBheWxvYWRbJ2NjJ10gPSBjYztcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0eXBlb2YgYmNjICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgcGF5bG9hZFsnYmNjJ10gPSBiY2M7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodHlwZW9mIHNjaGVkdWxlZEF0ICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgcGF5bG9hZFsnc2NoZWR1bGVkQXQnXSA9IHNjaGVkdWxlZEF0O1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMuY2xpZW50LmNhbGwoJ3BhdGNoJywgYXBpUGF0aCwge1xuICAgICAgICAgICAgJ2NvbnRlbnQtdHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJyxcbiAgICAgICAgfSwgcGF5bG9hZCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlIHB1c2ggbm90aWZpY2F0aW9uXG4gICAgICpcbiAgICAgKiBDcmVhdGUgYSBuZXcgcHVzaCBub3RpZmljYXRpb24uXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gbWVzc2FnZUlkXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHRpdGxlXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGJvZHlcbiAgICAgKiBAcGFyYW0ge3N0cmluZ1tdfSB0b3BpY3NcbiAgICAgKiBAcGFyYW0ge3N0cmluZ1tdfSB1c2Vyc1xuICAgICAqIEBwYXJhbSB7c3RyaW5nW119IHRhcmdldHNcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gZGF0YVxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBhY3Rpb25cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gaW1hZ2VcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gaWNvblxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBzb3VuZFxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBjb2xvclxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSB0YWdcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gYmFkZ2VcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IGRyYWZ0XG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHNjaGVkdWxlZEF0XG4gICAgICogQHRocm93cyB7QXBwd3JpdGVFeGNlcHRpb259XG4gICAgICogQHJldHVybnMge1Byb21pc2V9XG4gICAgICovXG4gICAgYXN5bmMgY3JlYXRlUHVzaChtZXNzYWdlSWQsIHRpdGxlLCBib2R5LCB0b3BpY3MsIHVzZXJzLCB0YXJnZXRzLCBkYXRhLCBhY3Rpb24sIGltYWdlLCBpY29uLCBzb3VuZCwgY29sb3IsIHRhZywgYmFkZ2UsIGRyYWZ0LCBzY2hlZHVsZWRBdCkge1xuICAgICAgICBjb25zdCBhcGlQYXRoID0gJy9tZXNzYWdpbmcvbWVzc2FnZXMvcHVzaCc7XG4gICAgICAgIGxldCBwYXlsb2FkID0ge307XG4gICAgICAgIGlmICh0eXBlb2YgbWVzc2FnZUlkID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEFwcHdyaXRlRXhjZXB0aW9uKCdNaXNzaW5nIHJlcXVpcmVkIHBhcmFtZXRlcjogXCJtZXNzYWdlSWRcIicpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHR5cGVvZiB0aXRsZSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBBcHB3cml0ZUV4Y2VwdGlvbignTWlzc2luZyByZXF1aXJlZCBwYXJhbWV0ZXI6IFwidGl0bGVcIicpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHR5cGVvZiBib2R5ID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEFwcHdyaXRlRXhjZXB0aW9uKCdNaXNzaW5nIHJlcXVpcmVkIHBhcmFtZXRlcjogXCJib2R5XCInKTtcbiAgICAgICAgfVxuXG5cbiAgICAgICAgaWYgKHR5cGVvZiBtZXNzYWdlSWQgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICBwYXlsb2FkWydtZXNzYWdlSWQnXSA9IG1lc3NhZ2VJZDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0eXBlb2YgdGl0bGUgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICBwYXlsb2FkWyd0aXRsZSddID0gdGl0bGU7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodHlwZW9mIGJvZHkgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICBwYXlsb2FkWydib2R5J10gPSBib2R5O1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHR5cGVvZiB0b3BpY3MgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICBwYXlsb2FkWyd0b3BpY3MnXSA9IHRvcGljcztcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0eXBlb2YgdXNlcnMgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICBwYXlsb2FkWyd1c2VycyddID0gdXNlcnM7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodHlwZW9mIHRhcmdldHMgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICBwYXlsb2FkWyd0YXJnZXRzJ10gPSB0YXJnZXRzO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHR5cGVvZiBkYXRhICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgcGF5bG9hZFsnZGF0YSddID0gZGF0YTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0eXBlb2YgYWN0aW9uICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgcGF5bG9hZFsnYWN0aW9uJ10gPSBhY3Rpb247XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodHlwZW9mIGltYWdlICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgcGF5bG9hZFsnaW1hZ2UnXSA9IGltYWdlO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHR5cGVvZiBpY29uICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgcGF5bG9hZFsnaWNvbiddID0gaWNvbjtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0eXBlb2Ygc291bmQgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICBwYXlsb2FkWydzb3VuZCddID0gc291bmQ7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodHlwZW9mIGNvbG9yICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgcGF5bG9hZFsnY29sb3InXSA9IGNvbG9yO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHR5cGVvZiB0YWcgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICBwYXlsb2FkWyd0YWcnXSA9IHRhZztcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0eXBlb2YgYmFkZ2UgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICBwYXlsb2FkWydiYWRnZSddID0gYmFkZ2U7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodHlwZW9mIGRyYWZ0ICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgcGF5bG9hZFsnZHJhZnQnXSA9IGRyYWZ0O1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHR5cGVvZiBzY2hlZHVsZWRBdCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHBheWxvYWRbJ3NjaGVkdWxlZEF0J10gPSBzY2hlZHVsZWRBdDtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBhd2FpdCB0aGlzLmNsaWVudC5jYWxsKCdwb3N0JywgYXBpUGF0aCwge1xuICAgICAgICAgICAgJ2NvbnRlbnQtdHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJyxcbiAgICAgICAgfSwgcGF5bG9hZCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVXBkYXRlIHB1c2ggbm90aWZpY2F0aW9uXG4gICAgICpcbiAgICAgKiBVcGRhdGUgYSBwdXNoIG5vdGlmaWNhdGlvbiBieSBpdHMgdW5pcXVlIElELlxuICAgICAqIFxuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IG1lc3NhZ2VJZFxuICAgICAqIEBwYXJhbSB7c3RyaW5nW119IHRvcGljc1xuICAgICAqIEBwYXJhbSB7c3RyaW5nW119IHVzZXJzXG4gICAgICogQHBhcmFtIHtzdHJpbmdbXX0gdGFyZ2V0c1xuICAgICAqIEBwYXJhbSB7c3RyaW5nfSB0aXRsZVxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBib2R5XG4gICAgICogQHBhcmFtIHtvYmplY3R9IGRhdGFcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gYWN0aW9uXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGltYWdlXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGljb25cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gc291bmRcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gY29sb3JcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gdGFnXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGJhZGdlXG4gICAgICogQHBhcmFtIHtib29sZWFufSBkcmFmdFxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBzY2hlZHVsZWRBdFxuICAgICAqIEB0aHJvd3Mge0FwcHdyaXRlRXhjZXB0aW9ufVxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlfVxuICAgICAqL1xuICAgIGFzeW5jIHVwZGF0ZVB1c2gobWVzc2FnZUlkLCB0b3BpY3MsIHVzZXJzLCB0YXJnZXRzLCB0aXRsZSwgYm9keSwgZGF0YSwgYWN0aW9uLCBpbWFnZSwgaWNvbiwgc291bmQsIGNvbG9yLCB0YWcsIGJhZGdlLCBkcmFmdCwgc2NoZWR1bGVkQXQpIHtcbiAgICAgICAgY29uc3QgYXBpUGF0aCA9ICcvbWVzc2FnaW5nL21lc3NhZ2VzL3B1c2gve21lc3NhZ2VJZH0nLnJlcGxhY2UoJ3ttZXNzYWdlSWR9JywgbWVzc2FnZUlkKTtcbiAgICAgICAgbGV0IHBheWxvYWQgPSB7fTtcbiAgICAgICAgaWYgKHR5cGVvZiBtZXNzYWdlSWQgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgQXBwd3JpdGVFeGNlcHRpb24oJ01pc3NpbmcgcmVxdWlyZWQgcGFyYW1ldGVyOiBcIm1lc3NhZ2VJZFwiJyk7XG4gICAgICAgIH1cblxuXG4gICAgICAgIGlmICh0eXBlb2YgdG9waWNzICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgcGF5bG9hZFsndG9waWNzJ10gPSB0b3BpY3M7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodHlwZW9mIHVzZXJzICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgcGF5bG9hZFsndXNlcnMnXSA9IHVzZXJzO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHR5cGVvZiB0YXJnZXRzICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgcGF5bG9hZFsndGFyZ2V0cyddID0gdGFyZ2V0cztcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0eXBlb2YgdGl0bGUgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICBwYXlsb2FkWyd0aXRsZSddID0gdGl0bGU7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodHlwZW9mIGJvZHkgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICBwYXlsb2FkWydib2R5J10gPSBib2R5O1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHR5cGVvZiBkYXRhICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgcGF5bG9hZFsnZGF0YSddID0gZGF0YTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0eXBlb2YgYWN0aW9uICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgcGF5bG9hZFsnYWN0aW9uJ10gPSBhY3Rpb247XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodHlwZW9mIGltYWdlICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgcGF5bG9hZFsnaW1hZ2UnXSA9IGltYWdlO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHR5cGVvZiBpY29uICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgcGF5bG9hZFsnaWNvbiddID0gaWNvbjtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0eXBlb2Ygc291bmQgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICBwYXlsb2FkWydzb3VuZCddID0gc291bmQ7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodHlwZW9mIGNvbG9yICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgcGF5bG9hZFsnY29sb3InXSA9IGNvbG9yO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHR5cGVvZiB0YWcgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICBwYXlsb2FkWyd0YWcnXSA9IHRhZztcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0eXBlb2YgYmFkZ2UgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICBwYXlsb2FkWydiYWRnZSddID0gYmFkZ2U7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodHlwZW9mIGRyYWZ0ICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgcGF5bG9hZFsnZHJhZnQnXSA9IGRyYWZ0O1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHR5cGVvZiBzY2hlZHVsZWRBdCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHBheWxvYWRbJ3NjaGVkdWxlZEF0J10gPSBzY2hlZHVsZWRBdDtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBhd2FpdCB0aGlzLmNsaWVudC5jYWxsKCdwYXRjaCcsIGFwaVBhdGgsIHtcbiAgICAgICAgICAgICdjb250ZW50LXR5cGUnOiAnYXBwbGljYXRpb24vanNvbicsXG4gICAgICAgIH0sIHBheWxvYWQpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZSBTTVNcbiAgICAgKlxuICAgICAqIENyZWF0ZSBhIG5ldyBTTVMgbWVzc2FnZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBtZXNzYWdlSWRcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gY29udGVudFxuICAgICAqIEBwYXJhbSB7c3RyaW5nW119IHRvcGljc1xuICAgICAqIEBwYXJhbSB7c3RyaW5nW119IHVzZXJzXG4gICAgICogQHBhcmFtIHtzdHJpbmdbXX0gdGFyZ2V0c1xuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gZHJhZnRcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gc2NoZWR1bGVkQXRcbiAgICAgKiBAdGhyb3dzIHtBcHB3cml0ZUV4Y2VwdGlvbn1cbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZX1cbiAgICAgKi9cbiAgICBhc3luYyBjcmVhdGVTbXMobWVzc2FnZUlkLCBjb250ZW50LCB0b3BpY3MsIHVzZXJzLCB0YXJnZXRzLCBkcmFmdCwgc2NoZWR1bGVkQXQpIHtcbiAgICAgICAgY29uc3QgYXBpUGF0aCA9ICcvbWVzc2FnaW5nL21lc3NhZ2VzL3Ntcyc7XG4gICAgICAgIGxldCBwYXlsb2FkID0ge307XG4gICAgICAgIGlmICh0eXBlb2YgbWVzc2FnZUlkID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEFwcHdyaXRlRXhjZXB0aW9uKCdNaXNzaW5nIHJlcXVpcmVkIHBhcmFtZXRlcjogXCJtZXNzYWdlSWRcIicpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHR5cGVvZiBjb250ZW50ID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEFwcHdyaXRlRXhjZXB0aW9uKCdNaXNzaW5nIHJlcXVpcmVkIHBhcmFtZXRlcjogXCJjb250ZW50XCInKTtcbiAgICAgICAgfVxuXG5cbiAgICAgICAgaWYgKHR5cGVvZiBtZXNzYWdlSWQgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICBwYXlsb2FkWydtZXNzYWdlSWQnXSA9IG1lc3NhZ2VJZDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0eXBlb2YgY29udGVudCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHBheWxvYWRbJ2NvbnRlbnQnXSA9IGNvbnRlbnQ7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodHlwZW9mIHRvcGljcyAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHBheWxvYWRbJ3RvcGljcyddID0gdG9waWNzO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHR5cGVvZiB1c2VycyAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHBheWxvYWRbJ3VzZXJzJ10gPSB1c2VycztcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0eXBlb2YgdGFyZ2V0cyAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHBheWxvYWRbJ3RhcmdldHMnXSA9IHRhcmdldHM7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodHlwZW9mIGRyYWZ0ICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgcGF5bG9hZFsnZHJhZnQnXSA9IGRyYWZ0O1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHR5cGVvZiBzY2hlZHVsZWRBdCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHBheWxvYWRbJ3NjaGVkdWxlZEF0J10gPSBzY2hlZHVsZWRBdDtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBhd2FpdCB0aGlzLmNsaWVudC5jYWxsKCdwb3N0JywgYXBpUGF0aCwge1xuICAgICAgICAgICAgJ2NvbnRlbnQtdHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJyxcbiAgICAgICAgfSwgcGF5bG9hZCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVXBkYXRlIFNNU1xuICAgICAqXG4gICAgICogVXBkYXRlIGFuIGVtYWlsIG1lc3NhZ2UgYnkgaXRzIHVuaXF1ZSBJRC5cbiAgICAgKiBcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBtZXNzYWdlSWRcbiAgICAgKiBAcGFyYW0ge3N0cmluZ1tdfSB0b3BpY3NcbiAgICAgKiBAcGFyYW0ge3N0cmluZ1tdfSB1c2Vyc1xuICAgICAqIEBwYXJhbSB7c3RyaW5nW119IHRhcmdldHNcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gY29udGVudFxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gZHJhZnRcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gc2NoZWR1bGVkQXRcbiAgICAgKiBAdGhyb3dzIHtBcHB3cml0ZUV4Y2VwdGlvbn1cbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZX1cbiAgICAgKi9cbiAgICBhc3luYyB1cGRhdGVTbXMobWVzc2FnZUlkLCB0b3BpY3MsIHVzZXJzLCB0YXJnZXRzLCBjb250ZW50LCBkcmFmdCwgc2NoZWR1bGVkQXQpIHtcbiAgICAgICAgY29uc3QgYXBpUGF0aCA9ICcvbWVzc2FnaW5nL21lc3NhZ2VzL3Ntcy97bWVzc2FnZUlkfScucmVwbGFjZSgne21lc3NhZ2VJZH0nLCBtZXNzYWdlSWQpO1xuICAgICAgICBsZXQgcGF5bG9hZCA9IHt9O1xuICAgICAgICBpZiAodHlwZW9mIG1lc3NhZ2VJZCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBBcHB3cml0ZUV4Y2VwdGlvbignTWlzc2luZyByZXF1aXJlZCBwYXJhbWV0ZXI6IFwibWVzc2FnZUlkXCInKTtcbiAgICAgICAgfVxuXG5cbiAgICAgICAgaWYgKHR5cGVvZiB0b3BpY3MgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICBwYXlsb2FkWyd0b3BpY3MnXSA9IHRvcGljcztcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0eXBlb2YgdXNlcnMgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICBwYXlsb2FkWyd1c2VycyddID0gdXNlcnM7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodHlwZW9mIHRhcmdldHMgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICBwYXlsb2FkWyd0YXJnZXRzJ10gPSB0YXJnZXRzO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHR5cGVvZiBjb250ZW50ICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgcGF5bG9hZFsnY29udGVudCddID0gY29udGVudDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0eXBlb2YgZHJhZnQgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICBwYXlsb2FkWydkcmFmdCddID0gZHJhZnQ7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodHlwZW9mIHNjaGVkdWxlZEF0ICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgcGF5bG9hZFsnc2NoZWR1bGVkQXQnXSA9IHNjaGVkdWxlZEF0O1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMuY2xpZW50LmNhbGwoJ3BhdGNoJywgYXBpUGF0aCwge1xuICAgICAgICAgICAgJ2NvbnRlbnQtdHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJyxcbiAgICAgICAgfSwgcGF5bG9hZCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2V0IG1lc3NhZ2VcbiAgICAgKlxuICAgICAqIEdldCBhIG1lc3NhZ2UgYnkgaXRzIHVuaXF1ZSBJRC5cbiAgICAgKiBcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBtZXNzYWdlSWRcbiAgICAgKiBAdGhyb3dzIHtBcHB3cml0ZUV4Y2VwdGlvbn1cbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZX1cbiAgICAgKi9cbiAgICBhc3luYyBnZXRNZXNzYWdlKG1lc3NhZ2VJZCkge1xuICAgICAgICBjb25zdCBhcGlQYXRoID0gJy9tZXNzYWdpbmcvbWVzc2FnZXMve21lc3NhZ2VJZH0nLnJlcGxhY2UoJ3ttZXNzYWdlSWR9JywgbWVzc2FnZUlkKTtcbiAgICAgICAgbGV0IHBheWxvYWQgPSB7fTtcbiAgICAgICAgaWYgKHR5cGVvZiBtZXNzYWdlSWQgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgQXBwd3JpdGVFeGNlcHRpb24oJ01pc3NpbmcgcmVxdWlyZWQgcGFyYW1ldGVyOiBcIm1lc3NhZ2VJZFwiJyk7XG4gICAgICAgIH1cblxuXG4gICAgICAgIHJldHVybiBhd2FpdCB0aGlzLmNsaWVudC5jYWxsKCdnZXQnLCBhcGlQYXRoLCB7XG4gICAgICAgICAgICAnY29udGVudC10eXBlJzogJ2FwcGxpY2F0aW9uL2pzb24nLFxuICAgICAgICB9LCBwYXlsb2FkKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBEZWxldGUgbWVzc2FnZVxuICAgICAqXG4gICAgICogRGVsZXRlIGEgbWVzc2FnZS4gSWYgdGhlIG1lc3NhZ2UgaXMgbm90IGEgZHJhZnQgb3Igc2NoZWR1bGVkLCBidXQgaGFzIGJlZW5cbiAgICAgKiBzZW50LCB0aGlzIHdpbGwgbm90IHJlY2FsbCB0aGUgbWVzc2FnZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBtZXNzYWdlSWRcbiAgICAgKiBAdGhyb3dzIHtBcHB3cml0ZUV4Y2VwdGlvbn1cbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZX1cbiAgICAgKi9cbiAgICBhc3luYyBkZWxldGUobWVzc2FnZUlkKSB7XG4gICAgICAgIGNvbnN0IGFwaVBhdGggPSAnL21lc3NhZ2luZy9tZXNzYWdlcy97bWVzc2FnZUlkfScucmVwbGFjZSgne21lc3NhZ2VJZH0nLCBtZXNzYWdlSWQpO1xuICAgICAgICBsZXQgcGF5bG9hZCA9IHt9O1xuICAgICAgICBpZiAodHlwZW9mIG1lc3NhZ2VJZCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBBcHB3cml0ZUV4Y2VwdGlvbignTWlzc2luZyByZXF1aXJlZCBwYXJhbWV0ZXI6IFwibWVzc2FnZUlkXCInKTtcbiAgICAgICAgfVxuXG5cbiAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMuY2xpZW50LmNhbGwoJ2RlbGV0ZScsIGFwaVBhdGgsIHtcbiAgICAgICAgICAgICdjb250ZW50LXR5cGUnOiAnYXBwbGljYXRpb24vanNvbicsXG4gICAgICAgIH0sIHBheWxvYWQpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIExpc3QgbWVzc2FnZSBsb2dzXG4gICAgICpcbiAgICAgKiBHZXQgdGhlIG1lc3NhZ2UgYWN0aXZpdHkgbG9ncyBsaXN0ZWQgYnkgaXRzIHVuaXF1ZSBJRC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBtZXNzYWdlSWRcbiAgICAgKiBAcGFyYW0ge3N0cmluZ1tdfSBxdWVyaWVzXG4gICAgICogQHRocm93cyB7QXBwd3JpdGVFeGNlcHRpb259XG4gICAgICogQHJldHVybnMge1Byb21pc2V9XG4gICAgICovXG4gICAgYXN5bmMgbGlzdE1lc3NhZ2VMb2dzKG1lc3NhZ2VJZCwgcXVlcmllcykge1xuICAgICAgICBjb25zdCBhcGlQYXRoID0gJy9tZXNzYWdpbmcvbWVzc2FnZXMve21lc3NhZ2VJZH0vbG9ncycucmVwbGFjZSgne21lc3NhZ2VJZH0nLCBtZXNzYWdlSWQpO1xuICAgICAgICBsZXQgcGF5bG9hZCA9IHt9O1xuICAgICAgICBpZiAodHlwZW9mIG1lc3NhZ2VJZCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBBcHB3cml0ZUV4Y2VwdGlvbignTWlzc2luZyByZXF1aXJlZCBwYXJhbWV0ZXI6IFwibWVzc2FnZUlkXCInKTtcbiAgICAgICAgfVxuXG5cbiAgICAgICAgaWYgKHR5cGVvZiBxdWVyaWVzICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgcGF5bG9hZFsncXVlcmllcyddID0gcXVlcmllcztcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBhd2FpdCB0aGlzLmNsaWVudC5jYWxsKCdnZXQnLCBhcGlQYXRoLCB7XG4gICAgICAgICAgICAnY29udGVudC10eXBlJzogJ2FwcGxpY2F0aW9uL2pzb24nLFxuICAgICAgICB9LCBwYXlsb2FkKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBMaXN0IG1lc3NhZ2UgdGFyZ2V0c1xuICAgICAqXG4gICAgICogR2V0IGEgbGlzdCBvZiB0aGUgdGFyZ2V0cyBhc3NvY2lhdGVkIHdpdGggYSBtZXNzYWdlLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IG1lc3NhZ2VJZFxuICAgICAqIEBwYXJhbSB7c3RyaW5nW119IHF1ZXJpZXNcbiAgICAgKiBAdGhyb3dzIHtBcHB3cml0ZUV4Y2VwdGlvbn1cbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZX1cbiAgICAgKi9cbiAgICBhc3luYyBsaXN0VGFyZ2V0cyhtZXNzYWdlSWQsIHF1ZXJpZXMpIHtcbiAgICAgICAgY29uc3QgYXBpUGF0aCA9ICcvbWVzc2FnaW5nL21lc3NhZ2VzL3ttZXNzYWdlSWR9L3RhcmdldHMnLnJlcGxhY2UoJ3ttZXNzYWdlSWR9JywgbWVzc2FnZUlkKTtcbiAgICAgICAgbGV0IHBheWxvYWQgPSB7fTtcbiAgICAgICAgaWYgKHR5cGVvZiBtZXNzYWdlSWQgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgQXBwd3JpdGVFeGNlcHRpb24oJ01pc3NpbmcgcmVxdWlyZWQgcGFyYW1ldGVyOiBcIm1lc3NhZ2VJZFwiJyk7XG4gICAgICAgIH1cblxuXG4gICAgICAgIGlmICh0eXBlb2YgcXVlcmllcyAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHBheWxvYWRbJ3F1ZXJpZXMnXSA9IHF1ZXJpZXM7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy5jbGllbnQuY2FsbCgnZ2V0JywgYXBpUGF0aCwge1xuICAgICAgICAgICAgJ2NvbnRlbnQtdHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJyxcbiAgICAgICAgfSwgcGF5bG9hZCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogTGlzdCBwcm92aWRlcnNcbiAgICAgKlxuICAgICAqIEdldCBhIGxpc3Qgb2YgYWxsIHByb3ZpZGVycyBmcm9tIHRoZSBjdXJyZW50IEFwcHdyaXRlIHByb2plY3QuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZ1tdfSBxdWVyaWVzXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHNlYXJjaFxuICAgICAqIEB0aHJvd3Mge0FwcHdyaXRlRXhjZXB0aW9ufVxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlfVxuICAgICAqL1xuICAgIGFzeW5jIGxpc3RQcm92aWRlcnMocXVlcmllcywgc2VhcmNoKSB7XG4gICAgICAgIGNvbnN0IGFwaVBhdGggPSAnL21lc3NhZ2luZy9wcm92aWRlcnMnO1xuICAgICAgICBsZXQgcGF5bG9hZCA9IHt9O1xuXG4gICAgICAgIGlmICh0eXBlb2YgcXVlcmllcyAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHBheWxvYWRbJ3F1ZXJpZXMnXSA9IHF1ZXJpZXM7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodHlwZW9mIHNlYXJjaCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHBheWxvYWRbJ3NlYXJjaCddID0gc2VhcmNoO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMuY2xpZW50LmNhbGwoJ2dldCcsIGFwaVBhdGgsIHtcbiAgICAgICAgICAgICdjb250ZW50LXR5cGUnOiAnYXBwbGljYXRpb24vanNvbicsXG4gICAgICAgIH0sIHBheWxvYWQpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZSBBUE5TIHByb3ZpZGVyXG4gICAgICpcbiAgICAgKiBDcmVhdGUgYSBuZXcgQXBwbGUgUHVzaCBOb3RpZmljYXRpb24gc2VydmljZSBwcm92aWRlci5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBwcm92aWRlcklkXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IG5hbWVcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gYXV0aEtleVxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBhdXRoS2V5SWRcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gdGVhbUlkXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGJ1bmRsZUlkXG4gICAgICogQHBhcmFtIHtib29sZWFufSBzYW5kYm94XG4gICAgICogQHBhcmFtIHtib29sZWFufSBlbmFibGVkXG4gICAgICogQHRocm93cyB7QXBwd3JpdGVFeGNlcHRpb259XG4gICAgICogQHJldHVybnMge1Byb21pc2V9XG4gICAgICovXG4gICAgYXN5bmMgY3JlYXRlQXBuc1Byb3ZpZGVyKHByb3ZpZGVySWQsIG5hbWUsIGF1dGhLZXksIGF1dGhLZXlJZCwgdGVhbUlkLCBidW5kbGVJZCwgc2FuZGJveCwgZW5hYmxlZCkge1xuICAgICAgICBjb25zdCBhcGlQYXRoID0gJy9tZXNzYWdpbmcvcHJvdmlkZXJzL2FwbnMnO1xuICAgICAgICBsZXQgcGF5bG9hZCA9IHt9O1xuICAgICAgICBpZiAodHlwZW9mIHByb3ZpZGVySWQgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgQXBwd3JpdGVFeGNlcHRpb24oJ01pc3NpbmcgcmVxdWlyZWQgcGFyYW1ldGVyOiBcInByb3ZpZGVySWRcIicpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHR5cGVvZiBuYW1lID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEFwcHdyaXRlRXhjZXB0aW9uKCdNaXNzaW5nIHJlcXVpcmVkIHBhcmFtZXRlcjogXCJuYW1lXCInKTtcbiAgICAgICAgfVxuXG5cbiAgICAgICAgaWYgKHR5cGVvZiBwcm92aWRlcklkICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgcGF5bG9hZFsncHJvdmlkZXJJZCddID0gcHJvdmlkZXJJZDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0eXBlb2YgbmFtZSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHBheWxvYWRbJ25hbWUnXSA9IG5hbWU7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodHlwZW9mIGF1dGhLZXkgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICBwYXlsb2FkWydhdXRoS2V5J10gPSBhdXRoS2V5O1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHR5cGVvZiBhdXRoS2V5SWQgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICBwYXlsb2FkWydhdXRoS2V5SWQnXSA9IGF1dGhLZXlJZDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0eXBlb2YgdGVhbUlkICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgcGF5bG9hZFsndGVhbUlkJ10gPSB0ZWFtSWQ7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodHlwZW9mIGJ1bmRsZUlkICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgcGF5bG9hZFsnYnVuZGxlSWQnXSA9IGJ1bmRsZUlkO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHR5cGVvZiBzYW5kYm94ICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgcGF5bG9hZFsnc2FuZGJveCddID0gc2FuZGJveDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0eXBlb2YgZW5hYmxlZCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHBheWxvYWRbJ2VuYWJsZWQnXSA9IGVuYWJsZWQ7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy5jbGllbnQuY2FsbCgncG9zdCcsIGFwaVBhdGgsIHtcbiAgICAgICAgICAgICdjb250ZW50LXR5cGUnOiAnYXBwbGljYXRpb24vanNvbicsXG4gICAgICAgIH0sIHBheWxvYWQpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFVwZGF0ZSBBUE5TIHByb3ZpZGVyXG4gICAgICpcbiAgICAgKiBVcGRhdGUgYSBBcHBsZSBQdXNoIE5vdGlmaWNhdGlvbiBzZXJ2aWNlIHByb3ZpZGVyIGJ5IGl0cyB1bmlxdWUgSUQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gcHJvdmlkZXJJZFxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lXG4gICAgICogQHBhcmFtIHtib29sZWFufSBlbmFibGVkXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGF1dGhLZXlcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gYXV0aEtleUlkXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHRlYW1JZFxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBidW5kbGVJZFxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gc2FuZGJveFxuICAgICAqIEB0aHJvd3Mge0FwcHdyaXRlRXhjZXB0aW9ufVxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlfVxuICAgICAqL1xuICAgIGFzeW5jIHVwZGF0ZUFwbnNQcm92aWRlcihwcm92aWRlcklkLCBuYW1lLCBlbmFibGVkLCBhdXRoS2V5LCBhdXRoS2V5SWQsIHRlYW1JZCwgYnVuZGxlSWQsIHNhbmRib3gpIHtcbiAgICAgICAgY29uc3QgYXBpUGF0aCA9ICcvbWVzc2FnaW5nL3Byb3ZpZGVycy9hcG5zL3twcm92aWRlcklkfScucmVwbGFjZSgne3Byb3ZpZGVySWR9JywgcHJvdmlkZXJJZCk7XG4gICAgICAgIGxldCBwYXlsb2FkID0ge307XG4gICAgICAgIGlmICh0eXBlb2YgcHJvdmlkZXJJZCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBBcHB3cml0ZUV4Y2VwdGlvbignTWlzc2luZyByZXF1aXJlZCBwYXJhbWV0ZXI6IFwicHJvdmlkZXJJZFwiJyk7XG4gICAgICAgIH1cblxuXG4gICAgICAgIGlmICh0eXBlb2YgbmFtZSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHBheWxvYWRbJ25hbWUnXSA9IG5hbWU7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodHlwZW9mIGVuYWJsZWQgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICBwYXlsb2FkWydlbmFibGVkJ10gPSBlbmFibGVkO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHR5cGVvZiBhdXRoS2V5ICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgcGF5bG9hZFsnYXV0aEtleSddID0gYXV0aEtleTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0eXBlb2YgYXV0aEtleUlkICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgcGF5bG9hZFsnYXV0aEtleUlkJ10gPSBhdXRoS2V5SWQ7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodHlwZW9mIHRlYW1JZCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHBheWxvYWRbJ3RlYW1JZCddID0gdGVhbUlkO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHR5cGVvZiBidW5kbGVJZCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHBheWxvYWRbJ2J1bmRsZUlkJ10gPSBidW5kbGVJZDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0eXBlb2Ygc2FuZGJveCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHBheWxvYWRbJ3NhbmRib3gnXSA9IHNhbmRib3g7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy5jbGllbnQuY2FsbCgncGF0Y2gnLCBhcGlQYXRoLCB7XG4gICAgICAgICAgICAnY29udGVudC10eXBlJzogJ2FwcGxpY2F0aW9uL2pzb24nLFxuICAgICAgICB9LCBwYXlsb2FkKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGUgRkNNIHByb3ZpZGVyXG4gICAgICpcbiAgICAgKiBDcmVhdGUgYSBuZXcgRmlyZWJhc2UgQ2xvdWQgTWVzc2FnaW5nIHByb3ZpZGVyLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHByb3ZpZGVySWRcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gbmFtZVxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBzZXJ2aWNlQWNjb3VudEpTT05cbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IGVuYWJsZWRcbiAgICAgKiBAdGhyb3dzIHtBcHB3cml0ZUV4Y2VwdGlvbn1cbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZX1cbiAgICAgKi9cbiAgICBhc3luYyBjcmVhdGVGY21Qcm92aWRlcihwcm92aWRlcklkLCBuYW1lLCBzZXJ2aWNlQWNjb3VudEpTT04sIGVuYWJsZWQpIHtcbiAgICAgICAgY29uc3QgYXBpUGF0aCA9ICcvbWVzc2FnaW5nL3Byb3ZpZGVycy9mY20nO1xuICAgICAgICBsZXQgcGF5bG9hZCA9IHt9O1xuICAgICAgICBpZiAodHlwZW9mIHByb3ZpZGVySWQgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgQXBwd3JpdGVFeGNlcHRpb24oJ01pc3NpbmcgcmVxdWlyZWQgcGFyYW1ldGVyOiBcInByb3ZpZGVySWRcIicpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHR5cGVvZiBuYW1lID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEFwcHdyaXRlRXhjZXB0aW9uKCdNaXNzaW5nIHJlcXVpcmVkIHBhcmFtZXRlcjogXCJuYW1lXCInKTtcbiAgICAgICAgfVxuXG5cbiAgICAgICAgaWYgKHR5cGVvZiBwcm92aWRlcklkICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgcGF5bG9hZFsncHJvdmlkZXJJZCddID0gcHJvdmlkZXJJZDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0eXBlb2YgbmFtZSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHBheWxvYWRbJ25hbWUnXSA9IG5hbWU7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodHlwZW9mIHNlcnZpY2VBY2NvdW50SlNPTiAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHBheWxvYWRbJ3NlcnZpY2VBY2NvdW50SlNPTiddID0gc2VydmljZUFjY291bnRKU09OO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHR5cGVvZiBlbmFibGVkICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgcGF5bG9hZFsnZW5hYmxlZCddID0gZW5hYmxlZDtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBhd2FpdCB0aGlzLmNsaWVudC5jYWxsKCdwb3N0JywgYXBpUGF0aCwge1xuICAgICAgICAgICAgJ2NvbnRlbnQtdHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJyxcbiAgICAgICAgfSwgcGF5bG9hZCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVXBkYXRlIEZDTSBwcm92aWRlclxuICAgICAqXG4gICAgICogVXBkYXRlIGEgRmlyZWJhc2UgQ2xvdWQgTWVzc2FnaW5nIHByb3ZpZGVyIGJ5IGl0cyB1bmlxdWUgSUQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gcHJvdmlkZXJJZFxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lXG4gICAgICogQHBhcmFtIHtib29sZWFufSBlbmFibGVkXG4gICAgICogQHBhcmFtIHtvYmplY3R9IHNlcnZpY2VBY2NvdW50SlNPTlxuICAgICAqIEB0aHJvd3Mge0FwcHdyaXRlRXhjZXB0aW9ufVxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlfVxuICAgICAqL1xuICAgIGFzeW5jIHVwZGF0ZUZjbVByb3ZpZGVyKHByb3ZpZGVySWQsIG5hbWUsIGVuYWJsZWQsIHNlcnZpY2VBY2NvdW50SlNPTikge1xuICAgICAgICBjb25zdCBhcGlQYXRoID0gJy9tZXNzYWdpbmcvcHJvdmlkZXJzL2ZjbS97cHJvdmlkZXJJZH0nLnJlcGxhY2UoJ3twcm92aWRlcklkfScsIHByb3ZpZGVySWQpO1xuICAgICAgICBsZXQgcGF5bG9hZCA9IHt9O1xuICAgICAgICBpZiAodHlwZW9mIHByb3ZpZGVySWQgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgQXBwd3JpdGVFeGNlcHRpb24oJ01pc3NpbmcgcmVxdWlyZWQgcGFyYW1ldGVyOiBcInByb3ZpZGVySWRcIicpO1xuICAgICAgICB9XG5cblxuICAgICAgICBpZiAodHlwZW9mIG5hbWUgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICBwYXlsb2FkWyduYW1lJ10gPSBuYW1lO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHR5cGVvZiBlbmFibGVkICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgcGF5bG9hZFsnZW5hYmxlZCddID0gZW5hYmxlZDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0eXBlb2Ygc2VydmljZUFjY291bnRKU09OICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgcGF5bG9hZFsnc2VydmljZUFjY291bnRKU09OJ10gPSBzZXJ2aWNlQWNjb3VudEpTT047XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy5jbGllbnQuY2FsbCgncGF0Y2gnLCBhcGlQYXRoLCB7XG4gICAgICAgICAgICAnY29udGVudC10eXBlJzogJ2FwcGxpY2F0aW9uL2pzb24nLFxuICAgICAgICB9LCBwYXlsb2FkKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGUgTWFpbGd1biBwcm92aWRlclxuICAgICAqXG4gICAgICogQ3JlYXRlIGEgbmV3IE1haWxndW4gcHJvdmlkZXIuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gcHJvdmlkZXJJZFxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGFwaUtleVxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBkb21haW5cbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IGlzRXVSZWdpb25cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gZnJvbU5hbWVcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gZnJvbUVtYWlsXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHJlcGx5VG9OYW1lXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHJlcGx5VG9FbWFpbFxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gZW5hYmxlZFxuICAgICAqIEB0aHJvd3Mge0FwcHdyaXRlRXhjZXB0aW9ufVxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlfVxuICAgICAqL1xuICAgIGFzeW5jIGNyZWF0ZU1haWxndW5Qcm92aWRlcihwcm92aWRlcklkLCBuYW1lLCBhcGlLZXksIGRvbWFpbiwgaXNFdVJlZ2lvbiwgZnJvbU5hbWUsIGZyb21FbWFpbCwgcmVwbHlUb05hbWUsIHJlcGx5VG9FbWFpbCwgZW5hYmxlZCkge1xuICAgICAgICBjb25zdCBhcGlQYXRoID0gJy9tZXNzYWdpbmcvcHJvdmlkZXJzL21haWxndW4nO1xuICAgICAgICBsZXQgcGF5bG9hZCA9IHt9O1xuICAgICAgICBpZiAodHlwZW9mIHByb3ZpZGVySWQgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgQXBwd3JpdGVFeGNlcHRpb24oJ01pc3NpbmcgcmVxdWlyZWQgcGFyYW1ldGVyOiBcInByb3ZpZGVySWRcIicpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHR5cGVvZiBuYW1lID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEFwcHdyaXRlRXhjZXB0aW9uKCdNaXNzaW5nIHJlcXVpcmVkIHBhcmFtZXRlcjogXCJuYW1lXCInKTtcbiAgICAgICAgfVxuXG5cbiAgICAgICAgaWYgKHR5cGVvZiBwcm92aWRlcklkICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgcGF5bG9hZFsncHJvdmlkZXJJZCddID0gcHJvdmlkZXJJZDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0eXBlb2YgbmFtZSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHBheWxvYWRbJ25hbWUnXSA9IG5hbWU7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodHlwZW9mIGFwaUtleSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHBheWxvYWRbJ2FwaUtleSddID0gYXBpS2V5O1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHR5cGVvZiBkb21haW4gIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICBwYXlsb2FkWydkb21haW4nXSA9IGRvbWFpbjtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0eXBlb2YgaXNFdVJlZ2lvbiAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHBheWxvYWRbJ2lzRXVSZWdpb24nXSA9IGlzRXVSZWdpb247XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodHlwZW9mIGZyb21OYW1lICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgcGF5bG9hZFsnZnJvbU5hbWUnXSA9IGZyb21OYW1lO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHR5cGVvZiBmcm9tRW1haWwgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICBwYXlsb2FkWydmcm9tRW1haWwnXSA9IGZyb21FbWFpbDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0eXBlb2YgcmVwbHlUb05hbWUgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICBwYXlsb2FkWydyZXBseVRvTmFtZSddID0gcmVwbHlUb05hbWU7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodHlwZW9mIHJlcGx5VG9FbWFpbCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHBheWxvYWRbJ3JlcGx5VG9FbWFpbCddID0gcmVwbHlUb0VtYWlsO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHR5cGVvZiBlbmFibGVkICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgcGF5bG9hZFsnZW5hYmxlZCddID0gZW5hYmxlZDtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBhd2FpdCB0aGlzLmNsaWVudC5jYWxsKCdwb3N0JywgYXBpUGF0aCwge1xuICAgICAgICAgICAgJ2NvbnRlbnQtdHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJyxcbiAgICAgICAgfSwgcGF5bG9hZCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVXBkYXRlIE1haWxndW4gcHJvdmlkZXJcbiAgICAgKlxuICAgICAqIFVwZGF0ZSBhIE1haWxndW4gcHJvdmlkZXIgYnkgaXRzIHVuaXF1ZSBJRC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBwcm92aWRlcklkXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IG5hbWVcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gYXBpS2V5XG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGRvbWFpblxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gaXNFdVJlZ2lvblxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gZW5hYmxlZFxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBmcm9tTmFtZVxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBmcm9tRW1haWxcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gcmVwbHlUb05hbWVcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gcmVwbHlUb0VtYWlsXG4gICAgICogQHRocm93cyB7QXBwd3JpdGVFeGNlcHRpb259XG4gICAgICogQHJldHVybnMge1Byb21pc2V9XG4gICAgICovXG4gICAgYXN5bmMgdXBkYXRlTWFpbGd1blByb3ZpZGVyKHByb3ZpZGVySWQsIG5hbWUsIGFwaUtleSwgZG9tYWluLCBpc0V1UmVnaW9uLCBlbmFibGVkLCBmcm9tTmFtZSwgZnJvbUVtYWlsLCByZXBseVRvTmFtZSwgcmVwbHlUb0VtYWlsKSB7XG4gICAgICAgIGNvbnN0IGFwaVBhdGggPSAnL21lc3NhZ2luZy9wcm92aWRlcnMvbWFpbGd1bi97cHJvdmlkZXJJZH0nLnJlcGxhY2UoJ3twcm92aWRlcklkfScsIHByb3ZpZGVySWQpO1xuICAgICAgICBsZXQgcGF5bG9hZCA9IHt9O1xuICAgICAgICBpZiAodHlwZW9mIHByb3ZpZGVySWQgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgQXBwd3JpdGVFeGNlcHRpb24oJ01pc3NpbmcgcmVxdWlyZWQgcGFyYW1ldGVyOiBcInByb3ZpZGVySWRcIicpO1xuICAgICAgICB9XG5cblxuICAgICAgICBpZiAodHlwZW9mIG5hbWUgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICBwYXlsb2FkWyduYW1lJ10gPSBuYW1lO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHR5cGVvZiBhcGlLZXkgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICBwYXlsb2FkWydhcGlLZXknXSA9IGFwaUtleTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0eXBlb2YgZG9tYWluICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgcGF5bG9hZFsnZG9tYWluJ10gPSBkb21haW47XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodHlwZW9mIGlzRXVSZWdpb24gIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICBwYXlsb2FkWydpc0V1UmVnaW9uJ10gPSBpc0V1UmVnaW9uO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHR5cGVvZiBlbmFibGVkICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgcGF5bG9hZFsnZW5hYmxlZCddID0gZW5hYmxlZDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0eXBlb2YgZnJvbU5hbWUgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICBwYXlsb2FkWydmcm9tTmFtZSddID0gZnJvbU5hbWU7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodHlwZW9mIGZyb21FbWFpbCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHBheWxvYWRbJ2Zyb21FbWFpbCddID0gZnJvbUVtYWlsO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHR5cGVvZiByZXBseVRvTmFtZSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHBheWxvYWRbJ3JlcGx5VG9OYW1lJ10gPSByZXBseVRvTmFtZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0eXBlb2YgcmVwbHlUb0VtYWlsICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgcGF5bG9hZFsncmVwbHlUb0VtYWlsJ10gPSByZXBseVRvRW1haWw7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy5jbGllbnQuY2FsbCgncGF0Y2gnLCBhcGlQYXRoLCB7XG4gICAgICAgICAgICAnY29udGVudC10eXBlJzogJ2FwcGxpY2F0aW9uL2pzb24nLFxuICAgICAgICB9LCBwYXlsb2FkKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGUgTXNnOTEgcHJvdmlkZXJcbiAgICAgKlxuICAgICAqIENyZWF0ZSBhIG5ldyBNU0c5MSBwcm92aWRlci5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBwcm92aWRlcklkXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IG5hbWVcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gdGVtcGxhdGVJZFxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBzZW5kZXJJZFxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBhdXRoS2V5XG4gICAgICogQHBhcmFtIHtib29sZWFufSBlbmFibGVkXG4gICAgICogQHRocm93cyB7QXBwd3JpdGVFeGNlcHRpb259XG4gICAgICogQHJldHVybnMge1Byb21pc2V9XG4gICAgICovXG4gICAgYXN5bmMgY3JlYXRlTXNnOTFQcm92aWRlcihwcm92aWRlcklkLCBuYW1lLCB0ZW1wbGF0ZUlkLCBzZW5kZXJJZCwgYXV0aEtleSwgZW5hYmxlZCkge1xuICAgICAgICBjb25zdCBhcGlQYXRoID0gJy9tZXNzYWdpbmcvcHJvdmlkZXJzL21zZzkxJztcbiAgICAgICAgbGV0IHBheWxvYWQgPSB7fTtcbiAgICAgICAgaWYgKHR5cGVvZiBwcm92aWRlcklkID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEFwcHdyaXRlRXhjZXB0aW9uKCdNaXNzaW5nIHJlcXVpcmVkIHBhcmFtZXRlcjogXCJwcm92aWRlcklkXCInKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0eXBlb2YgbmFtZSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBBcHB3cml0ZUV4Y2VwdGlvbignTWlzc2luZyByZXF1aXJlZCBwYXJhbWV0ZXI6IFwibmFtZVwiJyk7XG4gICAgICAgIH1cblxuXG4gICAgICAgIGlmICh0eXBlb2YgcHJvdmlkZXJJZCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHBheWxvYWRbJ3Byb3ZpZGVySWQnXSA9IHByb3ZpZGVySWQ7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodHlwZW9mIG5hbWUgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICBwYXlsb2FkWyduYW1lJ10gPSBuYW1lO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHR5cGVvZiB0ZW1wbGF0ZUlkICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgcGF5bG9hZFsndGVtcGxhdGVJZCddID0gdGVtcGxhdGVJZDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0eXBlb2Ygc2VuZGVySWQgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICBwYXlsb2FkWydzZW5kZXJJZCddID0gc2VuZGVySWQ7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodHlwZW9mIGF1dGhLZXkgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICBwYXlsb2FkWydhdXRoS2V5J10gPSBhdXRoS2V5O1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHR5cGVvZiBlbmFibGVkICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgcGF5bG9hZFsnZW5hYmxlZCddID0gZW5hYmxlZDtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBhd2FpdCB0aGlzLmNsaWVudC5jYWxsKCdwb3N0JywgYXBpUGF0aCwge1xuICAgICAgICAgICAgJ2NvbnRlbnQtdHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJyxcbiAgICAgICAgfSwgcGF5bG9hZCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVXBkYXRlIE1zZzkxIHByb3ZpZGVyXG4gICAgICpcbiAgICAgKiBVcGRhdGUgYSBNU0c5MSBwcm92aWRlciBieSBpdHMgdW5pcXVlIElELlxuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHByb3ZpZGVySWRcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gbmFtZVxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gZW5hYmxlZFxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSB0ZW1wbGF0ZUlkXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHNlbmRlcklkXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGF1dGhLZXlcbiAgICAgKiBAdGhyb3dzIHtBcHB3cml0ZUV4Y2VwdGlvbn1cbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZX1cbiAgICAgKi9cbiAgICBhc3luYyB1cGRhdGVNc2c5MVByb3ZpZGVyKHByb3ZpZGVySWQsIG5hbWUsIGVuYWJsZWQsIHRlbXBsYXRlSWQsIHNlbmRlcklkLCBhdXRoS2V5KSB7XG4gICAgICAgIGNvbnN0IGFwaVBhdGggPSAnL21lc3NhZ2luZy9wcm92aWRlcnMvbXNnOTEve3Byb3ZpZGVySWR9Jy5yZXBsYWNlKCd7cHJvdmlkZXJJZH0nLCBwcm92aWRlcklkKTtcbiAgICAgICAgbGV0IHBheWxvYWQgPSB7fTtcbiAgICAgICAgaWYgKHR5cGVvZiBwcm92aWRlcklkID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEFwcHdyaXRlRXhjZXB0aW9uKCdNaXNzaW5nIHJlcXVpcmVkIHBhcmFtZXRlcjogXCJwcm92aWRlcklkXCInKTtcbiAgICAgICAgfVxuXG5cbiAgICAgICAgaWYgKHR5cGVvZiBuYW1lICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgcGF5bG9hZFsnbmFtZSddID0gbmFtZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0eXBlb2YgZW5hYmxlZCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHBheWxvYWRbJ2VuYWJsZWQnXSA9IGVuYWJsZWQ7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodHlwZW9mIHRlbXBsYXRlSWQgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICBwYXlsb2FkWyd0ZW1wbGF0ZUlkJ10gPSB0ZW1wbGF0ZUlkO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHR5cGVvZiBzZW5kZXJJZCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHBheWxvYWRbJ3NlbmRlcklkJ10gPSBzZW5kZXJJZDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0eXBlb2YgYXV0aEtleSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHBheWxvYWRbJ2F1dGhLZXknXSA9IGF1dGhLZXk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy5jbGllbnQuY2FsbCgncGF0Y2gnLCBhcGlQYXRoLCB7XG4gICAgICAgICAgICAnY29udGVudC10eXBlJzogJ2FwcGxpY2F0aW9uL2pzb24nLFxuICAgICAgICB9LCBwYXlsb2FkKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGUgU2VuZGdyaWQgcHJvdmlkZXJcbiAgICAgKlxuICAgICAqIENyZWF0ZSBhIG5ldyBTZW5kZ3JpZCBwcm92aWRlci5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBwcm92aWRlcklkXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IG5hbWVcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gYXBpS2V5XG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGZyb21OYW1lXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGZyb21FbWFpbFxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSByZXBseVRvTmFtZVxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSByZXBseVRvRW1haWxcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IGVuYWJsZWRcbiAgICAgKiBAdGhyb3dzIHtBcHB3cml0ZUV4Y2VwdGlvbn1cbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZX1cbiAgICAgKi9cbiAgICBhc3luYyBjcmVhdGVTZW5kZ3JpZFByb3ZpZGVyKHByb3ZpZGVySWQsIG5hbWUsIGFwaUtleSwgZnJvbU5hbWUsIGZyb21FbWFpbCwgcmVwbHlUb05hbWUsIHJlcGx5VG9FbWFpbCwgZW5hYmxlZCkge1xuICAgICAgICBjb25zdCBhcGlQYXRoID0gJy9tZXNzYWdpbmcvcHJvdmlkZXJzL3NlbmRncmlkJztcbiAgICAgICAgbGV0IHBheWxvYWQgPSB7fTtcbiAgICAgICAgaWYgKHR5cGVvZiBwcm92aWRlcklkID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEFwcHdyaXRlRXhjZXB0aW9uKCdNaXNzaW5nIHJlcXVpcmVkIHBhcmFtZXRlcjogXCJwcm92aWRlcklkXCInKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0eXBlb2YgbmFtZSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBBcHB3cml0ZUV4Y2VwdGlvbignTWlzc2luZyByZXF1aXJlZCBwYXJhbWV0ZXI6IFwibmFtZVwiJyk7XG4gICAgICAgIH1cblxuXG4gICAgICAgIGlmICh0eXBlb2YgcHJvdmlkZXJJZCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHBheWxvYWRbJ3Byb3ZpZGVySWQnXSA9IHByb3ZpZGVySWQ7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodHlwZW9mIG5hbWUgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICBwYXlsb2FkWyduYW1lJ10gPSBuYW1lO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHR5cGVvZiBhcGlLZXkgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICBwYXlsb2FkWydhcGlLZXknXSA9IGFwaUtleTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0eXBlb2YgZnJvbU5hbWUgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICBwYXlsb2FkWydmcm9tTmFtZSddID0gZnJvbU5hbWU7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodHlwZW9mIGZyb21FbWFpbCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHBheWxvYWRbJ2Zyb21FbWFpbCddID0gZnJvbUVtYWlsO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHR5cGVvZiByZXBseVRvTmFtZSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHBheWxvYWRbJ3JlcGx5VG9OYW1lJ10gPSByZXBseVRvTmFtZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0eXBlb2YgcmVwbHlUb0VtYWlsICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgcGF5bG9hZFsncmVwbHlUb0VtYWlsJ10gPSByZXBseVRvRW1haWw7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodHlwZW9mIGVuYWJsZWQgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICBwYXlsb2FkWydlbmFibGVkJ10gPSBlbmFibGVkO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMuY2xpZW50LmNhbGwoJ3Bvc3QnLCBhcGlQYXRoLCB7XG4gICAgICAgICAgICAnY29udGVudC10eXBlJzogJ2FwcGxpY2F0aW9uL2pzb24nLFxuICAgICAgICB9LCBwYXlsb2FkKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBVcGRhdGUgU2VuZGdyaWQgcHJvdmlkZXJcbiAgICAgKlxuICAgICAqIFVwZGF0ZSBhIFNlbmRncmlkIHByb3ZpZGVyIGJ5IGl0cyB1bmlxdWUgSUQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gcHJvdmlkZXJJZFxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lXG4gICAgICogQHBhcmFtIHtib29sZWFufSBlbmFibGVkXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGFwaUtleVxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBmcm9tTmFtZVxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBmcm9tRW1haWxcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gcmVwbHlUb05hbWVcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gcmVwbHlUb0VtYWlsXG4gICAgICogQHRocm93cyB7QXBwd3JpdGVFeGNlcHRpb259XG4gICAgICogQHJldHVybnMge1Byb21pc2V9XG4gICAgICovXG4gICAgYXN5bmMgdXBkYXRlU2VuZGdyaWRQcm92aWRlcihwcm92aWRlcklkLCBuYW1lLCBlbmFibGVkLCBhcGlLZXksIGZyb21OYW1lLCBmcm9tRW1haWwsIHJlcGx5VG9OYW1lLCByZXBseVRvRW1haWwpIHtcbiAgICAgICAgY29uc3QgYXBpUGF0aCA9ICcvbWVzc2FnaW5nL3Byb3ZpZGVycy9zZW5kZ3JpZC97cHJvdmlkZXJJZH0nLnJlcGxhY2UoJ3twcm92aWRlcklkfScsIHByb3ZpZGVySWQpO1xuICAgICAgICBsZXQgcGF5bG9hZCA9IHt9O1xuICAgICAgICBpZiAodHlwZW9mIHByb3ZpZGVySWQgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgQXBwd3JpdGVFeGNlcHRpb24oJ01pc3NpbmcgcmVxdWlyZWQgcGFyYW1ldGVyOiBcInByb3ZpZGVySWRcIicpO1xuICAgICAgICB9XG5cblxuICAgICAgICBpZiAodHlwZW9mIG5hbWUgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICBwYXlsb2FkWyduYW1lJ10gPSBuYW1lO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHR5cGVvZiBlbmFibGVkICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgcGF5bG9hZFsnZW5hYmxlZCddID0gZW5hYmxlZDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0eXBlb2YgYXBpS2V5ICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgcGF5bG9hZFsnYXBpS2V5J10gPSBhcGlLZXk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodHlwZW9mIGZyb21OYW1lICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgcGF5bG9hZFsnZnJvbU5hbWUnXSA9IGZyb21OYW1lO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHR5cGVvZiBmcm9tRW1haWwgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICBwYXlsb2FkWydmcm9tRW1haWwnXSA9IGZyb21FbWFpbDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0eXBlb2YgcmVwbHlUb05hbWUgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICBwYXlsb2FkWydyZXBseVRvTmFtZSddID0gcmVwbHlUb05hbWU7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodHlwZW9mIHJlcGx5VG9FbWFpbCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHBheWxvYWRbJ3JlcGx5VG9FbWFpbCddID0gcmVwbHlUb0VtYWlsO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMuY2xpZW50LmNhbGwoJ3BhdGNoJywgYXBpUGF0aCwge1xuICAgICAgICAgICAgJ2NvbnRlbnQtdHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJyxcbiAgICAgICAgfSwgcGF5bG9hZCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlIFNNVFAgcHJvdmlkZXJcbiAgICAgKlxuICAgICAqIENyZWF0ZSBhIG5ldyBTTVRQIHByb3ZpZGVyLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHByb3ZpZGVySWRcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gbmFtZVxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBob3N0XG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHBvcnRcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gdXNlcm5hbWVcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gcGFzc3dvcmRcbiAgICAgKiBAcGFyYW0ge1NtdHBFbmNyeXB0aW9ufSBlbmNyeXB0aW9uXG4gICAgICogQHBhcmFtIHtib29sZWFufSBhdXRvVExTXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IG1haWxlclxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBmcm9tTmFtZVxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBmcm9tRW1haWxcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gcmVwbHlUb05hbWVcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gcmVwbHlUb0VtYWlsXG4gICAgICogQHBhcmFtIHtib29sZWFufSBlbmFibGVkXG4gICAgICogQHRocm93cyB7QXBwd3JpdGVFeGNlcHRpb259XG4gICAgICogQHJldHVybnMge1Byb21pc2V9XG4gICAgICovXG4gICAgYXN5bmMgY3JlYXRlU210cFByb3ZpZGVyKHByb3ZpZGVySWQsIG5hbWUsIGhvc3QsIHBvcnQsIHVzZXJuYW1lLCBwYXNzd29yZCwgZW5jcnlwdGlvbiwgYXV0b1RMUywgbWFpbGVyLCBmcm9tTmFtZSwgZnJvbUVtYWlsLCByZXBseVRvTmFtZSwgcmVwbHlUb0VtYWlsLCBlbmFibGVkKSB7XG4gICAgICAgIGNvbnN0IGFwaVBhdGggPSAnL21lc3NhZ2luZy9wcm92aWRlcnMvc210cCc7XG4gICAgICAgIGxldCBwYXlsb2FkID0ge307XG4gICAgICAgIGlmICh0eXBlb2YgcHJvdmlkZXJJZCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBBcHB3cml0ZUV4Y2VwdGlvbignTWlzc2luZyByZXF1aXJlZCBwYXJhbWV0ZXI6IFwicHJvdmlkZXJJZFwiJyk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodHlwZW9mIG5hbWUgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgQXBwd3JpdGVFeGNlcHRpb24oJ01pc3NpbmcgcmVxdWlyZWQgcGFyYW1ldGVyOiBcIm5hbWVcIicpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHR5cGVvZiBob3N0ID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEFwcHdyaXRlRXhjZXB0aW9uKCdNaXNzaW5nIHJlcXVpcmVkIHBhcmFtZXRlcjogXCJob3N0XCInKTtcbiAgICAgICAgfVxuXG5cbiAgICAgICAgaWYgKHR5cGVvZiBwcm92aWRlcklkICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgcGF5bG9hZFsncHJvdmlkZXJJZCddID0gcHJvdmlkZXJJZDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0eXBlb2YgbmFtZSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHBheWxvYWRbJ25hbWUnXSA9IG5hbWU7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodHlwZW9mIGhvc3QgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICBwYXlsb2FkWydob3N0J10gPSBob3N0O1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHR5cGVvZiBwb3J0ICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgcGF5bG9hZFsncG9ydCddID0gcG9ydDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0eXBlb2YgdXNlcm5hbWUgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICBwYXlsb2FkWyd1c2VybmFtZSddID0gdXNlcm5hbWU7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodHlwZW9mIHBhc3N3b3JkICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgcGF5bG9hZFsncGFzc3dvcmQnXSA9IHBhc3N3b3JkO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHR5cGVvZiBlbmNyeXB0aW9uICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgcGF5bG9hZFsnZW5jcnlwdGlvbiddID0gZW5jcnlwdGlvbjtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0eXBlb2YgYXV0b1RMUyAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHBheWxvYWRbJ2F1dG9UTFMnXSA9IGF1dG9UTFM7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodHlwZW9mIG1haWxlciAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHBheWxvYWRbJ21haWxlciddID0gbWFpbGVyO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHR5cGVvZiBmcm9tTmFtZSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHBheWxvYWRbJ2Zyb21OYW1lJ10gPSBmcm9tTmFtZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0eXBlb2YgZnJvbUVtYWlsICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgcGF5bG9hZFsnZnJvbUVtYWlsJ10gPSBmcm9tRW1haWw7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodHlwZW9mIHJlcGx5VG9OYW1lICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgcGF5bG9hZFsncmVwbHlUb05hbWUnXSA9IHJlcGx5VG9OYW1lO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHR5cGVvZiByZXBseVRvRW1haWwgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICBwYXlsb2FkWydyZXBseVRvRW1haWwnXSA9IHJlcGx5VG9FbWFpbDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0eXBlb2YgZW5hYmxlZCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHBheWxvYWRbJ2VuYWJsZWQnXSA9IGVuYWJsZWQ7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy5jbGllbnQuY2FsbCgncG9zdCcsIGFwaVBhdGgsIHtcbiAgICAgICAgICAgICdjb250ZW50LXR5cGUnOiAnYXBwbGljYXRpb24vanNvbicsXG4gICAgICAgIH0sIHBheWxvYWQpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFVwZGF0ZSBTTVRQIHByb3ZpZGVyXG4gICAgICpcbiAgICAgKiBVcGRhdGUgYSBTTVRQIHByb3ZpZGVyIGJ5IGl0cyB1bmlxdWUgSUQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gcHJvdmlkZXJJZFxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGhvc3RcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gcG9ydFxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSB1c2VybmFtZVxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBwYXNzd29yZFxuICAgICAqIEBwYXJhbSB7U210cEVuY3J5cHRpb259IGVuY3J5cHRpb25cbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IGF1dG9UTFNcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gbWFpbGVyXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGZyb21OYW1lXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGZyb21FbWFpbFxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSByZXBseVRvTmFtZVxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSByZXBseVRvRW1haWxcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IGVuYWJsZWRcbiAgICAgKiBAdGhyb3dzIHtBcHB3cml0ZUV4Y2VwdGlvbn1cbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZX1cbiAgICAgKi9cbiAgICBhc3luYyB1cGRhdGVTbXRwUHJvdmlkZXIocHJvdmlkZXJJZCwgbmFtZSwgaG9zdCwgcG9ydCwgdXNlcm5hbWUsIHBhc3N3b3JkLCBlbmNyeXB0aW9uLCBhdXRvVExTLCBtYWlsZXIsIGZyb21OYW1lLCBmcm9tRW1haWwsIHJlcGx5VG9OYW1lLCByZXBseVRvRW1haWwsIGVuYWJsZWQpIHtcbiAgICAgICAgY29uc3QgYXBpUGF0aCA9ICcvbWVzc2FnaW5nL3Byb3ZpZGVycy9zbXRwL3twcm92aWRlcklkfScucmVwbGFjZSgne3Byb3ZpZGVySWR9JywgcHJvdmlkZXJJZCk7XG4gICAgICAgIGxldCBwYXlsb2FkID0ge307XG4gICAgICAgIGlmICh0eXBlb2YgcHJvdmlkZXJJZCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBBcHB3cml0ZUV4Y2VwdGlvbignTWlzc2luZyByZXF1aXJlZCBwYXJhbWV0ZXI6IFwicHJvdmlkZXJJZFwiJyk7XG4gICAgICAgIH1cblxuXG4gICAgICAgIGlmICh0eXBlb2YgbmFtZSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHBheWxvYWRbJ25hbWUnXSA9IG5hbWU7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodHlwZW9mIGhvc3QgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICBwYXlsb2FkWydob3N0J10gPSBob3N0O1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHR5cGVvZiBwb3J0ICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgcGF5bG9hZFsncG9ydCddID0gcG9ydDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0eXBlb2YgdXNlcm5hbWUgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICBwYXlsb2FkWyd1c2VybmFtZSddID0gdXNlcm5hbWU7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodHlwZW9mIHBhc3N3b3JkICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgcGF5bG9hZFsncGFzc3dvcmQnXSA9IHBhc3N3b3JkO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHR5cGVvZiBlbmNyeXB0aW9uICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgcGF5bG9hZFsnZW5jcnlwdGlvbiddID0gZW5jcnlwdGlvbjtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0eXBlb2YgYXV0b1RMUyAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHBheWxvYWRbJ2F1dG9UTFMnXSA9IGF1dG9UTFM7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodHlwZW9mIG1haWxlciAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHBheWxvYWRbJ21haWxlciddID0gbWFpbGVyO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHR5cGVvZiBmcm9tTmFtZSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHBheWxvYWRbJ2Zyb21OYW1lJ10gPSBmcm9tTmFtZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0eXBlb2YgZnJvbUVtYWlsICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgcGF5bG9hZFsnZnJvbUVtYWlsJ10gPSBmcm9tRW1haWw7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodHlwZW9mIHJlcGx5VG9OYW1lICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgcGF5bG9hZFsncmVwbHlUb05hbWUnXSA9IHJlcGx5VG9OYW1lO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHR5cGVvZiByZXBseVRvRW1haWwgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICBwYXlsb2FkWydyZXBseVRvRW1haWwnXSA9IHJlcGx5VG9FbWFpbDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0eXBlb2YgZW5hYmxlZCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHBheWxvYWRbJ2VuYWJsZWQnXSA9IGVuYWJsZWQ7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy5jbGllbnQuY2FsbCgncGF0Y2gnLCBhcGlQYXRoLCB7XG4gICAgICAgICAgICAnY29udGVudC10eXBlJzogJ2FwcGxpY2F0aW9uL2pzb24nLFxuICAgICAgICB9LCBwYXlsb2FkKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGUgVGVsZXNpZ24gcHJvdmlkZXJcbiAgICAgKlxuICAgICAqIENyZWF0ZSBhIG5ldyBUZWxlc2lnbiBwcm92aWRlci5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBwcm92aWRlcklkXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IG5hbWVcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gZnJvbVxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBjdXN0b21lcklkXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGFwaUtleVxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gZW5hYmxlZFxuICAgICAqIEB0aHJvd3Mge0FwcHdyaXRlRXhjZXB0aW9ufVxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlfVxuICAgICAqL1xuICAgIGFzeW5jIGNyZWF0ZVRlbGVzaWduUHJvdmlkZXIocHJvdmlkZXJJZCwgbmFtZSwgZnJvbSwgY3VzdG9tZXJJZCwgYXBpS2V5LCBlbmFibGVkKSB7XG4gICAgICAgIGNvbnN0IGFwaVBhdGggPSAnL21lc3NhZ2luZy9wcm92aWRlcnMvdGVsZXNpZ24nO1xuICAgICAgICBsZXQgcGF5bG9hZCA9IHt9O1xuICAgICAgICBpZiAodHlwZW9mIHByb3ZpZGVySWQgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgQXBwd3JpdGVFeGNlcHRpb24oJ01pc3NpbmcgcmVxdWlyZWQgcGFyYW1ldGVyOiBcInByb3ZpZGVySWRcIicpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHR5cGVvZiBuYW1lID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEFwcHdyaXRlRXhjZXB0aW9uKCdNaXNzaW5nIHJlcXVpcmVkIHBhcmFtZXRlcjogXCJuYW1lXCInKTtcbiAgICAgICAgfVxuXG5cbiAgICAgICAgaWYgKHR5cGVvZiBwcm92aWRlcklkICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgcGF5bG9hZFsncHJvdmlkZXJJZCddID0gcHJvdmlkZXJJZDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0eXBlb2YgbmFtZSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHBheWxvYWRbJ25hbWUnXSA9IG5hbWU7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodHlwZW9mIGZyb20gIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICBwYXlsb2FkWydmcm9tJ10gPSBmcm9tO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHR5cGVvZiBjdXN0b21lcklkICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgcGF5bG9hZFsnY3VzdG9tZXJJZCddID0gY3VzdG9tZXJJZDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0eXBlb2YgYXBpS2V5ICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgcGF5bG9hZFsnYXBpS2V5J10gPSBhcGlLZXk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodHlwZW9mIGVuYWJsZWQgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICBwYXlsb2FkWydlbmFibGVkJ10gPSBlbmFibGVkO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMuY2xpZW50LmNhbGwoJ3Bvc3QnLCBhcGlQYXRoLCB7XG4gICAgICAgICAgICAnY29udGVudC10eXBlJzogJ2FwcGxpY2F0aW9uL2pzb24nLFxuICAgICAgICB9LCBwYXlsb2FkKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBVcGRhdGUgVGVsZXNpZ24gcHJvdmlkZXJcbiAgICAgKlxuICAgICAqIFVwZGF0ZSBhIFRlbGVzaWduIHByb3ZpZGVyIGJ5IGl0cyB1bmlxdWUgSUQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gcHJvdmlkZXJJZFxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lXG4gICAgICogQHBhcmFtIHtib29sZWFufSBlbmFibGVkXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGN1c3RvbWVySWRcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gYXBpS2V5XG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGZyb21cbiAgICAgKiBAdGhyb3dzIHtBcHB3cml0ZUV4Y2VwdGlvbn1cbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZX1cbiAgICAgKi9cbiAgICBhc3luYyB1cGRhdGVUZWxlc2lnblByb3ZpZGVyKHByb3ZpZGVySWQsIG5hbWUsIGVuYWJsZWQsIGN1c3RvbWVySWQsIGFwaUtleSwgZnJvbSkge1xuICAgICAgICBjb25zdCBhcGlQYXRoID0gJy9tZXNzYWdpbmcvcHJvdmlkZXJzL3RlbGVzaWduL3twcm92aWRlcklkfScucmVwbGFjZSgne3Byb3ZpZGVySWR9JywgcHJvdmlkZXJJZCk7XG4gICAgICAgIGxldCBwYXlsb2FkID0ge307XG4gICAgICAgIGlmICh0eXBlb2YgcHJvdmlkZXJJZCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBBcHB3cml0ZUV4Y2VwdGlvbignTWlzc2luZyByZXF1aXJlZCBwYXJhbWV0ZXI6IFwicHJvdmlkZXJJZFwiJyk7XG4gICAgICAgIH1cblxuXG4gICAgICAgIGlmICh0eXBlb2YgbmFtZSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHBheWxvYWRbJ25hbWUnXSA9IG5hbWU7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodHlwZW9mIGVuYWJsZWQgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICBwYXlsb2FkWydlbmFibGVkJ10gPSBlbmFibGVkO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHR5cGVvZiBjdXN0b21lcklkICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgcGF5bG9hZFsnY3VzdG9tZXJJZCddID0gY3VzdG9tZXJJZDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0eXBlb2YgYXBpS2V5ICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgcGF5bG9hZFsnYXBpS2V5J10gPSBhcGlLZXk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodHlwZW9mIGZyb20gIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICBwYXlsb2FkWydmcm9tJ10gPSBmcm9tO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMuY2xpZW50LmNhbGwoJ3BhdGNoJywgYXBpUGF0aCwge1xuICAgICAgICAgICAgJ2NvbnRlbnQtdHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJyxcbiAgICAgICAgfSwgcGF5bG9hZCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlIFRleHRtYWdpYyBwcm92aWRlclxuICAgICAqXG4gICAgICogQ3JlYXRlIGEgbmV3IFRleHRtYWdpYyBwcm92aWRlci5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBwcm92aWRlcklkXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IG5hbWVcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gZnJvbVxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSB1c2VybmFtZVxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBhcGlLZXlcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IGVuYWJsZWRcbiAgICAgKiBAdGhyb3dzIHtBcHB3cml0ZUV4Y2VwdGlvbn1cbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZX1cbiAgICAgKi9cbiAgICBhc3luYyBjcmVhdGVUZXh0bWFnaWNQcm92aWRlcihwcm92aWRlcklkLCBuYW1lLCBmcm9tLCB1c2VybmFtZSwgYXBpS2V5LCBlbmFibGVkKSB7XG4gICAgICAgIGNvbnN0IGFwaVBhdGggPSAnL21lc3NhZ2luZy9wcm92aWRlcnMvdGV4dG1hZ2ljJztcbiAgICAgICAgbGV0IHBheWxvYWQgPSB7fTtcbiAgICAgICAgaWYgKHR5cGVvZiBwcm92aWRlcklkID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEFwcHdyaXRlRXhjZXB0aW9uKCdNaXNzaW5nIHJlcXVpcmVkIHBhcmFtZXRlcjogXCJwcm92aWRlcklkXCInKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0eXBlb2YgbmFtZSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBBcHB3cml0ZUV4Y2VwdGlvbignTWlzc2luZyByZXF1aXJlZCBwYXJhbWV0ZXI6IFwibmFtZVwiJyk7XG4gICAgICAgIH1cblxuXG4gICAgICAgIGlmICh0eXBlb2YgcHJvdmlkZXJJZCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHBheWxvYWRbJ3Byb3ZpZGVySWQnXSA9IHByb3ZpZGVySWQ7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodHlwZW9mIG5hbWUgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICBwYXlsb2FkWyduYW1lJ10gPSBuYW1lO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHR5cGVvZiBmcm9tICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgcGF5bG9hZFsnZnJvbSddID0gZnJvbTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0eXBlb2YgdXNlcm5hbWUgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICBwYXlsb2FkWyd1c2VybmFtZSddID0gdXNlcm5hbWU7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodHlwZW9mIGFwaUtleSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHBheWxvYWRbJ2FwaUtleSddID0gYXBpS2V5O1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHR5cGVvZiBlbmFibGVkICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgcGF5bG9hZFsnZW5hYmxlZCddID0gZW5hYmxlZDtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBhd2FpdCB0aGlzLmNsaWVudC5jYWxsKCdwb3N0JywgYXBpUGF0aCwge1xuICAgICAgICAgICAgJ2NvbnRlbnQtdHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJyxcbiAgICAgICAgfSwgcGF5bG9hZCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVXBkYXRlIFRleHRtYWdpYyBwcm92aWRlclxuICAgICAqXG4gICAgICogVXBkYXRlIGEgVGV4dG1hZ2ljIHByb3ZpZGVyIGJ5IGl0cyB1bmlxdWUgSUQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gcHJvdmlkZXJJZFxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lXG4gICAgICogQHBhcmFtIHtib29sZWFufSBlbmFibGVkXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHVzZXJuYW1lXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGFwaUtleVxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBmcm9tXG4gICAgICogQHRocm93cyB7QXBwd3JpdGVFeGNlcHRpb259XG4gICAgICogQHJldHVybnMge1Byb21pc2V9XG4gICAgICovXG4gICAgYXN5bmMgdXBkYXRlVGV4dG1hZ2ljUHJvdmlkZXIocHJvdmlkZXJJZCwgbmFtZSwgZW5hYmxlZCwgdXNlcm5hbWUsIGFwaUtleSwgZnJvbSkge1xuICAgICAgICBjb25zdCBhcGlQYXRoID0gJy9tZXNzYWdpbmcvcHJvdmlkZXJzL3RleHRtYWdpYy97cHJvdmlkZXJJZH0nLnJlcGxhY2UoJ3twcm92aWRlcklkfScsIHByb3ZpZGVySWQpO1xuICAgICAgICBsZXQgcGF5bG9hZCA9IHt9O1xuICAgICAgICBpZiAodHlwZW9mIHByb3ZpZGVySWQgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgQXBwd3JpdGVFeGNlcHRpb24oJ01pc3NpbmcgcmVxdWlyZWQgcGFyYW1ldGVyOiBcInByb3ZpZGVySWRcIicpO1xuICAgICAgICB9XG5cblxuICAgICAgICBpZiAodHlwZW9mIG5hbWUgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICBwYXlsb2FkWyduYW1lJ10gPSBuYW1lO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHR5cGVvZiBlbmFibGVkICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgcGF5bG9hZFsnZW5hYmxlZCddID0gZW5hYmxlZDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0eXBlb2YgdXNlcm5hbWUgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICBwYXlsb2FkWyd1c2VybmFtZSddID0gdXNlcm5hbWU7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodHlwZW9mIGFwaUtleSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHBheWxvYWRbJ2FwaUtleSddID0gYXBpS2V5O1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHR5cGVvZiBmcm9tICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgcGF5bG9hZFsnZnJvbSddID0gZnJvbTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBhd2FpdCB0aGlzLmNsaWVudC5jYWxsKCdwYXRjaCcsIGFwaVBhdGgsIHtcbiAgICAgICAgICAgICdjb250ZW50LXR5cGUnOiAnYXBwbGljYXRpb24vanNvbicsXG4gICAgICAgIH0sIHBheWxvYWQpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZSBUd2lsaW8gcHJvdmlkZXJcbiAgICAgKlxuICAgICAqIENyZWF0ZSBhIG5ldyBUd2lsaW8gcHJvdmlkZXIuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gcHJvdmlkZXJJZFxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGZyb21cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gYWNjb3VudFNpZFxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBhdXRoVG9rZW5cbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IGVuYWJsZWRcbiAgICAgKiBAdGhyb3dzIHtBcHB3cml0ZUV4Y2VwdGlvbn1cbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZX1cbiAgICAgKi9cbiAgICBhc3luYyBjcmVhdGVUd2lsaW9Qcm92aWRlcihwcm92aWRlcklkLCBuYW1lLCBmcm9tLCBhY2NvdW50U2lkLCBhdXRoVG9rZW4sIGVuYWJsZWQpIHtcbiAgICAgICAgY29uc3QgYXBpUGF0aCA9ICcvbWVzc2FnaW5nL3Byb3ZpZGVycy90d2lsaW8nO1xuICAgICAgICBsZXQgcGF5bG9hZCA9IHt9O1xuICAgICAgICBpZiAodHlwZW9mIHByb3ZpZGVySWQgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgQXBwd3JpdGVFeGNlcHRpb24oJ01pc3NpbmcgcmVxdWlyZWQgcGFyYW1ldGVyOiBcInByb3ZpZGVySWRcIicpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHR5cGVvZiBuYW1lID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEFwcHdyaXRlRXhjZXB0aW9uKCdNaXNzaW5nIHJlcXVpcmVkIHBhcmFtZXRlcjogXCJuYW1lXCInKTtcbiAgICAgICAgfVxuXG5cbiAgICAgICAgaWYgKHR5cGVvZiBwcm92aWRlcklkICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgcGF5bG9hZFsncHJvdmlkZXJJZCddID0gcHJvdmlkZXJJZDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0eXBlb2YgbmFtZSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHBheWxvYWRbJ25hbWUnXSA9IG5hbWU7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodHlwZW9mIGZyb20gIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICBwYXlsb2FkWydmcm9tJ10gPSBmcm9tO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHR5cGVvZiBhY2NvdW50U2lkICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgcGF5bG9hZFsnYWNjb3VudFNpZCddID0gYWNjb3VudFNpZDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0eXBlb2YgYXV0aFRva2VuICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgcGF5bG9hZFsnYXV0aFRva2VuJ10gPSBhdXRoVG9rZW47XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodHlwZW9mIGVuYWJsZWQgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICBwYXlsb2FkWydlbmFibGVkJ10gPSBlbmFibGVkO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMuY2xpZW50LmNhbGwoJ3Bvc3QnLCBhcGlQYXRoLCB7XG4gICAgICAgICAgICAnY29udGVudC10eXBlJzogJ2FwcGxpY2F0aW9uL2pzb24nLFxuICAgICAgICB9LCBwYXlsb2FkKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBVcGRhdGUgVHdpbGlvIHByb3ZpZGVyXG4gICAgICpcbiAgICAgKiBVcGRhdGUgYSBUd2lsaW8gcHJvdmlkZXIgYnkgaXRzIHVuaXF1ZSBJRC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBwcm92aWRlcklkXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IG5hbWVcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IGVuYWJsZWRcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gYWNjb3VudFNpZFxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBhdXRoVG9rZW5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gZnJvbVxuICAgICAqIEB0aHJvd3Mge0FwcHdyaXRlRXhjZXB0aW9ufVxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlfVxuICAgICAqL1xuICAgIGFzeW5jIHVwZGF0ZVR3aWxpb1Byb3ZpZGVyKHByb3ZpZGVySWQsIG5hbWUsIGVuYWJsZWQsIGFjY291bnRTaWQsIGF1dGhUb2tlbiwgZnJvbSkge1xuICAgICAgICBjb25zdCBhcGlQYXRoID0gJy9tZXNzYWdpbmcvcHJvdmlkZXJzL3R3aWxpby97cHJvdmlkZXJJZH0nLnJlcGxhY2UoJ3twcm92aWRlcklkfScsIHByb3ZpZGVySWQpO1xuICAgICAgICBsZXQgcGF5bG9hZCA9IHt9O1xuICAgICAgICBpZiAodHlwZW9mIHByb3ZpZGVySWQgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgQXBwd3JpdGVFeGNlcHRpb24oJ01pc3NpbmcgcmVxdWlyZWQgcGFyYW1ldGVyOiBcInByb3ZpZGVySWRcIicpO1xuICAgICAgICB9XG5cblxuICAgICAgICBpZiAodHlwZW9mIG5hbWUgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICBwYXlsb2FkWyduYW1lJ10gPSBuYW1lO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHR5cGVvZiBlbmFibGVkICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgcGF5bG9hZFsnZW5hYmxlZCddID0gZW5hYmxlZDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0eXBlb2YgYWNjb3VudFNpZCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHBheWxvYWRbJ2FjY291bnRTaWQnXSA9IGFjY291bnRTaWQ7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodHlwZW9mIGF1dGhUb2tlbiAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHBheWxvYWRbJ2F1dGhUb2tlbiddID0gYXV0aFRva2VuO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHR5cGVvZiBmcm9tICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgcGF5bG9hZFsnZnJvbSddID0gZnJvbTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBhd2FpdCB0aGlzLmNsaWVudC5jYWxsKCdwYXRjaCcsIGFwaVBhdGgsIHtcbiAgICAgICAgICAgICdjb250ZW50LXR5cGUnOiAnYXBwbGljYXRpb24vanNvbicsXG4gICAgICAgIH0sIHBheWxvYWQpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZSBWb25hZ2UgcHJvdmlkZXJcbiAgICAgKlxuICAgICAqIENyZWF0ZSBhIG5ldyBWb25hZ2UgcHJvdmlkZXIuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gcHJvdmlkZXJJZFxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGZyb21cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gYXBpS2V5XG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGFwaVNlY3JldFxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gZW5hYmxlZFxuICAgICAqIEB0aHJvd3Mge0FwcHdyaXRlRXhjZXB0aW9ufVxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlfVxuICAgICAqL1xuICAgIGFzeW5jIGNyZWF0ZVZvbmFnZVByb3ZpZGVyKHByb3ZpZGVySWQsIG5hbWUsIGZyb20sIGFwaUtleSwgYXBpU2VjcmV0LCBlbmFibGVkKSB7XG4gICAgICAgIGNvbnN0IGFwaVBhdGggPSAnL21lc3NhZ2luZy9wcm92aWRlcnMvdm9uYWdlJztcbiAgICAgICAgbGV0IHBheWxvYWQgPSB7fTtcbiAgICAgICAgaWYgKHR5cGVvZiBwcm92aWRlcklkID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEFwcHdyaXRlRXhjZXB0aW9uKCdNaXNzaW5nIHJlcXVpcmVkIHBhcmFtZXRlcjogXCJwcm92aWRlcklkXCInKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0eXBlb2YgbmFtZSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBBcHB3cml0ZUV4Y2VwdGlvbignTWlzc2luZyByZXF1aXJlZCBwYXJhbWV0ZXI6IFwibmFtZVwiJyk7XG4gICAgICAgIH1cblxuXG4gICAgICAgIGlmICh0eXBlb2YgcHJvdmlkZXJJZCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHBheWxvYWRbJ3Byb3ZpZGVySWQnXSA9IHByb3ZpZGVySWQ7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodHlwZW9mIG5hbWUgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICBwYXlsb2FkWyduYW1lJ10gPSBuYW1lO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHR5cGVvZiBmcm9tICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgcGF5bG9hZFsnZnJvbSddID0gZnJvbTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0eXBlb2YgYXBpS2V5ICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgcGF5bG9hZFsnYXBpS2V5J10gPSBhcGlLZXk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodHlwZW9mIGFwaVNlY3JldCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHBheWxvYWRbJ2FwaVNlY3JldCddID0gYXBpU2VjcmV0O1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHR5cGVvZiBlbmFibGVkICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgcGF5bG9hZFsnZW5hYmxlZCddID0gZW5hYmxlZDtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBhd2FpdCB0aGlzLmNsaWVudC5jYWxsKCdwb3N0JywgYXBpUGF0aCwge1xuICAgICAgICAgICAgJ2NvbnRlbnQtdHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJyxcbiAgICAgICAgfSwgcGF5bG9hZCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVXBkYXRlIFZvbmFnZSBwcm92aWRlclxuICAgICAqXG4gICAgICogVXBkYXRlIGEgVm9uYWdlIHByb3ZpZGVyIGJ5IGl0cyB1bmlxdWUgSUQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gcHJvdmlkZXJJZFxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lXG4gICAgICogQHBhcmFtIHtib29sZWFufSBlbmFibGVkXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGFwaUtleVxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBhcGlTZWNyZXRcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gZnJvbVxuICAgICAqIEB0aHJvd3Mge0FwcHdyaXRlRXhjZXB0aW9ufVxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlfVxuICAgICAqL1xuICAgIGFzeW5jIHVwZGF0ZVZvbmFnZVByb3ZpZGVyKHByb3ZpZGVySWQsIG5hbWUsIGVuYWJsZWQsIGFwaUtleSwgYXBpU2VjcmV0LCBmcm9tKSB7XG4gICAgICAgIGNvbnN0IGFwaVBhdGggPSAnL21lc3NhZ2luZy9wcm92aWRlcnMvdm9uYWdlL3twcm92aWRlcklkfScucmVwbGFjZSgne3Byb3ZpZGVySWR9JywgcHJvdmlkZXJJZCk7XG4gICAgICAgIGxldCBwYXlsb2FkID0ge307XG4gICAgICAgIGlmICh0eXBlb2YgcHJvdmlkZXJJZCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBBcHB3cml0ZUV4Y2VwdGlvbignTWlzc2luZyByZXF1aXJlZCBwYXJhbWV0ZXI6IFwicHJvdmlkZXJJZFwiJyk7XG4gICAgICAgIH1cblxuXG4gICAgICAgIGlmICh0eXBlb2YgbmFtZSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHBheWxvYWRbJ25hbWUnXSA9IG5hbWU7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodHlwZW9mIGVuYWJsZWQgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICBwYXlsb2FkWydlbmFibGVkJ10gPSBlbmFibGVkO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHR5cGVvZiBhcGlLZXkgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICBwYXlsb2FkWydhcGlLZXknXSA9IGFwaUtleTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0eXBlb2YgYXBpU2VjcmV0ICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgcGF5bG9hZFsnYXBpU2VjcmV0J10gPSBhcGlTZWNyZXQ7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodHlwZW9mIGZyb20gIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICBwYXlsb2FkWydmcm9tJ10gPSBmcm9tO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMuY2xpZW50LmNhbGwoJ3BhdGNoJywgYXBpUGF0aCwge1xuICAgICAgICAgICAgJ2NvbnRlbnQtdHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJyxcbiAgICAgICAgfSwgcGF5bG9hZCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2V0IHByb3ZpZGVyXG4gICAgICpcbiAgICAgKiBHZXQgYSBwcm92aWRlciBieSBpdHMgdW5pcXVlIElELlxuICAgICAqIFxuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHByb3ZpZGVySWRcbiAgICAgKiBAdGhyb3dzIHtBcHB3cml0ZUV4Y2VwdGlvbn1cbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZX1cbiAgICAgKi9cbiAgICBhc3luYyBnZXRQcm92aWRlcihwcm92aWRlcklkKSB7XG4gICAgICAgIGNvbnN0IGFwaVBhdGggPSAnL21lc3NhZ2luZy9wcm92aWRlcnMve3Byb3ZpZGVySWR9Jy5yZXBsYWNlKCd7cHJvdmlkZXJJZH0nLCBwcm92aWRlcklkKTtcbiAgICAgICAgbGV0IHBheWxvYWQgPSB7fTtcbiAgICAgICAgaWYgKHR5cGVvZiBwcm92aWRlcklkID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEFwcHdyaXRlRXhjZXB0aW9uKCdNaXNzaW5nIHJlcXVpcmVkIHBhcmFtZXRlcjogXCJwcm92aWRlcklkXCInKTtcbiAgICAgICAgfVxuXG5cbiAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMuY2xpZW50LmNhbGwoJ2dldCcsIGFwaVBhdGgsIHtcbiAgICAgICAgICAgICdjb250ZW50LXR5cGUnOiAnYXBwbGljYXRpb24vanNvbicsXG4gICAgICAgIH0sIHBheWxvYWQpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIERlbGV0ZSBwcm92aWRlclxuICAgICAqXG4gICAgICogRGVsZXRlIGEgcHJvdmlkZXIgYnkgaXRzIHVuaXF1ZSBJRC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBwcm92aWRlcklkXG4gICAgICogQHRocm93cyB7QXBwd3JpdGVFeGNlcHRpb259XG4gICAgICogQHJldHVybnMge1Byb21pc2V9XG4gICAgICovXG4gICAgYXN5bmMgZGVsZXRlUHJvdmlkZXIocHJvdmlkZXJJZCkge1xuICAgICAgICBjb25zdCBhcGlQYXRoID0gJy9tZXNzYWdpbmcvcHJvdmlkZXJzL3twcm92aWRlcklkfScucmVwbGFjZSgne3Byb3ZpZGVySWR9JywgcHJvdmlkZXJJZCk7XG4gICAgICAgIGxldCBwYXlsb2FkID0ge307XG4gICAgICAgIGlmICh0eXBlb2YgcHJvdmlkZXJJZCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBBcHB3cml0ZUV4Y2VwdGlvbignTWlzc2luZyByZXF1aXJlZCBwYXJhbWV0ZXI6IFwicHJvdmlkZXJJZFwiJyk7XG4gICAgICAgIH1cblxuXG4gICAgICAgIHJldHVybiBhd2FpdCB0aGlzLmNsaWVudC5jYWxsKCdkZWxldGUnLCBhcGlQYXRoLCB7XG4gICAgICAgICAgICAnY29udGVudC10eXBlJzogJ2FwcGxpY2F0aW9uL2pzb24nLFxuICAgICAgICB9LCBwYXlsb2FkKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBMaXN0IHByb3ZpZGVyIGxvZ3NcbiAgICAgKlxuICAgICAqIEdldCB0aGUgcHJvdmlkZXIgYWN0aXZpdHkgbG9ncyBsaXN0ZWQgYnkgaXRzIHVuaXF1ZSBJRC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBwcm92aWRlcklkXG4gICAgICogQHBhcmFtIHtzdHJpbmdbXX0gcXVlcmllc1xuICAgICAqIEB0aHJvd3Mge0FwcHdyaXRlRXhjZXB0aW9ufVxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlfVxuICAgICAqL1xuICAgIGFzeW5jIGxpc3RQcm92aWRlckxvZ3MocHJvdmlkZXJJZCwgcXVlcmllcykge1xuICAgICAgICBjb25zdCBhcGlQYXRoID0gJy9tZXNzYWdpbmcvcHJvdmlkZXJzL3twcm92aWRlcklkfS9sb2dzJy5yZXBsYWNlKCd7cHJvdmlkZXJJZH0nLCBwcm92aWRlcklkKTtcbiAgICAgICAgbGV0IHBheWxvYWQgPSB7fTtcbiAgICAgICAgaWYgKHR5cGVvZiBwcm92aWRlcklkID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEFwcHdyaXRlRXhjZXB0aW9uKCdNaXNzaW5nIHJlcXVpcmVkIHBhcmFtZXRlcjogXCJwcm92aWRlcklkXCInKTtcbiAgICAgICAgfVxuXG5cbiAgICAgICAgaWYgKHR5cGVvZiBxdWVyaWVzICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgcGF5bG9hZFsncXVlcmllcyddID0gcXVlcmllcztcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBhd2FpdCB0aGlzLmNsaWVudC5jYWxsKCdnZXQnLCBhcGlQYXRoLCB7XG4gICAgICAgICAgICAnY29udGVudC10eXBlJzogJ2FwcGxpY2F0aW9uL2pzb24nLFxuICAgICAgICB9LCBwYXlsb2FkKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBMaXN0IHN1YnNjcmliZXIgbG9nc1xuICAgICAqXG4gICAgICogR2V0IHRoZSBzdWJzY3JpYmVyIGFjdGl2aXR5IGxvZ3MgbGlzdGVkIGJ5IGl0cyB1bmlxdWUgSUQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gc3Vic2NyaWJlcklkXG4gICAgICogQHBhcmFtIHtzdHJpbmdbXX0gcXVlcmllc1xuICAgICAqIEB0aHJvd3Mge0FwcHdyaXRlRXhjZXB0aW9ufVxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlfVxuICAgICAqL1xuICAgIGFzeW5jIGxpc3RTdWJzY3JpYmVyTG9ncyhzdWJzY3JpYmVySWQsIHF1ZXJpZXMpIHtcbiAgICAgICAgY29uc3QgYXBpUGF0aCA9ICcvbWVzc2FnaW5nL3N1YnNjcmliZXJzL3tzdWJzY3JpYmVySWR9L2xvZ3MnLnJlcGxhY2UoJ3tzdWJzY3JpYmVySWR9Jywgc3Vic2NyaWJlcklkKTtcbiAgICAgICAgbGV0IHBheWxvYWQgPSB7fTtcbiAgICAgICAgaWYgKHR5cGVvZiBzdWJzY3JpYmVySWQgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgQXBwd3JpdGVFeGNlcHRpb24oJ01pc3NpbmcgcmVxdWlyZWQgcGFyYW1ldGVyOiBcInN1YnNjcmliZXJJZFwiJyk7XG4gICAgICAgIH1cblxuXG4gICAgICAgIGlmICh0eXBlb2YgcXVlcmllcyAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHBheWxvYWRbJ3F1ZXJpZXMnXSA9IHF1ZXJpZXM7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy5jbGllbnQuY2FsbCgnZ2V0JywgYXBpUGF0aCwge1xuICAgICAgICAgICAgJ2NvbnRlbnQtdHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJyxcbiAgICAgICAgfSwgcGF5bG9hZCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogTGlzdCB0b3BpY3NcbiAgICAgKlxuICAgICAqIEdldCBhIGxpc3Qgb2YgYWxsIHRvcGljcyBmcm9tIHRoZSBjdXJyZW50IEFwcHdyaXRlIHByb2plY3QuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZ1tdfSBxdWVyaWVzXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHNlYXJjaFxuICAgICAqIEB0aHJvd3Mge0FwcHdyaXRlRXhjZXB0aW9ufVxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlfVxuICAgICAqL1xuICAgIGFzeW5jIGxpc3RUb3BpY3MocXVlcmllcywgc2VhcmNoKSB7XG4gICAgICAgIGNvbnN0IGFwaVBhdGggPSAnL21lc3NhZ2luZy90b3BpY3MnO1xuICAgICAgICBsZXQgcGF5bG9hZCA9IHt9O1xuXG4gICAgICAgIGlmICh0eXBlb2YgcXVlcmllcyAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHBheWxvYWRbJ3F1ZXJpZXMnXSA9IHF1ZXJpZXM7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodHlwZW9mIHNlYXJjaCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHBheWxvYWRbJ3NlYXJjaCddID0gc2VhcmNoO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMuY2xpZW50LmNhbGwoJ2dldCcsIGFwaVBhdGgsIHtcbiAgICAgICAgICAgICdjb250ZW50LXR5cGUnOiAnYXBwbGljYXRpb24vanNvbicsXG4gICAgICAgIH0sIHBheWxvYWQpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZSB0b3BpY1xuICAgICAqXG4gICAgICogQ3JlYXRlIGEgbmV3IHRvcGljLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHRvcGljSWRcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gbmFtZVxuICAgICAqIEBwYXJhbSB7c3RyaW5nW119IHN1YnNjcmliZVxuICAgICAqIEB0aHJvd3Mge0FwcHdyaXRlRXhjZXB0aW9ufVxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlfVxuICAgICAqL1xuICAgIGFzeW5jIGNyZWF0ZVRvcGljKHRvcGljSWQsIG5hbWUsIHN1YnNjcmliZSkge1xuICAgICAgICBjb25zdCBhcGlQYXRoID0gJy9tZXNzYWdpbmcvdG9waWNzJztcbiAgICAgICAgbGV0IHBheWxvYWQgPSB7fTtcbiAgICAgICAgaWYgKHR5cGVvZiB0b3BpY0lkID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEFwcHdyaXRlRXhjZXB0aW9uKCdNaXNzaW5nIHJlcXVpcmVkIHBhcmFtZXRlcjogXCJ0b3BpY0lkXCInKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0eXBlb2YgbmFtZSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBBcHB3cml0ZUV4Y2VwdGlvbignTWlzc2luZyByZXF1aXJlZCBwYXJhbWV0ZXI6IFwibmFtZVwiJyk7XG4gICAgICAgIH1cblxuXG4gICAgICAgIGlmICh0eXBlb2YgdG9waWNJZCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHBheWxvYWRbJ3RvcGljSWQnXSA9IHRvcGljSWQ7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodHlwZW9mIG5hbWUgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICBwYXlsb2FkWyduYW1lJ10gPSBuYW1lO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHR5cGVvZiBzdWJzY3JpYmUgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICBwYXlsb2FkWydzdWJzY3JpYmUnXSA9IHN1YnNjcmliZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBhd2FpdCB0aGlzLmNsaWVudC5jYWxsKCdwb3N0JywgYXBpUGF0aCwge1xuICAgICAgICAgICAgJ2NvbnRlbnQtdHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJyxcbiAgICAgICAgfSwgcGF5bG9hZCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2V0IHRvcGljXG4gICAgICpcbiAgICAgKiBHZXQgYSB0b3BpYyBieSBpdHMgdW5pcXVlIElELlxuICAgICAqIFxuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHRvcGljSWRcbiAgICAgKiBAdGhyb3dzIHtBcHB3cml0ZUV4Y2VwdGlvbn1cbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZX1cbiAgICAgKi9cbiAgICBhc3luYyBnZXRUb3BpYyh0b3BpY0lkKSB7XG4gICAgICAgIGNvbnN0IGFwaVBhdGggPSAnL21lc3NhZ2luZy90b3BpY3Mve3RvcGljSWR9Jy5yZXBsYWNlKCd7dG9waWNJZH0nLCB0b3BpY0lkKTtcbiAgICAgICAgbGV0IHBheWxvYWQgPSB7fTtcbiAgICAgICAgaWYgKHR5cGVvZiB0b3BpY0lkID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEFwcHdyaXRlRXhjZXB0aW9uKCdNaXNzaW5nIHJlcXVpcmVkIHBhcmFtZXRlcjogXCJ0b3BpY0lkXCInKTtcbiAgICAgICAgfVxuXG5cbiAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMuY2xpZW50LmNhbGwoJ2dldCcsIGFwaVBhdGgsIHtcbiAgICAgICAgICAgICdjb250ZW50LXR5cGUnOiAnYXBwbGljYXRpb24vanNvbicsXG4gICAgICAgIH0sIHBheWxvYWQpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFVwZGF0ZSB0b3BpY1xuICAgICAqXG4gICAgICogVXBkYXRlIGEgdG9waWMgYnkgaXRzIHVuaXF1ZSBJRC5cbiAgICAgKiBcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSB0b3BpY0lkXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IG5hbWVcbiAgICAgKiBAcGFyYW0ge3N0cmluZ1tdfSBzdWJzY3JpYmVcbiAgICAgKiBAdGhyb3dzIHtBcHB3cml0ZUV4Y2VwdGlvbn1cbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZX1cbiAgICAgKi9cbiAgICBhc3luYyB1cGRhdGVUb3BpYyh0b3BpY0lkLCBuYW1lLCBzdWJzY3JpYmUpIHtcbiAgICAgICAgY29uc3QgYXBpUGF0aCA9ICcvbWVzc2FnaW5nL3RvcGljcy97dG9waWNJZH0nLnJlcGxhY2UoJ3t0b3BpY0lkfScsIHRvcGljSWQpO1xuICAgICAgICBsZXQgcGF5bG9hZCA9IHt9O1xuICAgICAgICBpZiAodHlwZW9mIHRvcGljSWQgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgQXBwd3JpdGVFeGNlcHRpb24oJ01pc3NpbmcgcmVxdWlyZWQgcGFyYW1ldGVyOiBcInRvcGljSWRcIicpO1xuICAgICAgICB9XG5cblxuICAgICAgICBpZiAodHlwZW9mIG5hbWUgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICBwYXlsb2FkWyduYW1lJ10gPSBuYW1lO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHR5cGVvZiBzdWJzY3JpYmUgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICBwYXlsb2FkWydzdWJzY3JpYmUnXSA9IHN1YnNjcmliZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBhd2FpdCB0aGlzLmNsaWVudC5jYWxsKCdwYXRjaCcsIGFwaVBhdGgsIHtcbiAgICAgICAgICAgICdjb250ZW50LXR5cGUnOiAnYXBwbGljYXRpb24vanNvbicsXG4gICAgICAgIH0sIHBheWxvYWQpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIERlbGV0ZSB0b3BpY1xuICAgICAqXG4gICAgICogRGVsZXRlIGEgdG9waWMgYnkgaXRzIHVuaXF1ZSBJRC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSB0b3BpY0lkXG4gICAgICogQHRocm93cyB7QXBwd3JpdGVFeGNlcHRpb259XG4gICAgICogQHJldHVybnMge1Byb21pc2V9XG4gICAgICovXG4gICAgYXN5bmMgZGVsZXRlVG9waWModG9waWNJZCkge1xuICAgICAgICBjb25zdCBhcGlQYXRoID0gJy9tZXNzYWdpbmcvdG9waWNzL3t0b3BpY0lkfScucmVwbGFjZSgne3RvcGljSWR9JywgdG9waWNJZCk7XG4gICAgICAgIGxldCBwYXlsb2FkID0ge307XG4gICAgICAgIGlmICh0eXBlb2YgdG9waWNJZCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBBcHB3cml0ZUV4Y2VwdGlvbignTWlzc2luZyByZXF1aXJlZCBwYXJhbWV0ZXI6IFwidG9waWNJZFwiJyk7XG4gICAgICAgIH1cblxuXG4gICAgICAgIHJldHVybiBhd2FpdCB0aGlzLmNsaWVudC5jYWxsKCdkZWxldGUnLCBhcGlQYXRoLCB7XG4gICAgICAgICAgICAnY29udGVudC10eXBlJzogJ2FwcGxpY2F0aW9uL2pzb24nLFxuICAgICAgICB9LCBwYXlsb2FkKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBMaXN0IHRvcGljIGxvZ3NcbiAgICAgKlxuICAgICAqIEdldCB0aGUgdG9waWMgYWN0aXZpdHkgbG9ncyBsaXN0ZWQgYnkgaXRzIHVuaXF1ZSBJRC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSB0b3BpY0lkXG4gICAgICogQHBhcmFtIHtzdHJpbmdbXX0gcXVlcmllc1xuICAgICAqIEB0aHJvd3Mge0FwcHdyaXRlRXhjZXB0aW9ufVxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlfVxuICAgICAqL1xuICAgIGFzeW5jIGxpc3RUb3BpY0xvZ3ModG9waWNJZCwgcXVlcmllcykge1xuICAgICAgICBjb25zdCBhcGlQYXRoID0gJy9tZXNzYWdpbmcvdG9waWNzL3t0b3BpY0lkfS9sb2dzJy5yZXBsYWNlKCd7dG9waWNJZH0nLCB0b3BpY0lkKTtcbiAgICAgICAgbGV0IHBheWxvYWQgPSB7fTtcbiAgICAgICAgaWYgKHR5cGVvZiB0b3BpY0lkID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEFwcHdyaXRlRXhjZXB0aW9uKCdNaXNzaW5nIHJlcXVpcmVkIHBhcmFtZXRlcjogXCJ0b3BpY0lkXCInKTtcbiAgICAgICAgfVxuXG5cbiAgICAgICAgaWYgKHR5cGVvZiBxdWVyaWVzICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgcGF5bG9hZFsncXVlcmllcyddID0gcXVlcmllcztcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBhd2FpdCB0aGlzLmNsaWVudC5jYWxsKCdnZXQnLCBhcGlQYXRoLCB7XG4gICAgICAgICAgICAnY29udGVudC10eXBlJzogJ2FwcGxpY2F0aW9uL2pzb24nLFxuICAgICAgICB9LCBwYXlsb2FkKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBMaXN0IHN1YnNjcmliZXJzXG4gICAgICpcbiAgICAgKiBHZXQgYSBsaXN0IG9mIGFsbCBzdWJzY3JpYmVycyBmcm9tIHRoZSBjdXJyZW50IEFwcHdyaXRlIHByb2plY3QuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gdG9waWNJZFxuICAgICAqIEBwYXJhbSB7c3RyaW5nW119IHF1ZXJpZXNcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gc2VhcmNoXG4gICAgICogQHRocm93cyB7QXBwd3JpdGVFeGNlcHRpb259XG4gICAgICogQHJldHVybnMge1Byb21pc2V9XG4gICAgICovXG4gICAgYXN5bmMgbGlzdFN1YnNjcmliZXJzKHRvcGljSWQsIHF1ZXJpZXMsIHNlYXJjaCkge1xuICAgICAgICBjb25zdCBhcGlQYXRoID0gJy9tZXNzYWdpbmcvdG9waWNzL3t0b3BpY0lkfS9zdWJzY3JpYmVycycucmVwbGFjZSgne3RvcGljSWR9JywgdG9waWNJZCk7XG4gICAgICAgIGxldCBwYXlsb2FkID0ge307XG4gICAgICAgIGlmICh0eXBlb2YgdG9waWNJZCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBBcHB3cml0ZUV4Y2VwdGlvbignTWlzc2luZyByZXF1aXJlZCBwYXJhbWV0ZXI6IFwidG9waWNJZFwiJyk7XG4gICAgICAgIH1cblxuXG4gICAgICAgIGlmICh0eXBlb2YgcXVlcmllcyAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHBheWxvYWRbJ3F1ZXJpZXMnXSA9IHF1ZXJpZXM7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodHlwZW9mIHNlYXJjaCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHBheWxvYWRbJ3NlYXJjaCddID0gc2VhcmNoO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMuY2xpZW50LmNhbGwoJ2dldCcsIGFwaVBhdGgsIHtcbiAgICAgICAgICAgICdjb250ZW50LXR5cGUnOiAnYXBwbGljYXRpb24vanNvbicsXG4gICAgICAgIH0sIHBheWxvYWQpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZSBzdWJzY3JpYmVyXG4gICAgICpcbiAgICAgKiBDcmVhdGUgYSBuZXcgc3Vic2NyaWJlci5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSB0b3BpY0lkXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHN1YnNjcmliZXJJZFxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSB0YXJnZXRJZFxuICAgICAqIEB0aHJvd3Mge0FwcHdyaXRlRXhjZXB0aW9ufVxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlfVxuICAgICAqL1xuICAgIGFzeW5jIGNyZWF0ZVN1YnNjcmliZXIodG9waWNJZCwgc3Vic2NyaWJlcklkLCB0YXJnZXRJZCkge1xuICAgICAgICBjb25zdCBhcGlQYXRoID0gJy9tZXNzYWdpbmcvdG9waWNzL3t0b3BpY0lkfS9zdWJzY3JpYmVycycucmVwbGFjZSgne3RvcGljSWR9JywgdG9waWNJZCk7XG4gICAgICAgIGxldCBwYXlsb2FkID0ge307XG4gICAgICAgIGlmICh0eXBlb2YgdG9waWNJZCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBBcHB3cml0ZUV4Y2VwdGlvbignTWlzc2luZyByZXF1aXJlZCBwYXJhbWV0ZXI6IFwidG9waWNJZFwiJyk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodHlwZW9mIHN1YnNjcmliZXJJZCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBBcHB3cml0ZUV4Y2VwdGlvbignTWlzc2luZyByZXF1aXJlZCBwYXJhbWV0ZXI6IFwic3Vic2NyaWJlcklkXCInKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0eXBlb2YgdGFyZ2V0SWQgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgQXBwd3JpdGVFeGNlcHRpb24oJ01pc3NpbmcgcmVxdWlyZWQgcGFyYW1ldGVyOiBcInRhcmdldElkXCInKTtcbiAgICAgICAgfVxuXG5cbiAgICAgICAgaWYgKHR5cGVvZiBzdWJzY3JpYmVySWQgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICBwYXlsb2FkWydzdWJzY3JpYmVySWQnXSA9IHN1YnNjcmliZXJJZDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0eXBlb2YgdGFyZ2V0SWQgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICBwYXlsb2FkWyd0YXJnZXRJZCddID0gdGFyZ2V0SWQ7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy5jbGllbnQuY2FsbCgncG9zdCcsIGFwaVBhdGgsIHtcbiAgICAgICAgICAgICdjb250ZW50LXR5cGUnOiAnYXBwbGljYXRpb24vanNvbicsXG4gICAgICAgIH0sIHBheWxvYWQpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdldCBzdWJzY3JpYmVyXG4gICAgICpcbiAgICAgKiBHZXQgYSBzdWJzY3JpYmVyIGJ5IGl0cyB1bmlxdWUgSUQuXG4gICAgICogXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gdG9waWNJZFxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBzdWJzY3JpYmVySWRcbiAgICAgKiBAdGhyb3dzIHtBcHB3cml0ZUV4Y2VwdGlvbn1cbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZX1cbiAgICAgKi9cbiAgICBhc3luYyBnZXRTdWJzY3JpYmVyKHRvcGljSWQsIHN1YnNjcmliZXJJZCkge1xuICAgICAgICBjb25zdCBhcGlQYXRoID0gJy9tZXNzYWdpbmcvdG9waWNzL3t0b3BpY0lkfS9zdWJzY3JpYmVycy97c3Vic2NyaWJlcklkfScucmVwbGFjZSgne3RvcGljSWR9JywgdG9waWNJZCkucmVwbGFjZSgne3N1YnNjcmliZXJJZH0nLCBzdWJzY3JpYmVySWQpO1xuICAgICAgICBsZXQgcGF5bG9hZCA9IHt9O1xuICAgICAgICBpZiAodHlwZW9mIHRvcGljSWQgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgQXBwd3JpdGVFeGNlcHRpb24oJ01pc3NpbmcgcmVxdWlyZWQgcGFyYW1ldGVyOiBcInRvcGljSWRcIicpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHR5cGVvZiBzdWJzY3JpYmVySWQgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgQXBwd3JpdGVFeGNlcHRpb24oJ01pc3NpbmcgcmVxdWlyZWQgcGFyYW1ldGVyOiBcInN1YnNjcmliZXJJZFwiJyk7XG4gICAgICAgIH1cblxuXG4gICAgICAgIHJldHVybiBhd2FpdCB0aGlzLmNsaWVudC5jYWxsKCdnZXQnLCBhcGlQYXRoLCB7XG4gICAgICAgICAgICAnY29udGVudC10eXBlJzogJ2FwcGxpY2F0aW9uL2pzb24nLFxuICAgICAgICB9LCBwYXlsb2FkKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBEZWxldGUgc3Vic2NyaWJlclxuICAgICAqXG4gICAgICogRGVsZXRlIGEgc3Vic2NyaWJlciBieSBpdHMgdW5pcXVlIElELlxuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHRvcGljSWRcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gc3Vic2NyaWJlcklkXG4gICAgICogQHRocm93cyB7QXBwd3JpdGVFeGNlcHRpb259XG4gICAgICogQHJldHVybnMge1Byb21pc2V9XG4gICAgICovXG4gICAgYXN5bmMgZGVsZXRlU3Vic2NyaWJlcih0b3BpY0lkLCBzdWJzY3JpYmVySWQpIHtcbiAgICAgICAgY29uc3QgYXBpUGF0aCA9ICcvbWVzc2FnaW5nL3RvcGljcy97dG9waWNJZH0vc3Vic2NyaWJlcnMve3N1YnNjcmliZXJJZH0nLnJlcGxhY2UoJ3t0b3BpY0lkfScsIHRvcGljSWQpLnJlcGxhY2UoJ3tzdWJzY3JpYmVySWR9Jywgc3Vic2NyaWJlcklkKTtcbiAgICAgICAgbGV0IHBheWxvYWQgPSB7fTtcbiAgICAgICAgaWYgKHR5cGVvZiB0b3BpY0lkID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEFwcHdyaXRlRXhjZXB0aW9uKCdNaXNzaW5nIHJlcXVpcmVkIHBhcmFtZXRlcjogXCJ0b3BpY0lkXCInKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0eXBlb2Ygc3Vic2NyaWJlcklkID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEFwcHdyaXRlRXhjZXB0aW9uKCdNaXNzaW5nIHJlcXVpcmVkIHBhcmFtZXRlcjogXCJzdWJzY3JpYmVySWRcIicpO1xuICAgICAgICB9XG5cblxuICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy5jbGllbnQuY2FsbCgnZGVsZXRlJywgYXBpUGF0aCwge1xuICAgICAgICAgICAgJ2NvbnRlbnQtdHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJyxcbiAgICAgICAgfSwgcGF5bG9hZCk7XG4gICAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IE1lc3NhZ2luZztcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(action-browser)/./node_modules/node-appwrite/lib/services/messaging.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/node-appwrite/lib/services/messaging.js":
/*!**************************************************************!*\
  !*** ./node_modules/node-appwrite/lib/services/messaging.js ***!
  \**************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("const Service = __webpack_require__(/*! ../service.js */ \"(rsc)/./node_modules/node-appwrite/lib/service.js\");\nconst AppwriteException = __webpack_require__(/*! ../exception.js */ \"(rsc)/./node_modules/node-appwrite/lib/exception.js\");\nconst InputFile = __webpack_require__(/*! ../inputFile.js */ \"(rsc)/./node_modules/node-appwrite/lib/inputFile.js\");\nconst client = __webpack_require__(/*! ../client.js */ \"(rsc)/./node_modules/node-appwrite/lib/client.js\");\nconst Stream = __webpack_require__(/*! stream */ \"stream\");\nconst { promisify } = __webpack_require__(/*! util */ \"util\");\nconst fs = __webpack_require__(/*! fs */ \"fs\");\nconst { File } = __webpack_require__(/*! undici */ \"undici\");\nconst Query = __webpack_require__(/*! ../query.js */ \"(rsc)/./node_modules/node-appwrite/lib/query.js\");\n\nclass Messaging extends Service {\n\n     constructor(client)\n     {\n        super(client);\n     }\n\n\n    /**\n     * List messages\n     *\n     * Get a list of all messages from the current Appwrite project.\n     *\n     * @param {string[]} queries\n     * @param {string} search\n     * @throws {AppwriteException}\n     * @returns {Promise}\n     */\n    async listMessages(queries, search) {\n        const apiPath = '/messaging/messages';\n        let payload = {};\n\n        if (typeof queries !== 'undefined') {\n            payload['queries'] = queries;\n        }\n\n        if (typeof search !== 'undefined') {\n            payload['search'] = search;\n        }\n\n        return await this.client.call('get', apiPath, {\n            'content-type': 'application/json',\n        }, payload);\n    }\n\n    /**\n     * Create email\n     *\n     * Create a new email message.\n     *\n     * @param {string} messageId\n     * @param {string} subject\n     * @param {string} content\n     * @param {string[]} topics\n     * @param {string[]} users\n     * @param {string[]} targets\n     * @param {string[]} cc\n     * @param {string[]} bcc\n     * @param {string[]} attachments\n     * @param {boolean} draft\n     * @param {boolean} html\n     * @param {string} scheduledAt\n     * @throws {AppwriteException}\n     * @returns {Promise}\n     */\n    async createEmail(messageId, subject, content, topics, users, targets, cc, bcc, attachments, draft, html, scheduledAt) {\n        const apiPath = '/messaging/messages/email';\n        let payload = {};\n        if (typeof messageId === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"messageId\"');\n        }\n\n        if (typeof subject === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"subject\"');\n        }\n\n        if (typeof content === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"content\"');\n        }\n\n\n        if (typeof messageId !== 'undefined') {\n            payload['messageId'] = messageId;\n        }\n\n        if (typeof subject !== 'undefined') {\n            payload['subject'] = subject;\n        }\n\n        if (typeof content !== 'undefined') {\n            payload['content'] = content;\n        }\n\n        if (typeof topics !== 'undefined') {\n            payload['topics'] = topics;\n        }\n\n        if (typeof users !== 'undefined') {\n            payload['users'] = users;\n        }\n\n        if (typeof targets !== 'undefined') {\n            payload['targets'] = targets;\n        }\n\n        if (typeof cc !== 'undefined') {\n            payload['cc'] = cc;\n        }\n\n        if (typeof bcc !== 'undefined') {\n            payload['bcc'] = bcc;\n        }\n\n        if (typeof attachments !== 'undefined') {\n            payload['attachments'] = attachments;\n        }\n\n        if (typeof draft !== 'undefined') {\n            payload['draft'] = draft;\n        }\n\n        if (typeof html !== 'undefined') {\n            payload['html'] = html;\n        }\n\n        if (typeof scheduledAt !== 'undefined') {\n            payload['scheduledAt'] = scheduledAt;\n        }\n\n        return await this.client.call('post', apiPath, {\n            'content-type': 'application/json',\n        }, payload);\n    }\n\n    /**\n     * Update email\n     *\n     * Update an email message by its unique ID.\n     * \n     *\n     * @param {string} messageId\n     * @param {string[]} topics\n     * @param {string[]} users\n     * @param {string[]} targets\n     * @param {string} subject\n     * @param {string} content\n     * @param {boolean} draft\n     * @param {boolean} html\n     * @param {string[]} cc\n     * @param {string[]} bcc\n     * @param {string} scheduledAt\n     * @throws {AppwriteException}\n     * @returns {Promise}\n     */\n    async updateEmail(messageId, topics, users, targets, subject, content, draft, html, cc, bcc, scheduledAt) {\n        const apiPath = '/messaging/messages/email/{messageId}'.replace('{messageId}', messageId);\n        let payload = {};\n        if (typeof messageId === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"messageId\"');\n        }\n\n\n        if (typeof topics !== 'undefined') {\n            payload['topics'] = topics;\n        }\n\n        if (typeof users !== 'undefined') {\n            payload['users'] = users;\n        }\n\n        if (typeof targets !== 'undefined') {\n            payload['targets'] = targets;\n        }\n\n        if (typeof subject !== 'undefined') {\n            payload['subject'] = subject;\n        }\n\n        if (typeof content !== 'undefined') {\n            payload['content'] = content;\n        }\n\n        if (typeof draft !== 'undefined') {\n            payload['draft'] = draft;\n        }\n\n        if (typeof html !== 'undefined') {\n            payload['html'] = html;\n        }\n\n        if (typeof cc !== 'undefined') {\n            payload['cc'] = cc;\n        }\n\n        if (typeof bcc !== 'undefined') {\n            payload['bcc'] = bcc;\n        }\n\n        if (typeof scheduledAt !== 'undefined') {\n            payload['scheduledAt'] = scheduledAt;\n        }\n\n        return await this.client.call('patch', apiPath, {\n            'content-type': 'application/json',\n        }, payload);\n    }\n\n    /**\n     * Create push notification\n     *\n     * Create a new push notification.\n     *\n     * @param {string} messageId\n     * @param {string} title\n     * @param {string} body\n     * @param {string[]} topics\n     * @param {string[]} users\n     * @param {string[]} targets\n     * @param {object} data\n     * @param {string} action\n     * @param {string} image\n     * @param {string} icon\n     * @param {string} sound\n     * @param {string} color\n     * @param {string} tag\n     * @param {string} badge\n     * @param {boolean} draft\n     * @param {string} scheduledAt\n     * @throws {AppwriteException}\n     * @returns {Promise}\n     */\n    async createPush(messageId, title, body, topics, users, targets, data, action, image, icon, sound, color, tag, badge, draft, scheduledAt) {\n        const apiPath = '/messaging/messages/push';\n        let payload = {};\n        if (typeof messageId === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"messageId\"');\n        }\n\n        if (typeof title === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"title\"');\n        }\n\n        if (typeof body === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"body\"');\n        }\n\n\n        if (typeof messageId !== 'undefined') {\n            payload['messageId'] = messageId;\n        }\n\n        if (typeof title !== 'undefined') {\n            payload['title'] = title;\n        }\n\n        if (typeof body !== 'undefined') {\n            payload['body'] = body;\n        }\n\n        if (typeof topics !== 'undefined') {\n            payload['topics'] = topics;\n        }\n\n        if (typeof users !== 'undefined') {\n            payload['users'] = users;\n        }\n\n        if (typeof targets !== 'undefined') {\n            payload['targets'] = targets;\n        }\n\n        if (typeof data !== 'undefined') {\n            payload['data'] = data;\n        }\n\n        if (typeof action !== 'undefined') {\n            payload['action'] = action;\n        }\n\n        if (typeof image !== 'undefined') {\n            payload['image'] = image;\n        }\n\n        if (typeof icon !== 'undefined') {\n            payload['icon'] = icon;\n        }\n\n        if (typeof sound !== 'undefined') {\n            payload['sound'] = sound;\n        }\n\n        if (typeof color !== 'undefined') {\n            payload['color'] = color;\n        }\n\n        if (typeof tag !== 'undefined') {\n            payload['tag'] = tag;\n        }\n\n        if (typeof badge !== 'undefined') {\n            payload['badge'] = badge;\n        }\n\n        if (typeof draft !== 'undefined') {\n            payload['draft'] = draft;\n        }\n\n        if (typeof scheduledAt !== 'undefined') {\n            payload['scheduledAt'] = scheduledAt;\n        }\n\n        return await this.client.call('post', apiPath, {\n            'content-type': 'application/json',\n        }, payload);\n    }\n\n    /**\n     * Update push notification\n     *\n     * Update a push notification by its unique ID.\n     * \n     *\n     * @param {string} messageId\n     * @param {string[]} topics\n     * @param {string[]} users\n     * @param {string[]} targets\n     * @param {string} title\n     * @param {string} body\n     * @param {object} data\n     * @param {string} action\n     * @param {string} image\n     * @param {string} icon\n     * @param {string} sound\n     * @param {string} color\n     * @param {string} tag\n     * @param {number} badge\n     * @param {boolean} draft\n     * @param {string} scheduledAt\n     * @throws {AppwriteException}\n     * @returns {Promise}\n     */\n    async updatePush(messageId, topics, users, targets, title, body, data, action, image, icon, sound, color, tag, badge, draft, scheduledAt) {\n        const apiPath = '/messaging/messages/push/{messageId}'.replace('{messageId}', messageId);\n        let payload = {};\n        if (typeof messageId === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"messageId\"');\n        }\n\n\n        if (typeof topics !== 'undefined') {\n            payload['topics'] = topics;\n        }\n\n        if (typeof users !== 'undefined') {\n            payload['users'] = users;\n        }\n\n        if (typeof targets !== 'undefined') {\n            payload['targets'] = targets;\n        }\n\n        if (typeof title !== 'undefined') {\n            payload['title'] = title;\n        }\n\n        if (typeof body !== 'undefined') {\n            payload['body'] = body;\n        }\n\n        if (typeof data !== 'undefined') {\n            payload['data'] = data;\n        }\n\n        if (typeof action !== 'undefined') {\n            payload['action'] = action;\n        }\n\n        if (typeof image !== 'undefined') {\n            payload['image'] = image;\n        }\n\n        if (typeof icon !== 'undefined') {\n            payload['icon'] = icon;\n        }\n\n        if (typeof sound !== 'undefined') {\n            payload['sound'] = sound;\n        }\n\n        if (typeof color !== 'undefined') {\n            payload['color'] = color;\n        }\n\n        if (typeof tag !== 'undefined') {\n            payload['tag'] = tag;\n        }\n\n        if (typeof badge !== 'undefined') {\n            payload['badge'] = badge;\n        }\n\n        if (typeof draft !== 'undefined') {\n            payload['draft'] = draft;\n        }\n\n        if (typeof scheduledAt !== 'undefined') {\n            payload['scheduledAt'] = scheduledAt;\n        }\n\n        return await this.client.call('patch', apiPath, {\n            'content-type': 'application/json',\n        }, payload);\n    }\n\n    /**\n     * Create SMS\n     *\n     * Create a new SMS message.\n     *\n     * @param {string} messageId\n     * @param {string} content\n     * @param {string[]} topics\n     * @param {string[]} users\n     * @param {string[]} targets\n     * @param {boolean} draft\n     * @param {string} scheduledAt\n     * @throws {AppwriteException}\n     * @returns {Promise}\n     */\n    async createSms(messageId, content, topics, users, targets, draft, scheduledAt) {\n        const apiPath = '/messaging/messages/sms';\n        let payload = {};\n        if (typeof messageId === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"messageId\"');\n        }\n\n        if (typeof content === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"content\"');\n        }\n\n\n        if (typeof messageId !== 'undefined') {\n            payload['messageId'] = messageId;\n        }\n\n        if (typeof content !== 'undefined') {\n            payload['content'] = content;\n        }\n\n        if (typeof topics !== 'undefined') {\n            payload['topics'] = topics;\n        }\n\n        if (typeof users !== 'undefined') {\n            payload['users'] = users;\n        }\n\n        if (typeof targets !== 'undefined') {\n            payload['targets'] = targets;\n        }\n\n        if (typeof draft !== 'undefined') {\n            payload['draft'] = draft;\n        }\n\n        if (typeof scheduledAt !== 'undefined') {\n            payload['scheduledAt'] = scheduledAt;\n        }\n\n        return await this.client.call('post', apiPath, {\n            'content-type': 'application/json',\n        }, payload);\n    }\n\n    /**\n     * Update SMS\n     *\n     * Update an email message by its unique ID.\n     * \n     *\n     * @param {string} messageId\n     * @param {string[]} topics\n     * @param {string[]} users\n     * @param {string[]} targets\n     * @param {string} content\n     * @param {boolean} draft\n     * @param {string} scheduledAt\n     * @throws {AppwriteException}\n     * @returns {Promise}\n     */\n    async updateSms(messageId, topics, users, targets, content, draft, scheduledAt) {\n        const apiPath = '/messaging/messages/sms/{messageId}'.replace('{messageId}', messageId);\n        let payload = {};\n        if (typeof messageId === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"messageId\"');\n        }\n\n\n        if (typeof topics !== 'undefined') {\n            payload['topics'] = topics;\n        }\n\n        if (typeof users !== 'undefined') {\n            payload['users'] = users;\n        }\n\n        if (typeof targets !== 'undefined') {\n            payload['targets'] = targets;\n        }\n\n        if (typeof content !== 'undefined') {\n            payload['content'] = content;\n        }\n\n        if (typeof draft !== 'undefined') {\n            payload['draft'] = draft;\n        }\n\n        if (typeof scheduledAt !== 'undefined') {\n            payload['scheduledAt'] = scheduledAt;\n        }\n\n        return await this.client.call('patch', apiPath, {\n            'content-type': 'application/json',\n        }, payload);\n    }\n\n    /**\n     * Get message\n     *\n     * Get a message by its unique ID.\n     * \n     *\n     * @param {string} messageId\n     * @throws {AppwriteException}\n     * @returns {Promise}\n     */\n    async getMessage(messageId) {\n        const apiPath = '/messaging/messages/{messageId}'.replace('{messageId}', messageId);\n        let payload = {};\n        if (typeof messageId === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"messageId\"');\n        }\n\n\n        return await this.client.call('get', apiPath, {\n            'content-type': 'application/json',\n        }, payload);\n    }\n\n    /**\n     * Delete message\n     *\n     * Delete a message. If the message is not a draft or scheduled, but has been\n     * sent, this will not recall the message.\n     *\n     * @param {string} messageId\n     * @throws {AppwriteException}\n     * @returns {Promise}\n     */\n    async delete(messageId) {\n        const apiPath = '/messaging/messages/{messageId}'.replace('{messageId}', messageId);\n        let payload = {};\n        if (typeof messageId === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"messageId\"');\n        }\n\n\n        return await this.client.call('delete', apiPath, {\n            'content-type': 'application/json',\n        }, payload);\n    }\n\n    /**\n     * List message logs\n     *\n     * Get the message activity logs listed by its unique ID.\n     *\n     * @param {string} messageId\n     * @param {string[]} queries\n     * @throws {AppwriteException}\n     * @returns {Promise}\n     */\n    async listMessageLogs(messageId, queries) {\n        const apiPath = '/messaging/messages/{messageId}/logs'.replace('{messageId}', messageId);\n        let payload = {};\n        if (typeof messageId === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"messageId\"');\n        }\n\n\n        if (typeof queries !== 'undefined') {\n            payload['queries'] = queries;\n        }\n\n        return await this.client.call('get', apiPath, {\n            'content-type': 'application/json',\n        }, payload);\n    }\n\n    /**\n     * List message targets\n     *\n     * Get a list of the targets associated with a message.\n     *\n     * @param {string} messageId\n     * @param {string[]} queries\n     * @throws {AppwriteException}\n     * @returns {Promise}\n     */\n    async listTargets(messageId, queries) {\n        const apiPath = '/messaging/messages/{messageId}/targets'.replace('{messageId}', messageId);\n        let payload = {};\n        if (typeof messageId === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"messageId\"');\n        }\n\n\n        if (typeof queries !== 'undefined') {\n            payload['queries'] = queries;\n        }\n\n        return await this.client.call('get', apiPath, {\n            'content-type': 'application/json',\n        }, payload);\n    }\n\n    /**\n     * List providers\n     *\n     * Get a list of all providers from the current Appwrite project.\n     *\n     * @param {string[]} queries\n     * @param {string} search\n     * @throws {AppwriteException}\n     * @returns {Promise}\n     */\n    async listProviders(queries, search) {\n        const apiPath = '/messaging/providers';\n        let payload = {};\n\n        if (typeof queries !== 'undefined') {\n            payload['queries'] = queries;\n        }\n\n        if (typeof search !== 'undefined') {\n            payload['search'] = search;\n        }\n\n        return await this.client.call('get', apiPath, {\n            'content-type': 'application/json',\n        }, payload);\n    }\n\n    /**\n     * Create APNS provider\n     *\n     * Create a new Apple Push Notification service provider.\n     *\n     * @param {string} providerId\n     * @param {string} name\n     * @param {string} authKey\n     * @param {string} authKeyId\n     * @param {string} teamId\n     * @param {string} bundleId\n     * @param {boolean} sandbox\n     * @param {boolean} enabled\n     * @throws {AppwriteException}\n     * @returns {Promise}\n     */\n    async createApnsProvider(providerId, name, authKey, authKeyId, teamId, bundleId, sandbox, enabled) {\n        const apiPath = '/messaging/providers/apns';\n        let payload = {};\n        if (typeof providerId === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"providerId\"');\n        }\n\n        if (typeof name === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"name\"');\n        }\n\n\n        if (typeof providerId !== 'undefined') {\n            payload['providerId'] = providerId;\n        }\n\n        if (typeof name !== 'undefined') {\n            payload['name'] = name;\n        }\n\n        if (typeof authKey !== 'undefined') {\n            payload['authKey'] = authKey;\n        }\n\n        if (typeof authKeyId !== 'undefined') {\n            payload['authKeyId'] = authKeyId;\n        }\n\n        if (typeof teamId !== 'undefined') {\n            payload['teamId'] = teamId;\n        }\n\n        if (typeof bundleId !== 'undefined') {\n            payload['bundleId'] = bundleId;\n        }\n\n        if (typeof sandbox !== 'undefined') {\n            payload['sandbox'] = sandbox;\n        }\n\n        if (typeof enabled !== 'undefined') {\n            payload['enabled'] = enabled;\n        }\n\n        return await this.client.call('post', apiPath, {\n            'content-type': 'application/json',\n        }, payload);\n    }\n\n    /**\n     * Update APNS provider\n     *\n     * Update a Apple Push Notification service provider by its unique ID.\n     *\n     * @param {string} providerId\n     * @param {string} name\n     * @param {boolean} enabled\n     * @param {string} authKey\n     * @param {string} authKeyId\n     * @param {string} teamId\n     * @param {string} bundleId\n     * @param {boolean} sandbox\n     * @throws {AppwriteException}\n     * @returns {Promise}\n     */\n    async updateApnsProvider(providerId, name, enabled, authKey, authKeyId, teamId, bundleId, sandbox) {\n        const apiPath = '/messaging/providers/apns/{providerId}'.replace('{providerId}', providerId);\n        let payload = {};\n        if (typeof providerId === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"providerId\"');\n        }\n\n\n        if (typeof name !== 'undefined') {\n            payload['name'] = name;\n        }\n\n        if (typeof enabled !== 'undefined') {\n            payload['enabled'] = enabled;\n        }\n\n        if (typeof authKey !== 'undefined') {\n            payload['authKey'] = authKey;\n        }\n\n        if (typeof authKeyId !== 'undefined') {\n            payload['authKeyId'] = authKeyId;\n        }\n\n        if (typeof teamId !== 'undefined') {\n            payload['teamId'] = teamId;\n        }\n\n        if (typeof bundleId !== 'undefined') {\n            payload['bundleId'] = bundleId;\n        }\n\n        if (typeof sandbox !== 'undefined') {\n            payload['sandbox'] = sandbox;\n        }\n\n        return await this.client.call('patch', apiPath, {\n            'content-type': 'application/json',\n        }, payload);\n    }\n\n    /**\n     * Create FCM provider\n     *\n     * Create a new Firebase Cloud Messaging provider.\n     *\n     * @param {string} providerId\n     * @param {string} name\n     * @param {object} serviceAccountJSON\n     * @param {boolean} enabled\n     * @throws {AppwriteException}\n     * @returns {Promise}\n     */\n    async createFcmProvider(providerId, name, serviceAccountJSON, enabled) {\n        const apiPath = '/messaging/providers/fcm';\n        let payload = {};\n        if (typeof providerId === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"providerId\"');\n        }\n\n        if (typeof name === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"name\"');\n        }\n\n\n        if (typeof providerId !== 'undefined') {\n            payload['providerId'] = providerId;\n        }\n\n        if (typeof name !== 'undefined') {\n            payload['name'] = name;\n        }\n\n        if (typeof serviceAccountJSON !== 'undefined') {\n            payload['serviceAccountJSON'] = serviceAccountJSON;\n        }\n\n        if (typeof enabled !== 'undefined') {\n            payload['enabled'] = enabled;\n        }\n\n        return await this.client.call('post', apiPath, {\n            'content-type': 'application/json',\n        }, payload);\n    }\n\n    /**\n     * Update FCM provider\n     *\n     * Update a Firebase Cloud Messaging provider by its unique ID.\n     *\n     * @param {string} providerId\n     * @param {string} name\n     * @param {boolean} enabled\n     * @param {object} serviceAccountJSON\n     * @throws {AppwriteException}\n     * @returns {Promise}\n     */\n    async updateFcmProvider(providerId, name, enabled, serviceAccountJSON) {\n        const apiPath = '/messaging/providers/fcm/{providerId}'.replace('{providerId}', providerId);\n        let payload = {};\n        if (typeof providerId === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"providerId\"');\n        }\n\n\n        if (typeof name !== 'undefined') {\n            payload['name'] = name;\n        }\n\n        if (typeof enabled !== 'undefined') {\n            payload['enabled'] = enabled;\n        }\n\n        if (typeof serviceAccountJSON !== 'undefined') {\n            payload['serviceAccountJSON'] = serviceAccountJSON;\n        }\n\n        return await this.client.call('patch', apiPath, {\n            'content-type': 'application/json',\n        }, payload);\n    }\n\n    /**\n     * Create Mailgun provider\n     *\n     * Create a new Mailgun provider.\n     *\n     * @param {string} providerId\n     * @param {string} name\n     * @param {string} apiKey\n     * @param {string} domain\n     * @param {boolean} isEuRegion\n     * @param {string} fromName\n     * @param {string} fromEmail\n     * @param {string} replyToName\n     * @param {string} replyToEmail\n     * @param {boolean} enabled\n     * @throws {AppwriteException}\n     * @returns {Promise}\n     */\n    async createMailgunProvider(providerId, name, apiKey, domain, isEuRegion, fromName, fromEmail, replyToName, replyToEmail, enabled) {\n        const apiPath = '/messaging/providers/mailgun';\n        let payload = {};\n        if (typeof providerId === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"providerId\"');\n        }\n\n        if (typeof name === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"name\"');\n        }\n\n\n        if (typeof providerId !== 'undefined') {\n            payload['providerId'] = providerId;\n        }\n\n        if (typeof name !== 'undefined') {\n            payload['name'] = name;\n        }\n\n        if (typeof apiKey !== 'undefined') {\n            payload['apiKey'] = apiKey;\n        }\n\n        if (typeof domain !== 'undefined') {\n            payload['domain'] = domain;\n        }\n\n        if (typeof isEuRegion !== 'undefined') {\n            payload['isEuRegion'] = isEuRegion;\n        }\n\n        if (typeof fromName !== 'undefined') {\n            payload['fromName'] = fromName;\n        }\n\n        if (typeof fromEmail !== 'undefined') {\n            payload['fromEmail'] = fromEmail;\n        }\n\n        if (typeof replyToName !== 'undefined') {\n            payload['replyToName'] = replyToName;\n        }\n\n        if (typeof replyToEmail !== 'undefined') {\n            payload['replyToEmail'] = replyToEmail;\n        }\n\n        if (typeof enabled !== 'undefined') {\n            payload['enabled'] = enabled;\n        }\n\n        return await this.client.call('post', apiPath, {\n            'content-type': 'application/json',\n        }, payload);\n    }\n\n    /**\n     * Update Mailgun provider\n     *\n     * Update a Mailgun provider by its unique ID.\n     *\n     * @param {string} providerId\n     * @param {string} name\n     * @param {string} apiKey\n     * @param {string} domain\n     * @param {boolean} isEuRegion\n     * @param {boolean} enabled\n     * @param {string} fromName\n     * @param {string} fromEmail\n     * @param {string} replyToName\n     * @param {string} replyToEmail\n     * @throws {AppwriteException}\n     * @returns {Promise}\n     */\n    async updateMailgunProvider(providerId, name, apiKey, domain, isEuRegion, enabled, fromName, fromEmail, replyToName, replyToEmail) {\n        const apiPath = '/messaging/providers/mailgun/{providerId}'.replace('{providerId}', providerId);\n        let payload = {};\n        if (typeof providerId === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"providerId\"');\n        }\n\n\n        if (typeof name !== 'undefined') {\n            payload['name'] = name;\n        }\n\n        if (typeof apiKey !== 'undefined') {\n            payload['apiKey'] = apiKey;\n        }\n\n        if (typeof domain !== 'undefined') {\n            payload['domain'] = domain;\n        }\n\n        if (typeof isEuRegion !== 'undefined') {\n            payload['isEuRegion'] = isEuRegion;\n        }\n\n        if (typeof enabled !== 'undefined') {\n            payload['enabled'] = enabled;\n        }\n\n        if (typeof fromName !== 'undefined') {\n            payload['fromName'] = fromName;\n        }\n\n        if (typeof fromEmail !== 'undefined') {\n            payload['fromEmail'] = fromEmail;\n        }\n\n        if (typeof replyToName !== 'undefined') {\n            payload['replyToName'] = replyToName;\n        }\n\n        if (typeof replyToEmail !== 'undefined') {\n            payload['replyToEmail'] = replyToEmail;\n        }\n\n        return await this.client.call('patch', apiPath, {\n            'content-type': 'application/json',\n        }, payload);\n    }\n\n    /**\n     * Create Msg91 provider\n     *\n     * Create a new MSG91 provider.\n     *\n     * @param {string} providerId\n     * @param {string} name\n     * @param {string} templateId\n     * @param {string} senderId\n     * @param {string} authKey\n     * @param {boolean} enabled\n     * @throws {AppwriteException}\n     * @returns {Promise}\n     */\n    async createMsg91Provider(providerId, name, templateId, senderId, authKey, enabled) {\n        const apiPath = '/messaging/providers/msg91';\n        let payload = {};\n        if (typeof providerId === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"providerId\"');\n        }\n\n        if (typeof name === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"name\"');\n        }\n\n\n        if (typeof providerId !== 'undefined') {\n            payload['providerId'] = providerId;\n        }\n\n        if (typeof name !== 'undefined') {\n            payload['name'] = name;\n        }\n\n        if (typeof templateId !== 'undefined') {\n            payload['templateId'] = templateId;\n        }\n\n        if (typeof senderId !== 'undefined') {\n            payload['senderId'] = senderId;\n        }\n\n        if (typeof authKey !== 'undefined') {\n            payload['authKey'] = authKey;\n        }\n\n        if (typeof enabled !== 'undefined') {\n            payload['enabled'] = enabled;\n        }\n\n        return await this.client.call('post', apiPath, {\n            'content-type': 'application/json',\n        }, payload);\n    }\n\n    /**\n     * Update Msg91 provider\n     *\n     * Update a MSG91 provider by its unique ID.\n     *\n     * @param {string} providerId\n     * @param {string} name\n     * @param {boolean} enabled\n     * @param {string} templateId\n     * @param {string} senderId\n     * @param {string} authKey\n     * @throws {AppwriteException}\n     * @returns {Promise}\n     */\n    async updateMsg91Provider(providerId, name, enabled, templateId, senderId, authKey) {\n        const apiPath = '/messaging/providers/msg91/{providerId}'.replace('{providerId}', providerId);\n        let payload = {};\n        if (typeof providerId === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"providerId\"');\n        }\n\n\n        if (typeof name !== 'undefined') {\n            payload['name'] = name;\n        }\n\n        if (typeof enabled !== 'undefined') {\n            payload['enabled'] = enabled;\n        }\n\n        if (typeof templateId !== 'undefined') {\n            payload['templateId'] = templateId;\n        }\n\n        if (typeof senderId !== 'undefined') {\n            payload['senderId'] = senderId;\n        }\n\n        if (typeof authKey !== 'undefined') {\n            payload['authKey'] = authKey;\n        }\n\n        return await this.client.call('patch', apiPath, {\n            'content-type': 'application/json',\n        }, payload);\n    }\n\n    /**\n     * Create Sendgrid provider\n     *\n     * Create a new Sendgrid provider.\n     *\n     * @param {string} providerId\n     * @param {string} name\n     * @param {string} apiKey\n     * @param {string} fromName\n     * @param {string} fromEmail\n     * @param {string} replyToName\n     * @param {string} replyToEmail\n     * @param {boolean} enabled\n     * @throws {AppwriteException}\n     * @returns {Promise}\n     */\n    async createSendgridProvider(providerId, name, apiKey, fromName, fromEmail, replyToName, replyToEmail, enabled) {\n        const apiPath = '/messaging/providers/sendgrid';\n        let payload = {};\n        if (typeof providerId === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"providerId\"');\n        }\n\n        if (typeof name === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"name\"');\n        }\n\n\n        if (typeof providerId !== 'undefined') {\n            payload['providerId'] = providerId;\n        }\n\n        if (typeof name !== 'undefined') {\n            payload['name'] = name;\n        }\n\n        if (typeof apiKey !== 'undefined') {\n            payload['apiKey'] = apiKey;\n        }\n\n        if (typeof fromName !== 'undefined') {\n            payload['fromName'] = fromName;\n        }\n\n        if (typeof fromEmail !== 'undefined') {\n            payload['fromEmail'] = fromEmail;\n        }\n\n        if (typeof replyToName !== 'undefined') {\n            payload['replyToName'] = replyToName;\n        }\n\n        if (typeof replyToEmail !== 'undefined') {\n            payload['replyToEmail'] = replyToEmail;\n        }\n\n        if (typeof enabled !== 'undefined') {\n            payload['enabled'] = enabled;\n        }\n\n        return await this.client.call('post', apiPath, {\n            'content-type': 'application/json',\n        }, payload);\n    }\n\n    /**\n     * Update Sendgrid provider\n     *\n     * Update a Sendgrid provider by its unique ID.\n     *\n     * @param {string} providerId\n     * @param {string} name\n     * @param {boolean} enabled\n     * @param {string} apiKey\n     * @param {string} fromName\n     * @param {string} fromEmail\n     * @param {string} replyToName\n     * @param {string} replyToEmail\n     * @throws {AppwriteException}\n     * @returns {Promise}\n     */\n    async updateSendgridProvider(providerId, name, enabled, apiKey, fromName, fromEmail, replyToName, replyToEmail) {\n        const apiPath = '/messaging/providers/sendgrid/{providerId}'.replace('{providerId}', providerId);\n        let payload = {};\n        if (typeof providerId === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"providerId\"');\n        }\n\n\n        if (typeof name !== 'undefined') {\n            payload['name'] = name;\n        }\n\n        if (typeof enabled !== 'undefined') {\n            payload['enabled'] = enabled;\n        }\n\n        if (typeof apiKey !== 'undefined') {\n            payload['apiKey'] = apiKey;\n        }\n\n        if (typeof fromName !== 'undefined') {\n            payload['fromName'] = fromName;\n        }\n\n        if (typeof fromEmail !== 'undefined') {\n            payload['fromEmail'] = fromEmail;\n        }\n\n        if (typeof replyToName !== 'undefined') {\n            payload['replyToName'] = replyToName;\n        }\n\n        if (typeof replyToEmail !== 'undefined') {\n            payload['replyToEmail'] = replyToEmail;\n        }\n\n        return await this.client.call('patch', apiPath, {\n            'content-type': 'application/json',\n        }, payload);\n    }\n\n    /**\n     * Create SMTP provider\n     *\n     * Create a new SMTP provider.\n     *\n     * @param {string} providerId\n     * @param {string} name\n     * @param {string} host\n     * @param {number} port\n     * @param {string} username\n     * @param {string} password\n     * @param {SmtpEncryption} encryption\n     * @param {boolean} autoTLS\n     * @param {string} mailer\n     * @param {string} fromName\n     * @param {string} fromEmail\n     * @param {string} replyToName\n     * @param {string} replyToEmail\n     * @param {boolean} enabled\n     * @throws {AppwriteException}\n     * @returns {Promise}\n     */\n    async createSmtpProvider(providerId, name, host, port, username, password, encryption, autoTLS, mailer, fromName, fromEmail, replyToName, replyToEmail, enabled) {\n        const apiPath = '/messaging/providers/smtp';\n        let payload = {};\n        if (typeof providerId === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"providerId\"');\n        }\n\n        if (typeof name === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"name\"');\n        }\n\n        if (typeof host === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"host\"');\n        }\n\n\n        if (typeof providerId !== 'undefined') {\n            payload['providerId'] = providerId;\n        }\n\n        if (typeof name !== 'undefined') {\n            payload['name'] = name;\n        }\n\n        if (typeof host !== 'undefined') {\n            payload['host'] = host;\n        }\n\n        if (typeof port !== 'undefined') {\n            payload['port'] = port;\n        }\n\n        if (typeof username !== 'undefined') {\n            payload['username'] = username;\n        }\n\n        if (typeof password !== 'undefined') {\n            payload['password'] = password;\n        }\n\n        if (typeof encryption !== 'undefined') {\n            payload['encryption'] = encryption;\n        }\n\n        if (typeof autoTLS !== 'undefined') {\n            payload['autoTLS'] = autoTLS;\n        }\n\n        if (typeof mailer !== 'undefined') {\n            payload['mailer'] = mailer;\n        }\n\n        if (typeof fromName !== 'undefined') {\n            payload['fromName'] = fromName;\n        }\n\n        if (typeof fromEmail !== 'undefined') {\n            payload['fromEmail'] = fromEmail;\n        }\n\n        if (typeof replyToName !== 'undefined') {\n            payload['replyToName'] = replyToName;\n        }\n\n        if (typeof replyToEmail !== 'undefined') {\n            payload['replyToEmail'] = replyToEmail;\n        }\n\n        if (typeof enabled !== 'undefined') {\n            payload['enabled'] = enabled;\n        }\n\n        return await this.client.call('post', apiPath, {\n            'content-type': 'application/json',\n        }, payload);\n    }\n\n    /**\n     * Update SMTP provider\n     *\n     * Update a SMTP provider by its unique ID.\n     *\n     * @param {string} providerId\n     * @param {string} name\n     * @param {string} host\n     * @param {number} port\n     * @param {string} username\n     * @param {string} password\n     * @param {SmtpEncryption} encryption\n     * @param {boolean} autoTLS\n     * @param {string} mailer\n     * @param {string} fromName\n     * @param {string} fromEmail\n     * @param {string} replyToName\n     * @param {string} replyToEmail\n     * @param {boolean} enabled\n     * @throws {AppwriteException}\n     * @returns {Promise}\n     */\n    async updateSmtpProvider(providerId, name, host, port, username, password, encryption, autoTLS, mailer, fromName, fromEmail, replyToName, replyToEmail, enabled) {\n        const apiPath = '/messaging/providers/smtp/{providerId}'.replace('{providerId}', providerId);\n        let payload = {};\n        if (typeof providerId === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"providerId\"');\n        }\n\n\n        if (typeof name !== 'undefined') {\n            payload['name'] = name;\n        }\n\n        if (typeof host !== 'undefined') {\n            payload['host'] = host;\n        }\n\n        if (typeof port !== 'undefined') {\n            payload['port'] = port;\n        }\n\n        if (typeof username !== 'undefined') {\n            payload['username'] = username;\n        }\n\n        if (typeof password !== 'undefined') {\n            payload['password'] = password;\n        }\n\n        if (typeof encryption !== 'undefined') {\n            payload['encryption'] = encryption;\n        }\n\n        if (typeof autoTLS !== 'undefined') {\n            payload['autoTLS'] = autoTLS;\n        }\n\n        if (typeof mailer !== 'undefined') {\n            payload['mailer'] = mailer;\n        }\n\n        if (typeof fromName !== 'undefined') {\n            payload['fromName'] = fromName;\n        }\n\n        if (typeof fromEmail !== 'undefined') {\n            payload['fromEmail'] = fromEmail;\n        }\n\n        if (typeof replyToName !== 'undefined') {\n            payload['replyToName'] = replyToName;\n        }\n\n        if (typeof replyToEmail !== 'undefined') {\n            payload['replyToEmail'] = replyToEmail;\n        }\n\n        if (typeof enabled !== 'undefined') {\n            payload['enabled'] = enabled;\n        }\n\n        return await this.client.call('patch', apiPath, {\n            'content-type': 'application/json',\n        }, payload);\n    }\n\n    /**\n     * Create Telesign provider\n     *\n     * Create a new Telesign provider.\n     *\n     * @param {string} providerId\n     * @param {string} name\n     * @param {string} from\n     * @param {string} customerId\n     * @param {string} apiKey\n     * @param {boolean} enabled\n     * @throws {AppwriteException}\n     * @returns {Promise}\n     */\n    async createTelesignProvider(providerId, name, from, customerId, apiKey, enabled) {\n        const apiPath = '/messaging/providers/telesign';\n        let payload = {};\n        if (typeof providerId === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"providerId\"');\n        }\n\n        if (typeof name === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"name\"');\n        }\n\n\n        if (typeof providerId !== 'undefined') {\n            payload['providerId'] = providerId;\n        }\n\n        if (typeof name !== 'undefined') {\n            payload['name'] = name;\n        }\n\n        if (typeof from !== 'undefined') {\n            payload['from'] = from;\n        }\n\n        if (typeof customerId !== 'undefined') {\n            payload['customerId'] = customerId;\n        }\n\n        if (typeof apiKey !== 'undefined') {\n            payload['apiKey'] = apiKey;\n        }\n\n        if (typeof enabled !== 'undefined') {\n            payload['enabled'] = enabled;\n        }\n\n        return await this.client.call('post', apiPath, {\n            'content-type': 'application/json',\n        }, payload);\n    }\n\n    /**\n     * Update Telesign provider\n     *\n     * Update a Telesign provider by its unique ID.\n     *\n     * @param {string} providerId\n     * @param {string} name\n     * @param {boolean} enabled\n     * @param {string} customerId\n     * @param {string} apiKey\n     * @param {string} from\n     * @throws {AppwriteException}\n     * @returns {Promise}\n     */\n    async updateTelesignProvider(providerId, name, enabled, customerId, apiKey, from) {\n        const apiPath = '/messaging/providers/telesign/{providerId}'.replace('{providerId}', providerId);\n        let payload = {};\n        if (typeof providerId === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"providerId\"');\n        }\n\n\n        if (typeof name !== 'undefined') {\n            payload['name'] = name;\n        }\n\n        if (typeof enabled !== 'undefined') {\n            payload['enabled'] = enabled;\n        }\n\n        if (typeof customerId !== 'undefined') {\n            payload['customerId'] = customerId;\n        }\n\n        if (typeof apiKey !== 'undefined') {\n            payload['apiKey'] = apiKey;\n        }\n\n        if (typeof from !== 'undefined') {\n            payload['from'] = from;\n        }\n\n        return await this.client.call('patch', apiPath, {\n            'content-type': 'application/json',\n        }, payload);\n    }\n\n    /**\n     * Create Textmagic provider\n     *\n     * Create a new Textmagic provider.\n     *\n     * @param {string} providerId\n     * @param {string} name\n     * @param {string} from\n     * @param {string} username\n     * @param {string} apiKey\n     * @param {boolean} enabled\n     * @throws {AppwriteException}\n     * @returns {Promise}\n     */\n    async createTextmagicProvider(providerId, name, from, username, apiKey, enabled) {\n        const apiPath = '/messaging/providers/textmagic';\n        let payload = {};\n        if (typeof providerId === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"providerId\"');\n        }\n\n        if (typeof name === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"name\"');\n        }\n\n\n        if (typeof providerId !== 'undefined') {\n            payload['providerId'] = providerId;\n        }\n\n        if (typeof name !== 'undefined') {\n            payload['name'] = name;\n        }\n\n        if (typeof from !== 'undefined') {\n            payload['from'] = from;\n        }\n\n        if (typeof username !== 'undefined') {\n            payload['username'] = username;\n        }\n\n        if (typeof apiKey !== 'undefined') {\n            payload['apiKey'] = apiKey;\n        }\n\n        if (typeof enabled !== 'undefined') {\n            payload['enabled'] = enabled;\n        }\n\n        return await this.client.call('post', apiPath, {\n            'content-type': 'application/json',\n        }, payload);\n    }\n\n    /**\n     * Update Textmagic provider\n     *\n     * Update a Textmagic provider by its unique ID.\n     *\n     * @param {string} providerId\n     * @param {string} name\n     * @param {boolean} enabled\n     * @param {string} username\n     * @param {string} apiKey\n     * @param {string} from\n     * @throws {AppwriteException}\n     * @returns {Promise}\n     */\n    async updateTextmagicProvider(providerId, name, enabled, username, apiKey, from) {\n        const apiPath = '/messaging/providers/textmagic/{providerId}'.replace('{providerId}', providerId);\n        let payload = {};\n        if (typeof providerId === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"providerId\"');\n        }\n\n\n        if (typeof name !== 'undefined') {\n            payload['name'] = name;\n        }\n\n        if (typeof enabled !== 'undefined') {\n            payload['enabled'] = enabled;\n        }\n\n        if (typeof username !== 'undefined') {\n            payload['username'] = username;\n        }\n\n        if (typeof apiKey !== 'undefined') {\n            payload['apiKey'] = apiKey;\n        }\n\n        if (typeof from !== 'undefined') {\n            payload['from'] = from;\n        }\n\n        return await this.client.call('patch', apiPath, {\n            'content-type': 'application/json',\n        }, payload);\n    }\n\n    /**\n     * Create Twilio provider\n     *\n     * Create a new Twilio provider.\n     *\n     * @param {string} providerId\n     * @param {string} name\n     * @param {string} from\n     * @param {string} accountSid\n     * @param {string} authToken\n     * @param {boolean} enabled\n     * @throws {AppwriteException}\n     * @returns {Promise}\n     */\n    async createTwilioProvider(providerId, name, from, accountSid, authToken, enabled) {\n        const apiPath = '/messaging/providers/twilio';\n        let payload = {};\n        if (typeof providerId === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"providerId\"');\n        }\n\n        if (typeof name === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"name\"');\n        }\n\n\n        if (typeof providerId !== 'undefined') {\n            payload['providerId'] = providerId;\n        }\n\n        if (typeof name !== 'undefined') {\n            payload['name'] = name;\n        }\n\n        if (typeof from !== 'undefined') {\n            payload['from'] = from;\n        }\n\n        if (typeof accountSid !== 'undefined') {\n            payload['accountSid'] = accountSid;\n        }\n\n        if (typeof authToken !== 'undefined') {\n            payload['authToken'] = authToken;\n        }\n\n        if (typeof enabled !== 'undefined') {\n            payload['enabled'] = enabled;\n        }\n\n        return await this.client.call('post', apiPath, {\n            'content-type': 'application/json',\n        }, payload);\n    }\n\n    /**\n     * Update Twilio provider\n     *\n     * Update a Twilio provider by its unique ID.\n     *\n     * @param {string} providerId\n     * @param {string} name\n     * @param {boolean} enabled\n     * @param {string} accountSid\n     * @param {string} authToken\n     * @param {string} from\n     * @throws {AppwriteException}\n     * @returns {Promise}\n     */\n    async updateTwilioProvider(providerId, name, enabled, accountSid, authToken, from) {\n        const apiPath = '/messaging/providers/twilio/{providerId}'.replace('{providerId}', providerId);\n        let payload = {};\n        if (typeof providerId === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"providerId\"');\n        }\n\n\n        if (typeof name !== 'undefined') {\n            payload['name'] = name;\n        }\n\n        if (typeof enabled !== 'undefined') {\n            payload['enabled'] = enabled;\n        }\n\n        if (typeof accountSid !== 'undefined') {\n            payload['accountSid'] = accountSid;\n        }\n\n        if (typeof authToken !== 'undefined') {\n            payload['authToken'] = authToken;\n        }\n\n        if (typeof from !== 'undefined') {\n            payload['from'] = from;\n        }\n\n        return await this.client.call('patch', apiPath, {\n            'content-type': 'application/json',\n        }, payload);\n    }\n\n    /**\n     * Create Vonage provider\n     *\n     * Create a new Vonage provider.\n     *\n     * @param {string} providerId\n     * @param {string} name\n     * @param {string} from\n     * @param {string} apiKey\n     * @param {string} apiSecret\n     * @param {boolean} enabled\n     * @throws {AppwriteException}\n     * @returns {Promise}\n     */\n    async createVonageProvider(providerId, name, from, apiKey, apiSecret, enabled) {\n        const apiPath = '/messaging/providers/vonage';\n        let payload = {};\n        if (typeof providerId === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"providerId\"');\n        }\n\n        if (typeof name === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"name\"');\n        }\n\n\n        if (typeof providerId !== 'undefined') {\n            payload['providerId'] = providerId;\n        }\n\n        if (typeof name !== 'undefined') {\n            payload['name'] = name;\n        }\n\n        if (typeof from !== 'undefined') {\n            payload['from'] = from;\n        }\n\n        if (typeof apiKey !== 'undefined') {\n            payload['apiKey'] = apiKey;\n        }\n\n        if (typeof apiSecret !== 'undefined') {\n            payload['apiSecret'] = apiSecret;\n        }\n\n        if (typeof enabled !== 'undefined') {\n            payload['enabled'] = enabled;\n        }\n\n        return await this.client.call('post', apiPath, {\n            'content-type': 'application/json',\n        }, payload);\n    }\n\n    /**\n     * Update Vonage provider\n     *\n     * Update a Vonage provider by its unique ID.\n     *\n     * @param {string} providerId\n     * @param {string} name\n     * @param {boolean} enabled\n     * @param {string} apiKey\n     * @param {string} apiSecret\n     * @param {string} from\n     * @throws {AppwriteException}\n     * @returns {Promise}\n     */\n    async updateVonageProvider(providerId, name, enabled, apiKey, apiSecret, from) {\n        const apiPath = '/messaging/providers/vonage/{providerId}'.replace('{providerId}', providerId);\n        let payload = {};\n        if (typeof providerId === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"providerId\"');\n        }\n\n\n        if (typeof name !== 'undefined') {\n            payload['name'] = name;\n        }\n\n        if (typeof enabled !== 'undefined') {\n            payload['enabled'] = enabled;\n        }\n\n        if (typeof apiKey !== 'undefined') {\n            payload['apiKey'] = apiKey;\n        }\n\n        if (typeof apiSecret !== 'undefined') {\n            payload['apiSecret'] = apiSecret;\n        }\n\n        if (typeof from !== 'undefined') {\n            payload['from'] = from;\n        }\n\n        return await this.client.call('patch', apiPath, {\n            'content-type': 'application/json',\n        }, payload);\n    }\n\n    /**\n     * Get provider\n     *\n     * Get a provider by its unique ID.\n     * \n     *\n     * @param {string} providerId\n     * @throws {AppwriteException}\n     * @returns {Promise}\n     */\n    async getProvider(providerId) {\n        const apiPath = '/messaging/providers/{providerId}'.replace('{providerId}', providerId);\n        let payload = {};\n        if (typeof providerId === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"providerId\"');\n        }\n\n\n        return await this.client.call('get', apiPath, {\n            'content-type': 'application/json',\n        }, payload);\n    }\n\n    /**\n     * Delete provider\n     *\n     * Delete a provider by its unique ID.\n     *\n     * @param {string} providerId\n     * @throws {AppwriteException}\n     * @returns {Promise}\n     */\n    async deleteProvider(providerId) {\n        const apiPath = '/messaging/providers/{providerId}'.replace('{providerId}', providerId);\n        let payload = {};\n        if (typeof providerId === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"providerId\"');\n        }\n\n\n        return await this.client.call('delete', apiPath, {\n            'content-type': 'application/json',\n        }, payload);\n    }\n\n    /**\n     * List provider logs\n     *\n     * Get the provider activity logs listed by its unique ID.\n     *\n     * @param {string} providerId\n     * @param {string[]} queries\n     * @throws {AppwriteException}\n     * @returns {Promise}\n     */\n    async listProviderLogs(providerId, queries) {\n        const apiPath = '/messaging/providers/{providerId}/logs'.replace('{providerId}', providerId);\n        let payload = {};\n        if (typeof providerId === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"providerId\"');\n        }\n\n\n        if (typeof queries !== 'undefined') {\n            payload['queries'] = queries;\n        }\n\n        return await this.client.call('get', apiPath, {\n            'content-type': 'application/json',\n        }, payload);\n    }\n\n    /**\n     * List subscriber logs\n     *\n     * Get the subscriber activity logs listed by its unique ID.\n     *\n     * @param {string} subscriberId\n     * @param {string[]} queries\n     * @throws {AppwriteException}\n     * @returns {Promise}\n     */\n    async listSubscriberLogs(subscriberId, queries) {\n        const apiPath = '/messaging/subscribers/{subscriberId}/logs'.replace('{subscriberId}', subscriberId);\n        let payload = {};\n        if (typeof subscriberId === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"subscriberId\"');\n        }\n\n\n        if (typeof queries !== 'undefined') {\n            payload['queries'] = queries;\n        }\n\n        return await this.client.call('get', apiPath, {\n            'content-type': 'application/json',\n        }, payload);\n    }\n\n    /**\n     * List topics\n     *\n     * Get a list of all topics from the current Appwrite project.\n     *\n     * @param {string[]} queries\n     * @param {string} search\n     * @throws {AppwriteException}\n     * @returns {Promise}\n     */\n    async listTopics(queries, search) {\n        const apiPath = '/messaging/topics';\n        let payload = {};\n\n        if (typeof queries !== 'undefined') {\n            payload['queries'] = queries;\n        }\n\n        if (typeof search !== 'undefined') {\n            payload['search'] = search;\n        }\n\n        return await this.client.call('get', apiPath, {\n            'content-type': 'application/json',\n        }, payload);\n    }\n\n    /**\n     * Create topic\n     *\n     * Create a new topic.\n     *\n     * @param {string} topicId\n     * @param {string} name\n     * @param {string[]} subscribe\n     * @throws {AppwriteException}\n     * @returns {Promise}\n     */\n    async createTopic(topicId, name, subscribe) {\n        const apiPath = '/messaging/topics';\n        let payload = {};\n        if (typeof topicId === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"topicId\"');\n        }\n\n        if (typeof name === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"name\"');\n        }\n\n\n        if (typeof topicId !== 'undefined') {\n            payload['topicId'] = topicId;\n        }\n\n        if (typeof name !== 'undefined') {\n            payload['name'] = name;\n        }\n\n        if (typeof subscribe !== 'undefined') {\n            payload['subscribe'] = subscribe;\n        }\n\n        return await this.client.call('post', apiPath, {\n            'content-type': 'application/json',\n        }, payload);\n    }\n\n    /**\n     * Get topic\n     *\n     * Get a topic by its unique ID.\n     * \n     *\n     * @param {string} topicId\n     * @throws {AppwriteException}\n     * @returns {Promise}\n     */\n    async getTopic(topicId) {\n        const apiPath = '/messaging/topics/{topicId}'.replace('{topicId}', topicId);\n        let payload = {};\n        if (typeof topicId === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"topicId\"');\n        }\n\n\n        return await this.client.call('get', apiPath, {\n            'content-type': 'application/json',\n        }, payload);\n    }\n\n    /**\n     * Update topic\n     *\n     * Update a topic by its unique ID.\n     * \n     *\n     * @param {string} topicId\n     * @param {string} name\n     * @param {string[]} subscribe\n     * @throws {AppwriteException}\n     * @returns {Promise}\n     */\n    async updateTopic(topicId, name, subscribe) {\n        const apiPath = '/messaging/topics/{topicId}'.replace('{topicId}', topicId);\n        let payload = {};\n        if (typeof topicId === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"topicId\"');\n        }\n\n\n        if (typeof name !== 'undefined') {\n            payload['name'] = name;\n        }\n\n        if (typeof subscribe !== 'undefined') {\n            payload['subscribe'] = subscribe;\n        }\n\n        return await this.client.call('patch', apiPath, {\n            'content-type': 'application/json',\n        }, payload);\n    }\n\n    /**\n     * Delete topic\n     *\n     * Delete a topic by its unique ID.\n     *\n     * @param {string} topicId\n     * @throws {AppwriteException}\n     * @returns {Promise}\n     */\n    async deleteTopic(topicId) {\n        const apiPath = '/messaging/topics/{topicId}'.replace('{topicId}', topicId);\n        let payload = {};\n        if (typeof topicId === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"topicId\"');\n        }\n\n\n        return await this.client.call('delete', apiPath, {\n            'content-type': 'application/json',\n        }, payload);\n    }\n\n    /**\n     * List topic logs\n     *\n     * Get the topic activity logs listed by its unique ID.\n     *\n     * @param {string} topicId\n     * @param {string[]} queries\n     * @throws {AppwriteException}\n     * @returns {Promise}\n     */\n    async listTopicLogs(topicId, queries) {\n        const apiPath = '/messaging/topics/{topicId}/logs'.replace('{topicId}', topicId);\n        let payload = {};\n        if (typeof topicId === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"topicId\"');\n        }\n\n\n        if (typeof queries !== 'undefined') {\n            payload['queries'] = queries;\n        }\n\n        return await this.client.call('get', apiPath, {\n            'content-type': 'application/json',\n        }, payload);\n    }\n\n    /**\n     * List subscribers\n     *\n     * Get a list of all subscribers from the current Appwrite project.\n     *\n     * @param {string} topicId\n     * @param {string[]} queries\n     * @param {string} search\n     * @throws {AppwriteException}\n     * @returns {Promise}\n     */\n    async listSubscribers(topicId, queries, search) {\n        const apiPath = '/messaging/topics/{topicId}/subscribers'.replace('{topicId}', topicId);\n        let payload = {};\n        if (typeof topicId === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"topicId\"');\n        }\n\n\n        if (typeof queries !== 'undefined') {\n            payload['queries'] = queries;\n        }\n\n        if (typeof search !== 'undefined') {\n            payload['search'] = search;\n        }\n\n        return await this.client.call('get', apiPath, {\n            'content-type': 'application/json',\n        }, payload);\n    }\n\n    /**\n     * Create subscriber\n     *\n     * Create a new subscriber.\n     *\n     * @param {string} topicId\n     * @param {string} subscriberId\n     * @param {string} targetId\n     * @throws {AppwriteException}\n     * @returns {Promise}\n     */\n    async createSubscriber(topicId, subscriberId, targetId) {\n        const apiPath = '/messaging/topics/{topicId}/subscribers'.replace('{topicId}', topicId);\n        let payload = {};\n        if (typeof topicId === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"topicId\"');\n        }\n\n        if (typeof subscriberId === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"subscriberId\"');\n        }\n\n        if (typeof targetId === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"targetId\"');\n        }\n\n\n        if (typeof subscriberId !== 'undefined') {\n            payload['subscriberId'] = subscriberId;\n        }\n\n        if (typeof targetId !== 'undefined') {\n            payload['targetId'] = targetId;\n        }\n\n        return await this.client.call('post', apiPath, {\n            'content-type': 'application/json',\n        }, payload);\n    }\n\n    /**\n     * Get subscriber\n     *\n     * Get a subscriber by its unique ID.\n     * \n     *\n     * @param {string} topicId\n     * @param {string} subscriberId\n     * @throws {AppwriteException}\n     * @returns {Promise}\n     */\n    async getSubscriber(topicId, subscriberId) {\n        const apiPath = '/messaging/topics/{topicId}/subscribers/{subscriberId}'.replace('{topicId}', topicId).replace('{subscriberId}', subscriberId);\n        let payload = {};\n        if (typeof topicId === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"topicId\"');\n        }\n\n        if (typeof subscriberId === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"subscriberId\"');\n        }\n\n\n        return await this.client.call('get', apiPath, {\n            'content-type': 'application/json',\n        }, payload);\n    }\n\n    /**\n     * Delete subscriber\n     *\n     * Delete a subscriber by its unique ID.\n     *\n     * @param {string} topicId\n     * @param {string} subscriberId\n     * @throws {AppwriteException}\n     * @returns {Promise}\n     */\n    async deleteSubscriber(topicId, subscriberId) {\n        const apiPath = '/messaging/topics/{topicId}/subscribers/{subscriberId}'.replace('{topicId}', topicId).replace('{subscriberId}', subscriberId);\n        let payload = {};\n        if (typeof topicId === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"topicId\"');\n        }\n\n        if (typeof subscriberId === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"subscriberId\"');\n        }\n\n\n        return await this.client.call('delete', apiPath, {\n            'content-type': 'application/json',\n        }, payload);\n    }\n}\n\nmodule.exports = Messaging;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvbm9kZS1hcHB3cml0ZS9saWIvc2VydmljZXMvbWVzc2FnaW5nLmpzIiwibWFwcGluZ3MiOiJBQUFBLGdCQUFnQixtQkFBTyxDQUFDLHdFQUFlO0FBQ3ZDLDBCQUEwQixtQkFBTyxDQUFDLDRFQUFpQjtBQUNuRCxrQkFBa0IsbUJBQU8sQ0FBQyw0RUFBaUI7QUFDM0MsZUFBZSxtQkFBTyxDQUFDLHNFQUFjO0FBQ3JDLGVBQWUsbUJBQU8sQ0FBQyxzQkFBUTtBQUMvQixRQUFRLFlBQVksRUFBRSxtQkFBTyxDQUFDLGtCQUFNO0FBQ3BDLFdBQVcsbUJBQU8sQ0FBQyxjQUFJO0FBQ3ZCLFFBQVEsT0FBTyxFQUFFLG1CQUFPLENBQUMsc0JBQVE7QUFDakMsY0FBYyxtQkFBTyxDQUFDLG9FQUFhOztBQUVuQzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsVUFBVTtBQUN6QixlQUFlLFFBQVE7QUFDdkIsZ0JBQWdCO0FBQ2hCLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QixlQUFlLFFBQVE7QUFDdkIsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsVUFBVTtBQUN6QixlQUFlLFVBQVU7QUFDekIsZUFBZSxVQUFVO0FBQ3pCLGVBQWUsVUFBVTtBQUN6QixlQUFlLFVBQVU7QUFDekIsZUFBZSxVQUFVO0FBQ3pCLGVBQWUsU0FBUztBQUN4QixlQUFlLFNBQVM7QUFDeEIsZUFBZSxRQUFRO0FBQ3ZCLGdCQUFnQjtBQUNoQixpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFNBQVM7QUFDVDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkIsZUFBZSxVQUFVO0FBQ3pCLGVBQWUsVUFBVTtBQUN6QixlQUFlLFVBQVU7QUFDekIsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsUUFBUTtBQUN2QixlQUFlLFNBQVM7QUFDeEIsZUFBZSxTQUFTO0FBQ3hCLGVBQWUsVUFBVTtBQUN6QixlQUFlLFVBQVU7QUFDekIsZUFBZSxRQUFRO0FBQ3ZCLGdCQUFnQjtBQUNoQixpQkFBaUI7QUFDakI7QUFDQTtBQUNBLG9EQUFvRCxVQUFVLFlBQVksVUFBVTtBQUNwRjtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QixlQUFlLFFBQVE7QUFDdkIsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsVUFBVTtBQUN6QixlQUFlLFVBQVU7QUFDekIsZUFBZSxVQUFVO0FBQ3pCLGVBQWUsUUFBUTtBQUN2QixlQUFlLFFBQVE7QUFDdkIsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsUUFBUTtBQUN2QixlQUFlLFFBQVE7QUFDdkIsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsUUFBUTtBQUN2QixlQUFlLFFBQVE7QUFDdkIsZUFBZSxTQUFTO0FBQ3hCLGVBQWUsUUFBUTtBQUN2QixnQkFBZ0I7QUFDaEIsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsU0FBUztBQUNUOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QixlQUFlLFVBQVU7QUFDekIsZUFBZSxVQUFVO0FBQ3pCLGVBQWUsVUFBVTtBQUN6QixlQUFlLFFBQVE7QUFDdkIsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsUUFBUTtBQUN2QixlQUFlLFFBQVE7QUFDdkIsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsUUFBUTtBQUN2QixlQUFlLFFBQVE7QUFDdkIsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsUUFBUTtBQUN2QixlQUFlLFFBQVE7QUFDdkIsZUFBZSxTQUFTO0FBQ3hCLGVBQWUsUUFBUTtBQUN2QixnQkFBZ0I7QUFDaEIsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQSxtREFBbUQsVUFBVSxZQUFZLFVBQVU7QUFDbkY7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztB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YWNrOi8vanNtX2JhbmtpbmcvLi9ub2RlX21vZHVsZXMvbm9kZS1hcHB3cml0ZS9saWIvc2VydmljZXMvbWVzc2FnaW5nLmpzP2FhODIiXSwic291cmNlc0NvbnRlbnQiOlsiY29uc3QgU2VydmljZSA9IHJlcXVpcmUoJy4uL3NlcnZpY2UuanMnKTtcbmNvbnN0IEFwcHdyaXRlRXhjZXB0aW9uID0gcmVxdWlyZSgnLi4vZXhjZXB0aW9uLmpzJyk7XG5jb25zdCBJbnB1dEZpbGUgPSByZXF1aXJlKCcuLi9pbnB1dEZpbGUuanMnKTtcbmNvbnN0IGNsaWVudCA9IHJlcXVpcmUoJy4uL2NsaWVudC5qcycpO1xuY29uc3QgU3RyZWFtID0gcmVxdWlyZSgnc3RyZWFtJyk7XG5jb25zdCB7IHByb21pc2lmeSB9ID0gcmVxdWlyZSgndXRpbCcpO1xuY29uc3QgZnMgPSByZXF1aXJlKCdmcycpO1xuY29uc3QgeyBGaWxlIH0gPSByZXF1aXJlKCd1bmRpY2knKTtcbmNvbnN0IFF1ZXJ5ID0gcmVxdWlyZSgnLi4vcXVlcnkuanMnKTtcblxuY2xhc3MgTWVzc2FnaW5nIGV4dGVuZHMgU2VydmljZSB7XG5cbiAgICAgY29uc3RydWN0b3IoY2xpZW50KVxuICAgICB7XG4gICAgICAgIHN1cGVyKGNsaWVudCk7XG4gICAgIH1cblxuXG4gICAgLyoqXG4gICAgICogTGlzdCBtZXNzYWdlc1xuICAgICAqXG4gICAgICogR2V0IGEgbGlzdCBvZiBhbGwgbWVzc2FnZXMgZnJvbSB0aGUgY3VycmVudCBBcHB3cml0ZSBwcm9qZWN0LlxuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmdbXX0gcXVlcmllc1xuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBzZWFyY2hcbiAgICAgKiBAdGhyb3dzIHtBcHB3cml0ZUV4Y2VwdGlvbn1cbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZX1cbiAgICAgKi9cbiAgICBhc3luYyBsaXN0TWVzc2FnZXMocXVlcmllcywgc2VhcmNoKSB7XG4gICAgICAgIGNvbnN0IGFwaVBhdGggPSAnL21lc3NhZ2luZy9tZXNzYWdlcyc7XG4gICAgICAgIGxldCBwYXlsb2FkID0ge307XG5cbiAgICAgICAgaWYgKHR5cGVvZiBxdWVyaWVzICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgcGF5bG9hZFsncXVlcmllcyddID0gcXVlcmllcztcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0eXBlb2Ygc2VhcmNoICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgcGF5bG9hZFsnc2VhcmNoJ10gPSBzZWFyY2g7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy5jbGllbnQuY2FsbCgnZ2V0JywgYXBpUGF0aCwge1xuICAgICAgICAgICAgJ2NvbnRlbnQtdHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJyxcbiAgICAgICAgfSwgcGF5bG9hZCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlIGVtYWlsXG4gICAgICpcbiAgICAgKiBDcmVhdGUgYSBuZXcgZW1haWwgbWVzc2FnZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBtZXNzYWdlSWRcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gc3ViamVjdFxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBjb250ZW50XG4gICAgICogQHBhcmFtIHtzdHJpbmdbXX0gdG9waWNzXG4gICAgICogQHBhcmFtIHtzdHJpbmdbXX0gdXNlcnNcbiAgICAgKiBAcGFyYW0ge3N0cmluZ1tdfSB0YXJnZXRzXG4gICAgICogQHBhcmFtIHtzdHJpbmdbXX0gY2NcbiAgICAgKiBAcGFyYW0ge3N0cmluZ1tdfSBiY2NcbiAgICAgKiBAcGFyYW0ge3N0cmluZ1tdfSBhdHRhY2htZW50c1xuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gZHJhZnRcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IGh0bWxcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gc2NoZWR1bGVkQXRcbiAgICAgKiBAdGhyb3dzIHtBcHB3cml0ZUV4Y2VwdGlvbn1cbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZX1cbiAgICAgKi9cbiAgICBhc3luYyBjcmVhdGVFbWFpbChtZXNzYWdlSWQsIHN1YmplY3QsIGNvbnRlbnQsIHRvcGljcywgdXNlcnMsIHRhcmdldHMsIGNjLCBiY2MsIGF0dGFjaG1lbnRzLCBkcmFmdCwgaHRtbCwgc2NoZWR1bGVkQXQpIHtcbiAgICAgICAgY29uc3QgYXBpUGF0aCA9ICcvbWVzc2FnaW5nL21lc3NhZ2VzL2VtYWlsJztcbiAgICAgICAgbGV0IHBheWxvYWQgPSB7fTtcbiAgICAgICAgaWYgKHR5cGVvZiBtZXNzYWdlSWQgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgQXBwd3JpdGVFeGNlcHRpb24oJ01pc3NpbmcgcmVxdWlyZWQgcGFyYW1ldGVyOiBcIm1lc3NhZ2VJZFwiJyk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodHlwZW9mIHN1YmplY3QgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgQXBwd3JpdGVFeGNlcHRpb24oJ01pc3NpbmcgcmVxdWlyZWQgcGFyYW1ldGVyOiBcInN1YmplY3RcIicpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHR5cGVvZiBjb250ZW50ID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEFwcHdyaXRlRXhjZXB0aW9uKCdNaXNzaW5nIHJlcXVpcmVkIHBhcmFtZXRlcjogXCJjb250ZW50XCInKTtcbiAgICAgICAgfVxuXG5cbiAgICAgICAgaWYgKHR5cGVvZiBtZXNzYWdlSWQgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICBwYXlsb2FkWydtZXNzYWdlSWQnXSA9IG1lc3NhZ2VJZDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0eXBlb2Ygc3ViamVjdCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHBheWxvYWRbJ3N1YmplY3QnXSA9IHN1YmplY3Q7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodHlwZW9mIGNvbnRlbnQgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICBwYXlsb2FkWydjb250ZW50J10gPSBjb250ZW50O1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHR5cGVvZiB0b3BpY3MgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICBwYXlsb2FkWyd0b3BpY3MnXSA9IHRvcGljcztcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0eXBlb2YgdXNlcnMgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICBwYXlsb2FkWyd1c2VycyddID0gdXNlcnM7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodHlwZW9mIHRhcmdldHMgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICBwYXlsb2FkWyd0YXJnZXRzJ10gPSB0YXJnZXRzO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHR5cGVvZiBjYyAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHBheWxvYWRbJ2NjJ10gPSBjYztcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0eXBlb2YgYmNjICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgcGF5bG9hZFsnYmNjJ10gPSBiY2M7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodHlwZW9mIGF0dGFjaG1lbnRzICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgcGF5bG9hZFsnYXR0YWNobWVudHMnXSA9IGF0dGFjaG1lbnRzO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHR5cGVvZiBkcmFmdCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHBheWxvYWRbJ2RyYWZ0J10gPSBkcmFmdDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0eXBlb2YgaHRtbCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHBheWxvYWRbJ2h0bWwnXSA9IGh0bWw7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodHlwZW9mIHNjaGVkdWxlZEF0ICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgcGF5bG9hZFsnc2NoZWR1bGVkQXQnXSA9IHNjaGVkdWxlZEF0O1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMuY2xpZW50LmNhbGwoJ3Bvc3QnLCBhcGlQYXRoLCB7XG4gICAgICAgICAgICAnY29udGVudC10eXBlJzogJ2FwcGxpY2F0aW9uL2pzb24nLFxuICAgICAgICB9LCBwYXlsb2FkKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBVcGRhdGUgZW1haWxcbiAgICAgKlxuICAgICAqIFVwZGF0ZSBhbiBlbWFpbCBtZXNzYWdlIGJ5IGl0cyB1bmlxdWUgSUQuXG4gICAgICogXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gbWVzc2FnZUlkXG4gICAgICogQHBhcmFtIHtzdHJpbmdbXX0gdG9waWNzXG4gICAgICogQHBhcmFtIHtzdHJpbmdbXX0gdXNlcnNcbiAgICAgKiBAcGFyYW0ge3N0cmluZ1tdfSB0YXJnZXRzXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHN1YmplY3RcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gY29udGVudFxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gZHJhZnRcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IGh0bWxcbiAgICAgKiBAcGFyYW0ge3N0cmluZ1tdfSBjY1xuICAgICAqIEBwYXJhbSB7c3RyaW5nW119IGJjY1xuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBzY2hlZHVsZWRBdFxuICAgICAqIEB0aHJvd3Mge0FwcHdyaXRlRXhjZXB0aW9ufVxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlfVxuICAgICAqL1xuICAgIGFzeW5jIHVwZGF0ZUVtYWlsKG1lc3NhZ2VJZCwgdG9waWNzLCB1c2VycywgdGFyZ2V0cywgc3ViamVjdCwgY29udGVudCwgZHJhZnQsIGh0bWwsIGNjLCBiY2MsIHNjaGVkdWxlZEF0KSB7XG4gICAgICAgIGNvbnN0IGFwaVBhdGggPSAnL21lc3NhZ2luZy9tZXNzYWdlcy9lbWFpbC97bWVzc2FnZUlkfScucmVwbGFjZSgne21lc3NhZ2VJZH0nLCBtZXNzYWdlSWQpO1xuICAgICAgICBsZXQgcGF5bG9hZCA9IHt9O1xuICAgICAgICBpZiAodHlwZW9mIG1lc3NhZ2VJZCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBBcHB3cml0ZUV4Y2VwdGlvbignTWlzc2luZyByZXF1aXJlZCBwYXJhbWV0ZXI6IFwibWVzc2FnZUlkXCInKTtcbiAgICAgICAgfVxuXG5cbiAgICAgICAgaWYgKHR5cGVvZiB0b3BpY3MgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICBwYXlsb2FkWyd0b3BpY3MnXSA9IHRvcGljcztcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0eXBlb2YgdXNlcnMgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICBwYXlsb2FkWyd1c2VycyddID0gdXNlcnM7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodHlwZW9mIHRhcmdldHMgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICBwYXlsb2FkWyd0YXJnZXRzJ10gPSB0YXJnZXRzO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHR5cGVvZiBzdWJqZWN0ICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgcGF5bG9hZFsnc3ViamVjdCddID0gc3ViamVjdDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0eXBlb2YgY29udGVudCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHBheWxvYWRbJ2NvbnRlbnQnXSA9IGNvbnRlbnQ7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodHlwZW9mIGRyYWZ0ICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgcGF5bG9hZFsnZHJhZnQnXSA9IGRyYWZ0O1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHR5cGVvZiBodG1sICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgcGF5bG9hZFsnaHRtbCddID0gaHRtbDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0eXBlb2YgY2MgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICBwYXlsb2FkWydjYyddID0gY2M7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodHlwZW9mIGJjYyAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHBheWxvYWRbJ2JjYyddID0gYmNjO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHR5cGVvZiBzY2hlZHVsZWRBdCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHBheWxvYWRbJ3NjaGVkdWxlZEF0J10gPSBzY2hlZHVsZWRBdDtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBhd2FpdCB0aGlzLmNsaWVudC5jYWxsKCdwYXRjaCcsIGFwaVBhdGgsIHtcbiAgICAgICAgICAgICdjb250ZW50LXR5cGUnOiAnYXBwbGljYXRpb24vanNvbicsXG4gICAgICAgIH0sIHBheWxvYWQpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZSBwdXNoIG5vdGlmaWNhdGlvblxuICAgICAqXG4gICAgICogQ3JlYXRlIGEgbmV3IHB1c2ggbm90aWZpY2F0aW9uLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IG1lc3NhZ2VJZFxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSB0aXRsZVxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBib2R5XG4gICAgICogQHBhcmFtIHtzdHJpbmdbXX0gdG9waWNzXG4gICAgICogQHBhcmFtIHtzdHJpbmdbXX0gdXNlcnNcbiAgICAgKiBAcGFyYW0ge3N0cmluZ1tdfSB0YXJnZXRzXG4gICAgICogQHBhcmFtIHtvYmplY3R9IGRhdGFcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gYWN0aW9uXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGltYWdlXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGljb25cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gc291bmRcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gY29sb3JcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gdGFnXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGJhZGdlXG4gICAgICogQHBhcmFtIHtib29sZWFufSBkcmFmdFxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBzY2hlZHVsZWRBdFxuICAgICAqIEB0aHJvd3Mge0FwcHdyaXRlRXhjZXB0aW9ufVxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlfVxuICAgICAqL1xuICAgIGFzeW5jIGNyZWF0ZVB1c2gobWVzc2FnZUlkLCB0aXRsZSwgYm9keSwgdG9waWNzLCB1c2VycywgdGFyZ2V0cywgZGF0YSwgYWN0aW9uLCBpbWFnZSwgaWNvbiwgc291bmQsIGNvbG9yLCB0YWcsIGJhZGdlLCBkcmFmdCwgc2NoZWR1bGVkQXQpIHtcbiAgICAgICAgY29uc3QgYXBpUGF0aCA9ICcvbWVzc2FnaW5nL21lc3NhZ2VzL3B1c2gnO1xuICAgICAgICBsZXQgcGF5bG9hZCA9IHt9O1xuICAgICAgICBpZiAodHlwZW9mIG1lc3NhZ2VJZCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBBcHB3cml0ZUV4Y2VwdGlvbignTWlzc2luZyByZXF1aXJlZCBwYXJhbWV0ZXI6IFwibWVzc2FnZUlkXCInKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0eXBlb2YgdGl0bGUgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgQXBwd3JpdGVFeGNlcHRpb24oJ01pc3NpbmcgcmVxdWlyZWQgcGFyYW1ldGVyOiBcInRpdGxlXCInKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0eXBlb2YgYm9keSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBBcHB3cml0ZUV4Y2VwdGlvbignTWlzc2luZyByZXF1aXJlZCBwYXJhbWV0ZXI6IFwiYm9keVwiJyk7XG4gICAgICAgIH1cblxuXG4gICAgICAgIGlmICh0eXBlb2YgbWVzc2FnZUlkICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgcGF5bG9hZFsnbWVzc2FnZUlkJ10gPSBtZXNzYWdlSWQ7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodHlwZW9mIHRpdGxlICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgcGF5bG9hZFsndGl0bGUnXSA9IHRpdGxlO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHR5cGVvZiBib2R5ICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgcGF5bG9hZFsnYm9keSddID0gYm9keTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0eXBlb2YgdG9waWNzICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgcGF5bG9hZFsndG9waWNzJ10gPSB0b3BpY3M7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodHlwZW9mIHVzZXJzICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgcGF5bG9hZFsndXNlcnMnXSA9IHVzZXJzO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHR5cGVvZiB0YXJnZXRzICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgcGF5bG9hZFsndGFyZ2V0cyddID0gdGFyZ2V0cztcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0eXBlb2YgZGF0YSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHBheWxvYWRbJ2RhdGEnXSA9IGRhdGE7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodHlwZW9mIGFjdGlvbiAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHBheWxvYWRbJ2FjdGlvbiddID0gYWN0aW9uO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHR5cGVvZiBpbWFnZSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHBheWxvYWRbJ2ltYWdlJ10gPSBpbWFnZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0eXBlb2YgaWNvbiAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHBheWxvYWRbJ2ljb24nXSA9IGljb247XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodHlwZW9mIHNvdW5kICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgcGF5bG9hZFsnc291bmQnXSA9IHNvdW5kO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHR5cGVvZiBjb2xvciAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHBheWxvYWRbJ2NvbG9yJ10gPSBjb2xvcjtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0eXBlb2YgdGFnICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgcGF5bG9hZFsndGFnJ10gPSB0YWc7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodHlwZW9mIGJhZGdlICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgcGF5bG9hZFsnYmFkZ2UnXSA9IGJhZGdlO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHR5cGVvZiBkcmFmdCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHBheWxvYWRbJ2RyYWZ0J10gPSBkcmFmdDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0eXBlb2Ygc2NoZWR1bGVkQXQgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICBwYXlsb2FkWydzY2hlZHVsZWRBdCddID0gc2NoZWR1bGVkQXQ7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy5jbGllbnQuY2FsbCgncG9zdCcsIGFwaVBhdGgsIHtcbiAgICAgICAgICAgICdjb250ZW50LXR5cGUnOiAnYXBwbGljYXRpb24vanNvbicsXG4gICAgICAgIH0sIHBheWxvYWQpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFVwZGF0ZSBwdXNoIG5vdGlmaWNhdGlvblxuICAgICAqXG4gICAgICogVXBkYXRlIGEgcHVzaCBub3RpZmljYXRpb24gYnkgaXRzIHVuaXF1ZSBJRC5cbiAgICAgKiBcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBtZXNzYWdlSWRcbiAgICAgKiBAcGFyYW0ge3N0cmluZ1tdfSB0b3BpY3NcbiAgICAgKiBAcGFyYW0ge3N0cmluZ1tdfSB1c2Vyc1xuICAgICAqIEBwYXJhbSB7c3RyaW5nW119IHRhcmdldHNcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gdGl0bGVcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gYm9keVxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBkYXRhXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGFjdGlvblxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBpbWFnZVxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBpY29uXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHNvdW5kXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGNvbG9yXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHRhZ1xuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBiYWRnZVxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gZHJhZnRcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gc2NoZWR1bGVkQXRcbiAgICAgKiBAdGhyb3dzIHtBcHB3cml0ZUV4Y2VwdGlvbn1cbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZX1cbiAgICAgKi9cbiAgICBhc3luYyB1cGRhdGVQdXNoKG1lc3NhZ2VJZCwgdG9waWNzLCB1c2VycywgdGFyZ2V0cywgdGl0bGUsIGJvZHksIGRhdGEsIGFjdGlvbiwgaW1hZ2UsIGljb24sIHNvdW5kLCBjb2xvciwgdGFnLCBiYWRnZSwgZHJhZnQsIHNjaGVkdWxlZEF0KSB7XG4gICAgICAgIGNvbnN0IGFwaVBhdGggPSAnL21lc3NhZ2luZy9tZXNzYWdlcy9wdXNoL3ttZXNzYWdlSWR9Jy5yZXBsYWNlKCd7bWVzc2FnZUlkfScsIG1lc3NhZ2VJZCk7XG4gICAgICAgIGxldCBwYXlsb2FkID0ge307XG4gICAgICAgIGlmICh0eXBlb2YgbWVzc2FnZUlkID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEFwcHdyaXRlRXhjZXB0aW9uKCdNaXNzaW5nIHJlcXVpcmVkIHBhcmFtZXRlcjogXCJtZXNzYWdlSWRcIicpO1xuICAgICAgICB9XG5cblxuICAgICAgICBpZiAodHlwZW9mIHRvcGljcyAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHBheWxvYWRbJ3RvcGljcyddID0gdG9waWNzO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHR5cGVvZiB1c2VycyAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHBheWxvYWRbJ3VzZXJzJ10gPSB1c2VycztcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0eXBlb2YgdGFyZ2V0cyAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHBheWxvYWRbJ3RhcmdldHMnXSA9IHRhcmdldHM7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodHlwZW9mIHRpdGxlICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgcGF5bG9hZFsndGl0bGUnXSA9IHRpdGxlO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHR5cGVvZiBib2R5ICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgcGF5bG9hZFsnYm9keSddID0gYm9keTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0eXBlb2YgZGF0YSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHBheWxvYWRbJ2RhdGEnXSA9IGRhdGE7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodHlwZW9mIGFjdGlvbiAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHBheWxvYWRbJ2FjdGlvbiddID0gYWN0aW9uO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHR5cGVvZiBpbWFnZSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHBheWxvYWRbJ2ltYWdlJ10gPSBpbWFnZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0eXBlb2YgaWNvbiAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHBheWxvYWRbJ2ljb24nXSA9IGljb247XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodHlwZW9mIHNvdW5kICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgcGF5bG9hZFsnc291bmQnXSA9IHNvdW5kO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHR5cGVvZiBjb2xvciAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHBheWxvYWRbJ2NvbG9yJ10gPSBjb2xvcjtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0eXBlb2YgdGFnICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgcGF5bG9hZFsndGFnJ10gPSB0YWc7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodHlwZW9mIGJhZGdlICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgcGF5bG9hZFsnYmFkZ2UnXSA9IGJhZGdlO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHR5cGVvZiBkcmFmdCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHBheWxvYWRbJ2RyYWZ0J10gPSBkcmFmdDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0eXBlb2Ygc2NoZWR1bGVkQXQgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICBwYXlsb2FkWydzY2hlZHVsZWRBdCddID0gc2NoZWR1bGVkQXQ7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy5jbGllbnQuY2FsbCgncGF0Y2gnLCBhcGlQYXRoLCB7XG4gICAgICAgICAgICAnY29udGVudC10eXBlJzogJ2FwcGxpY2F0aW9uL2pzb24nLFxuICAgICAgICB9LCBwYXlsb2FkKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGUgU01TXG4gICAgICpcbiAgICAgKiBDcmVhdGUgYSBuZXcgU01TIG1lc3NhZ2UuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gbWVzc2FnZUlkXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGNvbnRlbnRcbiAgICAgKiBAcGFyYW0ge3N0cmluZ1tdfSB0b3BpY3NcbiAgICAgKiBAcGFyYW0ge3N0cmluZ1tdfSB1c2Vyc1xuICAgICAqIEBwYXJhbSB7c3RyaW5nW119IHRhcmdldHNcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IGRyYWZ0XG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHNjaGVkdWxlZEF0XG4gICAgICogQHRocm93cyB7QXBwd3JpdGVFeGNlcHRpb259XG4gICAgICogQHJldHVybnMge1Byb21pc2V9XG4gICAgICovXG4gICAgYXN5bmMgY3JlYXRlU21zKG1lc3NhZ2VJZCwgY29udGVudCwgdG9waWNzLCB1c2VycywgdGFyZ2V0cywgZHJhZnQsIHNjaGVkdWxlZEF0KSB7XG4gICAgICAgIGNvbnN0IGFwaVBhdGggPSAnL21lc3NhZ2luZy9tZXNzYWdlcy9zbXMnO1xuICAgICAgICBsZXQgcGF5bG9hZCA9IHt9O1xuICAgICAgICBpZiAodHlwZW9mIG1lc3NhZ2VJZCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBBcHB3cml0ZUV4Y2VwdGlvbignTWlzc2luZyByZXF1aXJlZCBwYXJhbWV0ZXI6IFwibWVzc2FnZUlkXCInKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0eXBlb2YgY29udGVudCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBBcHB3cml0ZUV4Y2VwdGlvbignTWlzc2luZyByZXF1aXJlZCBwYXJhbWV0ZXI6IFwiY29udGVudFwiJyk7XG4gICAgICAgIH1cblxuXG4gICAgICAgIGlmICh0eXBlb2YgbWVzc2FnZUlkICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgcGF5bG9hZFsnbWVzc2FnZUlkJ10gPSBtZXNzYWdlSWQ7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodHlwZW9mIGNvbnRlbnQgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICBwYXlsb2FkWydjb250ZW50J10gPSBjb250ZW50O1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHR5cGVvZiB0b3BpY3MgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICBwYXlsb2FkWyd0b3BpY3MnXSA9IHRvcGljcztcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0eXBlb2YgdXNlcnMgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICBwYXlsb2FkWyd1c2VycyddID0gdXNlcnM7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodHlwZW9mIHRhcmdldHMgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICBwYXlsb2FkWyd0YXJnZXRzJ10gPSB0YXJnZXRzO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHR5cGVvZiBkcmFmdCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHBheWxvYWRbJ2RyYWZ0J10gPSBkcmFmdDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0eXBlb2Ygc2NoZWR1bGVkQXQgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICBwYXlsb2FkWydzY2hlZHVsZWRBdCddID0gc2NoZWR1bGVkQXQ7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy5jbGllbnQuY2FsbCgncG9zdCcsIGFwaVBhdGgsIHtcbiAgICAgICAgICAgICdjb250ZW50LXR5cGUnOiAnYXBwbGljYXRpb24vanNvbicsXG4gICAgICAgIH0sIHBheWxvYWQpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFVwZGF0ZSBTTVNcbiAgICAgKlxuICAgICAqIFVwZGF0ZSBhbiBlbWFpbCBtZXNzYWdlIGJ5IGl0cyB1bmlxdWUgSUQuXG4gICAgICogXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gbWVzc2FnZUlkXG4gICAgICogQHBhcmFtIHtzdHJpbmdbXX0gdG9waWNzXG4gICAgICogQHBhcmFtIHtzdHJpbmdbXX0gdXNlcnNcbiAgICAgKiBAcGFyYW0ge3N0cmluZ1tdfSB0YXJnZXRzXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGNvbnRlbnRcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IGRyYWZ0XG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHNjaGVkdWxlZEF0XG4gICAgICogQHRocm93cyB7QXBwd3JpdGVFeGNlcHRpb259XG4gICAgICogQHJldHVybnMge1Byb21pc2V9XG4gICAgICovXG4gICAgYXN5bmMgdXBkYXRlU21zKG1lc3NhZ2VJZCwgdG9waWNzLCB1c2VycywgdGFyZ2V0cywgY29udGVudCwgZHJhZnQsIHNjaGVkdWxlZEF0KSB7XG4gICAgICAgIGNvbnN0IGFwaVBhdGggPSAnL21lc3NhZ2luZy9tZXNzYWdlcy9zbXMve21lc3NhZ2VJZH0nLnJlcGxhY2UoJ3ttZXNzYWdlSWR9JywgbWVzc2FnZUlkKTtcbiAgICAgICAgbGV0IHBheWxvYWQgPSB7fTtcbiAgICAgICAgaWYgKHR5cGVvZiBtZXNzYWdlSWQgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgQXBwd3JpdGVFeGNlcHRpb24oJ01pc3NpbmcgcmVxdWlyZWQgcGFyYW1ldGVyOiBcIm1lc3NhZ2VJZFwiJyk7XG4gICAgICAgIH1cblxuXG4gICAgICAgIGlmICh0eXBlb2YgdG9waWNzICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgcGF5bG9hZFsndG9waWNzJ10gPSB0b3BpY3M7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodHlwZW9mIHVzZXJzICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgcGF5bG9hZFsndXNlcnMnXSA9IHVzZXJzO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHR5cGVvZiB0YXJnZXRzICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgcGF5bG9hZFsndGFyZ2V0cyddID0gdGFyZ2V0cztcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0eXBlb2YgY29udGVudCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHBheWxvYWRbJ2NvbnRlbnQnXSA9IGNvbnRlbnQ7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodHlwZW9mIGRyYWZ0ICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgcGF5bG9hZFsnZHJhZnQnXSA9IGRyYWZ0O1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHR5cGVvZiBzY2hlZHVsZWRBdCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHBheWxvYWRbJ3NjaGVkdWxlZEF0J10gPSBzY2hlZHVsZWRBdDtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBhd2FpdCB0aGlzLmNsaWVudC5jYWxsKCdwYXRjaCcsIGFwaVBhdGgsIHtcbiAgICAgICAgICAgICdjb250ZW50LXR5cGUnOiAnYXBwbGljYXRpb24vanNvbicsXG4gICAgICAgIH0sIHBheWxvYWQpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdldCBtZXNzYWdlXG4gICAgICpcbiAgICAgKiBHZXQgYSBtZXNzYWdlIGJ5IGl0cyB1bmlxdWUgSUQuXG4gICAgICogXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gbWVzc2FnZUlkXG4gICAgICogQHRocm93cyB7QXBwd3JpdGVFeGNlcHRpb259XG4gICAgICogQHJldHVybnMge1Byb21pc2V9XG4gICAgICovXG4gICAgYXN5bmMgZ2V0TWVzc2FnZShtZXNzYWdlSWQpIHtcbiAgICAgICAgY29uc3QgYXBpUGF0aCA9ICcvbWVzc2FnaW5nL21lc3NhZ2VzL3ttZXNzYWdlSWR9Jy5yZXBsYWNlKCd7bWVzc2FnZUlkfScsIG1lc3NhZ2VJZCk7XG4gICAgICAgIGxldCBwYXlsb2FkID0ge307XG4gICAgICAgIGlmICh0eXBlb2YgbWVzc2FnZUlkID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEFwcHdyaXRlRXhjZXB0aW9uKCdNaXNzaW5nIHJlcXVpcmVkIHBhcmFtZXRlcjogXCJtZXNzYWdlSWRcIicpO1xuICAgICAgICB9XG5cblxuICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy5jbGllbnQuY2FsbCgnZ2V0JywgYXBpUGF0aCwge1xuICAgICAgICAgICAgJ2NvbnRlbnQtdHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJyxcbiAgICAgICAgfSwgcGF5bG9hZCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRGVsZXRlIG1lc3NhZ2VcbiAgICAgKlxuICAgICAqIERlbGV0ZSBhIG1lc3NhZ2UuIElmIHRoZSBtZXNzYWdlIGlzIG5vdCBhIGRyYWZ0IG9yIHNjaGVkdWxlZCwgYnV0IGhhcyBiZWVuXG4gICAgICogc2VudCwgdGhpcyB3aWxsIG5vdCByZWNhbGwgdGhlIG1lc3NhZ2UuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gbWVzc2FnZUlkXG4gICAgICogQHRocm93cyB7QXBwd3JpdGVFeGNlcHRpb259XG4gICAgICogQHJldHVybnMge1Byb21pc2V9XG4gICAgICovXG4gICAgYXN5bmMgZGVsZXRlKG1lc3NhZ2VJZCkge1xuICAgICAgICBjb25zdCBhcGlQYXRoID0gJy9tZXNzYWdpbmcvbWVzc2FnZXMve21lc3NhZ2VJZH0nLnJlcGxhY2UoJ3ttZXNzYWdlSWR9JywgbWVzc2FnZUlkKTtcbiAgICAgICAgbGV0IHBheWxvYWQgPSB7fTtcbiAgICAgICAgaWYgKHR5cGVvZiBtZXNzYWdlSWQgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgQXBwd3JpdGVFeGNlcHRpb24oJ01pc3NpbmcgcmVxdWlyZWQgcGFyYW1ldGVyOiBcIm1lc3NhZ2VJZFwiJyk7XG4gICAgICAgIH1cblxuXG4gICAgICAgIHJldHVybiBhd2FpdCB0aGlzLmNsaWVudC5jYWxsKCdkZWxldGUnLCBhcGlQYXRoLCB7XG4gICAgICAgICAgICAnY29udGVudC10eXBlJzogJ2FwcGxpY2F0aW9uL2pzb24nLFxuICAgICAgICB9LCBwYXlsb2FkKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBMaXN0IG1lc3NhZ2UgbG9nc1xuICAgICAqXG4gICAgICogR2V0IHRoZSBtZXNzYWdlIGFjdGl2aXR5IGxvZ3MgbGlzdGVkIGJ5IGl0cyB1bmlxdWUgSUQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gbWVzc2FnZUlkXG4gICAgICogQHBhcmFtIHtzdHJpbmdbXX0gcXVlcmllc1xuICAgICAqIEB0aHJvd3Mge0FwcHdyaXRlRXhjZXB0aW9ufVxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlfVxuICAgICAqL1xuICAgIGFzeW5jIGxpc3RNZXNzYWdlTG9ncyhtZXNzYWdlSWQsIHF1ZXJpZXMpIHtcbiAgICAgICAgY29uc3QgYXBpUGF0aCA9ICcvbWVzc2FnaW5nL21lc3NhZ2VzL3ttZXNzYWdlSWR9L2xvZ3MnLnJlcGxhY2UoJ3ttZXNzYWdlSWR9JywgbWVzc2FnZUlkKTtcbiAgICAgICAgbGV0IHBheWxvYWQgPSB7fTtcbiAgICAgICAgaWYgKHR5cGVvZiBtZXNzYWdlSWQgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgQXBwd3JpdGVFeGNlcHRpb24oJ01pc3NpbmcgcmVxdWlyZWQgcGFyYW1ldGVyOiBcIm1lc3NhZ2VJZFwiJyk7XG4gICAgICAgIH1cblxuXG4gICAgICAgIGlmICh0eXBlb2YgcXVlcmllcyAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHBheWxvYWRbJ3F1ZXJpZXMnXSA9IHF1ZXJpZXM7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy5jbGllbnQuY2FsbCgnZ2V0JywgYXBpUGF0aCwge1xuICAgICAgICAgICAgJ2NvbnRlbnQtdHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJyxcbiAgICAgICAgfSwgcGF5bG9hZCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogTGlzdCBtZXNzYWdlIHRhcmdldHNcbiAgICAgKlxuICAgICAqIEdldCBhIGxpc3Qgb2YgdGhlIHRhcmdldHMgYXNzb2NpYXRlZCB3aXRoIGEgbWVzc2FnZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBtZXNzYWdlSWRcbiAgICAgKiBAcGFyYW0ge3N0cmluZ1tdfSBxdWVyaWVzXG4gICAgICogQHRocm93cyB7QXBwd3JpdGVFeGNlcHRpb259XG4gICAgICogQHJldHVybnMge1Byb21pc2V9XG4gICAgICovXG4gICAgYXN5bmMgbGlzdFRhcmdldHMobWVzc2FnZUlkLCBxdWVyaWVzKSB7XG4gICAgICAgIGNvbnN0IGFwaVBhdGggPSAnL21lc3NhZ2luZy9tZXNzYWdlcy97bWVzc2FnZUlkfS90YXJnZXRzJy5yZXBsYWNlKCd7bWVzc2FnZUlkfScsIG1lc3NhZ2VJZCk7XG4gICAgICAgIGxldCBwYXlsb2FkID0ge307XG4gICAgICAgIGlmICh0eXBlb2YgbWVzc2FnZUlkID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEFwcHdyaXRlRXhjZXB0aW9uKCdNaXNzaW5nIHJlcXVpcmVkIHBhcmFtZXRlcjogXCJtZXNzYWdlSWRcIicpO1xuICAgICAgICB9XG5cblxuICAgICAgICBpZiAodHlwZW9mIHF1ZXJpZXMgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICBwYXlsb2FkWydxdWVyaWVzJ10gPSBxdWVyaWVzO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMuY2xpZW50LmNhbGwoJ2dldCcsIGFwaVBhdGgsIHtcbiAgICAgICAgICAgICdjb250ZW50LXR5cGUnOiAnYXBwbGljYXRpb24vanNvbicsXG4gICAgICAgIH0sIHBheWxvYWQpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIExpc3QgcHJvdmlkZXJzXG4gICAgICpcbiAgICAgKiBHZXQgYSBsaXN0IG9mIGFsbCBwcm92aWRlcnMgZnJvbSB0aGUgY3VycmVudCBBcHB3cml0ZSBwcm9qZWN0LlxuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmdbXX0gcXVlcmllc1xuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBzZWFyY2hcbiAgICAgKiBAdGhyb3dzIHtBcHB3cml0ZUV4Y2VwdGlvbn1cbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZX1cbiAgICAgKi9cbiAgICBhc3luYyBsaXN0UHJvdmlkZXJzKHF1ZXJpZXMsIHNlYXJjaCkge1xuICAgICAgICBjb25zdCBhcGlQYXRoID0gJy9tZXNzYWdpbmcvcHJvdmlkZXJzJztcbiAgICAgICAgbGV0IHBheWxvYWQgPSB7fTtcblxuICAgICAgICBpZiAodHlwZW9mIHF1ZXJpZXMgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICBwYXlsb2FkWydxdWVyaWVzJ10gPSBxdWVyaWVzO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHR5cGVvZiBzZWFyY2ggIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICBwYXlsb2FkWydzZWFyY2gnXSA9IHNlYXJjaDtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBhd2FpdCB0aGlzLmNsaWVudC5jYWxsKCdnZXQnLCBhcGlQYXRoLCB7XG4gICAgICAgICAgICAnY29udGVudC10eXBlJzogJ2FwcGxpY2F0aW9uL2pzb24nLFxuICAgICAgICB9LCBwYXlsb2FkKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGUgQVBOUyBwcm92aWRlclxuICAgICAqXG4gICAgICogQ3JlYXRlIGEgbmV3IEFwcGxlIFB1c2ggTm90aWZpY2F0aW9uIHNlcnZpY2UgcHJvdmlkZXIuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gcHJvdmlkZXJJZFxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGF1dGhLZXlcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gYXV0aEtleUlkXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHRlYW1JZFxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBidW5kbGVJZFxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gc2FuZGJveFxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gZW5hYmxlZFxuICAgICAqIEB0aHJvd3Mge0FwcHdyaXRlRXhjZXB0aW9ufVxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlfVxuICAgICAqL1xuICAgIGFzeW5jIGNyZWF0ZUFwbnNQcm92aWRlcihwcm92aWRlcklkLCBuYW1lLCBhdXRoS2V5LCBhdXRoS2V5SWQsIHRlYW1JZCwgYnVuZGxlSWQsIHNhbmRib3gsIGVuYWJsZWQpIHtcbiAgICAgICAgY29uc3QgYXBpUGF0aCA9ICcvbWVzc2FnaW5nL3Byb3ZpZGVycy9hcG5zJztcbiAgICAgICAgbGV0IHBheWxvYWQgPSB7fTtcbiAgICAgICAgaWYgKHR5cGVvZiBwcm92aWRlcklkID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEFwcHdyaXRlRXhjZXB0aW9uKCdNaXNzaW5nIHJlcXVpcmVkIHBhcmFtZXRlcjogXCJwcm92aWRlcklkXCInKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0eXBlb2YgbmFtZSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBBcHB3cml0ZUV4Y2VwdGlvbignTWlzc2luZyByZXF1aXJlZCBwYXJhbWV0ZXI6IFwibmFtZVwiJyk7XG4gICAgICAgIH1cblxuXG4gICAgICAgIGlmICh0eXBlb2YgcHJvdmlkZXJJZCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHBheWxvYWRbJ3Byb3ZpZGVySWQnXSA9IHByb3ZpZGVySWQ7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodHlwZW9mIG5hbWUgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICBwYXlsb2FkWyduYW1lJ10gPSBuYW1lO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHR5cGVvZiBhdXRoS2V5ICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgcGF5bG9hZFsnYXV0aEtleSddID0gYXV0aEtleTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0eXBlb2YgYXV0aEtleUlkICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgcGF5bG9hZFsnYXV0aEtleUlkJ10gPSBhdXRoS2V5SWQ7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodHlwZW9mIHRlYW1JZCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHBheWxvYWRbJ3RlYW1JZCddID0gdGVhbUlkO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHR5cGVvZiBidW5kbGVJZCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHBheWxvYWRbJ2J1bmRsZUlkJ10gPSBidW5kbGVJZDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0eXBlb2Ygc2FuZGJveCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHBheWxvYWRbJ3NhbmRib3gnXSA9IHNhbmRib3g7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodHlwZW9mIGVuYWJsZWQgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICBwYXlsb2FkWydlbmFibGVkJ10gPSBlbmFibGVkO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMuY2xpZW50LmNhbGwoJ3Bvc3QnLCBhcGlQYXRoLCB7XG4gICAgICAgICAgICAnY29udGVudC10eXBlJzogJ2FwcGxpY2F0aW9uL2pzb24nLFxuICAgICAgICB9LCBwYXlsb2FkKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBVcGRhdGUgQVBOUyBwcm92aWRlclxuICAgICAqXG4gICAgICogVXBkYXRlIGEgQXBwbGUgUHVzaCBOb3RpZmljYXRpb24gc2VydmljZSBwcm92aWRlciBieSBpdHMgdW5pcXVlIElELlxuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHByb3ZpZGVySWRcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gbmFtZVxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gZW5hYmxlZFxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBhdXRoS2V5XG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGF1dGhLZXlJZFxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSB0ZWFtSWRcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gYnVuZGxlSWRcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IHNhbmRib3hcbiAgICAgKiBAdGhyb3dzIHtBcHB3cml0ZUV4Y2VwdGlvbn1cbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZX1cbiAgICAgKi9cbiAgICBhc3luYyB1cGRhdGVBcG5zUHJvdmlkZXIocHJvdmlkZXJJZCwgbmFtZSwgZW5hYmxlZCwgYXV0aEtleSwgYXV0aEtleUlkLCB0ZWFtSWQsIGJ1bmRsZUlkLCBzYW5kYm94KSB7XG4gICAgICAgIGNvbnN0IGFwaVBhdGggPSAnL21lc3NhZ2luZy9wcm92aWRlcnMvYXBucy97cHJvdmlkZXJJZH0nLnJlcGxhY2UoJ3twcm92aWRlcklkfScsIHByb3ZpZGVySWQpO1xuICAgICAgICBsZXQgcGF5bG9hZCA9IHt9O1xuICAgICAgICBpZiAodHlwZW9mIHByb3ZpZGVySWQgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgQXBwd3JpdGVFeGNlcHRpb24oJ01pc3NpbmcgcmVxdWlyZWQgcGFyYW1ldGVyOiBcInByb3ZpZGVySWRcIicpO1xuICAgICAgICB9XG5cblxuICAgICAgICBpZiAodHlwZW9mIG5hbWUgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICBwYXlsb2FkWyduYW1lJ10gPSBuYW1lO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHR5cGVvZiBlbmFibGVkICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgcGF5bG9hZFsnZW5hYmxlZCddID0gZW5hYmxlZDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0eXBlb2YgYXV0aEtleSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHBheWxvYWRbJ2F1dGhLZXknXSA9IGF1dGhLZXk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodHlwZW9mIGF1dGhLZXlJZCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHBheWxvYWRbJ2F1dGhLZXlJZCddID0gYXV0aEtleUlkO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHR5cGVvZiB0ZWFtSWQgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICBwYXlsb2FkWyd0ZWFtSWQnXSA9IHRlYW1JZDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0eXBlb2YgYnVuZGxlSWQgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICBwYXlsb2FkWydidW5kbGVJZCddID0gYnVuZGxlSWQ7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodHlwZW9mIHNhbmRib3ggIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICBwYXlsb2FkWydzYW5kYm94J10gPSBzYW5kYm94O1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMuY2xpZW50LmNhbGwoJ3BhdGNoJywgYXBpUGF0aCwge1xuICAgICAgICAgICAgJ2NvbnRlbnQtdHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJyxcbiAgICAgICAgfSwgcGF5bG9hZCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlIEZDTSBwcm92aWRlclxuICAgICAqXG4gICAgICogQ3JlYXRlIGEgbmV3IEZpcmViYXNlIENsb3VkIE1lc3NhZ2luZyBwcm92aWRlci5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBwcm92aWRlcklkXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IG5hbWVcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gc2VydmljZUFjY291bnRKU09OXG4gICAgICogQHBhcmFtIHtib29sZWFufSBlbmFibGVkXG4gICAgICogQHRocm93cyB7QXBwd3JpdGVFeGNlcHRpb259XG4gICAgICogQHJldHVybnMge1Byb21pc2V9XG4gICAgICovXG4gICAgYXN5bmMgY3JlYXRlRmNtUHJvdmlkZXIocHJvdmlkZXJJZCwgbmFtZSwgc2VydmljZUFjY291bnRKU09OLCBlbmFibGVkKSB7XG4gICAgICAgIGNvbnN0IGFwaVBhdGggPSAnL21lc3NhZ2luZy9wcm92aWRlcnMvZmNtJztcbiAgICAgICAgbGV0IHBheWxvYWQgPSB7fTtcbiAgICAgICAgaWYgKHR5cGVvZiBwcm92aWRlcklkID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEFwcHdyaXRlRXhjZXB0aW9uKCdNaXNzaW5nIHJlcXVpcmVkIHBhcmFtZXRlcjogXCJwcm92aWRlcklkXCInKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0eXBlb2YgbmFtZSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBBcHB3cml0ZUV4Y2VwdGlvbignTWlzc2luZyByZXF1aXJlZCBwYXJhbWV0ZXI6IFwibmFtZVwiJyk7XG4gICAgICAgIH1cblxuXG4gICAgICAgIGlmICh0eXBlb2YgcHJvdmlkZXJJZCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHBheWxvYWRbJ3Byb3ZpZGVySWQnXSA9IHByb3ZpZGVySWQ7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodHlwZW9mIG5hbWUgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICBwYXlsb2FkWyduYW1lJ10gPSBuYW1lO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHR5cGVvZiBzZXJ2aWNlQWNjb3VudEpTT04gIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICBwYXlsb2FkWydzZXJ2aWNlQWNjb3VudEpTT04nXSA9IHNlcnZpY2VBY2NvdW50SlNPTjtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0eXBlb2YgZW5hYmxlZCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHBheWxvYWRbJ2VuYWJsZWQnXSA9IGVuYWJsZWQ7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy5jbGllbnQuY2FsbCgncG9zdCcsIGFwaVBhdGgsIHtcbiAgICAgICAgICAgICdjb250ZW50LXR5cGUnOiAnYXBwbGljYXRpb24vanNvbicsXG4gICAgICAgIH0sIHBheWxvYWQpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFVwZGF0ZSBGQ00gcHJvdmlkZXJcbiAgICAgKlxuICAgICAqIFVwZGF0ZSBhIEZpcmViYXNlIENsb3VkIE1lc3NhZ2luZyBwcm92aWRlciBieSBpdHMgdW5pcXVlIElELlxuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHByb3ZpZGVySWRcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gbmFtZVxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gZW5hYmxlZFxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBzZXJ2aWNlQWNjb3VudEpTT05cbiAgICAgKiBAdGhyb3dzIHtBcHB3cml0ZUV4Y2VwdGlvbn1cbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZX1cbiAgICAgKi9cbiAgICBhc3luYyB1cGRhdGVGY21Qcm92aWRlcihwcm92aWRlcklkLCBuYW1lLCBlbmFibGVkLCBzZXJ2aWNlQWNjb3VudEpTT04pIHtcbiAgICAgICAgY29uc3QgYXBpUGF0aCA9ICcvbWVzc2FnaW5nL3Byb3ZpZGVycy9mY20ve3Byb3ZpZGVySWR9Jy5yZXBsYWNlKCd7cHJvdmlkZXJJZH0nLCBwcm92aWRlcklkKTtcbiAgICAgICAgbGV0IHBheWxvYWQgPSB7fTtcbiAgICAgICAgaWYgKHR5cGVvZiBwcm92aWRlcklkID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEFwcHdyaXRlRXhjZXB0aW9uKCdNaXNzaW5nIHJlcXVpcmVkIHBhcmFtZXRlcjogXCJwcm92aWRlcklkXCInKTtcbiAgICAgICAgfVxuXG5cbiAgICAgICAgaWYgKHR5cGVvZiBuYW1lICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgcGF5bG9hZFsnbmFtZSddID0gbmFtZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0eXBlb2YgZW5hYmxlZCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHBheWxvYWRbJ2VuYWJsZWQnXSA9IGVuYWJsZWQ7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodHlwZW9mIHNlcnZpY2VBY2NvdW50SlNPTiAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHBheWxvYWRbJ3NlcnZpY2VBY2NvdW50SlNPTiddID0gc2VydmljZUFjY291bnRKU09OO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMuY2xpZW50LmNhbGwoJ3BhdGNoJywgYXBpUGF0aCwge1xuICAgICAgICAgICAgJ2NvbnRlbnQtdHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJyxcbiAgICAgICAgfSwgcGF5bG9hZCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlIE1haWxndW4gcHJvdmlkZXJcbiAgICAgKlxuICAgICAqIENyZWF0ZSBhIG5ldyBNYWlsZ3VuIHByb3ZpZGVyLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHByb3ZpZGVySWRcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gbmFtZVxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBhcGlLZXlcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gZG9tYWluXG4gICAgICogQHBhcmFtIHtib29sZWFufSBpc0V1UmVnaW9uXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGZyb21OYW1lXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGZyb21FbWFpbFxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSByZXBseVRvTmFtZVxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSByZXBseVRvRW1haWxcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IGVuYWJsZWRcbiAgICAgKiBAdGhyb3dzIHtBcHB3cml0ZUV4Y2VwdGlvbn1cbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZX1cbiAgICAgKi9cbiAgICBhc3luYyBjcmVhdGVNYWlsZ3VuUHJvdmlkZXIocHJvdmlkZXJJZCwgbmFtZSwgYXBpS2V5LCBkb21haW4sIGlzRXVSZWdpb24sIGZyb21OYW1lLCBmcm9tRW1haWwsIHJlcGx5VG9OYW1lLCByZXBseVRvRW1haWwsIGVuYWJsZWQpIHtcbiAgICAgICAgY29uc3QgYXBpUGF0aCA9ICcvbWVzc2FnaW5nL3Byb3ZpZGVycy9tYWlsZ3VuJztcbiAgICAgICAgbGV0IHBheWxvYWQgPSB7fTtcbiAgICAgICAgaWYgKHR5cGVvZiBwcm92aWRlcklkID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEFwcHdyaXRlRXhjZXB0aW9uKCdNaXNzaW5nIHJlcXVpcmVkIHBhcmFtZXRlcjogXCJwcm92aWRlcklkXCInKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0eXBlb2YgbmFtZSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBBcHB3cml0ZUV4Y2VwdGlvbignTWlzc2luZyByZXF1aXJlZCBwYXJhbWV0ZXI6IFwibmFtZVwiJyk7XG4gICAgICAgIH1cblxuXG4gICAgICAgIGlmICh0eXBlb2YgcHJvdmlkZXJJZCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHBheWxvYWRbJ3Byb3ZpZGVySWQnXSA9IHByb3ZpZGVySWQ7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodHlwZW9mIG5hbWUgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICBwYXlsb2FkWyduYW1lJ10gPSBuYW1lO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHR5cGVvZiBhcGlLZXkgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICBwYXlsb2FkWydhcGlLZXknXSA9IGFwaUtleTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0eXBlb2YgZG9tYWluICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgcGF5bG9hZFsnZG9tYWluJ10gPSBkb21haW47XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodHlwZW9mIGlzRXVSZWdpb24gIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICBwYXlsb2FkWydpc0V1UmVnaW9uJ10gPSBpc0V1UmVnaW9uO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHR5cGVvZiBmcm9tTmFtZSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHBheWxvYWRbJ2Zyb21OYW1lJ10gPSBmcm9tTmFtZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0eXBlb2YgZnJvbUVtYWlsICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgcGF5bG9hZFsnZnJvbUVtYWlsJ10gPSBmcm9tRW1haWw7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodHlwZW9mIHJlcGx5VG9OYW1lICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgcGF5bG9hZFsncmVwbHlUb05hbWUnXSA9IHJlcGx5VG9OYW1lO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHR5cGVvZiByZXBseVRvRW1haWwgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICBwYXlsb2FkWydyZXBseVRvRW1haWwnXSA9IHJlcGx5VG9FbWFpbDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0eXBlb2YgZW5hYmxlZCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHBheWxvYWRbJ2VuYWJsZWQnXSA9IGVuYWJsZWQ7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy5jbGllbnQuY2FsbCgncG9zdCcsIGFwaVBhdGgsIHtcbiAgICAgICAgICAgICdjb250ZW50LXR5cGUnOiAnYXBwbGljYXRpb24vanNvbicsXG4gICAgICAgIH0sIHBheWxvYWQpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFVwZGF0ZSBNYWlsZ3VuIHByb3ZpZGVyXG4gICAgICpcbiAgICAgKiBVcGRhdGUgYSBNYWlsZ3VuIHByb3ZpZGVyIGJ5IGl0cyB1bmlxdWUgSUQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gcHJvdmlkZXJJZFxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGFwaUtleVxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBkb21haW5cbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IGlzRXVSZWdpb25cbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IGVuYWJsZWRcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gZnJvbU5hbWVcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gZnJvbUVtYWlsXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHJlcGx5VG9OYW1lXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHJlcGx5VG9FbWFpbFxuICAgICAqIEB0aHJvd3Mge0FwcHdyaXRlRXhjZXB0aW9ufVxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlfVxuICAgICAqL1xuICAgIGFzeW5jIHVwZGF0ZU1haWxndW5Qcm92aWRlcihwcm92aWRlcklkLCBuYW1lLCBhcGlLZXksIGRvbWFpbiwgaXNFdVJlZ2lvbiwgZW5hYmxlZCwgZnJvbU5hbWUsIGZyb21FbWFpbCwgcmVwbHlUb05hbWUsIHJlcGx5VG9FbWFpbCkge1xuICAgICAgICBjb25zdCBhcGlQYXRoID0gJy9tZXNzYWdpbmcvcHJvdmlkZXJzL21haWxndW4ve3Byb3ZpZGVySWR9Jy5yZXBsYWNlKCd7cHJvdmlkZXJJZH0nLCBwcm92aWRlcklkKTtcbiAgICAgICAgbGV0IHBheWxvYWQgPSB7fTtcbiAgICAgICAgaWYgKHR5cGVvZiBwcm92aWRlcklkID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEFwcHdyaXRlRXhjZXB0aW9uKCdNaXNzaW5nIHJlcXVpcmVkIHBhcmFtZXRlcjogXCJwcm92aWRlcklkXCInKTtcbiAgICAgICAgfVxuXG5cbiAgICAgICAgaWYgKHR5cGVvZiBuYW1lICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgcGF5bG9hZFsnbmFtZSddID0gbmFtZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0eXBlb2YgYXBpS2V5ICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgcGF5bG9hZFsnYXBpS2V5J10gPSBhcGlLZXk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodHlwZW9mIGRvbWFpbiAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHBheWxvYWRbJ2RvbWFpbiddID0gZG9tYWluO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHR5cGVvZiBpc0V1UmVnaW9uICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgcGF5bG9hZFsnaXNFdVJlZ2lvbiddID0gaXNFdVJlZ2lvbjtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0eXBlb2YgZW5hYmxlZCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHBheWxvYWRbJ2VuYWJsZWQnXSA9IGVuYWJsZWQ7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodHlwZW9mIGZyb21OYW1lICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgcGF5bG9hZFsnZnJvbU5hbWUnXSA9IGZyb21OYW1lO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHR5cGVvZiBmcm9tRW1haWwgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICBwYXlsb2FkWydmcm9tRW1haWwnXSA9IGZyb21FbWFpbDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0eXBlb2YgcmVwbHlUb05hbWUgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICBwYXlsb2FkWydyZXBseVRvTmFtZSddID0gcmVwbHlUb05hbWU7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodHlwZW9mIHJlcGx5VG9FbWFpbCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHBheWxvYWRbJ3JlcGx5VG9FbWFpbCddID0gcmVwbHlUb0VtYWlsO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMuY2xpZW50LmNhbGwoJ3BhdGNoJywgYXBpUGF0aCwge1xuICAgICAgICAgICAgJ2NvbnRlbnQtdHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJyxcbiAgICAgICAgfSwgcGF5bG9hZCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlIE1zZzkxIHByb3ZpZGVyXG4gICAgICpcbiAgICAgKiBDcmVhdGUgYSBuZXcgTVNHOTEgcHJvdmlkZXIuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gcHJvdmlkZXJJZFxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHRlbXBsYXRlSWRcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gc2VuZGVySWRcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gYXV0aEtleVxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gZW5hYmxlZFxuICAgICAqIEB0aHJvd3Mge0FwcHdyaXRlRXhjZXB0aW9ufVxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlfVxuICAgICAqL1xuICAgIGFzeW5jIGNyZWF0ZU1zZzkxUHJvdmlkZXIocHJvdmlkZXJJZCwgbmFtZSwgdGVtcGxhdGVJZCwgc2VuZGVySWQsIGF1dGhLZXksIGVuYWJsZWQpIHtcbiAgICAgICAgY29uc3QgYXBpUGF0aCA9ICcvbWVzc2FnaW5nL3Byb3ZpZGVycy9tc2c5MSc7XG4gICAgICAgIGxldCBwYXlsb2FkID0ge307XG4gICAgICAgIGlmICh0eXBlb2YgcHJvdmlkZXJJZCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBBcHB3cml0ZUV4Y2VwdGlvbignTWlzc2luZyByZXF1aXJlZCBwYXJhbWV0ZXI6IFwicHJvdmlkZXJJZFwiJyk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodHlwZW9mIG5hbWUgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgQXBwd3JpdGVFeGNlcHRpb24oJ01pc3NpbmcgcmVxdWlyZWQgcGFyYW1ldGVyOiBcIm5hbWVcIicpO1xuICAgICAgICB9XG5cblxuICAgICAgICBpZiAodHlwZW9mIHByb3ZpZGVySWQgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICBwYXlsb2FkWydwcm92aWRlcklkJ10gPSBwcm92aWRlcklkO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHR5cGVvZiBuYW1lICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgcGF5bG9hZFsnbmFtZSddID0gbmFtZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0eXBlb2YgdGVtcGxhdGVJZCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHBheWxvYWRbJ3RlbXBsYXRlSWQnXSA9IHRlbXBsYXRlSWQ7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodHlwZW9mIHNlbmRlcklkICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgcGF5bG9hZFsnc2VuZGVySWQnXSA9IHNlbmRlcklkO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHR5cGVvZiBhdXRoS2V5ICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgcGF5bG9hZFsnYXV0aEtleSddID0gYXV0aEtleTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0eXBlb2YgZW5hYmxlZCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHBheWxvYWRbJ2VuYWJsZWQnXSA9IGVuYWJsZWQ7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy5jbGllbnQuY2FsbCgncG9zdCcsIGFwaVBhdGgsIHtcbiAgICAgICAgICAgICdjb250ZW50LXR5cGUnOiAnYXBwbGljYXRpb24vanNvbicsXG4gICAgICAgIH0sIHBheWxvYWQpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFVwZGF0ZSBNc2c5MSBwcm92aWRlclxuICAgICAqXG4gICAgICogVXBkYXRlIGEgTVNHOTEgcHJvdmlkZXIgYnkgaXRzIHVuaXF1ZSBJRC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBwcm92aWRlcklkXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IG5hbWVcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IGVuYWJsZWRcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gdGVtcGxhdGVJZFxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBzZW5kZXJJZFxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBhdXRoS2V5XG4gICAgICogQHRocm93cyB7QXBwd3JpdGVFeGNlcHRpb259XG4gICAgICogQHJldHVybnMge1Byb21pc2V9XG4gICAgICovXG4gICAgYXN5bmMgdXBkYXRlTXNnOTFQcm92aWRlcihwcm92aWRlcklkLCBuYW1lLCBlbmFibGVkLCB0ZW1wbGF0ZUlkLCBzZW5kZXJJZCwgYXV0aEtleSkge1xuICAgICAgICBjb25zdCBhcGlQYXRoID0gJy9tZXNzYWdpbmcvcHJvdmlkZXJzL21zZzkxL3twcm92aWRlcklkfScucmVwbGFjZSgne3Byb3ZpZGVySWR9JywgcHJvdmlkZXJJZCk7XG4gICAgICAgIGxldCBwYXlsb2FkID0ge307XG4gICAgICAgIGlmICh0eXBlb2YgcHJvdmlkZXJJZCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBBcHB3cml0ZUV4Y2VwdGlvbignTWlzc2luZyByZXF1aXJlZCBwYXJhbWV0ZXI6IFwicHJvdmlkZXJJZFwiJyk7XG4gICAgICAgIH1cblxuXG4gICAgICAgIGlmICh0eXBlb2YgbmFtZSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHBheWxvYWRbJ25hbWUnXSA9IG5hbWU7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodHlwZW9mIGVuYWJsZWQgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICBwYXlsb2FkWydlbmFibGVkJ10gPSBlbmFibGVkO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHR5cGVvZiB0ZW1wbGF0ZUlkICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgcGF5bG9hZFsndGVtcGxhdGVJZCddID0gdGVtcGxhdGVJZDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0eXBlb2Ygc2VuZGVySWQgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICBwYXlsb2FkWydzZW5kZXJJZCddID0gc2VuZGVySWQ7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodHlwZW9mIGF1dGhLZXkgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICBwYXlsb2FkWydhdXRoS2V5J10gPSBhdXRoS2V5O1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMuY2xpZW50LmNhbGwoJ3BhdGNoJywgYXBpUGF0aCwge1xuICAgICAgICAgICAgJ2NvbnRlbnQtdHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJyxcbiAgICAgICAgfSwgcGF5bG9hZCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlIFNlbmRncmlkIHByb3ZpZGVyXG4gICAgICpcbiAgICAgKiBDcmVhdGUgYSBuZXcgU2VuZGdyaWQgcHJvdmlkZXIuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gcHJvdmlkZXJJZFxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGFwaUtleVxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBmcm9tTmFtZVxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBmcm9tRW1haWxcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gcmVwbHlUb05hbWVcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gcmVwbHlUb0VtYWlsXG4gICAgICogQHBhcmFtIHtib29sZWFufSBlbmFibGVkXG4gICAgICogQHRocm93cyB7QXBwd3JpdGVFeGNlcHRpb259XG4gICAgICogQHJldHVybnMge1Byb21pc2V9XG4gICAgICovXG4gICAgYXN5bmMgY3JlYXRlU2VuZGdyaWRQcm92aWRlcihwcm92aWRlcklkLCBuYW1lLCBhcGlLZXksIGZyb21OYW1lLCBmcm9tRW1haWwsIHJlcGx5VG9OYW1lLCByZXBseVRvRW1haWwsIGVuYWJsZWQpIHtcbiAgICAgICAgY29uc3QgYXBpUGF0aCA9ICcvbWVzc2FnaW5nL3Byb3ZpZGVycy9zZW5kZ3JpZCc7XG4gICAgICAgIGxldCBwYXlsb2FkID0ge307XG4gICAgICAgIGlmICh0eXBlb2YgcHJvdmlkZXJJZCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBBcHB3cml0ZUV4Y2VwdGlvbignTWlzc2luZyByZXF1aXJlZCBwYXJhbWV0ZXI6IFwicHJvdmlkZXJJZFwiJyk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodHlwZW9mIG5hbWUgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgQXBwd3JpdGVFeGNlcHRpb24oJ01pc3NpbmcgcmVxdWlyZWQgcGFyYW1ldGVyOiBcIm5hbWVcIicpO1xuICAgICAgICB9XG5cblxuICAgICAgICBpZiAodHlwZW9mIHByb3ZpZGVySWQgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICBwYXlsb2FkWydwcm92aWRlcklkJ10gPSBwcm92aWRlcklkO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHR5cGVvZiBuYW1lICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgcGF5bG9hZFsnbmFtZSddID0gbmFtZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0eXBlb2YgYXBpS2V5ICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgcGF5bG9hZFsnYXBpS2V5J10gPSBhcGlLZXk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodHlwZW9mIGZyb21OYW1lICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgcGF5bG9hZFsnZnJvbU5hbWUnXSA9IGZyb21OYW1lO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHR5cGVvZiBmcm9tRW1haWwgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICBwYXlsb2FkWydmcm9tRW1haWwnXSA9IGZyb21FbWFpbDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0eXBlb2YgcmVwbHlUb05hbWUgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICBwYXlsb2FkWydyZXBseVRvTmFtZSddID0gcmVwbHlUb05hbWU7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodHlwZW9mIHJlcGx5VG9FbWFpbCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHBheWxvYWRbJ3JlcGx5VG9FbWFpbCddID0gcmVwbHlUb0VtYWlsO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHR5cGVvZiBlbmFibGVkICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgcGF5bG9hZFsnZW5hYmxlZCddID0gZW5hYmxlZDtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBhd2FpdCB0aGlzLmNsaWVudC5jYWxsKCdwb3N0JywgYXBpUGF0aCwge1xuICAgICAgICAgICAgJ2NvbnRlbnQtdHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJyxcbiAgICAgICAgfSwgcGF5bG9hZCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVXBkYXRlIFNlbmRncmlkIHByb3ZpZGVyXG4gICAgICpcbiAgICAgKiBVcGRhdGUgYSBTZW5kZ3JpZCBwcm92aWRlciBieSBpdHMgdW5pcXVlIElELlxuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHByb3ZpZGVySWRcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gbmFtZVxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gZW5hYmxlZFxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBhcGlLZXlcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gZnJvbU5hbWVcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gZnJvbUVtYWlsXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHJlcGx5VG9OYW1lXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHJlcGx5VG9FbWFpbFxuICAgICAqIEB0aHJvd3Mge0FwcHdyaXRlRXhjZXB0aW9ufVxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlfVxuICAgICAqL1xuICAgIGFzeW5jIHVwZGF0ZVNlbmRncmlkUHJvdmlkZXIocHJvdmlkZXJJZCwgbmFtZSwgZW5hYmxlZCwgYXBpS2V5LCBmcm9tTmFtZSwgZnJvbUVtYWlsLCByZXBseVRvTmFtZSwgcmVwbHlUb0VtYWlsKSB7XG4gICAgICAgIGNvbnN0IGFwaVBhdGggPSAnL21lc3NhZ2luZy9wcm92aWRlcnMvc2VuZGdyaWQve3Byb3ZpZGVySWR9Jy5yZXBsYWNlKCd7cHJvdmlkZXJJZH0nLCBwcm92aWRlcklkKTtcbiAgICAgICAgbGV0IHBheWxvYWQgPSB7fTtcbiAgICAgICAgaWYgKHR5cGVvZiBwcm92aWRlcklkID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEFwcHdyaXRlRXhjZXB0aW9uKCdNaXNzaW5nIHJlcXVpcmVkIHBhcmFtZXRlcjogXCJwcm92aWRlcklkXCInKTtcbiAgICAgICAgfVxuXG5cbiAgICAgICAgaWYgKHR5cGVvZiBuYW1lICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgcGF5bG9hZFsnbmFtZSddID0gbmFtZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0eXBlb2YgZW5hYmxlZCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHBheWxvYWRbJ2VuYWJsZWQnXSA9IGVuYWJsZWQ7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodHlwZW9mIGFwaUtleSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHBheWxvYWRbJ2FwaUtleSddID0gYXBpS2V5O1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHR5cGVvZiBmcm9tTmFtZSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHBheWxvYWRbJ2Zyb21OYW1lJ10gPSBmcm9tTmFtZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0eXBlb2YgZnJvbUVtYWlsICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgcGF5bG9hZFsnZnJvbUVtYWlsJ10gPSBmcm9tRW1haWw7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodHlwZW9mIHJlcGx5VG9OYW1lICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgcGF5bG9hZFsncmVwbHlUb05hbWUnXSA9IHJlcGx5VG9OYW1lO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHR5cGVvZiByZXBseVRvRW1haWwgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICBwYXlsb2FkWydyZXBseVRvRW1haWwnXSA9IHJlcGx5VG9FbWFpbDtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBhd2FpdCB0aGlzLmNsaWVudC5jYWxsKCdwYXRjaCcsIGFwaVBhdGgsIHtcbiAgICAgICAgICAgICdjb250ZW50LXR5cGUnOiAnYXBwbGljYXRpb24vanNvbicsXG4gICAgICAgIH0sIHBheWxvYWQpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZSBTTVRQIHByb3ZpZGVyXG4gICAgICpcbiAgICAgKiBDcmVhdGUgYSBuZXcgU01UUCBwcm92aWRlci5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBwcm92aWRlcklkXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IG5hbWVcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gaG9zdFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBwb3J0XG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHVzZXJuYW1lXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHBhc3N3b3JkXG4gICAgICogQHBhcmFtIHtTbXRwRW5jcnlwdGlvbn0gZW5jcnlwdGlvblxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gYXV0b1RMU1xuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBtYWlsZXJcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gZnJvbU5hbWVcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gZnJvbUVtYWlsXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHJlcGx5VG9OYW1lXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHJlcGx5VG9FbWFpbFxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gZW5hYmxlZFxuICAgICAqIEB0aHJvd3Mge0FwcHdyaXRlRXhjZXB0aW9ufVxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlfVxuICAgICAqL1xuICAgIGFzeW5jIGNyZWF0ZVNtdHBQcm92aWRlcihwcm92aWRlcklkLCBuYW1lLCBob3N0LCBwb3J0LCB1c2VybmFtZSwgcGFzc3dvcmQsIGVuY3J5cHRpb24sIGF1dG9UTFMsIG1haWxlciwgZnJvbU5hbWUsIGZyb21FbWFpbCwgcmVwbHlUb05hbWUsIHJlcGx5VG9FbWFpbCwgZW5hYmxlZCkge1xuICAgICAgICBjb25zdCBhcGlQYXRoID0gJy9tZXNzYWdpbmcvcHJvdmlkZXJzL3NtdHAnO1xuICAgICAgICBsZXQgcGF5bG9hZCA9IHt9O1xuICAgICAgICBpZiAodHlwZW9mIHByb3ZpZGVySWQgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgQXBwd3JpdGVFeGNlcHRpb24oJ01pc3NpbmcgcmVxdWlyZWQgcGFyYW1ldGVyOiBcInByb3ZpZGVySWRcIicpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHR5cGVvZiBuYW1lID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEFwcHdyaXRlRXhjZXB0aW9uKCdNaXNzaW5nIHJlcXVpcmVkIHBhcmFtZXRlcjogXCJuYW1lXCInKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0eXBlb2YgaG9zdCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBBcHB3cml0ZUV4Y2VwdGlvbignTWlzc2luZyByZXF1aXJlZCBwYXJhbWV0ZXI6IFwiaG9zdFwiJyk7XG4gICAgICAgIH1cblxuXG4gICAgICAgIGlmICh0eXBlb2YgcHJvdmlkZXJJZCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHBheWxvYWRbJ3Byb3ZpZGVySWQnXSA9IHByb3ZpZGVySWQ7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodHlwZW9mIG5hbWUgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICBwYXlsb2FkWyduYW1lJ10gPSBuYW1lO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHR5cGVvZiBob3N0ICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgcGF5bG9hZFsnaG9zdCddID0gaG9zdDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0eXBlb2YgcG9ydCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHBheWxvYWRbJ3BvcnQnXSA9IHBvcnQ7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodHlwZW9mIHVzZXJuYW1lICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgcGF5bG9hZFsndXNlcm5hbWUnXSA9IHVzZXJuYW1lO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHR5cGVvZiBwYXNzd29yZCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHBheWxvYWRbJ3Bhc3N3b3JkJ10gPSBwYXNzd29yZDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0eXBlb2YgZW5jcnlwdGlvbiAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHBheWxvYWRbJ2VuY3J5cHRpb24nXSA9IGVuY3J5cHRpb247XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodHlwZW9mIGF1dG9UTFMgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICBwYXlsb2FkWydhdXRvVExTJ10gPSBhdXRvVExTO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHR5cGVvZiBtYWlsZXIgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICBwYXlsb2FkWydtYWlsZXInXSA9IG1haWxlcjtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0eXBlb2YgZnJvbU5hbWUgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICBwYXlsb2FkWydmcm9tTmFtZSddID0gZnJvbU5hbWU7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodHlwZW9mIGZyb21FbWFpbCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHBheWxvYWRbJ2Zyb21FbWFpbCddID0gZnJvbUVtYWlsO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHR5cGVvZiByZXBseVRvTmFtZSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHBheWxvYWRbJ3JlcGx5VG9OYW1lJ10gPSByZXBseVRvTmFtZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0eXBlb2YgcmVwbHlUb0VtYWlsICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgcGF5bG9hZFsncmVwbHlUb0VtYWlsJ10gPSByZXBseVRvRW1haWw7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodHlwZW9mIGVuYWJsZWQgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICBwYXlsb2FkWydlbmFibGVkJ10gPSBlbmFibGVkO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMuY2xpZW50LmNhbGwoJ3Bvc3QnLCBhcGlQYXRoLCB7XG4gICAgICAgICAgICAnY29udGVudC10eXBlJzogJ2FwcGxpY2F0aW9uL2pzb24nLFxuICAgICAgICB9LCBwYXlsb2FkKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBVcGRhdGUgU01UUCBwcm92aWRlclxuICAgICAqXG4gICAgICogVXBkYXRlIGEgU01UUCBwcm92aWRlciBieSBpdHMgdW5pcXVlIElELlxuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHByb3ZpZGVySWRcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gbmFtZVxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBob3N0XG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHBvcnRcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gdXNlcm5hbWVcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gcGFzc3dvcmRcbiAgICAgKiBAcGFyYW0ge1NtdHBFbmNyeXB0aW9ufSBlbmNyeXB0aW9uXG4gICAgICogQHBhcmFtIHtib29sZWFufSBhdXRvVExTXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IG1haWxlclxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBmcm9tTmFtZVxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBmcm9tRW1haWxcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gcmVwbHlUb05hbWVcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gcmVwbHlUb0VtYWlsXG4gICAgICogQHBhcmFtIHtib29sZWFufSBlbmFibGVkXG4gICAgICogQHRocm93cyB7QXBwd3JpdGVFeGNlcHRpb259XG4gICAgICogQHJldHVybnMge1Byb21pc2V9XG4gICAgICovXG4gICAgYXN5bmMgdXBkYXRlU210cFByb3ZpZGVyKHByb3ZpZGVySWQsIG5hbWUsIGhvc3QsIHBvcnQsIHVzZXJuYW1lLCBwYXNzd29yZCwgZW5jcnlwdGlvbiwgYXV0b1RMUywgbWFpbGVyLCBmcm9tTmFtZSwgZnJvbUVtYWlsLCByZXBseVRvTmFtZSwgcmVwbHlUb0VtYWlsLCBlbmFibGVkKSB7XG4gICAgICAgIGNvbnN0IGFwaVBhdGggPSAnL21lc3NhZ2luZy9wcm92aWRlcnMvc210cC97cHJvdmlkZXJJZH0nLnJlcGxhY2UoJ3twcm92aWRlcklkfScsIHByb3ZpZGVySWQpO1xuICAgICAgICBsZXQgcGF5bG9hZCA9IHt9O1xuICAgICAgICBpZiAodHlwZW9mIHByb3ZpZGVySWQgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgQXBwd3JpdGVFeGNlcHRpb24oJ01pc3NpbmcgcmVxdWlyZWQgcGFyYW1ldGVyOiBcInByb3ZpZGVySWRcIicpO1xuICAgICAgICB9XG5cblxuICAgICAgICBpZiAodHlwZW9mIG5hbWUgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICBwYXlsb2FkWyduYW1lJ10gPSBuYW1lO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHR5cGVvZiBob3N0ICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgcGF5bG9hZFsnaG9zdCddID0gaG9zdDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0eXBlb2YgcG9ydCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHBheWxvYWRbJ3BvcnQnXSA9IHBvcnQ7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodHlwZW9mIHVzZXJuYW1lICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgcGF5bG9hZFsndXNlcm5hbWUnXSA9IHVzZXJuYW1lO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHR5cGVvZiBwYXNzd29yZCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHBheWxvYWRbJ3Bhc3N3b3JkJ10gPSBwYXNzd29yZDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0eXBlb2YgZW5jcnlwdGlvbiAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHBheWxvYWRbJ2VuY3J5cHRpb24nXSA9IGVuY3J5cHRpb247XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodHlwZW9mIGF1dG9UTFMgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICBwYXlsb2FkWydhdXRvVExTJ10gPSBhdXRvVExTO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHR5cGVvZiBtYWlsZXIgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICBwYXlsb2FkWydtYWlsZXInXSA9IG1haWxlcjtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0eXBlb2YgZnJvbU5hbWUgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICBwYXlsb2FkWydmcm9tTmFtZSddID0gZnJvbU5hbWU7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodHlwZW9mIGZyb21FbWFpbCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHBheWxvYWRbJ2Zyb21FbWFpbCddID0gZnJvbUVtYWlsO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHR5cGVvZiByZXBseVRvTmFtZSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHBheWxvYWRbJ3JlcGx5VG9OYW1lJ10gPSByZXBseVRvTmFtZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0eXBlb2YgcmVwbHlUb0VtYWlsICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgcGF5bG9hZFsncmVwbHlUb0VtYWlsJ10gPSByZXBseVRvRW1haWw7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodHlwZW9mIGVuYWJsZWQgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICBwYXlsb2FkWydlbmFibGVkJ10gPSBlbmFibGVkO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMuY2xpZW50LmNhbGwoJ3BhdGNoJywgYXBpUGF0aCwge1xuICAgICAgICAgICAgJ2NvbnRlbnQtdHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJyxcbiAgICAgICAgfSwgcGF5bG9hZCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlIFRlbGVzaWduIHByb3ZpZGVyXG4gICAgICpcbiAgICAgKiBDcmVhdGUgYSBuZXcgVGVsZXNpZ24gcHJvdmlkZXIuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gcHJvdmlkZXJJZFxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGZyb21cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gY3VzdG9tZXJJZFxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBhcGlLZXlcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IGVuYWJsZWRcbiAgICAgKiBAdGhyb3dzIHtBcHB3cml0ZUV4Y2VwdGlvbn1cbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZX1cbiAgICAgKi9cbiAgICBhc3luYyBjcmVhdGVUZWxlc2lnblByb3ZpZGVyKHByb3ZpZGVySWQsIG5hbWUsIGZyb20sIGN1c3RvbWVySWQsIGFwaUtleSwgZW5hYmxlZCkge1xuICAgICAgICBjb25zdCBhcGlQYXRoID0gJy9tZXNzYWdpbmcvcHJvdmlkZXJzL3RlbGVzaWduJztcbiAgICAgICAgbGV0IHBheWxvYWQgPSB7fTtcbiAgICAgICAgaWYgKHR5cGVvZiBwcm92aWRlcklkID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEFwcHdyaXRlRXhjZXB0aW9uKCdNaXNzaW5nIHJlcXVpcmVkIHBhcmFtZXRlcjogXCJwcm92aWRlcklkXCInKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0eXBlb2YgbmFtZSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBBcHB3cml0ZUV4Y2VwdGlvbignTWlzc2luZyByZXF1aXJlZCBwYXJhbWV0ZXI6IFwibmFtZVwiJyk7XG4gICAgICAgIH1cblxuXG4gICAgICAgIGlmICh0eXBlb2YgcHJvdmlkZXJJZCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHBheWxvYWRbJ3Byb3ZpZGVySWQnXSA9IHByb3ZpZGVySWQ7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodHlwZW9mIG5hbWUgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICBwYXlsb2FkWyduYW1lJ10gPSBuYW1lO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHR5cGVvZiBmcm9tICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgcGF5bG9hZFsnZnJvbSddID0gZnJvbTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0eXBlb2YgY3VzdG9tZXJJZCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHBheWxvYWRbJ2N1c3RvbWVySWQnXSA9IGN1c3RvbWVySWQ7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodHlwZW9mIGFwaUtleSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHBheWxvYWRbJ2FwaUtleSddID0gYXBpS2V5O1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHR5cGVvZiBlbmFibGVkICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgcGF5bG9hZFsnZW5hYmxlZCddID0gZW5hYmxlZDtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBhd2FpdCB0aGlzLmNsaWVudC5jYWxsKCdwb3N0JywgYXBpUGF0aCwge1xuICAgICAgICAgICAgJ2NvbnRlbnQtdHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJyxcbiAgICAgICAgfSwgcGF5bG9hZCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVXBkYXRlIFRlbGVzaWduIHByb3ZpZGVyXG4gICAgICpcbiAgICAgKiBVcGRhdGUgYSBUZWxlc2lnbiBwcm92aWRlciBieSBpdHMgdW5pcXVlIElELlxuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHByb3ZpZGVySWRcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gbmFtZVxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gZW5hYmxlZFxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBjdXN0b21lcklkXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGFwaUtleVxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBmcm9tXG4gICAgICogQHRocm93cyB7QXBwd3JpdGVFeGNlcHRpb259XG4gICAgICogQHJldHVybnMge1Byb21pc2V9XG4gICAgICovXG4gICAgYXN5bmMgdXBkYXRlVGVsZXNpZ25Qcm92aWRlcihwcm92aWRlcklkLCBuYW1lLCBlbmFibGVkLCBjdXN0b21lcklkLCBhcGlLZXksIGZyb20pIHtcbiAgICAgICAgY29uc3QgYXBpUGF0aCA9ICcvbWVzc2FnaW5nL3Byb3ZpZGVycy90ZWxlc2lnbi97cHJvdmlkZXJJZH0nLnJlcGxhY2UoJ3twcm92aWRlcklkfScsIHByb3ZpZGVySWQpO1xuICAgICAgICBsZXQgcGF5bG9hZCA9IHt9O1xuICAgICAgICBpZiAodHlwZW9mIHByb3ZpZGVySWQgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgQXBwd3JpdGVFeGNlcHRpb24oJ01pc3NpbmcgcmVxdWlyZWQgcGFyYW1ldGVyOiBcInByb3ZpZGVySWRcIicpO1xuICAgICAgICB9XG5cblxuICAgICAgICBpZiAodHlwZW9mIG5hbWUgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICBwYXlsb2FkWyduYW1lJ10gPSBuYW1lO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHR5cGVvZiBlbmFibGVkICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgcGF5bG9hZFsnZW5hYmxlZCddID0gZW5hYmxlZDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0eXBlb2YgY3VzdG9tZXJJZCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHBheWxvYWRbJ2N1c3RvbWVySWQnXSA9IGN1c3RvbWVySWQ7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodHlwZW9mIGFwaUtleSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHBheWxvYWRbJ2FwaUtleSddID0gYXBpS2V5O1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHR5cGVvZiBmcm9tICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgcGF5bG9hZFsnZnJvbSddID0gZnJvbTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBhd2FpdCB0aGlzLmNsaWVudC5jYWxsKCdwYXRjaCcsIGFwaVBhdGgsIHtcbiAgICAgICAgICAgICdjb250ZW50LXR5cGUnOiAnYXBwbGljYXRpb24vanNvbicsXG4gICAgICAgIH0sIHBheWxvYWQpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZSBUZXh0bWFnaWMgcHJvdmlkZXJcbiAgICAgKlxuICAgICAqIENyZWF0ZSBhIG5ldyBUZXh0bWFnaWMgcHJvdmlkZXIuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gcHJvdmlkZXJJZFxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGZyb21cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gdXNlcm5hbWVcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gYXBpS2V5XG4gICAgICogQHBhcmFtIHtib29sZWFufSBlbmFibGVkXG4gICAgICogQHRocm93cyB7QXBwd3JpdGVFeGNlcHRpb259XG4gICAgICogQHJldHVybnMge1Byb21pc2V9XG4gICAgICovXG4gICAgYXN5bmMgY3JlYXRlVGV4dG1hZ2ljUHJvdmlkZXIocHJvdmlkZXJJZCwgbmFtZSwgZnJvbSwgdXNlcm5hbWUsIGFwaUtleSwgZW5hYmxlZCkge1xuICAgICAgICBjb25zdCBhcGlQYXRoID0gJy9tZXNzYWdpbmcvcHJvdmlkZXJzL3RleHRtYWdpYyc7XG4gICAgICAgIGxldCBwYXlsb2FkID0ge307XG4gICAgICAgIGlmICh0eXBlb2YgcHJvdmlkZXJJZCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBBcHB3cml0ZUV4Y2VwdGlvbignTWlzc2luZyByZXF1aXJlZCBwYXJhbWV0ZXI6IFwicHJvdmlkZXJJZFwiJyk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodHlwZW9mIG5hbWUgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgQXBwd3JpdGVFeGNlcHRpb24oJ01pc3NpbmcgcmVxdWlyZWQgcGFyYW1ldGVyOiBcIm5hbWVcIicpO1xuICAgICAgICB9XG5cblxuICAgICAgICBpZiAodHlwZW9mIHByb3ZpZGVySWQgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICBwYXlsb2FkWydwcm92aWRlcklkJ10gPSBwcm92aWRlcklkO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHR5cGVvZiBuYW1lICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgcGF5bG9hZFsnbmFtZSddID0gbmFtZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0eXBlb2YgZnJvbSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHBheWxvYWRbJ2Zyb20nXSA9IGZyb207XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodHlwZW9mIHVzZXJuYW1lICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgcGF5bG9hZFsndXNlcm5hbWUnXSA9IHVzZXJuYW1lO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHR5cGVvZiBhcGlLZXkgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICBwYXlsb2FkWydhcGlLZXknXSA9IGFwaUtleTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0eXBlb2YgZW5hYmxlZCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHBheWxvYWRbJ2VuYWJsZWQnXSA9IGVuYWJsZWQ7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy5jbGllbnQuY2FsbCgncG9zdCcsIGFwaVBhdGgsIHtcbiAgICAgICAgICAgICdjb250ZW50LXR5cGUnOiAnYXBwbGljYXRpb24vanNvbicsXG4gICAgICAgIH0sIHBheWxvYWQpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFVwZGF0ZSBUZXh0bWFnaWMgcHJvdmlkZXJcbiAgICAgKlxuICAgICAqIFVwZGF0ZSBhIFRleHRtYWdpYyBwcm92aWRlciBieSBpdHMgdW5pcXVlIElELlxuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHByb3ZpZGVySWRcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gbmFtZVxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gZW5hYmxlZFxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSB1c2VybmFtZVxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBhcGlLZXlcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gZnJvbVxuICAgICAqIEB0aHJvd3Mge0FwcHdyaXRlRXhjZXB0aW9ufVxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlfVxuICAgICAqL1xuICAgIGFzeW5jIHVwZGF0ZVRleHRtYWdpY1Byb3ZpZGVyKHByb3ZpZGVySWQsIG5hbWUsIGVuYWJsZWQsIHVzZXJuYW1lLCBhcGlLZXksIGZyb20pIHtcbiAgICAgICAgY29uc3QgYXBpUGF0aCA9ICcvbWVzc2FnaW5nL3Byb3ZpZGVycy90ZXh0bWFnaWMve3Byb3ZpZGVySWR9Jy5yZXBsYWNlKCd7cHJvdmlkZXJJZH0nLCBwcm92aWRlcklkKTtcbiAgICAgICAgbGV0IHBheWxvYWQgPSB7fTtcbiAgICAgICAgaWYgKHR5cGVvZiBwcm92aWRlcklkID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEFwcHdyaXRlRXhjZXB0aW9uKCdNaXNzaW5nIHJlcXVpcmVkIHBhcmFtZXRlcjogXCJwcm92aWRlcklkXCInKTtcbiAgICAgICAgfVxuXG5cbiAgICAgICAgaWYgKHR5cGVvZiBuYW1lICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgcGF5bG9hZFsnbmFtZSddID0gbmFtZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0eXBlb2YgZW5hYmxlZCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHBheWxvYWRbJ2VuYWJsZWQnXSA9IGVuYWJsZWQ7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodHlwZW9mIHVzZXJuYW1lICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgcGF5bG9hZFsndXNlcm5hbWUnXSA9IHVzZXJuYW1lO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHR5cGVvZiBhcGlLZXkgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICBwYXlsb2FkWydhcGlLZXknXSA9IGFwaUtleTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0eXBlb2YgZnJvbSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHBheWxvYWRbJ2Zyb20nXSA9IGZyb207XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy5jbGllbnQuY2FsbCgncGF0Y2gnLCBhcGlQYXRoLCB7XG4gICAgICAgICAgICAnY29udGVudC10eXBlJzogJ2FwcGxpY2F0aW9uL2pzb24nLFxuICAgICAgICB9LCBwYXlsb2FkKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGUgVHdpbGlvIHByb3ZpZGVyXG4gICAgICpcbiAgICAgKiBDcmVhdGUgYSBuZXcgVHdpbGlvIHByb3ZpZGVyLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHByb3ZpZGVySWRcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gbmFtZVxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBmcm9tXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGFjY291bnRTaWRcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gYXV0aFRva2VuXG4gICAgICogQHBhcmFtIHtib29sZWFufSBlbmFibGVkXG4gICAgICogQHRocm93cyB7QXBwd3JpdGVFeGNlcHRpb259XG4gICAgICogQHJldHVybnMge1Byb21pc2V9XG4gICAgICovXG4gICAgYXN5bmMgY3JlYXRlVHdpbGlvUHJvdmlkZXIocHJvdmlkZXJJZCwgbmFtZSwgZnJvbSwgYWNjb3VudFNpZCwgYXV0aFRva2VuLCBlbmFibGVkKSB7XG4gICAgICAgIGNvbnN0IGFwaVBhdGggPSAnL21lc3NhZ2luZy9wcm92aWRlcnMvdHdpbGlvJztcbiAgICAgICAgbGV0IHBheWxvYWQgPSB7fTtcbiAgICAgICAgaWYgKHR5cGVvZiBwcm92aWRlcklkID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEFwcHdyaXRlRXhjZXB0aW9uKCdNaXNzaW5nIHJlcXVpcmVkIHBhcmFtZXRlcjogXCJwcm92aWRlcklkXCInKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0eXBlb2YgbmFtZSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBBcHB3cml0ZUV4Y2VwdGlvbignTWlzc2luZyByZXF1aXJlZCBwYXJhbWV0ZXI6IFwibmFtZVwiJyk7XG4gICAgICAgIH1cblxuXG4gICAgICAgIGlmICh0eXBlb2YgcHJvdmlkZXJJZCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHBheWxvYWRbJ3Byb3ZpZGVySWQnXSA9IHByb3ZpZGVySWQ7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodHlwZW9mIG5hbWUgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICBwYXlsb2FkWyduYW1lJ10gPSBuYW1lO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHR5cGVvZiBmcm9tICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgcGF5bG9hZFsnZnJvbSddID0gZnJvbTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0eXBlb2YgYWNjb3VudFNpZCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHBheWxvYWRbJ2FjY291bnRTaWQnXSA9IGFjY291bnRTaWQ7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodHlwZW9mIGF1dGhUb2tlbiAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHBheWxvYWRbJ2F1dGhUb2tlbiddID0gYXV0aFRva2VuO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHR5cGVvZiBlbmFibGVkICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgcGF5bG9hZFsnZW5hYmxlZCddID0gZW5hYmxlZDtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBhd2FpdCB0aGlzLmNsaWVudC5jYWxsKCdwb3N0JywgYXBpUGF0aCwge1xuICAgICAgICAgICAgJ2NvbnRlbnQtdHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJyxcbiAgICAgICAgfSwgcGF5bG9hZCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVXBkYXRlIFR3aWxpbyBwcm92aWRlclxuICAgICAqXG4gICAgICogVXBkYXRlIGEgVHdpbGlvIHByb3ZpZGVyIGJ5IGl0cyB1bmlxdWUgSUQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gcHJvdmlkZXJJZFxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lXG4gICAgICogQHBhcmFtIHtib29sZWFufSBlbmFibGVkXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGFjY291bnRTaWRcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gYXV0aFRva2VuXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGZyb21cbiAgICAgKiBAdGhyb3dzIHtBcHB3cml0ZUV4Y2VwdGlvbn1cbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZX1cbiAgICAgKi9cbiAgICBhc3luYyB1cGRhdGVUd2lsaW9Qcm92aWRlcihwcm92aWRlcklkLCBuYW1lLCBlbmFibGVkLCBhY2NvdW50U2lkLCBhdXRoVG9rZW4sIGZyb20pIHtcbiAgICAgICAgY29uc3QgYXBpUGF0aCA9ICcvbWVzc2FnaW5nL3Byb3ZpZGVycy90d2lsaW8ve3Byb3ZpZGVySWR9Jy5yZXBsYWNlKCd7cHJvdmlkZXJJZH0nLCBwcm92aWRlcklkKTtcbiAgICAgICAgbGV0IHBheWxvYWQgPSB7fTtcbiAgICAgICAgaWYgKHR5cGVvZiBwcm92aWRlcklkID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEFwcHdyaXRlRXhjZXB0aW9uKCdNaXNzaW5nIHJlcXVpcmVkIHBhcmFtZXRlcjogXCJwcm92aWRlcklkXCInKTtcbiAgICAgICAgfVxuXG5cbiAgICAgICAgaWYgKHR5cGVvZiBuYW1lICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgcGF5bG9hZFsnbmFtZSddID0gbmFtZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0eXBlb2YgZW5hYmxlZCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHBheWxvYWRbJ2VuYWJsZWQnXSA9IGVuYWJsZWQ7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodHlwZW9mIGFjY291bnRTaWQgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICBwYXlsb2FkWydhY2NvdW50U2lkJ10gPSBhY2NvdW50U2lkO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHR5cGVvZiBhdXRoVG9rZW4gIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICBwYXlsb2FkWydhdXRoVG9rZW4nXSA9IGF1dGhUb2tlbjtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0eXBlb2YgZnJvbSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHBheWxvYWRbJ2Zyb20nXSA9IGZyb207XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy5jbGllbnQuY2FsbCgncGF0Y2gnLCBhcGlQYXRoLCB7XG4gICAgICAgICAgICAnY29udGVudC10eXBlJzogJ2FwcGxpY2F0aW9uL2pzb24nLFxuICAgICAgICB9LCBwYXlsb2FkKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGUgVm9uYWdlIHByb3ZpZGVyXG4gICAgICpcbiAgICAgKiBDcmVhdGUgYSBuZXcgVm9uYWdlIHByb3ZpZGVyLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHByb3ZpZGVySWRcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gbmFtZVxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBmcm9tXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGFwaUtleVxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBhcGlTZWNyZXRcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IGVuYWJsZWRcbiAgICAgKiBAdGhyb3dzIHtBcHB3cml0ZUV4Y2VwdGlvbn1cbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZX1cbiAgICAgKi9cbiAgICBhc3luYyBjcmVhdGVWb25hZ2VQcm92aWRlcihwcm92aWRlcklkLCBuYW1lLCBmcm9tLCBhcGlLZXksIGFwaVNlY3JldCwgZW5hYmxlZCkge1xuICAgICAgICBjb25zdCBhcGlQYXRoID0gJy9tZXNzYWdpbmcvcHJvdmlkZXJzL3ZvbmFnZSc7XG4gICAgICAgIGxldCBwYXlsb2FkID0ge307XG4gICAgICAgIGlmICh0eXBlb2YgcHJvdmlkZXJJZCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBBcHB3cml0ZUV4Y2VwdGlvbignTWlzc2luZyByZXF1aXJlZCBwYXJhbWV0ZXI6IFwicHJvdmlkZXJJZFwiJyk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodHlwZW9mIG5hbWUgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgQXBwd3JpdGVFeGNlcHRpb24oJ01pc3NpbmcgcmVxdWlyZWQgcGFyYW1ldGVyOiBcIm5hbWVcIicpO1xuICAgICAgICB9XG5cblxuICAgICAgICBpZiAodHlwZW9mIHByb3ZpZGVySWQgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICBwYXlsb2FkWydwcm92aWRlcklkJ10gPSBwcm92aWRlcklkO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHR5cGVvZiBuYW1lICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgcGF5bG9hZFsnbmFtZSddID0gbmFtZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0eXBlb2YgZnJvbSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHBheWxvYWRbJ2Zyb20nXSA9IGZyb207XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodHlwZW9mIGFwaUtleSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHBheWxvYWRbJ2FwaUtleSddID0gYXBpS2V5O1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHR5cGVvZiBhcGlTZWNyZXQgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICBwYXlsb2FkWydhcGlTZWNyZXQnXSA9IGFwaVNlY3JldDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0eXBlb2YgZW5hYmxlZCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHBheWxvYWRbJ2VuYWJsZWQnXSA9IGVuYWJsZWQ7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy5jbGllbnQuY2FsbCgncG9zdCcsIGFwaVBhdGgsIHtcbiAgICAgICAgICAgICdjb250ZW50LXR5cGUnOiAnYXBwbGljYXRpb24vanNvbicsXG4gICAgICAgIH0sIHBheWxvYWQpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFVwZGF0ZSBWb25hZ2UgcHJvdmlkZXJcbiAgICAgKlxuICAgICAqIFVwZGF0ZSBhIFZvbmFnZSBwcm92aWRlciBieSBpdHMgdW5pcXVlIElELlxuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHByb3ZpZGVySWRcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gbmFtZVxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gZW5hYmxlZFxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBhcGlLZXlcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gYXBpU2VjcmV0XG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGZyb21cbiAgICAgKiBAdGhyb3dzIHtBcHB3cml0ZUV4Y2VwdGlvbn1cbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZX1cbiAgICAgKi9cbiAgICBhc3luYyB1cGRhdGVWb25hZ2VQcm92aWRlcihwcm92aWRlcklkLCBuYW1lLCBlbmFibGVkLCBhcGlLZXksIGFwaVNlY3JldCwgZnJvbSkge1xuICAgICAgICBjb25zdCBhcGlQYXRoID0gJy9tZXNzYWdpbmcvcHJvdmlkZXJzL3ZvbmFnZS97cHJvdmlkZXJJZH0nLnJlcGxhY2UoJ3twcm92aWRlcklkfScsIHByb3ZpZGVySWQpO1xuICAgICAgICBsZXQgcGF5bG9hZCA9IHt9O1xuICAgICAgICBpZiAodHlwZW9mIHByb3ZpZGVySWQgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgQXBwd3JpdGVFeGNlcHRpb24oJ01pc3NpbmcgcmVxdWlyZWQgcGFyYW1ldGVyOiBcInByb3ZpZGVySWRcIicpO1xuICAgICAgICB9XG5cblxuICAgICAgICBpZiAodHlwZW9mIG5hbWUgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICBwYXlsb2FkWyduYW1lJ10gPSBuYW1lO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHR5cGVvZiBlbmFibGVkICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgcGF5bG9hZFsnZW5hYmxlZCddID0gZW5hYmxlZDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0eXBlb2YgYXBpS2V5ICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgcGF5bG9hZFsnYXBpS2V5J10gPSBhcGlLZXk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodHlwZW9mIGFwaVNlY3JldCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHBheWxvYWRbJ2FwaVNlY3JldCddID0gYXBpU2VjcmV0O1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHR5cGVvZiBmcm9tICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgcGF5bG9hZFsnZnJvbSddID0gZnJvbTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBhd2FpdCB0aGlzLmNsaWVudC5jYWxsKCdwYXRjaCcsIGFwaVBhdGgsIHtcbiAgICAgICAgICAgICdjb250ZW50LXR5cGUnOiAnYXBwbGljYXRpb24vanNvbicsXG4gICAgICAgIH0sIHBheWxvYWQpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdldCBwcm92aWRlclxuICAgICAqXG4gICAgICogR2V0IGEgcHJvdmlkZXIgYnkgaXRzIHVuaXF1ZSBJRC5cbiAgICAgKiBcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBwcm92aWRlcklkXG4gICAgICogQHRocm93cyB7QXBwd3JpdGVFeGNlcHRpb259XG4gICAgICogQHJldHVybnMge1Byb21pc2V9XG4gICAgICovXG4gICAgYXN5bmMgZ2V0UHJvdmlkZXIocHJvdmlkZXJJZCkge1xuICAgICAgICBjb25zdCBhcGlQYXRoID0gJy9tZXNzYWdpbmcvcHJvdmlkZXJzL3twcm92aWRlcklkfScucmVwbGFjZSgne3Byb3ZpZGVySWR9JywgcHJvdmlkZXJJZCk7XG4gICAgICAgIGxldCBwYXlsb2FkID0ge307XG4gICAgICAgIGlmICh0eXBlb2YgcHJvdmlkZXJJZCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBBcHB3cml0ZUV4Y2VwdGlvbignTWlzc2luZyByZXF1aXJlZCBwYXJhbWV0ZXI6IFwicHJvdmlkZXJJZFwiJyk7XG4gICAgICAgIH1cblxuXG4gICAgICAgIHJldHVybiBhd2FpdCB0aGlzLmNsaWVudC5jYWxsKCdnZXQnLCBhcGlQYXRoLCB7XG4gICAgICAgICAgICAnY29udGVudC10eXBlJzogJ2FwcGxpY2F0aW9uL2pzb24nLFxuICAgICAgICB9LCBwYXlsb2FkKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBEZWxldGUgcHJvdmlkZXJcbiAgICAgKlxuICAgICAqIERlbGV0ZSBhIHByb3ZpZGVyIGJ5IGl0cyB1bmlxdWUgSUQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gcHJvdmlkZXJJZFxuICAgICAqIEB0aHJvd3Mge0FwcHdyaXRlRXhjZXB0aW9ufVxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlfVxuICAgICAqL1xuICAgIGFzeW5jIGRlbGV0ZVByb3ZpZGVyKHByb3ZpZGVySWQpIHtcbiAgICAgICAgY29uc3QgYXBpUGF0aCA9ICcvbWVzc2FnaW5nL3Byb3ZpZGVycy97cHJvdmlkZXJJZH0nLnJlcGxhY2UoJ3twcm92aWRlcklkfScsIHByb3ZpZGVySWQpO1xuICAgICAgICBsZXQgcGF5bG9hZCA9IHt9O1xuICAgICAgICBpZiAodHlwZW9mIHByb3ZpZGVySWQgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgQXBwd3JpdGVFeGNlcHRpb24oJ01pc3NpbmcgcmVxdWlyZWQgcGFyYW1ldGVyOiBcInByb3ZpZGVySWRcIicpO1xuICAgICAgICB9XG5cblxuICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy5jbGllbnQuY2FsbCgnZGVsZXRlJywgYXBpUGF0aCwge1xuICAgICAgICAgICAgJ2NvbnRlbnQtdHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJyxcbiAgICAgICAgfSwgcGF5bG9hZCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogTGlzdCBwcm92aWRlciBsb2dzXG4gICAgICpcbiAgICAgKiBHZXQgdGhlIHByb3ZpZGVyIGFjdGl2aXR5IGxvZ3MgbGlzdGVkIGJ5IGl0cyB1bmlxdWUgSUQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gcHJvdmlkZXJJZFxuICAgICAqIEBwYXJhbSB7c3RyaW5nW119IHF1ZXJpZXNcbiAgICAgKiBAdGhyb3dzIHtBcHB3cml0ZUV4Y2VwdGlvbn1cbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZX1cbiAgICAgKi9cbiAgICBhc3luYyBsaXN0UHJvdmlkZXJMb2dzKHByb3ZpZGVySWQsIHF1ZXJpZXMpIHtcbiAgICAgICAgY29uc3QgYXBpUGF0aCA9ICcvbWVzc2FnaW5nL3Byb3ZpZGVycy97cHJvdmlkZXJJZH0vbG9ncycucmVwbGFjZSgne3Byb3ZpZGVySWR9JywgcHJvdmlkZXJJZCk7XG4gICAgICAgIGxldCBwYXlsb2FkID0ge307XG4gICAgICAgIGlmICh0eXBlb2YgcHJvdmlkZXJJZCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBBcHB3cml0ZUV4Y2VwdGlvbignTWlzc2luZyByZXF1aXJlZCBwYXJhbWV0ZXI6IFwicHJvdmlkZXJJZFwiJyk7XG4gICAgICAgIH1cblxuXG4gICAgICAgIGlmICh0eXBlb2YgcXVlcmllcyAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHBheWxvYWRbJ3F1ZXJpZXMnXSA9IHF1ZXJpZXM7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy5jbGllbnQuY2FsbCgnZ2V0JywgYXBpUGF0aCwge1xuICAgICAgICAgICAgJ2NvbnRlbnQtdHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJyxcbiAgICAgICAgfSwgcGF5bG9hZCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogTGlzdCBzdWJzY3JpYmVyIGxvZ3NcbiAgICAgKlxuICAgICAqIEdldCB0aGUgc3Vic2NyaWJlciBhY3Rpdml0eSBsb2dzIGxpc3RlZCBieSBpdHMgdW5pcXVlIElELlxuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHN1YnNjcmliZXJJZFxuICAgICAqIEBwYXJhbSB7c3RyaW5nW119IHF1ZXJpZXNcbiAgICAgKiBAdGhyb3dzIHtBcHB3cml0ZUV4Y2VwdGlvbn1cbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZX1cbiAgICAgKi9cbiAgICBhc3luYyBsaXN0U3Vic2NyaWJlckxvZ3Moc3Vic2NyaWJlcklkLCBxdWVyaWVzKSB7XG4gICAgICAgIGNvbnN0IGFwaVBhdGggPSAnL21lc3NhZ2luZy9zdWJzY3JpYmVycy97c3Vic2NyaWJlcklkfS9sb2dzJy5yZXBsYWNlKCd7c3Vic2NyaWJlcklkfScsIHN1YnNjcmliZXJJZCk7XG4gICAgICAgIGxldCBwYXlsb2FkID0ge307XG4gICAgICAgIGlmICh0eXBlb2Ygc3Vic2NyaWJlcklkID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEFwcHdyaXRlRXhjZXB0aW9uKCdNaXNzaW5nIHJlcXVpcmVkIHBhcmFtZXRlcjogXCJzdWJzY3JpYmVySWRcIicpO1xuICAgICAgICB9XG5cblxuICAgICAgICBpZiAodHlwZW9mIHF1ZXJpZXMgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICBwYXlsb2FkWydxdWVyaWVzJ10gPSBxdWVyaWVzO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMuY2xpZW50LmNhbGwoJ2dldCcsIGFwaVBhdGgsIHtcbiAgICAgICAgICAgICdjb250ZW50LXR5cGUnOiAnYXBwbGljYXRpb24vanNvbicsXG4gICAgICAgIH0sIHBheWxvYWQpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIExpc3QgdG9waWNzXG4gICAgICpcbiAgICAgKiBHZXQgYSBsaXN0IG9mIGFsbCB0b3BpY3MgZnJvbSB0aGUgY3VycmVudCBBcHB3cml0ZSBwcm9qZWN0LlxuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmdbXX0gcXVlcmllc1xuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBzZWFyY2hcbiAgICAgKiBAdGhyb3dzIHtBcHB3cml0ZUV4Y2VwdGlvbn1cbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZX1cbiAgICAgKi9cbiAgICBhc3luYyBsaXN0VG9waWNzKHF1ZXJpZXMsIHNlYXJjaCkge1xuICAgICAgICBjb25zdCBhcGlQYXRoID0gJy9tZXNzYWdpbmcvdG9waWNzJztcbiAgICAgICAgbGV0IHBheWxvYWQgPSB7fTtcblxuICAgICAgICBpZiAodHlwZW9mIHF1ZXJpZXMgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICBwYXlsb2FkWydxdWVyaWVzJ10gPSBxdWVyaWVzO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHR5cGVvZiBzZWFyY2ggIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICBwYXlsb2FkWydzZWFyY2gnXSA9IHNlYXJjaDtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBhd2FpdCB0aGlzLmNsaWVudC5jYWxsKCdnZXQnLCBhcGlQYXRoLCB7XG4gICAgICAgICAgICAnY29udGVudC10eXBlJzogJ2FwcGxpY2F0aW9uL2pzb24nLFxuICAgICAgICB9LCBwYXlsb2FkKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGUgdG9waWNcbiAgICAgKlxuICAgICAqIENyZWF0ZSBhIG5ldyB0b3BpYy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSB0b3BpY0lkXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IG5hbWVcbiAgICAgKiBAcGFyYW0ge3N0cmluZ1tdfSBzdWJzY3JpYmVcbiAgICAgKiBAdGhyb3dzIHtBcHB3cml0ZUV4Y2VwdGlvbn1cbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZX1cbiAgICAgKi9cbiAgICBhc3luYyBjcmVhdGVUb3BpYyh0b3BpY0lkLCBuYW1lLCBzdWJzY3JpYmUpIHtcbiAgICAgICAgY29uc3QgYXBpUGF0aCA9ICcvbWVzc2FnaW5nL3RvcGljcyc7XG4gICAgICAgIGxldCBwYXlsb2FkID0ge307XG4gICAgICAgIGlmICh0eXBlb2YgdG9waWNJZCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBBcHB3cml0ZUV4Y2VwdGlvbignTWlzc2luZyByZXF1aXJlZCBwYXJhbWV0ZXI6IFwidG9waWNJZFwiJyk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodHlwZW9mIG5hbWUgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgQXBwd3JpdGVFeGNlcHRpb24oJ01pc3NpbmcgcmVxdWlyZWQgcGFyYW1ldGVyOiBcIm5hbWVcIicpO1xuICAgICAgICB9XG5cblxuICAgICAgICBpZiAodHlwZW9mIHRvcGljSWQgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICBwYXlsb2FkWyd0b3BpY0lkJ10gPSB0b3BpY0lkO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHR5cGVvZiBuYW1lICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgcGF5bG9hZFsnbmFtZSddID0gbmFtZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0eXBlb2Ygc3Vic2NyaWJlICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgcGF5bG9hZFsnc3Vic2NyaWJlJ10gPSBzdWJzY3JpYmU7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy5jbGllbnQuY2FsbCgncG9zdCcsIGFwaVBhdGgsIHtcbiAgICAgICAgICAgICdjb250ZW50LXR5cGUnOiAnYXBwbGljYXRpb24vanNvbicsXG4gICAgICAgIH0sIHBheWxvYWQpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdldCB0b3BpY1xuICAgICAqXG4gICAgICogR2V0IGEgdG9waWMgYnkgaXRzIHVuaXF1ZSBJRC5cbiAgICAgKiBcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSB0b3BpY0lkXG4gICAgICogQHRocm93cyB7QXBwd3JpdGVFeGNlcHRpb259XG4gICAgICogQHJldHVybnMge1Byb21pc2V9XG4gICAgICovXG4gICAgYXN5bmMgZ2V0VG9waWModG9waWNJZCkge1xuICAgICAgICBjb25zdCBhcGlQYXRoID0gJy9tZXNzYWdpbmcvdG9waWNzL3t0b3BpY0lkfScucmVwbGFjZSgne3RvcGljSWR9JywgdG9waWNJZCk7XG4gICAgICAgIGxldCBwYXlsb2FkID0ge307XG4gICAgICAgIGlmICh0eXBlb2YgdG9waWNJZCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBBcHB3cml0ZUV4Y2VwdGlvbignTWlzc2luZyByZXF1aXJlZCBwYXJhbWV0ZXI6IFwidG9waWNJZFwiJyk7XG4gICAgICAgIH1cblxuXG4gICAgICAgIHJldHVybiBhd2FpdCB0aGlzLmNsaWVudC5jYWxsKCdnZXQnLCBhcGlQYXRoLCB7XG4gICAgICAgICAgICAnY29udGVudC10eXBlJzogJ2FwcGxpY2F0aW9uL2pzb24nLFxuICAgICAgICB9LCBwYXlsb2FkKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBVcGRhdGUgdG9waWNcbiAgICAgKlxuICAgICAqIFVwZGF0ZSBhIHRvcGljIGJ5IGl0cyB1bmlxdWUgSUQuXG4gICAgICogXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gdG9waWNJZFxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lXG4gICAgICogQHBhcmFtIHtzdHJpbmdbXX0gc3Vic2NyaWJlXG4gICAgICogQHRocm93cyB7QXBwd3JpdGVFeGNlcHRpb259XG4gICAgICogQHJldHVybnMge1Byb21pc2V9XG4gICAgICovXG4gICAgYXN5bmMgdXBkYXRlVG9waWModG9waWNJZCwgbmFtZSwgc3Vic2NyaWJlKSB7XG4gICAgICAgIGNvbnN0IGFwaVBhdGggPSAnL21lc3NhZ2luZy90b3BpY3Mve3RvcGljSWR9Jy5yZXBsYWNlKCd7dG9waWNJZH0nLCB0b3BpY0lkKTtcbiAgICAgICAgbGV0IHBheWxvYWQgPSB7fTtcbiAgICAgICAgaWYgKHR5cGVvZiB0b3BpY0lkID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEFwcHdyaXRlRXhjZXB0aW9uKCdNaXNzaW5nIHJlcXVpcmVkIHBhcmFtZXRlcjogXCJ0b3BpY0lkXCInKTtcbiAgICAgICAgfVxuXG5cbiAgICAgICAgaWYgKHR5cGVvZiBuYW1lICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgcGF5bG9hZFsnbmFtZSddID0gbmFtZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0eXBlb2Ygc3Vic2NyaWJlICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgcGF5bG9hZFsnc3Vic2NyaWJlJ10gPSBzdWJzY3JpYmU7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy5jbGllbnQuY2FsbCgncGF0Y2gnLCBhcGlQYXRoLCB7XG4gICAgICAgICAgICAnY29udGVudC10eXBlJzogJ2FwcGxpY2F0aW9uL2pzb24nLFxuICAgICAgICB9LCBwYXlsb2FkKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBEZWxldGUgdG9waWNcbiAgICAgKlxuICAgICAqIERlbGV0ZSBhIHRvcGljIGJ5IGl0cyB1bmlxdWUgSUQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gdG9waWNJZFxuICAgICAqIEB0aHJvd3Mge0FwcHdyaXRlRXhjZXB0aW9ufVxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlfVxuICAgICAqL1xuICAgIGFzeW5jIGRlbGV0ZVRvcGljKHRvcGljSWQpIHtcbiAgICAgICAgY29uc3QgYXBpUGF0aCA9ICcvbWVzc2FnaW5nL3RvcGljcy97dG9waWNJZH0nLnJlcGxhY2UoJ3t0b3BpY0lkfScsIHRvcGljSWQpO1xuICAgICAgICBsZXQgcGF5bG9hZCA9IHt9O1xuICAgICAgICBpZiAodHlwZW9mIHRvcGljSWQgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgQXBwd3JpdGVFeGNlcHRpb24oJ01pc3NpbmcgcmVxdWlyZWQgcGFyYW1ldGVyOiBcInRvcGljSWRcIicpO1xuICAgICAgICB9XG5cblxuICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy5jbGllbnQuY2FsbCgnZGVsZXRlJywgYXBpUGF0aCwge1xuICAgICAgICAgICAgJ2NvbnRlbnQtdHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJyxcbiAgICAgICAgfSwgcGF5bG9hZCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogTGlzdCB0b3BpYyBsb2dzXG4gICAgICpcbiAgICAgKiBHZXQgdGhlIHRvcGljIGFjdGl2aXR5IGxvZ3MgbGlzdGVkIGJ5IGl0cyB1bmlxdWUgSUQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gdG9waWNJZFxuICAgICAqIEBwYXJhbSB7c3RyaW5nW119IHF1ZXJpZXNcbiAgICAgKiBAdGhyb3dzIHtBcHB3cml0ZUV4Y2VwdGlvbn1cbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZX1cbiAgICAgKi9cbiAgICBhc3luYyBsaXN0VG9waWNMb2dzKHRvcGljSWQsIHF1ZXJpZXMpIHtcbiAgICAgICAgY29uc3QgYXBpUGF0aCA9ICcvbWVzc2FnaW5nL3RvcGljcy97dG9waWNJZH0vbG9ncycucmVwbGFjZSgne3RvcGljSWR9JywgdG9waWNJZCk7XG4gICAgICAgIGxldCBwYXlsb2FkID0ge307XG4gICAgICAgIGlmICh0eXBlb2YgdG9waWNJZCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBBcHB3cml0ZUV4Y2VwdGlvbignTWlzc2luZyByZXF1aXJlZCBwYXJhbWV0ZXI6IFwidG9waWNJZFwiJyk7XG4gICAgICAgIH1cblxuXG4gICAgICAgIGlmICh0eXBlb2YgcXVlcmllcyAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHBheWxvYWRbJ3F1ZXJpZXMnXSA9IHF1ZXJpZXM7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy5jbGllbnQuY2FsbCgnZ2V0JywgYXBpUGF0aCwge1xuICAgICAgICAgICAgJ2NvbnRlbnQtdHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJyxcbiAgICAgICAgfSwgcGF5bG9hZCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogTGlzdCBzdWJzY3JpYmVyc1xuICAgICAqXG4gICAgICogR2V0IGEgbGlzdCBvZiBhbGwgc3Vic2NyaWJlcnMgZnJvbSB0aGUgY3VycmVudCBBcHB3cml0ZSBwcm9qZWN0LlxuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHRvcGljSWRcbiAgICAgKiBAcGFyYW0ge3N0cmluZ1tdfSBxdWVyaWVzXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHNlYXJjaFxuICAgICAqIEB0aHJvd3Mge0FwcHdyaXRlRXhjZXB0aW9ufVxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlfVxuICAgICAqL1xuICAgIGFzeW5jIGxpc3RTdWJzY3JpYmVycyh0b3BpY0lkLCBxdWVyaWVzLCBzZWFyY2gpIHtcbiAgICAgICAgY29uc3QgYXBpUGF0aCA9ICcvbWVzc2FnaW5nL3RvcGljcy97dG9waWNJZH0vc3Vic2NyaWJlcnMnLnJlcGxhY2UoJ3t0b3BpY0lkfScsIHRvcGljSWQpO1xuICAgICAgICBsZXQgcGF5bG9hZCA9IHt9O1xuICAgICAgICBpZiAodHlwZW9mIHRvcGljSWQgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgQXBwd3JpdGVFeGNlcHRpb24oJ01pc3NpbmcgcmVxdWlyZWQgcGFyYW1ldGVyOiBcInRvcGljSWRcIicpO1xuICAgICAgICB9XG5cblxuICAgICAgICBpZiAodHlwZW9mIHF1ZXJpZXMgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICBwYXlsb2FkWydxdWVyaWVzJ10gPSBxdWVyaWVzO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHR5cGVvZiBzZWFyY2ggIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICBwYXlsb2FkWydzZWFyY2gnXSA9IHNlYXJjaDtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBhd2FpdCB0aGlzLmNsaWVudC5jYWxsKCdnZXQnLCBhcGlQYXRoLCB7XG4gICAgICAgICAgICAnY29udGVudC10eXBlJzogJ2FwcGxpY2F0aW9uL2pzb24nLFxuICAgICAgICB9LCBwYXlsb2FkKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGUgc3Vic2NyaWJlclxuICAgICAqXG4gICAgICogQ3JlYXRlIGEgbmV3IHN1YnNjcmliZXIuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gdG9waWNJZFxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBzdWJzY3JpYmVySWRcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gdGFyZ2V0SWRcbiAgICAgKiBAdGhyb3dzIHtBcHB3cml0ZUV4Y2VwdGlvbn1cbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZX1cbiAgICAgKi9cbiAgICBhc3luYyBjcmVhdGVTdWJzY3JpYmVyKHRvcGljSWQsIHN1YnNjcmliZXJJZCwgdGFyZ2V0SWQpIHtcbiAgICAgICAgY29uc3QgYXBpUGF0aCA9ICcvbWVzc2FnaW5nL3RvcGljcy97dG9waWNJZH0vc3Vic2NyaWJlcnMnLnJlcGxhY2UoJ3t0b3BpY0lkfScsIHRvcGljSWQpO1xuICAgICAgICBsZXQgcGF5bG9hZCA9IHt9O1xuICAgICAgICBpZiAodHlwZW9mIHRvcGljSWQgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgQXBwd3JpdGVFeGNlcHRpb24oJ01pc3NpbmcgcmVxdWlyZWQgcGFyYW1ldGVyOiBcInRvcGljSWRcIicpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHR5cGVvZiBzdWJzY3JpYmVySWQgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgQXBwd3JpdGVFeGNlcHRpb24oJ01pc3NpbmcgcmVxdWlyZWQgcGFyYW1ldGVyOiBcInN1YnNjcmliZXJJZFwiJyk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodHlwZW9mIHRhcmdldElkID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEFwcHdyaXRlRXhjZXB0aW9uKCdNaXNzaW5nIHJlcXVpcmVkIHBhcmFtZXRlcjogXCJ0YXJnZXRJZFwiJyk7XG4gICAgICAgIH1cblxuXG4gICAgICAgIGlmICh0eXBlb2Ygc3Vic2NyaWJlcklkICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgcGF5bG9hZFsnc3Vic2NyaWJlcklkJ10gPSBzdWJzY3JpYmVySWQ7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodHlwZW9mIHRhcmdldElkICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgcGF5bG9hZFsndGFyZ2V0SWQnXSA9IHRhcmdldElkO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMuY2xpZW50LmNhbGwoJ3Bvc3QnLCBhcGlQYXRoLCB7XG4gICAgICAgICAgICAnY29udGVudC10eXBlJzogJ2FwcGxpY2F0aW9uL2pzb24nLFxuICAgICAgICB9LCBwYXlsb2FkKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZXQgc3Vic2NyaWJlclxuICAgICAqXG4gICAgICogR2V0IGEgc3Vic2NyaWJlciBieSBpdHMgdW5pcXVlIElELlxuICAgICAqIFxuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHRvcGljSWRcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gc3Vic2NyaWJlcklkXG4gICAgICogQHRocm93cyB7QXBwd3JpdGVFeGNlcHRpb259XG4gICAgICogQHJldHVybnMge1Byb21pc2V9XG4gICAgICovXG4gICAgYXN5bmMgZ2V0U3Vic2NyaWJlcih0b3BpY0lkLCBzdWJzY3JpYmVySWQpIHtcbiAgICAgICAgY29uc3QgYXBpUGF0aCA9ICcvbWVzc2FnaW5nL3RvcGljcy97dG9waWNJZH0vc3Vic2NyaWJlcnMve3N1YnNjcmliZXJJZH0nLnJlcGxhY2UoJ3t0b3BpY0lkfScsIHRvcGljSWQpLnJlcGxhY2UoJ3tzdWJzY3JpYmVySWR9Jywgc3Vic2NyaWJlcklkKTtcbiAgICAgICAgbGV0IHBheWxvYWQgPSB7fTtcbiAgICAgICAgaWYgKHR5cGVvZiB0b3BpY0lkID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEFwcHdyaXRlRXhjZXB0aW9uKCdNaXNzaW5nIHJlcXVpcmVkIHBhcmFtZXRlcjogXCJ0b3BpY0lkXCInKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0eXBlb2Ygc3Vic2NyaWJlcklkID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEFwcHdyaXRlRXhjZXB0aW9uKCdNaXNzaW5nIHJlcXVpcmVkIHBhcmFtZXRlcjogXCJzdWJzY3JpYmVySWRcIicpO1xuICAgICAgICB9XG5cblxuICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy5jbGllbnQuY2FsbCgnZ2V0JywgYXBpUGF0aCwge1xuICAgICAgICAgICAgJ2NvbnRlbnQtdHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJyxcbiAgICAgICAgfSwgcGF5bG9hZCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRGVsZXRlIHN1YnNjcmliZXJcbiAgICAgKlxuICAgICAqIERlbGV0ZSBhIHN1YnNjcmliZXIgYnkgaXRzIHVuaXF1ZSBJRC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSB0b3BpY0lkXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHN1YnNjcmliZXJJZFxuICAgICAqIEB0aHJvd3Mge0FwcHdyaXRlRXhjZXB0aW9ufVxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlfVxuICAgICAqL1xuICAgIGFzeW5jIGRlbGV0ZVN1YnNjcmliZXIodG9waWNJZCwgc3Vic2NyaWJlcklkKSB7XG4gICAgICAgIGNvbnN0IGFwaVBhdGggPSAnL21lc3NhZ2luZy90b3BpY3Mve3RvcGljSWR9L3N1YnNjcmliZXJzL3tzdWJzY3JpYmVySWR9Jy5yZXBsYWNlKCd7dG9waWNJZH0nLCB0b3BpY0lkKS5yZXBsYWNlKCd7c3Vic2NyaWJlcklkfScsIHN1YnNjcmliZXJJZCk7XG4gICAgICAgIGxldCBwYXlsb2FkID0ge307XG4gICAgICAgIGlmICh0eXBlb2YgdG9waWNJZCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBBcHB3cml0ZUV4Y2VwdGlvbignTWlzc2luZyByZXF1aXJlZCBwYXJhbWV0ZXI6IFwidG9waWNJZFwiJyk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodHlwZW9mIHN1YnNjcmliZXJJZCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBBcHB3cml0ZUV4Y2VwdGlvbignTWlzc2luZyByZXF1aXJlZCBwYXJhbWV0ZXI6IFwic3Vic2NyaWJlcklkXCInKTtcbiAgICAgICAgfVxuXG5cbiAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMuY2xpZW50LmNhbGwoJ2RlbGV0ZScsIGFwaVBhdGgsIHtcbiAgICAgICAgICAgICdjb250ZW50LXR5cGUnOiAnYXBwbGljYXRpb24vanNvbicsXG4gICAgICAgIH0sIHBheWxvYWQpO1xuICAgIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBNZXNzYWdpbmc7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/node-appwrite/lib/services/messaging.js\n");

/***/ }),

/***/ "(action-browser)/./node_modules/node-appwrite/lib/services/storage.js":
/*!************************************************************!*\
  !*** ./node_modules/node-appwrite/lib/services/storage.js ***!
  \************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("const Service = __webpack_require__(/*! ../service.js */ \"(action-browser)/./node_modules/node-appwrite/lib/service.js\");\nconst AppwriteException = __webpack_require__(/*! ../exception.js */ \"(action-browser)/./node_modules/node-appwrite/lib/exception.js\");\nconst InputFile = __webpack_require__(/*! ../inputFile.js */ \"(action-browser)/./node_modules/node-appwrite/lib/inputFile.js\");\nconst client = __webpack_require__(/*! ../client.js */ \"(action-browser)/./node_modules/node-appwrite/lib/client.js\");\nconst Stream = __webpack_require__(/*! stream */ \"stream\");\nconst { promisify } = __webpack_require__(/*! util */ \"util\");\nconst fs = __webpack_require__(/*! fs */ \"fs\");\nconst { File } = __webpack_require__(/*! undici */ \"undici\");\nconst Query = __webpack_require__(/*! ../query.js */ \"(action-browser)/./node_modules/node-appwrite/lib/query.js\");\n\nclass Storage extends Service {\n\n     constructor(client)\n     {\n        super(client);\n     }\n\n\n    /**\n     * List buckets\n     *\n     * Get a list of all the storage buckets. You can use the query params to\n     * filter your results.\n     *\n     * @param {string[]} queries\n     * @param {string} search\n     * @throws {AppwriteException}\n     * @returns {Promise}\n     */\n    async listBuckets(queries, search) {\n        const apiPath = '/storage/buckets';\n        let payload = {};\n\n        if (typeof queries !== 'undefined') {\n            payload['queries'] = queries;\n        }\n\n        if (typeof search !== 'undefined') {\n            payload['search'] = search;\n        }\n\n        return await this.client.call('get', apiPath, {\n            'content-type': 'application/json',\n        }, payload);\n    }\n\n    /**\n     * Create bucket\n     *\n     * Create a new storage bucket.\n     *\n     * @param {string} bucketId\n     * @param {string} name\n     * @param {string[]} permissions\n     * @param {boolean} fileSecurity\n     * @param {boolean} enabled\n     * @param {number} maximumFileSize\n     * @param {string[]} allowedFileExtensions\n     * @param {Compression} compression\n     * @param {boolean} encryption\n     * @param {boolean} antivirus\n     * @throws {AppwriteException}\n     * @returns {Promise}\n     */\n    async createBucket(bucketId, name, permissions, fileSecurity, enabled, maximumFileSize, allowedFileExtensions, compression, encryption, antivirus) {\n        const apiPath = '/storage/buckets';\n        let payload = {};\n        if (typeof bucketId === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"bucketId\"');\n        }\n\n        if (typeof name === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"name\"');\n        }\n\n\n        if (typeof bucketId !== 'undefined') {\n            payload['bucketId'] = bucketId;\n        }\n\n        if (typeof name !== 'undefined') {\n            payload['name'] = name;\n        }\n\n        if (typeof permissions !== 'undefined') {\n            payload['permissions'] = permissions;\n        }\n\n        if (typeof fileSecurity !== 'undefined') {\n            payload['fileSecurity'] = fileSecurity;\n        }\n\n        if (typeof enabled !== 'undefined') {\n            payload['enabled'] = enabled;\n        }\n\n        if (typeof maximumFileSize !== 'undefined') {\n            payload['maximumFileSize'] = maximumFileSize;\n        }\n\n        if (typeof allowedFileExtensions !== 'undefined') {\n            payload['allowedFileExtensions'] = allowedFileExtensions;\n        }\n\n        if (typeof compression !== 'undefined') {\n            payload['compression'] = compression;\n        }\n\n        if (typeof encryption !== 'undefined') {\n            payload['encryption'] = encryption;\n        }\n\n        if (typeof antivirus !== 'undefined') {\n            payload['antivirus'] = antivirus;\n        }\n\n        return await this.client.call('post', apiPath, {\n            'content-type': 'application/json',\n        }, payload);\n    }\n\n    /**\n     * Get bucket\n     *\n     * Get a storage bucket by its unique ID. This endpoint response returns a\n     * JSON object with the storage bucket metadata.\n     *\n     * @param {string} bucketId\n     * @throws {AppwriteException}\n     * @returns {Promise}\n     */\n    async getBucket(bucketId) {\n        const apiPath = '/storage/buckets/{bucketId}'.replace('{bucketId}', bucketId);\n        let payload = {};\n        if (typeof bucketId === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"bucketId\"');\n        }\n\n\n        return await this.client.call('get', apiPath, {\n            'content-type': 'application/json',\n        }, payload);\n    }\n\n    /**\n     * Update bucket\n     *\n     * Update a storage bucket by its unique ID.\n     *\n     * @param {string} bucketId\n     * @param {string} name\n     * @param {string[]} permissions\n     * @param {boolean} fileSecurity\n     * @param {boolean} enabled\n     * @param {number} maximumFileSize\n     * @param {string[]} allowedFileExtensions\n     * @param {Compression} compression\n     * @param {boolean} encryption\n     * @param {boolean} antivirus\n     * @throws {AppwriteException}\n     * @returns {Promise}\n     */\n    async updateBucket(bucketId, name, permissions, fileSecurity, enabled, maximumFileSize, allowedFileExtensions, compression, encryption, antivirus) {\n        const apiPath = '/storage/buckets/{bucketId}'.replace('{bucketId}', bucketId);\n        let payload = {};\n        if (typeof bucketId === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"bucketId\"');\n        }\n\n        if (typeof name === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"name\"');\n        }\n\n\n        if (typeof name !== 'undefined') {\n            payload['name'] = name;\n        }\n\n        if (typeof permissions !== 'undefined') {\n            payload['permissions'] = permissions;\n        }\n\n        if (typeof fileSecurity !== 'undefined') {\n            payload['fileSecurity'] = fileSecurity;\n        }\n\n        if (typeof enabled !== 'undefined') {\n            payload['enabled'] = enabled;\n        }\n\n        if (typeof maximumFileSize !== 'undefined') {\n            payload['maximumFileSize'] = maximumFileSize;\n        }\n\n        if (typeof allowedFileExtensions !== 'undefined') {\n            payload['allowedFileExtensions'] = allowedFileExtensions;\n        }\n\n        if (typeof compression !== 'undefined') {\n            payload['compression'] = compression;\n        }\n\n        if (typeof encryption !== 'undefined') {\n            payload['encryption'] = encryption;\n        }\n\n        if (typeof antivirus !== 'undefined') {\n            payload['antivirus'] = antivirus;\n        }\n\n        return await this.client.call('put', apiPath, {\n            'content-type': 'application/json',\n        }, payload);\n    }\n\n    /**\n     * Delete bucket\n     *\n     * Delete a storage bucket by its unique ID.\n     *\n     * @param {string} bucketId\n     * @throws {AppwriteException}\n     * @returns {Promise}\n     */\n    async deleteBucket(bucketId) {\n        const apiPath = '/storage/buckets/{bucketId}'.replace('{bucketId}', bucketId);\n        let payload = {};\n        if (typeof bucketId === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"bucketId\"');\n        }\n\n\n        return await this.client.call('delete', apiPath, {\n            'content-type': 'application/json',\n        }, payload);\n    }\n\n    /**\n     * List files\n     *\n     * Get a list of all the user files. You can use the query params to filter\n     * your results.\n     *\n     * @param {string} bucketId\n     * @param {string[]} queries\n     * @param {string} search\n     * @throws {AppwriteException}\n     * @returns {Promise}\n     */\n    async listFiles(bucketId, queries, search) {\n        const apiPath = '/storage/buckets/{bucketId}/files'.replace('{bucketId}', bucketId);\n        let payload = {};\n        if (typeof bucketId === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"bucketId\"');\n        }\n\n\n        if (typeof queries !== 'undefined') {\n            payload['queries'] = queries;\n        }\n\n        if (typeof search !== 'undefined') {\n            payload['search'] = search;\n        }\n\n        return await this.client.call('get', apiPath, {\n            'content-type': 'application/json',\n        }, payload);\n    }\n\n    /**\n     * Create file\n     *\n     * Create a new file. Before using this route, you should create a new bucket\n     * resource using either a [server\n     * integration](https://appwrite.io/docs/server/storage#storageCreateBucket)\n     * API or directly from your Appwrite console.\n     * \n     * Larger files should be uploaded using multiple requests with the\n     * [content-range](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Content-Range)\n     * header to send a partial request with a maximum supported chunk of `5MB`.\n     * The `content-range` header values should always be in bytes.\n     * \n     * When the first request is sent, the server will return the **File** object,\n     * and the subsequent part request must include the file's **id** in\n     * `x-appwrite-id` header to allow the server to know that the partial upload\n     * is for the existing file and not for a new one.\n     * \n     * If you're creating a new file using one of the Appwrite SDKs, all the\n     * chunking logic will be managed by the SDK internally.\n     * \n     *\n     * @param {string} bucketId\n     * @param {string} fileId\n     * @param {InputFile} file\n     * @param {string[]} permissions\n     * @param {CallableFunction} onProgress\n     * @throws {AppwriteException}\n     * @returns {Promise}\n     */\n    async createFile(bucketId, fileId, file, permissions, onProgress = () => {}) {\n        const apiPath = '/storage/buckets/{bucketId}/files'.replace('{bucketId}', bucketId);\n        let payload = {};\n        if (typeof bucketId === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"bucketId\"');\n        }\n\n        if (typeof fileId === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"fileId\"');\n        }\n\n        if (typeof file === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"file\"');\n        }\n\n\n        if (typeof fileId !== 'undefined') {\n            payload['fileId'] = fileId;\n        }\n\n        if (typeof file !== 'undefined') {\n            payload['file'] = file;\n        }\n\n        if (typeof permissions !== 'undefined') {\n            payload['permissions'] = permissions;\n        }\n\n\n        const size = file.size;\n        \n        const apiHeaders = {\n            'content-type': 'multipart/form-data',\n        };\n\n        let id = undefined;\n        let response = undefined;\n\n        let chunksUploaded = 0;\n\n        if(fileId != 'unique()') {\n            try {\n                response = await this.client.call('get', apiPath + '/' + fileId, apiHeaders);\n                chunksUploaded = response.chunksUploaded;\n            } catch(e) {\n            }\n        }\n\n        let currentChunk = 1;\n        let currentPosition = 0;\n        let uploadableChunk = new Uint8Array(client.CHUNK_SIZE);\n    \n\n        const uploadChunk = async (lastUpload = false) => {\n            if(currentChunk <= chunksUploaded) {\n                return;\n            }\n\n            const start = ((currentChunk - 1) * client.CHUNK_SIZE);\n            let end = start + currentPosition - 1;\n\n            if(!lastUpload || currentChunk !== 1) {\n                apiHeaders['content-range'] = 'bytes ' + start + '-' + end + '/' + size;\n            }\n\n            let uploadableChunkTrimmed;\n            \n            if(currentPosition + 1 >= client.CHUNK_SIZE) {\n                uploadableChunkTrimmed = uploadableChunk;\n            } else {\n                uploadableChunkTrimmed = new Uint8Array(currentPosition);\n                for(let i = 0; i <= currentPosition; i++) {\n                    uploadableChunkTrimmed[i] = uploadableChunk[i];\n                }\n            }\n\n            if (id) {\n                apiHeaders['x-appwrite-id'] = id;\n            }\n\n            payload['file'] = { type: 'file', file: new File([uploadableChunkTrimmed], file.filename), filename: file.filename };\n\n            response = await this.client.call('post', apiPath, apiHeaders, payload);\n\n            if (!id) {\n                id = response['$id'];\n            }\n\n            if (onProgress !== null) {\n                onProgress({\n                    $id: response['$id'],\n                    progress: Math.min((currentChunk) * client.CHUNK_SIZE, size) / size * 100,\n                    sizeUploaded: end+1,\n                    chunksTotal: response['chunksTotal'],\n                    chunksUploaded: response['chunksUploaded']\n                });\n            }\n\n            uploadableChunk = new Uint8Array(client.CHUNK_SIZE);\n            currentChunk++;\n            currentPosition = 0;\n        }\n\n        for await (const chunk of file.stream) {\n            for(const b of chunk) {\n                uploadableChunk[currentPosition] = b;\n\n                currentPosition++;\n                if(currentPosition >= client.CHUNK_SIZE) {\n                    await uploadChunk();\n                    currentPosition = 0;\n                }\n            }\n        }\n\n        if (currentPosition > 0) { // Check if there's any remaining data for the last chunk\n            await uploadChunk(true);\n        }\n\n        return response;\n\n    }\n\n    /**\n     * Get file\n     *\n     * Get a file by its unique ID. This endpoint response returns a JSON object\n     * with the file metadata.\n     *\n     * @param {string} bucketId\n     * @param {string} fileId\n     * @throws {AppwriteException}\n     * @returns {Promise}\n     */\n    async getFile(bucketId, fileId) {\n        const apiPath = '/storage/buckets/{bucketId}/files/{fileId}'.replace('{bucketId}', bucketId).replace('{fileId}', fileId);\n        let payload = {};\n        if (typeof bucketId === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"bucketId\"');\n        }\n\n        if (typeof fileId === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"fileId\"');\n        }\n\n\n        return await this.client.call('get', apiPath, {\n            'content-type': 'application/json',\n        }, payload);\n    }\n\n    /**\n     * Update file\n     *\n     * Update a file by its unique ID. Only users with write permissions have\n     * access to update this resource.\n     *\n     * @param {string} bucketId\n     * @param {string} fileId\n     * @param {string} name\n     * @param {string[]} permissions\n     * @throws {AppwriteException}\n     * @returns {Promise}\n     */\n    async updateFile(bucketId, fileId, name, permissions) {\n        const apiPath = '/storage/buckets/{bucketId}/files/{fileId}'.replace('{bucketId}', bucketId).replace('{fileId}', fileId);\n        let payload = {};\n        if (typeof bucketId === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"bucketId\"');\n        }\n\n        if (typeof fileId === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"fileId\"');\n        }\n\n\n        if (typeof name !== 'undefined') {\n            payload['name'] = name;\n        }\n\n        if (typeof permissions !== 'undefined') {\n            payload['permissions'] = permissions;\n        }\n\n        return await this.client.call('put', apiPath, {\n            'content-type': 'application/json',\n        }, payload);\n    }\n\n    /**\n     * Delete File\n     *\n     * Delete a file by its unique ID. Only users with write permissions have\n     * access to delete this resource.\n     *\n     * @param {string} bucketId\n     * @param {string} fileId\n     * @throws {AppwriteException}\n     * @returns {Promise}\n     */\n    async deleteFile(bucketId, fileId) {\n        const apiPath = '/storage/buckets/{bucketId}/files/{fileId}'.replace('{bucketId}', bucketId).replace('{fileId}', fileId);\n        let payload = {};\n        if (typeof bucketId === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"bucketId\"');\n        }\n\n        if (typeof fileId === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"fileId\"');\n        }\n\n\n        return await this.client.call('delete', apiPath, {\n            'content-type': 'application/json',\n        }, payload);\n    }\n\n    /**\n     * Get file for download\n     *\n     * Get a file content by its unique ID. The endpoint response return with a\n     * 'Content-Disposition: attachment' header that tells the browser to start\n     * downloading the file to user downloads directory.\n     *\n     * @param {string} bucketId\n     * @param {string} fileId\n     * @throws {AppwriteException}\n     * @returns {Promise}\n     */\n    async getFileDownload(bucketId, fileId) {\n        const apiPath = '/storage/buckets/{bucketId}/files/{fileId}/download'.replace('{bucketId}', bucketId).replace('{fileId}', fileId);\n        let payload = {};\n        if (typeof bucketId === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"bucketId\"');\n        }\n\n        if (typeof fileId === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"fileId\"');\n        }\n\n\n        return await this.client.call('get', apiPath, {\n            'content-type': 'application/json',\n        }, payload, 'arraybuffer');\n    }\n\n    /**\n     * Get file preview\n     *\n     * Get a file preview image. Currently, this method supports preview for image\n     * files (jpg, png, and gif), other supported formats, like pdf, docs, slides,\n     * and spreadsheets, will return the file icon image. You can also pass query\n     * string arguments for cutting and resizing your preview image. Preview is\n     * supported only for image files smaller than 10MB.\n     *\n     * @param {string} bucketId\n     * @param {string} fileId\n     * @param {number} width\n     * @param {number} height\n     * @param {ImageGravity} gravity\n     * @param {number} quality\n     * @param {number} borderWidth\n     * @param {string} borderColor\n     * @param {number} borderRadius\n     * @param {number} opacity\n     * @param {number} rotation\n     * @param {string} background\n     * @param {ImageFormat} output\n     * @throws {AppwriteException}\n     * @returns {Promise}\n     */\n    async getFilePreview(bucketId, fileId, width, height, gravity, quality, borderWidth, borderColor, borderRadius, opacity, rotation, background, output) {\n        const apiPath = '/storage/buckets/{bucketId}/files/{fileId}/preview'.replace('{bucketId}', bucketId).replace('{fileId}', fileId);\n        let payload = {};\n        if (typeof bucketId === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"bucketId\"');\n        }\n\n        if (typeof fileId === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"fileId\"');\n        }\n\n\n        if (typeof width !== 'undefined') {\n            payload['width'] = width;\n        }\n\n        if (typeof height !== 'undefined') {\n            payload['height'] = height;\n        }\n\n        if (typeof gravity !== 'undefined') {\n            payload['gravity'] = gravity;\n        }\n\n        if (typeof quality !== 'undefined') {\n            payload['quality'] = quality;\n        }\n\n        if (typeof borderWidth !== 'undefined') {\n            payload['borderWidth'] = borderWidth;\n        }\n\n        if (typeof borderColor !== 'undefined') {\n            payload['borderColor'] = borderColor;\n        }\n\n        if (typeof borderRadius !== 'undefined') {\n            payload['borderRadius'] = borderRadius;\n        }\n\n        if (typeof opacity !== 'undefined') {\n            payload['opacity'] = opacity;\n        }\n\n        if (typeof rotation !== 'undefined') {\n            payload['rotation'] = rotation;\n        }\n\n        if (typeof background !== 'undefined') {\n            payload['background'] = background;\n        }\n\n        if (typeof output !== 'undefined') {\n            payload['output'] = output;\n        }\n\n        return await this.client.call('get', apiPath, {\n            'content-type': 'application/json',\n        }, payload, 'arraybuffer');\n    }\n\n    /**\n     * Get file for view\n     *\n     * Get a file content by its unique ID. This endpoint is similar to the\n     * download method but returns with no  'Content-Disposition: attachment'\n     * header.\n     *\n     * @param {string} bucketId\n     * @param {string} fileId\n     * @throws {AppwriteException}\n     * @returns {Promise}\n     */\n    async getFileView(bucketId, fileId) {\n        const apiPath = '/storage/buckets/{bucketId}/files/{fileId}/view'.replace('{bucketId}', bucketId).replace('{fileId}', fileId);\n        let payload = {};\n        if (typeof bucketId === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"bucketId\"');\n        }\n\n        if (typeof fileId === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"fileId\"');\n        }\n\n\n        return await this.client.call('get', apiPath, {\n            'content-type': 'application/json',\n        }, payload, 'arraybuffer');\n    }\n}\n\nmodule.exports = Storage;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFjdGlvbi1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9ub2RlLWFwcHdyaXRlL2xpYi9zZXJ2aWNlcy9zdG9yYWdlLmpzIiwibWFwcGluZ3MiOiJBQUFBLGdCQUFnQixtQkFBTyxDQUFDLG1GQUFlO0FBQ3ZDLDBCQUEwQixtQkFBTyxDQUFDLHVGQUFpQjtBQUNuRCxrQkFBa0IsbUJBQU8sQ0FBQyx1RkFBaUI7QUFDM0MsZUFBZSxtQkFBTyxDQUFDLGlGQUFjO0FBQ3JDLGVBQWUsbUJBQU8sQ0FBQyxzQkFBUTtBQUMvQixRQUFRLFlBQVksRUFBRSxtQkFBTyxDQUFDLGtCQUFNO0FBQ3BDLFdBQVcsbUJBQU8sQ0FBQyxjQUFJO0FBQ3ZCLFFBQVEsT0FBTyxFQUFFLG1CQUFPLENBQUMsc0JBQVE7QUFDakMsY0FBYyxtQkFBTyxDQUFDLCtFQUFhOztBQUVuQzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxVQUFVO0FBQ3pCLGVBQWUsUUFBUTtBQUN2QixnQkFBZ0I7QUFDaEIsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFNBQVM7QUFDVDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsUUFBUTtBQUN2QixlQUFlLFVBQVU7QUFDekIsZUFBZSxTQUFTO0FBQ3hCLGVBQWUsU0FBUztBQUN4QixlQUFlLFFBQVE7QUFDdkIsZUFBZSxVQUFVO0FBQ3pCLGVBQWUsYUFBYTtBQUM1QixlQUFlLFNBQVM7QUFDeEIsZUFBZSxTQUFTO0FBQ3hCLGdCQUFnQjtBQUNoQixpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFNBQVM7QUFDVDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkIsZ0JBQWdCO0FBQ2hCLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0EsMkNBQTJDLFNBQVMsWUFBWSxTQUFTO0FBQ3pFO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0EsU0FBUztBQUNUOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkIsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsVUFBVTtBQUN6QixlQUFlLFNBQVM7QUFDeEIsZUFBZSxTQUFTO0FBQ3hCLGVBQWUsUUFBUTtBQUN2QixlQUFlLFVBQVU7QUFDekIsZUFBZSxhQUFhO0FBQzVCLGVBQWUsU0FBUztBQUN4QixlQUFlLFNBQVM7QUFDeEIsZ0JBQWdCO0FBQ2hCLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0EsMkNBQTJDLFNBQVMsWUFBWSxTQUFTO0FBQ3pFO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFNBQVM7QUFDVDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCLGdCQUFnQjtBQUNoQixpQkFBaUI7QUFDakI7QUFDQTtBQUNBLDJDQUEyQyxTQUFTLFlBQVksU0FBUztBQUN6RTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBLFNBQVM7QUFDVDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkIsZUFBZSxVQUFVO0FBQ3pCLGVBQWUsUUFBUTtBQUN2QixnQkFBZ0I7QUFDaEIsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQSwyQ0FBMkMsU0FBUyxrQkFBa0IsU0FBUztBQUMvRTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsU0FBUztBQUNUOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsUUFBUTtBQUN2QixlQUFlLFdBQVc7QUFDMUIsZUFBZSxVQUFVO0FBQ3pCLGVBQWUsa0JBQWtCO0FBQ2pDLGdCQUFnQjtBQUNoQixpQkFBaUI7QUFDakI7QUFDQSwrRUFBK0U7QUFDL0UsMkNBQTJDLFNBQVMsa0JBQWtCLFNBQVM7QUFDL0U7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0EsK0JBQStCLHNCQUFzQjtBQUNyRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLGdDQUFnQzs7QUFFaEM7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxtQ0FBbUM7QUFDbkM7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkIsZUFBZSxRQUFRO0FBQ3ZCLGdCQUFnQjtBQUNoQixpQkFBaUI7QUFDakI7QUFDQTtBQUNBLDJDQUEyQyxTQUFTLFFBQVEsT0FBTyxZQUFZLFNBQVMsdUJBQXVCLE9BQU87QUFDdEg7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0EsU0FBUztBQUNUOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QixlQUFlLFFBQVE7QUFDdkIsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsVUFBVTtBQUN6QixnQkFBZ0I7QUFDaEIsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQSwyQ0FBMkMsU0FBUyxRQUFRLE9BQU8sWUFBWSxTQUFTLHVCQUF1QixPQUFPO0FBQ3RIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsU0FBUztBQUNUOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QixlQUFlLFFBQVE7QUFDdkIsZ0JBQWdCO0FBQ2hCLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0EsMkNBQTJDLFNBQVMsUUFBUSxPQUFPLFlBQVksU0FBUyx1QkFBdUIsT0FBTztBQUN0SDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkIsZUFBZSxRQUFRO0FBQ3ZCLGdCQUFnQjtBQUNoQixpQkFBaUI7QUFDakI7QUFDQTtBQUNBLDJDQUEyQyxTQUFTLFFBQVEsT0FBTyxxQkFBcUIsU0FBUyx1QkFBdUIsT0FBTztBQUMvSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsUUFBUTtBQUN2QixlQUFlLFFBQVE7QUFDdkIsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsY0FBYztBQUM3QixlQUFlLFFBQVE7QUFDdkIsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsUUFBUTtBQUN2QixlQUFlLFFBQVE7QUFDdkIsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsUUFBUTtBQUN2QixlQUFlLFFBQVE7QUFDdkIsZUFBZSxhQUFhO0FBQzVCLGdCQUFnQjtBQUNoQixpQkFBaUI7QUFDakI7QUFDQTtBQUNBLDJDQUEyQyxTQUFTLFFBQVEsT0FBTyxvQkFBb0IsU0FBUyx1QkFBdUIsT0FBTztBQUM5SDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFNBQVM7QUFDVDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QixlQUFlLFFBQVE7QUFDdkIsZ0JBQWdCO0FBQ2hCLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0EsMkNBQTJDLFNBQVMsUUFBUSxPQUFPLGlCQUFpQixTQUFTLHVCQUF1QixPQUFPO0FBQzNIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBOztBQUVBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vanNtX2JhbmtpbmcvLi9ub2RlX21vZHVsZXMvbm9kZS1hcHB3cml0ZS9saWIvc2VydmljZXMvc3RvcmFnZS5qcz9jMTU3Il0sInNvdXJjZXNDb250ZW50IjpbImNvbnN0IFNlcnZpY2UgPSByZXF1aXJlKCcuLi9zZXJ2aWNlLmpzJyk7XG5jb25zdCBBcHB3cml0ZUV4Y2VwdGlvbiA9IHJlcXVpcmUoJy4uL2V4Y2VwdGlvbi5qcycpO1xuY29uc3QgSW5wdXRGaWxlID0gcmVxdWlyZSgnLi4vaW5wdXRGaWxlLmpzJyk7XG5jb25zdCBjbGllbnQgPSByZXF1aXJlKCcuLi9jbGllbnQuanMnKTtcbmNvbnN0IFN0cmVhbSA9IHJlcXVpcmUoJ3N0cmVhbScpO1xuY29uc3QgeyBwcm9taXNpZnkgfSA9IHJlcXVpcmUoJ3V0aWwnKTtcbmNvbnN0IGZzID0gcmVxdWlyZSgnZnMnKTtcbmNvbnN0IHsgRmlsZSB9ID0gcmVxdWlyZSgndW5kaWNpJyk7XG5jb25zdCBRdWVyeSA9IHJlcXVpcmUoJy4uL3F1ZXJ5LmpzJyk7XG5cbmNsYXNzIFN0b3JhZ2UgZXh0ZW5kcyBTZXJ2aWNlIHtcblxuICAgICBjb25zdHJ1Y3RvcihjbGllbnQpXG4gICAgIHtcbiAgICAgICAgc3VwZXIoY2xpZW50KTtcbiAgICAgfVxuXG5cbiAgICAvKipcbiAgICAgKiBMaXN0IGJ1Y2tldHNcbiAgICAgKlxuICAgICAqIEdldCBhIGxpc3Qgb2YgYWxsIHRoZSBzdG9yYWdlIGJ1Y2tldHMuIFlvdSBjYW4gdXNlIHRoZSBxdWVyeSBwYXJhbXMgdG9cbiAgICAgKiBmaWx0ZXIgeW91ciByZXN1bHRzLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmdbXX0gcXVlcmllc1xuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBzZWFyY2hcbiAgICAgKiBAdGhyb3dzIHtBcHB3cml0ZUV4Y2VwdGlvbn1cbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZX1cbiAgICAgKi9cbiAgICBhc3luYyBsaXN0QnVja2V0cyhxdWVyaWVzLCBzZWFyY2gpIHtcbiAgICAgICAgY29uc3QgYXBpUGF0aCA9ICcvc3RvcmFnZS9idWNrZXRzJztcbiAgICAgICAgbGV0IHBheWxvYWQgPSB7fTtcblxuICAgICAgICBpZiAodHlwZW9mIHF1ZXJpZXMgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICBwYXlsb2FkWydxdWVyaWVzJ10gPSBxdWVyaWVzO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHR5cGVvZiBzZWFyY2ggIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICBwYXlsb2FkWydzZWFyY2gnXSA9IHNlYXJjaDtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBhd2FpdCB0aGlzLmNsaWVudC5jYWxsKCdnZXQnLCBhcGlQYXRoLCB7XG4gICAgICAgICAgICAnY29udGVudC10eXBlJzogJ2FwcGxpY2F0aW9uL2pzb24nLFxuICAgICAgICB9LCBwYXlsb2FkKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGUgYnVja2V0XG4gICAgICpcbiAgICAgKiBDcmVhdGUgYSBuZXcgc3RvcmFnZSBidWNrZXQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gYnVja2V0SWRcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gbmFtZVxuICAgICAqIEBwYXJhbSB7c3RyaW5nW119IHBlcm1pc3Npb25zXG4gICAgICogQHBhcmFtIHtib29sZWFufSBmaWxlU2VjdXJpdHlcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IGVuYWJsZWRcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gbWF4aW11bUZpbGVTaXplXG4gICAgICogQHBhcmFtIHtzdHJpbmdbXX0gYWxsb3dlZEZpbGVFeHRlbnNpb25zXG4gICAgICogQHBhcmFtIHtDb21wcmVzc2lvbn0gY29tcHJlc3Npb25cbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IGVuY3J5cHRpb25cbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IGFudGl2aXJ1c1xuICAgICAqIEB0aHJvd3Mge0FwcHdyaXRlRXhjZXB0aW9ufVxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlfVxuICAgICAqL1xuICAgIGFzeW5jIGNyZWF0ZUJ1Y2tldChidWNrZXRJZCwgbmFtZSwgcGVybWlzc2lvbnMsIGZpbGVTZWN1cml0eSwgZW5hYmxlZCwgbWF4aW11bUZpbGVTaXplLCBhbGxvd2VkRmlsZUV4dGVuc2lvbnMsIGNvbXByZXNzaW9uLCBlbmNyeXB0aW9uLCBhbnRpdmlydXMpIHtcbiAgICAgICAgY29uc3QgYXBpUGF0aCA9ICcvc3RvcmFnZS9idWNrZXRzJztcbiAgICAgICAgbGV0IHBheWxvYWQgPSB7fTtcbiAgICAgICAgaWYgKHR5cGVvZiBidWNrZXRJZCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBBcHB3cml0ZUV4Y2VwdGlvbignTWlzc2luZyByZXF1aXJlZCBwYXJhbWV0ZXI6IFwiYnVja2V0SWRcIicpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHR5cGVvZiBuYW1lID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEFwcHdyaXRlRXhjZXB0aW9uKCdNaXNzaW5nIHJlcXVpcmVkIHBhcmFtZXRlcjogXCJuYW1lXCInKTtcbiAgICAgICAgfVxuXG5cbiAgICAgICAgaWYgKHR5cGVvZiBidWNrZXRJZCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHBheWxvYWRbJ2J1Y2tldElkJ10gPSBidWNrZXRJZDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0eXBlb2YgbmFtZSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHBheWxvYWRbJ25hbWUnXSA9IG5hbWU7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodHlwZW9mIHBlcm1pc3Npb25zICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgcGF5bG9hZFsncGVybWlzc2lvbnMnXSA9IHBlcm1pc3Npb25zO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHR5cGVvZiBmaWxlU2VjdXJpdHkgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICBwYXlsb2FkWydmaWxlU2VjdXJpdHknXSA9IGZpbGVTZWN1cml0eTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0eXBlb2YgZW5hYmxlZCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHBheWxvYWRbJ2VuYWJsZWQnXSA9IGVuYWJsZWQ7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodHlwZW9mIG1heGltdW1GaWxlU2l6ZSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHBheWxvYWRbJ21heGltdW1GaWxlU2l6ZSddID0gbWF4aW11bUZpbGVTaXplO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHR5cGVvZiBhbGxvd2VkRmlsZUV4dGVuc2lvbnMgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICBwYXlsb2FkWydhbGxvd2VkRmlsZUV4dGVuc2lvbnMnXSA9IGFsbG93ZWRGaWxlRXh0ZW5zaW9ucztcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0eXBlb2YgY29tcHJlc3Npb24gIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICBwYXlsb2FkWydjb21wcmVzc2lvbiddID0gY29tcHJlc3Npb247XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodHlwZW9mIGVuY3J5cHRpb24gIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICBwYXlsb2FkWydlbmNyeXB0aW9uJ10gPSBlbmNyeXB0aW9uO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHR5cGVvZiBhbnRpdmlydXMgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICBwYXlsb2FkWydhbnRpdmlydXMnXSA9IGFudGl2aXJ1cztcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBhd2FpdCB0aGlzLmNsaWVudC5jYWxsKCdwb3N0JywgYXBpUGF0aCwge1xuICAgICAgICAgICAgJ2NvbnRlbnQtdHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJyxcbiAgICAgICAgfSwgcGF5bG9hZCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2V0IGJ1Y2tldFxuICAgICAqXG4gICAgICogR2V0IGEgc3RvcmFnZSBidWNrZXQgYnkgaXRzIHVuaXF1ZSBJRC4gVGhpcyBlbmRwb2ludCByZXNwb25zZSByZXR1cm5zIGFcbiAgICAgKiBKU09OIG9iamVjdCB3aXRoIHRoZSBzdG9yYWdlIGJ1Y2tldCBtZXRhZGF0YS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBidWNrZXRJZFxuICAgICAqIEB0aHJvd3Mge0FwcHdyaXRlRXhjZXB0aW9ufVxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlfVxuICAgICAqL1xuICAgIGFzeW5jIGdldEJ1Y2tldChidWNrZXRJZCkge1xuICAgICAgICBjb25zdCBhcGlQYXRoID0gJy9zdG9yYWdlL2J1Y2tldHMve2J1Y2tldElkfScucmVwbGFjZSgne2J1Y2tldElkfScsIGJ1Y2tldElkKTtcbiAgICAgICAgbGV0IHBheWxvYWQgPSB7fTtcbiAgICAgICAgaWYgKHR5cGVvZiBidWNrZXRJZCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBBcHB3cml0ZUV4Y2VwdGlvbignTWlzc2luZyByZXF1aXJlZCBwYXJhbWV0ZXI6IFwiYnVja2V0SWRcIicpO1xuICAgICAgICB9XG5cblxuICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy5jbGllbnQuY2FsbCgnZ2V0JywgYXBpUGF0aCwge1xuICAgICAgICAgICAgJ2NvbnRlbnQtdHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJyxcbiAgICAgICAgfSwgcGF5bG9hZCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVXBkYXRlIGJ1Y2tldFxuICAgICAqXG4gICAgICogVXBkYXRlIGEgc3RvcmFnZSBidWNrZXQgYnkgaXRzIHVuaXF1ZSBJRC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBidWNrZXRJZFxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lXG4gICAgICogQHBhcmFtIHtzdHJpbmdbXX0gcGVybWlzc2lvbnNcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IGZpbGVTZWN1cml0eVxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gZW5hYmxlZFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBtYXhpbXVtRmlsZVNpemVcbiAgICAgKiBAcGFyYW0ge3N0cmluZ1tdfSBhbGxvd2VkRmlsZUV4dGVuc2lvbnNcbiAgICAgKiBAcGFyYW0ge0NvbXByZXNzaW9ufSBjb21wcmVzc2lvblxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gZW5jcnlwdGlvblxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gYW50aXZpcnVzXG4gICAgICogQHRocm93cyB7QXBwd3JpdGVFeGNlcHRpb259XG4gICAgICogQHJldHVybnMge1Byb21pc2V9XG4gICAgICovXG4gICAgYXN5bmMgdXBkYXRlQnVja2V0KGJ1Y2tldElkLCBuYW1lLCBwZXJtaXNzaW9ucywgZmlsZVNlY3VyaXR5LCBlbmFibGVkLCBtYXhpbXVtRmlsZVNpemUsIGFsbG93ZWRGaWxlRXh0ZW5zaW9ucywgY29tcHJlc3Npb24sIGVuY3J5cHRpb24sIGFudGl2aXJ1cykge1xuICAgICAgICBjb25zdCBhcGlQYXRoID0gJy9zdG9yYWdlL2J1Y2tldHMve2J1Y2tldElkfScucmVwbGFjZSgne2J1Y2tldElkfScsIGJ1Y2tldElkKTtcbiAgICAgICAgbGV0IHBheWxvYWQgPSB7fTtcbiAgICAgICAgaWYgKHR5cGVvZiBidWNrZXRJZCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBBcHB3cml0ZUV4Y2VwdGlvbignTWlzc2luZyByZXF1aXJlZCBwYXJhbWV0ZXI6IFwiYnVja2V0SWRcIicpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHR5cGVvZiBuYW1lID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEFwcHdyaXRlRXhjZXB0aW9uKCdNaXNzaW5nIHJlcXVpcmVkIHBhcmFtZXRlcjogXCJuYW1lXCInKTtcbiAgICAgICAgfVxuXG5cbiAgICAgICAgaWYgKHR5cGVvZiBuYW1lICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgcGF5bG9hZFsnbmFtZSddID0gbmFtZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0eXBlb2YgcGVybWlzc2lvbnMgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICBwYXlsb2FkWydwZXJtaXNzaW9ucyddID0gcGVybWlzc2lvbnM7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodHlwZW9mIGZpbGVTZWN1cml0eSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHBheWxvYWRbJ2ZpbGVTZWN1cml0eSddID0gZmlsZVNlY3VyaXR5O1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHR5cGVvZiBlbmFibGVkICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgcGF5bG9hZFsnZW5hYmxlZCddID0gZW5hYmxlZDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0eXBlb2YgbWF4aW11bUZpbGVTaXplICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgcGF5bG9hZFsnbWF4aW11bUZpbGVTaXplJ10gPSBtYXhpbXVtRmlsZVNpemU7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodHlwZW9mIGFsbG93ZWRGaWxlRXh0ZW5zaW9ucyAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHBheWxvYWRbJ2FsbG93ZWRGaWxlRXh0ZW5zaW9ucyddID0gYWxsb3dlZEZpbGVFeHRlbnNpb25zO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHR5cGVvZiBjb21wcmVzc2lvbiAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHBheWxvYWRbJ2NvbXByZXNzaW9uJ10gPSBjb21wcmVzc2lvbjtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0eXBlb2YgZW5jcnlwdGlvbiAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHBheWxvYWRbJ2VuY3J5cHRpb24nXSA9IGVuY3J5cHRpb247XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodHlwZW9mIGFudGl2aXJ1cyAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHBheWxvYWRbJ2FudGl2aXJ1cyddID0gYW50aXZpcnVzO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMuY2xpZW50LmNhbGwoJ3B1dCcsIGFwaVBhdGgsIHtcbiAgICAgICAgICAgICdjb250ZW50LXR5cGUnOiAnYXBwbGljYXRpb24vanNvbicsXG4gICAgICAgIH0sIHBheWxvYWQpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIERlbGV0ZSBidWNrZXRcbiAgICAgKlxuICAgICAqIERlbGV0ZSBhIHN0b3JhZ2UgYnVja2V0IGJ5IGl0cyB1bmlxdWUgSUQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gYnVja2V0SWRcbiAgICAgKiBAdGhyb3dzIHtBcHB3cml0ZUV4Y2VwdGlvbn1cbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZX1cbiAgICAgKi9cbiAgICBhc3luYyBkZWxldGVCdWNrZXQoYnVja2V0SWQpIHtcbiAgICAgICAgY29uc3QgYXBpUGF0aCA9ICcvc3RvcmFnZS9idWNrZXRzL3tidWNrZXRJZH0nLnJlcGxhY2UoJ3tidWNrZXRJZH0nLCBidWNrZXRJZCk7XG4gICAgICAgIGxldCBwYXlsb2FkID0ge307XG4gICAgICAgIGlmICh0eXBlb2YgYnVja2V0SWQgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgQXBwd3JpdGVFeGNlcHRpb24oJ01pc3NpbmcgcmVxdWlyZWQgcGFyYW1ldGVyOiBcImJ1Y2tldElkXCInKTtcbiAgICAgICAgfVxuXG5cbiAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMuY2xpZW50LmNhbGwoJ2RlbGV0ZScsIGFwaVBhdGgsIHtcbiAgICAgICAgICAgICdjb250ZW50LXR5cGUnOiAnYXBwbGljYXRpb24vanNvbicsXG4gICAgICAgIH0sIHBheWxvYWQpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIExpc3QgZmlsZXNcbiAgICAgKlxuICAgICAqIEdldCBhIGxpc3Qgb2YgYWxsIHRoZSB1c2VyIGZpbGVzLiBZb3UgY2FuIHVzZSB0aGUgcXVlcnkgcGFyYW1zIHRvIGZpbHRlclxuICAgICAqIHlvdXIgcmVzdWx0cy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBidWNrZXRJZFxuICAgICAqIEBwYXJhbSB7c3RyaW5nW119IHF1ZXJpZXNcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gc2VhcmNoXG4gICAgICogQHRocm93cyB7QXBwd3JpdGVFeGNlcHRpb259XG4gICAgICogQHJldHVybnMge1Byb21pc2V9XG4gICAgICovXG4gICAgYXN5bmMgbGlzdEZpbGVzKGJ1Y2tldElkLCBxdWVyaWVzLCBzZWFyY2gpIHtcbiAgICAgICAgY29uc3QgYXBpUGF0aCA9ICcvc3RvcmFnZS9idWNrZXRzL3tidWNrZXRJZH0vZmlsZXMnLnJlcGxhY2UoJ3tidWNrZXRJZH0nLCBidWNrZXRJZCk7XG4gICAgICAgIGxldCBwYXlsb2FkID0ge307XG4gICAgICAgIGlmICh0eXBlb2YgYnVja2V0SWQgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgQXBwd3JpdGVFeGNlcHRpb24oJ01pc3NpbmcgcmVxdWlyZWQgcGFyYW1ldGVyOiBcImJ1Y2tldElkXCInKTtcbiAgICAgICAgfVxuXG5cbiAgICAgICAgaWYgKHR5cGVvZiBxdWVyaWVzICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgcGF5bG9hZFsncXVlcmllcyddID0gcXVlcmllcztcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0eXBlb2Ygc2VhcmNoICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgcGF5bG9hZFsnc2VhcmNoJ10gPSBzZWFyY2g7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy5jbGllbnQuY2FsbCgnZ2V0JywgYXBpUGF0aCwge1xuICAgICAgICAgICAgJ2NvbnRlbnQtdHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJyxcbiAgICAgICAgfSwgcGF5bG9hZCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlIGZpbGVcbiAgICAgKlxuICAgICAqIENyZWF0ZSBhIG5ldyBmaWxlLiBCZWZvcmUgdXNpbmcgdGhpcyByb3V0ZSwgeW91IHNob3VsZCBjcmVhdGUgYSBuZXcgYnVja2V0XG4gICAgICogcmVzb3VyY2UgdXNpbmcgZWl0aGVyIGEgW3NlcnZlclxuICAgICAqIGludGVncmF0aW9uXShodHRwczovL2FwcHdyaXRlLmlvL2RvY3Mvc2VydmVyL3N0b3JhZ2Ujc3RvcmFnZUNyZWF0ZUJ1Y2tldClcbiAgICAgKiBBUEkgb3IgZGlyZWN0bHkgZnJvbSB5b3VyIEFwcHdyaXRlIGNvbnNvbGUuXG4gICAgICogXG4gICAgICogTGFyZ2VyIGZpbGVzIHNob3VsZCBiZSB1cGxvYWRlZCB1c2luZyBtdWx0aXBsZSByZXF1ZXN0cyB3aXRoIHRoZVxuICAgICAqIFtjb250ZW50LXJhbmdlXShodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9IVFRQL0hlYWRlcnMvQ29udGVudC1SYW5nZSlcbiAgICAgKiBoZWFkZXIgdG8gc2VuZCBhIHBhcnRpYWwgcmVxdWVzdCB3aXRoIGEgbWF4aW11bSBzdXBwb3J0ZWQgY2h1bmsgb2YgYDVNQmAuXG4gICAgICogVGhlIGBjb250ZW50LXJhbmdlYCBoZWFkZXIgdmFsdWVzIHNob3VsZCBhbHdheXMgYmUgaW4gYnl0ZXMuXG4gICAgICogXG4gICAgICogV2hlbiB0aGUgZmlyc3QgcmVxdWVzdCBpcyBzZW50LCB0aGUgc2VydmVyIHdpbGwgcmV0dXJuIHRoZSAqKkZpbGUqKiBvYmplY3QsXG4gICAgICogYW5kIHRoZSBzdWJzZXF1ZW50IHBhcnQgcmVxdWVzdCBtdXN0IGluY2x1ZGUgdGhlIGZpbGUncyAqKmlkKiogaW5cbiAgICAgKiBgeC1hcHB3cml0ZS1pZGAgaGVhZGVyIHRvIGFsbG93IHRoZSBzZXJ2ZXIgdG8ga25vdyB0aGF0IHRoZSBwYXJ0aWFsIHVwbG9hZFxuICAgICAqIGlzIGZvciB0aGUgZXhpc3RpbmcgZmlsZSBhbmQgbm90IGZvciBhIG5ldyBvbmUuXG4gICAgICogXG4gICAgICogSWYgeW91J3JlIGNyZWF0aW5nIGEgbmV3IGZpbGUgdXNpbmcgb25lIG9mIHRoZSBBcHB3cml0ZSBTREtzLCBhbGwgdGhlXG4gICAgICogY2h1bmtpbmcgbG9naWMgd2lsbCBiZSBtYW5hZ2VkIGJ5IHRoZSBTREsgaW50ZXJuYWxseS5cbiAgICAgKiBcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBidWNrZXRJZFxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBmaWxlSWRcbiAgICAgKiBAcGFyYW0ge0lucHV0RmlsZX0gZmlsZVxuICAgICAqIEBwYXJhbSB7c3RyaW5nW119IHBlcm1pc3Npb25zXG4gICAgICogQHBhcmFtIHtDYWxsYWJsZUZ1bmN0aW9ufSBvblByb2dyZXNzXG4gICAgICogQHRocm93cyB7QXBwd3JpdGVFeGNlcHRpb259XG4gICAgICogQHJldHVybnMge1Byb21pc2V9XG4gICAgICovXG4gICAgYXN5bmMgY3JlYXRlRmlsZShidWNrZXRJZCwgZmlsZUlkLCBmaWxlLCBwZXJtaXNzaW9ucywgb25Qcm9ncmVzcyA9ICgpID0+IHt9KSB7XG4gICAgICAgIGNvbnN0IGFwaVBhdGggPSAnL3N0b3JhZ2UvYnVja2V0cy97YnVja2V0SWR9L2ZpbGVzJy5yZXBsYWNlKCd7YnVja2V0SWR9JywgYnVja2V0SWQpO1xuICAgICAgICBsZXQgcGF5bG9hZCA9IHt9O1xuICAgICAgICBpZiAodHlwZW9mIGJ1Y2tldElkID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEFwcHdyaXRlRXhjZXB0aW9uKCdNaXNzaW5nIHJlcXVpcmVkIHBhcmFtZXRlcjogXCJidWNrZXRJZFwiJyk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodHlwZW9mIGZpbGVJZCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBBcHB3cml0ZUV4Y2VwdGlvbignTWlzc2luZyByZXF1aXJlZCBwYXJhbWV0ZXI6IFwiZmlsZUlkXCInKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0eXBlb2YgZmlsZSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBBcHB3cml0ZUV4Y2VwdGlvbignTWlzc2luZyByZXF1aXJlZCBwYXJhbWV0ZXI6IFwiZmlsZVwiJyk7XG4gICAgICAgIH1cblxuXG4gICAgICAgIGlmICh0eXBlb2YgZmlsZUlkICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgcGF5bG9hZFsnZmlsZUlkJ10gPSBmaWxlSWQ7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodHlwZW9mIGZpbGUgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICBwYXlsb2FkWydmaWxlJ10gPSBmaWxlO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHR5cGVvZiBwZXJtaXNzaW9ucyAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHBheWxvYWRbJ3Blcm1pc3Npb25zJ10gPSBwZXJtaXNzaW9ucztcbiAgICAgICAgfVxuXG5cbiAgICAgICAgY29uc3Qgc2l6ZSA9IGZpbGUuc2l6ZTtcbiAgICAgICAgXG4gICAgICAgIGNvbnN0IGFwaUhlYWRlcnMgPSB7XG4gICAgICAgICAgICAnY29udGVudC10eXBlJzogJ211bHRpcGFydC9mb3JtLWRhdGEnLFxuICAgICAgICB9O1xuXG4gICAgICAgIGxldCBpZCA9IHVuZGVmaW5lZDtcbiAgICAgICAgbGV0IHJlc3BvbnNlID0gdW5kZWZpbmVkO1xuXG4gICAgICAgIGxldCBjaHVua3NVcGxvYWRlZCA9IDA7XG5cbiAgICAgICAgaWYoZmlsZUlkICE9ICd1bmlxdWUoKScpIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLmNsaWVudC5jYWxsKCdnZXQnLCBhcGlQYXRoICsgJy8nICsgZmlsZUlkLCBhcGlIZWFkZXJzKTtcbiAgICAgICAgICAgICAgICBjaHVua3NVcGxvYWRlZCA9IHJlc3BvbnNlLmNodW5rc1VwbG9hZGVkO1xuICAgICAgICAgICAgfSBjYXRjaChlKSB7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBsZXQgY3VycmVudENodW5rID0gMTtcbiAgICAgICAgbGV0IGN1cnJlbnRQb3NpdGlvbiA9IDA7XG4gICAgICAgIGxldCB1cGxvYWRhYmxlQ2h1bmsgPSBuZXcgVWludDhBcnJheShjbGllbnQuQ0hVTktfU0laRSk7XG4gICAgXG5cbiAgICAgICAgY29uc3QgdXBsb2FkQ2h1bmsgPSBhc3luYyAobGFzdFVwbG9hZCA9IGZhbHNlKSA9PiB7XG4gICAgICAgICAgICBpZihjdXJyZW50Q2h1bmsgPD0gY2h1bmtzVXBsb2FkZWQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGNvbnN0IHN0YXJ0ID0gKChjdXJyZW50Q2h1bmsgLSAxKSAqIGNsaWVudC5DSFVOS19TSVpFKTtcbiAgICAgICAgICAgIGxldCBlbmQgPSBzdGFydCArIGN1cnJlbnRQb3NpdGlvbiAtIDE7XG5cbiAgICAgICAgICAgIGlmKCFsYXN0VXBsb2FkIHx8IGN1cnJlbnRDaHVuayAhPT0gMSkge1xuICAgICAgICAgICAgICAgIGFwaUhlYWRlcnNbJ2NvbnRlbnQtcmFuZ2UnXSA9ICdieXRlcyAnICsgc3RhcnQgKyAnLScgKyBlbmQgKyAnLycgKyBzaXplO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBsZXQgdXBsb2FkYWJsZUNodW5rVHJpbW1lZDtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgaWYoY3VycmVudFBvc2l0aW9uICsgMSA+PSBjbGllbnQuQ0hVTktfU0laRSkge1xuICAgICAgICAgICAgICAgIHVwbG9hZGFibGVDaHVua1RyaW1tZWQgPSB1cGxvYWRhYmxlQ2h1bms7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHVwbG9hZGFibGVDaHVua1RyaW1tZWQgPSBuZXcgVWludDhBcnJheShjdXJyZW50UG9zaXRpb24pO1xuICAgICAgICAgICAgICAgIGZvcihsZXQgaSA9IDA7IGkgPD0gY3VycmVudFBvc2l0aW9uOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgdXBsb2FkYWJsZUNodW5rVHJpbW1lZFtpXSA9IHVwbG9hZGFibGVDaHVua1tpXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChpZCkge1xuICAgICAgICAgICAgICAgIGFwaUhlYWRlcnNbJ3gtYXBwd3JpdGUtaWQnXSA9IGlkO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBwYXlsb2FkWydmaWxlJ10gPSB7IHR5cGU6ICdmaWxlJywgZmlsZTogbmV3IEZpbGUoW3VwbG9hZGFibGVDaHVua1RyaW1tZWRdLCBmaWxlLmZpbGVuYW1lKSwgZmlsZW5hbWU6IGZpbGUuZmlsZW5hbWUgfTtcblxuICAgICAgICAgICAgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLmNsaWVudC5jYWxsKCdwb3N0JywgYXBpUGF0aCwgYXBpSGVhZGVycywgcGF5bG9hZCk7XG5cbiAgICAgICAgICAgIGlmICghaWQpIHtcbiAgICAgICAgICAgICAgICBpZCA9IHJlc3BvbnNlWyckaWQnXTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKG9uUHJvZ3Jlc3MgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICBvblByb2dyZXNzKHtcbiAgICAgICAgICAgICAgICAgICAgJGlkOiByZXNwb25zZVsnJGlkJ10sXG4gICAgICAgICAgICAgICAgICAgIHByb2dyZXNzOiBNYXRoLm1pbigoY3VycmVudENodW5rKSAqIGNsaWVudC5DSFVOS19TSVpFLCBzaXplKSAvIHNpemUgKiAxMDAsXG4gICAgICAgICAgICAgICAgICAgIHNpemVVcGxvYWRlZDogZW5kKzEsXG4gICAgICAgICAgICAgICAgICAgIGNodW5rc1RvdGFsOiByZXNwb25zZVsnY2h1bmtzVG90YWwnXSxcbiAgICAgICAgICAgICAgICAgICAgY2h1bmtzVXBsb2FkZWQ6IHJlc3BvbnNlWydjaHVua3NVcGxvYWRlZCddXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHVwbG9hZGFibGVDaHVuayA9IG5ldyBVaW50OEFycmF5KGNsaWVudC5DSFVOS19TSVpFKTtcbiAgICAgICAgICAgIGN1cnJlbnRDaHVuaysrO1xuICAgICAgICAgICAgY3VycmVudFBvc2l0aW9uID0gMDtcbiAgICAgICAgfVxuXG4gICAgICAgIGZvciBhd2FpdCAoY29uc3QgY2h1bmsgb2YgZmlsZS5zdHJlYW0pIHtcbiAgICAgICAgICAgIGZvcihjb25zdCBiIG9mIGNodW5rKSB7XG4gICAgICAgICAgICAgICAgdXBsb2FkYWJsZUNodW5rW2N1cnJlbnRQb3NpdGlvbl0gPSBiO1xuXG4gICAgICAgICAgICAgICAgY3VycmVudFBvc2l0aW9uKys7XG4gICAgICAgICAgICAgICAgaWYoY3VycmVudFBvc2l0aW9uID49IGNsaWVudC5DSFVOS19TSVpFKSB7XG4gICAgICAgICAgICAgICAgICAgIGF3YWl0IHVwbG9hZENodW5rKCk7XG4gICAgICAgICAgICAgICAgICAgIGN1cnJlbnRQb3NpdGlvbiA9IDA7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGN1cnJlbnRQb3NpdGlvbiA+IDApIHsgLy8gQ2hlY2sgaWYgdGhlcmUncyBhbnkgcmVtYWluaW5nIGRhdGEgZm9yIHRoZSBsYXN0IGNodW5rXG4gICAgICAgICAgICBhd2FpdCB1cGxvYWRDaHVuayh0cnVlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiByZXNwb25zZTtcblxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdldCBmaWxlXG4gICAgICpcbiAgICAgKiBHZXQgYSBmaWxlIGJ5IGl0cyB1bmlxdWUgSUQuIFRoaXMgZW5kcG9pbnQgcmVzcG9uc2UgcmV0dXJucyBhIEpTT04gb2JqZWN0XG4gICAgICogd2l0aCB0aGUgZmlsZSBtZXRhZGF0YS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBidWNrZXRJZFxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBmaWxlSWRcbiAgICAgKiBAdGhyb3dzIHtBcHB3cml0ZUV4Y2VwdGlvbn1cbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZX1cbiAgICAgKi9cbiAgICBhc3luYyBnZXRGaWxlKGJ1Y2tldElkLCBmaWxlSWQpIHtcbiAgICAgICAgY29uc3QgYXBpUGF0aCA9ICcvc3RvcmFnZS9idWNrZXRzL3tidWNrZXRJZH0vZmlsZXMve2ZpbGVJZH0nLnJlcGxhY2UoJ3tidWNrZXRJZH0nLCBidWNrZXRJZCkucmVwbGFjZSgne2ZpbGVJZH0nLCBmaWxlSWQpO1xuICAgICAgICBsZXQgcGF5bG9hZCA9IHt9O1xuICAgICAgICBpZiAodHlwZW9mIGJ1Y2tldElkID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEFwcHdyaXRlRXhjZXB0aW9uKCdNaXNzaW5nIHJlcXVpcmVkIHBhcmFtZXRlcjogXCJidWNrZXRJZFwiJyk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodHlwZW9mIGZpbGVJZCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBBcHB3cml0ZUV4Y2VwdGlvbignTWlzc2luZyByZXF1aXJlZCBwYXJhbWV0ZXI6IFwiZmlsZUlkXCInKTtcbiAgICAgICAgfVxuXG5cbiAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMuY2xpZW50LmNhbGwoJ2dldCcsIGFwaVBhdGgsIHtcbiAgICAgICAgICAgICdjb250ZW50LXR5cGUnOiAnYXBwbGljYXRpb24vanNvbicsXG4gICAgICAgIH0sIHBheWxvYWQpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFVwZGF0ZSBmaWxlXG4gICAgICpcbiAgICAgKiBVcGRhdGUgYSBmaWxlIGJ5IGl0cyB1bmlxdWUgSUQuIE9ubHkgdXNlcnMgd2l0aCB3cml0ZSBwZXJtaXNzaW9ucyBoYXZlXG4gICAgICogYWNjZXNzIHRvIHVwZGF0ZSB0aGlzIHJlc291cmNlLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGJ1Y2tldElkXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGZpbGVJZFxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lXG4gICAgICogQHBhcmFtIHtzdHJpbmdbXX0gcGVybWlzc2lvbnNcbiAgICAgKiBAdGhyb3dzIHtBcHB3cml0ZUV4Y2VwdGlvbn1cbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZX1cbiAgICAgKi9cbiAgICBhc3luYyB1cGRhdGVGaWxlKGJ1Y2tldElkLCBmaWxlSWQsIG5hbWUsIHBlcm1pc3Npb25zKSB7XG4gICAgICAgIGNvbnN0IGFwaVBhdGggPSAnL3N0b3JhZ2UvYnVja2V0cy97YnVja2V0SWR9L2ZpbGVzL3tmaWxlSWR9Jy5yZXBsYWNlKCd7YnVja2V0SWR9JywgYnVja2V0SWQpLnJlcGxhY2UoJ3tmaWxlSWR9JywgZmlsZUlkKTtcbiAgICAgICAgbGV0IHBheWxvYWQgPSB7fTtcbiAgICAgICAgaWYgKHR5cGVvZiBidWNrZXRJZCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBBcHB3cml0ZUV4Y2VwdGlvbignTWlzc2luZyByZXF1aXJlZCBwYXJhbWV0ZXI6IFwiYnVja2V0SWRcIicpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHR5cGVvZiBmaWxlSWQgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgQXBwd3JpdGVFeGNlcHRpb24oJ01pc3NpbmcgcmVxdWlyZWQgcGFyYW1ldGVyOiBcImZpbGVJZFwiJyk7XG4gICAgICAgIH1cblxuXG4gICAgICAgIGlmICh0eXBlb2YgbmFtZSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHBheWxvYWRbJ25hbWUnXSA9IG5hbWU7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodHlwZW9mIHBlcm1pc3Npb25zICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgcGF5bG9hZFsncGVybWlzc2lvbnMnXSA9IHBlcm1pc3Npb25zO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMuY2xpZW50LmNhbGwoJ3B1dCcsIGFwaVBhdGgsIHtcbiAgICAgICAgICAgICdjb250ZW50LXR5cGUnOiAnYXBwbGljYXRpb24vanNvbicsXG4gICAgICAgIH0sIHBheWxvYWQpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIERlbGV0ZSBGaWxlXG4gICAgICpcbiAgICAgKiBEZWxldGUgYSBmaWxlIGJ5IGl0cyB1bmlxdWUgSUQuIE9ubHkgdXNlcnMgd2l0aCB3cml0ZSBwZXJtaXNzaW9ucyBoYXZlXG4gICAgICogYWNjZXNzIHRvIGRlbGV0ZSB0aGlzIHJlc291cmNlLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGJ1Y2tldElkXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGZpbGVJZFxuICAgICAqIEB0aHJvd3Mge0FwcHdyaXRlRXhjZXB0aW9ufVxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlfVxuICAgICAqL1xuICAgIGFzeW5jIGRlbGV0ZUZpbGUoYnVja2V0SWQsIGZpbGVJZCkge1xuICAgICAgICBjb25zdCBhcGlQYXRoID0gJy9zdG9yYWdlL2J1Y2tldHMve2J1Y2tldElkfS9maWxlcy97ZmlsZUlkfScucmVwbGFjZSgne2J1Y2tldElkfScsIGJ1Y2tldElkKS5yZXBsYWNlKCd7ZmlsZUlkfScsIGZpbGVJZCk7XG4gICAgICAgIGxldCBwYXlsb2FkID0ge307XG4gICAgICAgIGlmICh0eXBlb2YgYnVja2V0SWQgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgQXBwd3JpdGVFeGNlcHRpb24oJ01pc3NpbmcgcmVxdWlyZWQgcGFyYW1ldGVyOiBcImJ1Y2tldElkXCInKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0eXBlb2YgZmlsZUlkID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEFwcHdyaXRlRXhjZXB0aW9uKCdNaXNzaW5nIHJlcXVpcmVkIHBhcmFtZXRlcjogXCJmaWxlSWRcIicpO1xuICAgICAgICB9XG5cblxuICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy5jbGllbnQuY2FsbCgnZGVsZXRlJywgYXBpUGF0aCwge1xuICAgICAgICAgICAgJ2NvbnRlbnQtdHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJyxcbiAgICAgICAgfSwgcGF5bG9hZCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2V0IGZpbGUgZm9yIGRvd25sb2FkXG4gICAgICpcbiAgICAgKiBHZXQgYSBmaWxlIGNvbnRlbnQgYnkgaXRzIHVuaXF1ZSBJRC4gVGhlIGVuZHBvaW50IHJlc3BvbnNlIHJldHVybiB3aXRoIGFcbiAgICAgKiAnQ29udGVudC1EaXNwb3NpdGlvbjogYXR0YWNobWVudCcgaGVhZGVyIHRoYXQgdGVsbHMgdGhlIGJyb3dzZXIgdG8gc3RhcnRcbiAgICAgKiBkb3dubG9hZGluZyB0aGUgZmlsZSB0byB1c2VyIGRvd25sb2FkcyBkaXJlY3RvcnkuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gYnVja2V0SWRcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gZmlsZUlkXG4gICAgICogQHRocm93cyB7QXBwd3JpdGVFeGNlcHRpb259XG4gICAgICogQHJldHVybnMge1Byb21pc2V9XG4gICAgICovXG4gICAgYXN5bmMgZ2V0RmlsZURvd25sb2FkKGJ1Y2tldElkLCBmaWxlSWQpIHtcbiAgICAgICAgY29uc3QgYXBpUGF0aCA9ICcvc3RvcmFnZS9idWNrZXRzL3tidWNrZXRJZH0vZmlsZXMve2ZpbGVJZH0vZG93bmxvYWQnLnJlcGxhY2UoJ3tidWNrZXRJZH0nLCBidWNrZXRJZCkucmVwbGFjZSgne2ZpbGVJZH0nLCBmaWxlSWQpO1xuICAgICAgICBsZXQgcGF5bG9hZCA9IHt9O1xuICAgICAgICBpZiAodHlwZW9mIGJ1Y2tldElkID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEFwcHdyaXRlRXhjZXB0aW9uKCdNaXNzaW5nIHJlcXVpcmVkIHBhcmFtZXRlcjogXCJidWNrZXRJZFwiJyk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodHlwZW9mIGZpbGVJZCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBBcHB3cml0ZUV4Y2VwdGlvbignTWlzc2luZyByZXF1aXJlZCBwYXJhbWV0ZXI6IFwiZmlsZUlkXCInKTtcbiAgICAgICAgfVxuXG5cbiAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMuY2xpZW50LmNhbGwoJ2dldCcsIGFwaVBhdGgsIHtcbiAgICAgICAgICAgICdjb250ZW50LXR5cGUnOiAnYXBwbGljYXRpb24vanNvbicsXG4gICAgICAgIH0sIHBheWxvYWQsICdhcnJheWJ1ZmZlcicpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdldCBmaWxlIHByZXZpZXdcbiAgICAgKlxuICAgICAqIEdldCBhIGZpbGUgcHJldmlldyBpbWFnZS4gQ3VycmVudGx5LCB0aGlzIG1ldGhvZCBzdXBwb3J0cyBwcmV2aWV3IGZvciBpbWFnZVxuICAgICAqIGZpbGVzIChqcGcsIHBuZywgYW5kIGdpZiksIG90aGVyIHN1cHBvcnRlZCBmb3JtYXRzLCBsaWtlIHBkZiwgZG9jcywgc2xpZGVzLFxuICAgICAqIGFuZCBzcHJlYWRzaGVldHMsIHdpbGwgcmV0dXJuIHRoZSBmaWxlIGljb24gaW1hZ2UuIFlvdSBjYW4gYWxzbyBwYXNzIHF1ZXJ5XG4gICAgICogc3RyaW5nIGFyZ3VtZW50cyBmb3IgY3V0dGluZyBhbmQgcmVzaXppbmcgeW91ciBwcmV2aWV3IGltYWdlLiBQcmV2aWV3IGlzXG4gICAgICogc3VwcG9ydGVkIG9ubHkgZm9yIGltYWdlIGZpbGVzIHNtYWxsZXIgdGhhbiAxME1CLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGJ1Y2tldElkXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGZpbGVJZFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB3aWR0aFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBoZWlnaHRcbiAgICAgKiBAcGFyYW0ge0ltYWdlR3Jhdml0eX0gZ3Jhdml0eVxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBxdWFsaXR5XG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGJvcmRlcldpZHRoXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGJvcmRlckNvbG9yXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGJvcmRlclJhZGl1c1xuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBvcGFjaXR5XG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHJvdGF0aW9uXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGJhY2tncm91bmRcbiAgICAgKiBAcGFyYW0ge0ltYWdlRm9ybWF0fSBvdXRwdXRcbiAgICAgKiBAdGhyb3dzIHtBcHB3cml0ZUV4Y2VwdGlvbn1cbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZX1cbiAgICAgKi9cbiAgICBhc3luYyBnZXRGaWxlUHJldmlldyhidWNrZXRJZCwgZmlsZUlkLCB3aWR0aCwgaGVpZ2h0LCBncmF2aXR5LCBxdWFsaXR5LCBib3JkZXJXaWR0aCwgYm9yZGVyQ29sb3IsIGJvcmRlclJhZGl1cywgb3BhY2l0eSwgcm90YXRpb24sIGJhY2tncm91bmQsIG91dHB1dCkge1xuICAgICAgICBjb25zdCBhcGlQYXRoID0gJy9zdG9yYWdlL2J1Y2tldHMve2J1Y2tldElkfS9maWxlcy97ZmlsZUlkfS9wcmV2aWV3Jy5yZXBsYWNlKCd7YnVja2V0SWR9JywgYnVja2V0SWQpLnJlcGxhY2UoJ3tmaWxlSWR9JywgZmlsZUlkKTtcbiAgICAgICAgbGV0IHBheWxvYWQgPSB7fTtcbiAgICAgICAgaWYgKHR5cGVvZiBidWNrZXRJZCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBBcHB3cml0ZUV4Y2VwdGlvbignTWlzc2luZyByZXF1aXJlZCBwYXJhbWV0ZXI6IFwiYnVja2V0SWRcIicpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHR5cGVvZiBmaWxlSWQgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgQXBwd3JpdGVFeGNlcHRpb24oJ01pc3NpbmcgcmVxdWlyZWQgcGFyYW1ldGVyOiBcImZpbGVJZFwiJyk7XG4gICAgICAgIH1cblxuXG4gICAgICAgIGlmICh0eXBlb2Ygd2lkdGggIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICBwYXlsb2FkWyd3aWR0aCddID0gd2lkdGg7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodHlwZW9mIGhlaWdodCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHBheWxvYWRbJ2hlaWdodCddID0gaGVpZ2h0O1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHR5cGVvZiBncmF2aXR5ICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgcGF5bG9hZFsnZ3Jhdml0eSddID0gZ3Jhdml0eTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0eXBlb2YgcXVhbGl0eSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHBheWxvYWRbJ3F1YWxpdHknXSA9IHF1YWxpdHk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodHlwZW9mIGJvcmRlcldpZHRoICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgcGF5bG9hZFsnYm9yZGVyV2lkdGgnXSA9IGJvcmRlcldpZHRoO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHR5cGVvZiBib3JkZXJDb2xvciAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHBheWxvYWRbJ2JvcmRlckNvbG9yJ10gPSBib3JkZXJDb2xvcjtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0eXBlb2YgYm9yZGVyUmFkaXVzICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgcGF5bG9hZFsnYm9yZGVyUmFkaXVzJ10gPSBib3JkZXJSYWRpdXM7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodHlwZW9mIG9wYWNpdHkgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICBwYXlsb2FkWydvcGFjaXR5J10gPSBvcGFjaXR5O1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHR5cGVvZiByb3RhdGlvbiAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHBheWxvYWRbJ3JvdGF0aW9uJ10gPSByb3RhdGlvbjtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0eXBlb2YgYmFja2dyb3VuZCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHBheWxvYWRbJ2JhY2tncm91bmQnXSA9IGJhY2tncm91bmQ7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodHlwZW9mIG91dHB1dCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHBheWxvYWRbJ291dHB1dCddID0gb3V0cHV0O1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMuY2xpZW50LmNhbGwoJ2dldCcsIGFwaVBhdGgsIHtcbiAgICAgICAgICAgICdjb250ZW50LXR5cGUnOiAnYXBwbGljYXRpb24vanNvbicsXG4gICAgICAgIH0sIHBheWxvYWQsICdhcnJheWJ1ZmZlcicpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdldCBmaWxlIGZvciB2aWV3XG4gICAgICpcbiAgICAgKiBHZXQgYSBmaWxlIGNvbnRlbnQgYnkgaXRzIHVuaXF1ZSBJRC4gVGhpcyBlbmRwb2ludCBpcyBzaW1pbGFyIHRvIHRoZVxuICAgICAqIGRvd25sb2FkIG1ldGhvZCBidXQgcmV0dXJucyB3aXRoIG5vICAnQ29udGVudC1EaXNwb3NpdGlvbjogYXR0YWNobWVudCdcbiAgICAgKiBoZWFkZXIuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gYnVja2V0SWRcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gZmlsZUlkXG4gICAgICogQHRocm93cyB7QXBwd3JpdGVFeGNlcHRpb259XG4gICAgICogQHJldHVybnMge1Byb21pc2V9XG4gICAgICovXG4gICAgYXN5bmMgZ2V0RmlsZVZpZXcoYnVja2V0SWQsIGZpbGVJZCkge1xuICAgICAgICBjb25zdCBhcGlQYXRoID0gJy9zdG9yYWdlL2J1Y2tldHMve2J1Y2tldElkfS9maWxlcy97ZmlsZUlkfS92aWV3Jy5yZXBsYWNlKCd7YnVja2V0SWR9JywgYnVja2V0SWQpLnJlcGxhY2UoJ3tmaWxlSWR9JywgZmlsZUlkKTtcbiAgICAgICAgbGV0IHBheWxvYWQgPSB7fTtcbiAgICAgICAgaWYgKHR5cGVvZiBidWNrZXRJZCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBBcHB3cml0ZUV4Y2VwdGlvbignTWlzc2luZyByZXF1aXJlZCBwYXJhbWV0ZXI6IFwiYnVja2V0SWRcIicpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHR5cGVvZiBmaWxlSWQgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgQXBwd3JpdGVFeGNlcHRpb24oJ01pc3NpbmcgcmVxdWlyZWQgcGFyYW1ldGVyOiBcImZpbGVJZFwiJyk7XG4gICAgICAgIH1cblxuXG4gICAgICAgIHJldHVybiBhd2FpdCB0aGlzLmNsaWVudC5jYWxsKCdnZXQnLCBhcGlQYXRoLCB7XG4gICAgICAgICAgICAnY29udGVudC10eXBlJzogJ2FwcGxpY2F0aW9uL2pzb24nLFxuICAgICAgICB9LCBwYXlsb2FkLCAnYXJyYXlidWZmZXInKTtcbiAgICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gU3RvcmFnZTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(action-browser)/./node_modules/node-appwrite/lib/services/storage.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/node-appwrite/lib/services/storage.js":
/*!************************************************************!*\
  !*** ./node_modules/node-appwrite/lib/services/storage.js ***!
  \************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("const Service = __webpack_require__(/*! ../service.js */ \"(rsc)/./node_modules/node-appwrite/lib/service.js\");\nconst AppwriteException = __webpack_require__(/*! ../exception.js */ \"(rsc)/./node_modules/node-appwrite/lib/exception.js\");\nconst InputFile = __webpack_require__(/*! ../inputFile.js */ \"(rsc)/./node_modules/node-appwrite/lib/inputFile.js\");\nconst client = __webpack_require__(/*! ../client.js */ \"(rsc)/./node_modules/node-appwrite/lib/client.js\");\nconst Stream = __webpack_require__(/*! stream */ \"stream\");\nconst { promisify } = __webpack_require__(/*! util */ \"util\");\nconst fs = __webpack_require__(/*! fs */ \"fs\");\nconst { File } = __webpack_require__(/*! undici */ \"undici\");\nconst Query = __webpack_require__(/*! ../query.js */ \"(rsc)/./node_modules/node-appwrite/lib/query.js\");\n\nclass Storage extends Service {\n\n     constructor(client)\n     {\n        super(client);\n     }\n\n\n    /**\n     * List buckets\n     *\n     * Get a list of all the storage buckets. You can use the query params to\n     * filter your results.\n     *\n     * @param {string[]} queries\n     * @param {string} search\n     * @throws {AppwriteException}\n     * @returns {Promise}\n     */\n    async listBuckets(queries, search) {\n        const apiPath = '/storage/buckets';\n        let payload = {};\n\n        if (typeof queries !== 'undefined') {\n            payload['queries'] = queries;\n        }\n\n        if (typeof search !== 'undefined') {\n            payload['search'] = search;\n        }\n\n        return await this.client.call('get', apiPath, {\n            'content-type': 'application/json',\n        }, payload);\n    }\n\n    /**\n     * Create bucket\n     *\n     * Create a new storage bucket.\n     *\n     * @param {string} bucketId\n     * @param {string} name\n     * @param {string[]} permissions\n     * @param {boolean} fileSecurity\n     * @param {boolean} enabled\n     * @param {number} maximumFileSize\n     * @param {string[]} allowedFileExtensions\n     * @param {Compression} compression\n     * @param {boolean} encryption\n     * @param {boolean} antivirus\n     * @throws {AppwriteException}\n     * @returns {Promise}\n     */\n    async createBucket(bucketId, name, permissions, fileSecurity, enabled, maximumFileSize, allowedFileExtensions, compression, encryption, antivirus) {\n        const apiPath = '/storage/buckets';\n        let payload = {};\n        if (typeof bucketId === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"bucketId\"');\n        }\n\n        if (typeof name === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"name\"');\n        }\n\n\n        if (typeof bucketId !== 'undefined') {\n            payload['bucketId'] = bucketId;\n        }\n\n        if (typeof name !== 'undefined') {\n            payload['name'] = name;\n        }\n\n        if (typeof permissions !== 'undefined') {\n            payload['permissions'] = permissions;\n        }\n\n        if (typeof fileSecurity !== 'undefined') {\n            payload['fileSecurity'] = fileSecurity;\n        }\n\n        if (typeof enabled !== 'undefined') {\n            payload['enabled'] = enabled;\n        }\n\n        if (typeof maximumFileSize !== 'undefined') {\n            payload['maximumFileSize'] = maximumFileSize;\n        }\n\n        if (typeof allowedFileExtensions !== 'undefined') {\n            payload['allowedFileExtensions'] = allowedFileExtensions;\n        }\n\n        if (typeof compression !== 'undefined') {\n            payload['compression'] = compression;\n        }\n\n        if (typeof encryption !== 'undefined') {\n            payload['encryption'] = encryption;\n        }\n\n        if (typeof antivirus !== 'undefined') {\n            payload['antivirus'] = antivirus;\n        }\n\n        return await this.client.call('post', apiPath, {\n            'content-type': 'application/json',\n        }, payload);\n    }\n\n    /**\n     * Get bucket\n     *\n     * Get a storage bucket by its unique ID. This endpoint response returns a\n     * JSON object with the storage bucket metadata.\n     *\n     * @param {string} bucketId\n     * @throws {AppwriteException}\n     * @returns {Promise}\n     */\n    async getBucket(bucketId) {\n        const apiPath = '/storage/buckets/{bucketId}'.replace('{bucketId}', bucketId);\n        let payload = {};\n        if (typeof bucketId === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"bucketId\"');\n        }\n\n\n        return await this.client.call('get', apiPath, {\n            'content-type': 'application/json',\n        }, payload);\n    }\n\n    /**\n     * Update bucket\n     *\n     * Update a storage bucket by its unique ID.\n     *\n     * @param {string} bucketId\n     * @param {string} name\n     * @param {string[]} permissions\n     * @param {boolean} fileSecurity\n     * @param {boolean} enabled\n     * @param {number} maximumFileSize\n     * @param {string[]} allowedFileExtensions\n     * @param {Compression} compression\n     * @param {boolean} encryption\n     * @param {boolean} antivirus\n     * @throws {AppwriteException}\n     * @returns {Promise}\n     */\n    async updateBucket(bucketId, name, permissions, fileSecurity, enabled, maximumFileSize, allowedFileExtensions, compression, encryption, antivirus) {\n        const apiPath = '/storage/buckets/{bucketId}'.replace('{bucketId}', bucketId);\n        let payload = {};\n        if (typeof bucketId === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"bucketId\"');\n        }\n\n        if (typeof name === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"name\"');\n        }\n\n\n        if (typeof name !== 'undefined') {\n            payload['name'] = name;\n        }\n\n        if (typeof permissions !== 'undefined') {\n            payload['permissions'] = permissions;\n        }\n\n        if (typeof fileSecurity !== 'undefined') {\n            payload['fileSecurity'] = fileSecurity;\n        }\n\n        if (typeof enabled !== 'undefined') {\n            payload['enabled'] = enabled;\n        }\n\n        if (typeof maximumFileSize !== 'undefined') {\n            payload['maximumFileSize'] = maximumFileSize;\n        }\n\n        if (typeof allowedFileExtensions !== 'undefined') {\n            payload['allowedFileExtensions'] = allowedFileExtensions;\n        }\n\n        if (typeof compression !== 'undefined') {\n            payload['compression'] = compression;\n        }\n\n        if (typeof encryption !== 'undefined') {\n            payload['encryption'] = encryption;\n        }\n\n        if (typeof antivirus !== 'undefined') {\n            payload['antivirus'] = antivirus;\n        }\n\n        return await this.client.call('put', apiPath, {\n            'content-type': 'application/json',\n        }, payload);\n    }\n\n    /**\n     * Delete bucket\n     *\n     * Delete a storage bucket by its unique ID.\n     *\n     * @param {string} bucketId\n     * @throws {AppwriteException}\n     * @returns {Promise}\n     */\n    async deleteBucket(bucketId) {\n        const apiPath = '/storage/buckets/{bucketId}'.replace('{bucketId}', bucketId);\n        let payload = {};\n        if (typeof bucketId === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"bucketId\"');\n        }\n\n\n        return await this.client.call('delete', apiPath, {\n            'content-type': 'application/json',\n        }, payload);\n    }\n\n    /**\n     * List files\n     *\n     * Get a list of all the user files. You can use the query params to filter\n     * your results.\n     *\n     * @param {string} bucketId\n     * @param {string[]} queries\n     * @param {string} search\n     * @throws {AppwriteException}\n     * @returns {Promise}\n     */\n    async listFiles(bucketId, queries, search) {\n        const apiPath = '/storage/buckets/{bucketId}/files'.replace('{bucketId}', bucketId);\n        let payload = {};\n        if (typeof bucketId === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"bucketId\"');\n        }\n\n\n        if (typeof queries !== 'undefined') {\n            payload['queries'] = queries;\n        }\n\n        if (typeof search !== 'undefined') {\n            payload['search'] = search;\n        }\n\n        return await this.client.call('get', apiPath, {\n            'content-type': 'application/json',\n        }, payload);\n    }\n\n    /**\n     * Create file\n     *\n     * Create a new file. Before using this route, you should create a new bucket\n     * resource using either a [server\n     * integration](https://appwrite.io/docs/server/storage#storageCreateBucket)\n     * API or directly from your Appwrite console.\n     * \n     * Larger files should be uploaded using multiple requests with the\n     * [content-range](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Content-Range)\n     * header to send a partial request with a maximum supported chunk of `5MB`.\n     * The `content-range` header values should always be in bytes.\n     * \n     * When the first request is sent, the server will return the **File** object,\n     * and the subsequent part request must include the file's **id** in\n     * `x-appwrite-id` header to allow the server to know that the partial upload\n     * is for the existing file and not for a new one.\n     * \n     * If you're creating a new file using one of the Appwrite SDKs, all the\n     * chunking logic will be managed by the SDK internally.\n     * \n     *\n     * @param {string} bucketId\n     * @param {string} fileId\n     * @param {InputFile} file\n     * @param {string[]} permissions\n     * @param {CallableFunction} onProgress\n     * @throws {AppwriteException}\n     * @returns {Promise}\n     */\n    async createFile(bucketId, fileId, file, permissions, onProgress = () => {}) {\n        const apiPath = '/storage/buckets/{bucketId}/files'.replace('{bucketId}', bucketId);\n        let payload = {};\n        if (typeof bucketId === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"bucketId\"');\n        }\n\n        if (typeof fileId === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"fileId\"');\n        }\n\n        if (typeof file === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"file\"');\n        }\n\n\n        if (typeof fileId !== 'undefined') {\n            payload['fileId'] = fileId;\n        }\n\n        if (typeof file !== 'undefined') {\n            payload['file'] = file;\n        }\n\n        if (typeof permissions !== 'undefined') {\n            payload['permissions'] = permissions;\n        }\n\n\n        const size = file.size;\n        \n        const apiHeaders = {\n            'content-type': 'multipart/form-data',\n        };\n\n        let id = undefined;\n        let response = undefined;\n\n        let chunksUploaded = 0;\n\n        if(fileId != 'unique()') {\n            try {\n                response = await this.client.call('get', apiPath + '/' + fileId, apiHeaders);\n                chunksUploaded = response.chunksUploaded;\n            } catch(e) {\n            }\n        }\n\n        let currentChunk = 1;\n        let currentPosition = 0;\n        let uploadableChunk = new Uint8Array(client.CHUNK_SIZE);\n    \n\n        const uploadChunk = async (lastUpload = false) => {\n            if(currentChunk <= chunksUploaded) {\n                return;\n            }\n\n            const start = ((currentChunk - 1) * client.CHUNK_SIZE);\n            let end = start + currentPosition - 1;\n\n            if(!lastUpload || currentChunk !== 1) {\n                apiHeaders['content-range'] = 'bytes ' + start + '-' + end + '/' + size;\n            }\n\n            let uploadableChunkTrimmed;\n            \n            if(currentPosition + 1 >= client.CHUNK_SIZE) {\n                uploadableChunkTrimmed = uploadableChunk;\n            } else {\n                uploadableChunkTrimmed = new Uint8Array(currentPosition);\n                for(let i = 0; i <= currentPosition; i++) {\n                    uploadableChunkTrimmed[i] = uploadableChunk[i];\n                }\n            }\n\n            if (id) {\n                apiHeaders['x-appwrite-id'] = id;\n            }\n\n            payload['file'] = { type: 'file', file: new File([uploadableChunkTrimmed], file.filename), filename: file.filename };\n\n            response = await this.client.call('post', apiPath, apiHeaders, payload);\n\n            if (!id) {\n                id = response['$id'];\n            }\n\n            if (onProgress !== null) {\n                onProgress({\n                    $id: response['$id'],\n                    progress: Math.min((currentChunk) * client.CHUNK_SIZE, size) / size * 100,\n                    sizeUploaded: end+1,\n                    chunksTotal: response['chunksTotal'],\n                    chunksUploaded: response['chunksUploaded']\n                });\n            }\n\n            uploadableChunk = new Uint8Array(client.CHUNK_SIZE);\n            currentChunk++;\n            currentPosition = 0;\n        }\n\n        for await (const chunk of file.stream) {\n            for(const b of chunk) {\n                uploadableChunk[currentPosition] = b;\n\n                currentPosition++;\n                if(currentPosition >= client.CHUNK_SIZE) {\n                    await uploadChunk();\n                    currentPosition = 0;\n                }\n            }\n        }\n\n        if (currentPosition > 0) { // Check if there's any remaining data for the last chunk\n            await uploadChunk(true);\n        }\n\n        return response;\n\n    }\n\n    /**\n     * Get file\n     *\n     * Get a file by its unique ID. This endpoint response returns a JSON object\n     * with the file metadata.\n     *\n     * @param {string} bucketId\n     * @param {string} fileId\n     * @throws {AppwriteException}\n     * @returns {Promise}\n     */\n    async getFile(bucketId, fileId) {\n        const apiPath = '/storage/buckets/{bucketId}/files/{fileId}'.replace('{bucketId}', bucketId).replace('{fileId}', fileId);\n        let payload = {};\n        if (typeof bucketId === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"bucketId\"');\n        }\n\n        if (typeof fileId === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"fileId\"');\n        }\n\n\n        return await this.client.call('get', apiPath, {\n            'content-type': 'application/json',\n        }, payload);\n    }\n\n    /**\n     * Update file\n     *\n     * Update a file by its unique ID. Only users with write permissions have\n     * access to update this resource.\n     *\n     * @param {string} bucketId\n     * @param {string} fileId\n     * @param {string} name\n     * @param {string[]} permissions\n     * @throws {AppwriteException}\n     * @returns {Promise}\n     */\n    async updateFile(bucketId, fileId, name, permissions) {\n        const apiPath = '/storage/buckets/{bucketId}/files/{fileId}'.replace('{bucketId}', bucketId).replace('{fileId}', fileId);\n        let payload = {};\n        if (typeof bucketId === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"bucketId\"');\n        }\n\n        if (typeof fileId === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"fileId\"');\n        }\n\n\n        if (typeof name !== 'undefined') {\n            payload['name'] = name;\n        }\n\n        if (typeof permissions !== 'undefined') {\n            payload['permissions'] = permissions;\n        }\n\n        return await this.client.call('put', apiPath, {\n            'content-type': 'application/json',\n        }, payload);\n    }\n\n    /**\n     * Delete File\n     *\n     * Delete a file by its unique ID. Only users with write permissions have\n     * access to delete this resource.\n     *\n     * @param {string} bucketId\n     * @param {string} fileId\n     * @throws {AppwriteException}\n     * @returns {Promise}\n     */\n    async deleteFile(bucketId, fileId) {\n        const apiPath = '/storage/buckets/{bucketId}/files/{fileId}'.replace('{bucketId}', bucketId).replace('{fileId}', fileId);\n        let payload = {};\n        if (typeof bucketId === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"bucketId\"');\n        }\n\n        if (typeof fileId === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"fileId\"');\n        }\n\n\n        return await this.client.call('delete', apiPath, {\n            'content-type': 'application/json',\n        }, payload);\n    }\n\n    /**\n     * Get file for download\n     *\n     * Get a file content by its unique ID. The endpoint response return with a\n     * 'Content-Disposition: attachment' header that tells the browser to start\n     * downloading the file to user downloads directory.\n     *\n     * @param {string} bucketId\n     * @param {string} fileId\n     * @throws {AppwriteException}\n     * @returns {Promise}\n     */\n    async getFileDownload(bucketId, fileId) {\n        const apiPath = '/storage/buckets/{bucketId}/files/{fileId}/download'.replace('{bucketId}', bucketId).replace('{fileId}', fileId);\n        let payload = {};\n        if (typeof bucketId === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"bucketId\"');\n        }\n\n        if (typeof fileId === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"fileId\"');\n        }\n\n\n        return await this.client.call('get', apiPath, {\n            'content-type': 'application/json',\n        }, payload, 'arraybuffer');\n    }\n\n    /**\n     * Get file preview\n     *\n     * Get a file preview image. Currently, this method supports preview for image\n     * files (jpg, png, and gif), other supported formats, like pdf, docs, slides,\n     * and spreadsheets, will return the file icon image. You can also pass query\n     * string arguments for cutting and resizing your preview image. Preview is\n     * supported only for image files smaller than 10MB.\n     *\n     * @param {string} bucketId\n     * @param {string} fileId\n     * @param {number} width\n     * @param {number} height\n     * @param {ImageGravity} gravity\n     * @param {number} quality\n     * @param {number} borderWidth\n     * @param {string} borderColor\n     * @param {number} borderRadius\n     * @param {number} opacity\n     * @param {number} rotation\n     * @param {string} background\n     * @param {ImageFormat} output\n     * @throws {AppwriteException}\n     * @returns {Promise}\n     */\n    async getFilePreview(bucketId, fileId, width, height, gravity, quality, borderWidth, borderColor, borderRadius, opacity, rotation, background, output) {\n        const apiPath = '/storage/buckets/{bucketId}/files/{fileId}/preview'.replace('{bucketId}', bucketId).replace('{fileId}', fileId);\n        let payload = {};\n        if (typeof bucketId === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"bucketId\"');\n        }\n\n        if (typeof fileId === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"fileId\"');\n        }\n\n\n        if (typeof width !== 'undefined') {\n            payload['width'] = width;\n        }\n\n        if (typeof height !== 'undefined') {\n            payload['height'] = height;\n        }\n\n        if (typeof gravity !== 'undefined') {\n            payload['gravity'] = gravity;\n        }\n\n        if (typeof quality !== 'undefined') {\n            payload['quality'] = quality;\n        }\n\n        if (typeof borderWidth !== 'undefined') {\n            payload['borderWidth'] = borderWidth;\n        }\n\n        if (typeof borderColor !== 'undefined') {\n            payload['borderColor'] = borderColor;\n        }\n\n        if (typeof borderRadius !== 'undefined') {\n            payload['borderRadius'] = borderRadius;\n        }\n\n        if (typeof opacity !== 'undefined') {\n            payload['opacity'] = opacity;\n        }\n\n        if (typeof rotation !== 'undefined') {\n            payload['rotation'] = rotation;\n        }\n\n        if (typeof background !== 'undefined') {\n            payload['background'] = background;\n        }\n\n        if (typeof output !== 'undefined') {\n            payload['output'] = output;\n        }\n\n        return await this.client.call('get', apiPath, {\n            'content-type': 'application/json',\n        }, payload, 'arraybuffer');\n    }\n\n    /**\n     * Get file for view\n     *\n     * Get a file content by its unique ID. This endpoint is similar to the\n     * download method but returns with no  'Content-Disposition: attachment'\n     * header.\n     *\n     * @param {string} bucketId\n     * @param {string} fileId\n     * @throws {AppwriteException}\n     * @returns {Promise}\n     */\n    async getFileView(bucketId, fileId) {\n        const apiPath = '/storage/buckets/{bucketId}/files/{fileId}/view'.replace('{bucketId}', bucketId).replace('{fileId}', fileId);\n        let payload = {};\n        if (typeof bucketId === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"bucketId\"');\n        }\n\n        if (typeof fileId === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"fileId\"');\n        }\n\n\n        return await this.client.call('get', apiPath, {\n            'content-type': 'application/json',\n        }, payload, 'arraybuffer');\n    }\n}\n\nmodule.exports = Storage;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvbm9kZS1hcHB3cml0ZS9saWIvc2VydmljZXMvc3RvcmFnZS5qcyIsIm1hcHBpbmdzIjoiQUFBQSxnQkFBZ0IsbUJBQU8sQ0FBQyx3RUFBZTtBQUN2QywwQkFBMEIsbUJBQU8sQ0FBQyw0RUFBaUI7QUFDbkQsa0JBQWtCLG1CQUFPLENBQUMsNEVBQWlCO0FBQzNDLGVBQWUsbUJBQU8sQ0FBQyxzRUFBYztBQUNyQyxlQUFlLG1CQUFPLENBQUMsc0JBQVE7QUFDL0IsUUFBUSxZQUFZLEVBQUUsbUJBQU8sQ0FBQyxrQkFBTTtBQUNwQyxXQUFXLG1CQUFPLENBQUMsY0FBSTtBQUN2QixRQUFRLE9BQU8sRUFBRSxtQkFBTyxDQUFDLHNCQUFRO0FBQ2pDLGNBQWMsbUJBQU8sQ0FBQyxvRUFBYTs7QUFFbkM7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsVUFBVTtBQUN6QixlQUFlLFFBQVE7QUFDdkIsZ0JBQWdCO0FBQ2hCLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QixlQUFlLFFBQVE7QUFDdkIsZUFBZSxVQUFVO0FBQ3pCLGVBQWUsU0FBUztBQUN4QixlQUFlLFNBQVM7QUFDeEIsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsVUFBVTtBQUN6QixlQUFlLGFBQWE7QUFDNUIsZUFBZSxTQUFTO0FBQ3hCLGVBQWUsU0FBUztBQUN4QixnQkFBZ0I7QUFDaEIsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVB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QUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTs7QUFFQSIsInNvdXJjZXMiOlsid2VicGFjazovL2pzbV9iYW5raW5nLy4vbm9kZV9tb2R1bGVzL25vZGUtYXBwd3JpdGUvbGliL3NlcnZpY2VzL3N0b3JhZ2UuanM/MWI0NCJdLCJzb3VyY2VzQ29udGVudCI6WyJjb25zdCBTZXJ2aWNlID0gcmVxdWlyZSgnLi4vc2VydmljZS5qcycpO1xuY29uc3QgQXBwd3JpdGVFeGNlcHRpb24gPSByZXF1aXJlKCcuLi9leGNlcHRpb24uanMnKTtcbmNvbnN0IElucHV0RmlsZSA9IHJlcXVpcmUoJy4uL2lucHV0RmlsZS5qcycpO1xuY29uc3QgY2xpZW50ID0gcmVxdWlyZSgnLi4vY2xpZW50LmpzJyk7XG5jb25zdCBTdHJlYW0gPSByZXF1aXJlKCdzdHJlYW0nKTtcbmNvbnN0IHsgcHJvbWlzaWZ5IH0gPSByZXF1aXJlKCd1dGlsJyk7XG5jb25zdCBmcyA9IHJlcXVpcmUoJ2ZzJyk7XG5jb25zdCB7IEZpbGUgfSA9IHJlcXVpcmUoJ3VuZGljaScpO1xuY29uc3QgUXVlcnkgPSByZXF1aXJlKCcuLi9xdWVyeS5qcycpO1xuXG5jbGFzcyBTdG9yYWdlIGV4dGVuZHMgU2VydmljZSB7XG5cbiAgICAgY29uc3RydWN0b3IoY2xpZW50KVxuICAgICB7XG4gICAgICAgIHN1cGVyKGNsaWVudCk7XG4gICAgIH1cblxuXG4gICAgLyoqXG4gICAgICogTGlzdCBidWNrZXRzXG4gICAgICpcbiAgICAgKiBHZXQgYSBsaXN0IG9mIGFsbCB0aGUgc3RvcmFnZSBidWNrZXRzLiBZb3UgY2FuIHVzZSB0aGUgcXVlcnkgcGFyYW1zIHRvXG4gICAgICogZmlsdGVyIHlvdXIgcmVzdWx0cy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nW119IHF1ZXJpZXNcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gc2VhcmNoXG4gICAgICogQHRocm93cyB7QXBwd3JpdGVFeGNlcHRpb259XG4gICAgICogQHJldHVybnMge1Byb21pc2V9XG4gICAgICovXG4gICAgYXN5bmMgbGlzdEJ1Y2tldHMocXVlcmllcywgc2VhcmNoKSB7XG4gICAgICAgIGNvbnN0IGFwaVBhdGggPSAnL3N0b3JhZ2UvYnVja2V0cyc7XG4gICAgICAgIGxldCBwYXlsb2FkID0ge307XG5cbiAgICAgICAgaWYgKHR5cGVvZiBxdWVyaWVzICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgcGF5bG9hZFsncXVlcmllcyddID0gcXVlcmllcztcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0eXBlb2Ygc2VhcmNoICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgcGF5bG9hZFsnc2VhcmNoJ10gPSBzZWFyY2g7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy5jbGllbnQuY2FsbCgnZ2V0JywgYXBpUGF0aCwge1xuICAgICAgICAgICAgJ2NvbnRlbnQtdHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJyxcbiAgICAgICAgfSwgcGF5bG9hZCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlIGJ1Y2tldFxuICAgICAqXG4gICAgICogQ3JlYXRlIGEgbmV3IHN0b3JhZ2UgYnVja2V0LlxuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGJ1Y2tldElkXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IG5hbWVcbiAgICAgKiBAcGFyYW0ge3N0cmluZ1tdfSBwZXJtaXNzaW9uc1xuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gZmlsZVNlY3VyaXR5XG4gICAgICogQHBhcmFtIHtib29sZWFufSBlbmFibGVkXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IG1heGltdW1GaWxlU2l6ZVxuICAgICAqIEBwYXJhbSB7c3RyaW5nW119IGFsbG93ZWRGaWxlRXh0ZW5zaW9uc1xuICAgICAqIEBwYXJhbSB7Q29tcHJlc3Npb259IGNvbXByZXNzaW9uXG4gICAgICogQHBhcmFtIHtib29sZWFufSBlbmNyeXB0aW9uXG4gICAgICogQHBhcmFtIHtib29sZWFufSBhbnRpdmlydXNcbiAgICAgKiBAdGhyb3dzIHtBcHB3cml0ZUV4Y2VwdGlvbn1cbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZX1cbiAgICAgKi9cbiAgICBhc3luYyBjcmVhdGVCdWNrZXQoYnVja2V0SWQsIG5hbWUsIHBlcm1pc3Npb25zLCBmaWxlU2VjdXJpdHksIGVuYWJsZWQsIG1heGltdW1GaWxlU2l6ZSwgYWxsb3dlZEZpbGVFeHRlbnNpb25zLCBjb21wcmVzc2lvbiwgZW5jcnlwdGlvbiwgYW50aXZpcnVzKSB7XG4gICAgICAgIGNvbnN0IGFwaVBhdGggPSAnL3N0b3JhZ2UvYnVja2V0cyc7XG4gICAgICAgIGxldCBwYXlsb2FkID0ge307XG4gICAgICAgIGlmICh0eXBlb2YgYnVja2V0SWQgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgQXBwd3JpdGVFeGNlcHRpb24oJ01pc3NpbmcgcmVxdWlyZWQgcGFyYW1ldGVyOiBcImJ1Y2tldElkXCInKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0eXBlb2YgbmFtZSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBBcHB3cml0ZUV4Y2VwdGlvbignTWlzc2luZyByZXF1aXJlZCBwYXJhbWV0ZXI6IFwibmFtZVwiJyk7XG4gICAgICAgIH1cblxuXG4gICAgICAgIGlmICh0eXBlb2YgYnVja2V0SWQgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICBwYXlsb2FkWydidWNrZXRJZCddID0gYnVja2V0SWQ7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodHlwZW9mIG5hbWUgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICBwYXlsb2FkWyduYW1lJ10gPSBuYW1lO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHR5cGVvZiBwZXJtaXNzaW9ucyAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHBheWxvYWRbJ3Blcm1pc3Npb25zJ10gPSBwZXJtaXNzaW9ucztcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0eXBlb2YgZmlsZVNlY3VyaXR5ICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgcGF5bG9hZFsnZmlsZVNlY3VyaXR5J10gPSBmaWxlU2VjdXJpdHk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodHlwZW9mIGVuYWJsZWQgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICBwYXlsb2FkWydlbmFibGVkJ10gPSBlbmFibGVkO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHR5cGVvZiBtYXhpbXVtRmlsZVNpemUgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICBwYXlsb2FkWydtYXhpbXVtRmlsZVNpemUnXSA9IG1heGltdW1GaWxlU2l6ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0eXBlb2YgYWxsb3dlZEZpbGVFeHRlbnNpb25zICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgcGF5bG9hZFsnYWxsb3dlZEZpbGVFeHRlbnNpb25zJ10gPSBhbGxvd2VkRmlsZUV4dGVuc2lvbnM7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodHlwZW9mIGNvbXByZXNzaW9uICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgcGF5bG9hZFsnY29tcHJlc3Npb24nXSA9IGNvbXByZXNzaW9uO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHR5cGVvZiBlbmNyeXB0aW9uICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgcGF5bG9hZFsnZW5jcnlwdGlvbiddID0gZW5jcnlwdGlvbjtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0eXBlb2YgYW50aXZpcnVzICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgcGF5bG9hZFsnYW50aXZpcnVzJ10gPSBhbnRpdmlydXM7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy5jbGllbnQuY2FsbCgncG9zdCcsIGFwaVBhdGgsIHtcbiAgICAgICAgICAgICdjb250ZW50LXR5cGUnOiAnYXBwbGljYXRpb24vanNvbicsXG4gICAgICAgIH0sIHBheWxvYWQpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdldCBidWNrZXRcbiAgICAgKlxuICAgICAqIEdldCBhIHN0b3JhZ2UgYnVja2V0IGJ5IGl0cyB1bmlxdWUgSUQuIFRoaXMgZW5kcG9pbnQgcmVzcG9uc2UgcmV0dXJucyBhXG4gICAgICogSlNPTiBvYmplY3Qgd2l0aCB0aGUgc3RvcmFnZSBidWNrZXQgbWV0YWRhdGEuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gYnVja2V0SWRcbiAgICAgKiBAdGhyb3dzIHtBcHB3cml0ZUV4Y2VwdGlvbn1cbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZX1cbiAgICAgKi9cbiAgICBhc3luYyBnZXRCdWNrZXQoYnVja2V0SWQpIHtcbiAgICAgICAgY29uc3QgYXBpUGF0aCA9ICcvc3RvcmFnZS9idWNrZXRzL3tidWNrZXRJZH0nLnJlcGxhY2UoJ3tidWNrZXRJZH0nLCBidWNrZXRJZCk7XG4gICAgICAgIGxldCBwYXlsb2FkID0ge307XG4gICAgICAgIGlmICh0eXBlb2YgYnVja2V0SWQgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgQXBwd3JpdGVFeGNlcHRpb24oJ01pc3NpbmcgcmVxdWlyZWQgcGFyYW1ldGVyOiBcImJ1Y2tldElkXCInKTtcbiAgICAgICAgfVxuXG5cbiAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMuY2xpZW50LmNhbGwoJ2dldCcsIGFwaVBhdGgsIHtcbiAgICAgICAgICAgICdjb250ZW50LXR5cGUnOiAnYXBwbGljYXRpb24vanNvbicsXG4gICAgICAgIH0sIHBheWxvYWQpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFVwZGF0ZSBidWNrZXRcbiAgICAgKlxuICAgICAqIFVwZGF0ZSBhIHN0b3JhZ2UgYnVja2V0IGJ5IGl0cyB1bmlxdWUgSUQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gYnVja2V0SWRcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gbmFtZVxuICAgICAqIEBwYXJhbSB7c3RyaW5nW119IHBlcm1pc3Npb25zXG4gICAgICogQHBhcmFtIHtib29sZWFufSBmaWxlU2VjdXJpdHlcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IGVuYWJsZWRcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gbWF4aW11bUZpbGVTaXplXG4gICAgICogQHBhcmFtIHtzdHJpbmdbXX0gYWxsb3dlZEZpbGVFeHRlbnNpb25zXG4gICAgICogQHBhcmFtIHtDb21wcmVzc2lvbn0gY29tcHJlc3Npb25cbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IGVuY3J5cHRpb25cbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IGFudGl2aXJ1c1xuICAgICAqIEB0aHJvd3Mge0FwcHdyaXRlRXhjZXB0aW9ufVxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlfVxuICAgICAqL1xuICAgIGFzeW5jIHVwZGF0ZUJ1Y2tldChidWNrZXRJZCwgbmFtZSwgcGVybWlzc2lvbnMsIGZpbGVTZWN1cml0eSwgZW5hYmxlZCwgbWF4aW11bUZpbGVTaXplLCBhbGxvd2VkRmlsZUV4dGVuc2lvbnMsIGNvbXByZXNzaW9uLCBlbmNyeXB0aW9uLCBhbnRpdmlydXMpIHtcbiAgICAgICAgY29uc3QgYXBpUGF0aCA9ICcvc3RvcmFnZS9idWNrZXRzL3tidWNrZXRJZH0nLnJlcGxhY2UoJ3tidWNrZXRJZH0nLCBidWNrZXRJZCk7XG4gICAgICAgIGxldCBwYXlsb2FkID0ge307XG4gICAgICAgIGlmICh0eXBlb2YgYnVja2V0SWQgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgQXBwd3JpdGVFeGNlcHRpb24oJ01pc3NpbmcgcmVxdWlyZWQgcGFyYW1ldGVyOiBcImJ1Y2tldElkXCInKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0eXBlb2YgbmFtZSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBBcHB3cml0ZUV4Y2VwdGlvbignTWlzc2luZyByZXF1aXJlZCBwYXJhbWV0ZXI6IFwibmFtZVwiJyk7XG4gICAgICAgIH1cblxuXG4gICAgICAgIGlmICh0eXBlb2YgbmFtZSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHBheWxvYWRbJ25hbWUnXSA9IG5hbWU7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodHlwZW9mIHBlcm1pc3Npb25zICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgcGF5bG9hZFsncGVybWlzc2lvbnMnXSA9IHBlcm1pc3Npb25zO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHR5cGVvZiBmaWxlU2VjdXJpdHkgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICBwYXlsb2FkWydmaWxlU2VjdXJpdHknXSA9IGZpbGVTZWN1cml0eTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0eXBlb2YgZW5hYmxlZCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHBheWxvYWRbJ2VuYWJsZWQnXSA9IGVuYWJsZWQ7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodHlwZW9mIG1heGltdW1GaWxlU2l6ZSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHBheWxvYWRbJ21heGltdW1GaWxlU2l6ZSddID0gbWF4aW11bUZpbGVTaXplO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHR5cGVvZiBhbGxvd2VkRmlsZUV4dGVuc2lvbnMgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICBwYXlsb2FkWydhbGxvd2VkRmlsZUV4dGVuc2lvbnMnXSA9IGFsbG93ZWRGaWxlRXh0ZW5zaW9ucztcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0eXBlb2YgY29tcHJlc3Npb24gIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICBwYXlsb2FkWydjb21wcmVzc2lvbiddID0gY29tcHJlc3Npb247XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodHlwZW9mIGVuY3J5cHRpb24gIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICBwYXlsb2FkWydlbmNyeXB0aW9uJ10gPSBlbmNyeXB0aW9uO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHR5cGVvZiBhbnRpdmlydXMgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICBwYXlsb2FkWydhbnRpdmlydXMnXSA9IGFudGl2aXJ1cztcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBhd2FpdCB0aGlzLmNsaWVudC5jYWxsKCdwdXQnLCBhcGlQYXRoLCB7XG4gICAgICAgICAgICAnY29udGVudC10eXBlJzogJ2FwcGxpY2F0aW9uL2pzb24nLFxuICAgICAgICB9LCBwYXlsb2FkKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBEZWxldGUgYnVja2V0XG4gICAgICpcbiAgICAgKiBEZWxldGUgYSBzdG9yYWdlIGJ1Y2tldCBieSBpdHMgdW5pcXVlIElELlxuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGJ1Y2tldElkXG4gICAgICogQHRocm93cyB7QXBwd3JpdGVFeGNlcHRpb259XG4gICAgICogQHJldHVybnMge1Byb21pc2V9XG4gICAgICovXG4gICAgYXN5bmMgZGVsZXRlQnVja2V0KGJ1Y2tldElkKSB7XG4gICAgICAgIGNvbnN0IGFwaVBhdGggPSAnL3N0b3JhZ2UvYnVja2V0cy97YnVja2V0SWR9Jy5yZXBsYWNlKCd7YnVja2V0SWR9JywgYnVja2V0SWQpO1xuICAgICAgICBsZXQgcGF5bG9hZCA9IHt9O1xuICAgICAgICBpZiAodHlwZW9mIGJ1Y2tldElkID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEFwcHdyaXRlRXhjZXB0aW9uKCdNaXNzaW5nIHJlcXVpcmVkIHBhcmFtZXRlcjogXCJidWNrZXRJZFwiJyk7XG4gICAgICAgIH1cblxuXG4gICAgICAgIHJldHVybiBhd2FpdCB0aGlzLmNsaWVudC5jYWxsKCdkZWxldGUnLCBhcGlQYXRoLCB7XG4gICAgICAgICAgICAnY29udGVudC10eXBlJzogJ2FwcGxpY2F0aW9uL2pzb24nLFxuICAgICAgICB9LCBwYXlsb2FkKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBMaXN0IGZpbGVzXG4gICAgICpcbiAgICAgKiBHZXQgYSBsaXN0IG9mIGFsbCB0aGUgdXNlciBmaWxlcy4gWW91IGNhbiB1c2UgdGhlIHF1ZXJ5IHBhcmFtcyB0byBmaWx0ZXJcbiAgICAgKiB5b3VyIHJlc3VsdHMuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gYnVja2V0SWRcbiAgICAgKiBAcGFyYW0ge3N0cmluZ1tdfSBxdWVyaWVzXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHNlYXJjaFxuICAgICAqIEB0aHJvd3Mge0FwcHdyaXRlRXhjZXB0aW9ufVxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlfVxuICAgICAqL1xuICAgIGFzeW5jIGxpc3RGaWxlcyhidWNrZXRJZCwgcXVlcmllcywgc2VhcmNoKSB7XG4gICAgICAgIGNvbnN0IGFwaVBhdGggPSAnL3N0b3JhZ2UvYnVja2V0cy97YnVja2V0SWR9L2ZpbGVzJy5yZXBsYWNlKCd7YnVja2V0SWR9JywgYnVja2V0SWQpO1xuICAgICAgICBsZXQgcGF5bG9hZCA9IHt9O1xuICAgICAgICBpZiAodHlwZW9mIGJ1Y2tldElkID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEFwcHdyaXRlRXhjZXB0aW9uKCdNaXNzaW5nIHJlcXVpcmVkIHBhcmFtZXRlcjogXCJidWNrZXRJZFwiJyk7XG4gICAgICAgIH1cblxuXG4gICAgICAgIGlmICh0eXBlb2YgcXVlcmllcyAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHBheWxvYWRbJ3F1ZXJpZXMnXSA9IHF1ZXJpZXM7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodHlwZW9mIHNlYXJjaCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHBheWxvYWRbJ3NlYXJjaCddID0gc2VhcmNoO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMuY2xpZW50LmNhbGwoJ2dldCcsIGFwaVBhdGgsIHtcbiAgICAgICAgICAgICdjb250ZW50LXR5cGUnOiAnYXBwbGljYXRpb24vanNvbicsXG4gICAgICAgIH0sIHBheWxvYWQpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZSBmaWxlXG4gICAgICpcbiAgICAgKiBDcmVhdGUgYSBuZXcgZmlsZS4gQmVmb3JlIHVzaW5nIHRoaXMgcm91dGUsIHlvdSBzaG91bGQgY3JlYXRlIGEgbmV3IGJ1Y2tldFxuICAgICAqIHJlc291cmNlIHVzaW5nIGVpdGhlciBhIFtzZXJ2ZXJcbiAgICAgKiBpbnRlZ3JhdGlvbl0oaHR0cHM6Ly9hcHB3cml0ZS5pby9kb2NzL3NlcnZlci9zdG9yYWdlI3N0b3JhZ2VDcmVhdGVCdWNrZXQpXG4gICAgICogQVBJIG9yIGRpcmVjdGx5IGZyb20geW91ciBBcHB3cml0ZSBjb25zb2xlLlxuICAgICAqIFxuICAgICAqIExhcmdlciBmaWxlcyBzaG91bGQgYmUgdXBsb2FkZWQgdXNpbmcgbXVsdGlwbGUgcmVxdWVzdHMgd2l0aCB0aGVcbiAgICAgKiBbY29udGVudC1yYW5nZV0oaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSFRUUC9IZWFkZXJzL0NvbnRlbnQtUmFuZ2UpXG4gICAgICogaGVhZGVyIHRvIHNlbmQgYSBwYXJ0aWFsIHJlcXVlc3Qgd2l0aCBhIG1heGltdW0gc3VwcG9ydGVkIGNodW5rIG9mIGA1TUJgLlxuICAgICAqIFRoZSBgY29udGVudC1yYW5nZWAgaGVhZGVyIHZhbHVlcyBzaG91bGQgYWx3YXlzIGJlIGluIGJ5dGVzLlxuICAgICAqIFxuICAgICAqIFdoZW4gdGhlIGZpcnN0IHJlcXVlc3QgaXMgc2VudCwgdGhlIHNlcnZlciB3aWxsIHJldHVybiB0aGUgKipGaWxlKiogb2JqZWN0LFxuICAgICAqIGFuZCB0aGUgc3Vic2VxdWVudCBwYXJ0IHJlcXVlc3QgbXVzdCBpbmNsdWRlIHRoZSBmaWxlJ3MgKippZCoqIGluXG4gICAgICogYHgtYXBwd3JpdGUtaWRgIGhlYWRlciB0byBhbGxvdyB0aGUgc2VydmVyIHRvIGtub3cgdGhhdCB0aGUgcGFydGlhbCB1cGxvYWRcbiAgICAgKiBpcyBmb3IgdGhlIGV4aXN0aW5nIGZpbGUgYW5kIG5vdCBmb3IgYSBuZXcgb25lLlxuICAgICAqIFxuICAgICAqIElmIHlvdSdyZSBjcmVhdGluZyBhIG5ldyBmaWxlIHVzaW5nIG9uZSBvZiB0aGUgQXBwd3JpdGUgU0RLcywgYWxsIHRoZVxuICAgICAqIGNodW5raW5nIGxvZ2ljIHdpbGwgYmUgbWFuYWdlZCBieSB0aGUgU0RLIGludGVybmFsbHkuXG4gICAgICogXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gYnVja2V0SWRcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gZmlsZUlkXG4gICAgICogQHBhcmFtIHtJbnB1dEZpbGV9IGZpbGVcbiAgICAgKiBAcGFyYW0ge3N0cmluZ1tdfSBwZXJtaXNzaW9uc1xuICAgICAqIEBwYXJhbSB7Q2FsbGFibGVGdW5jdGlvbn0gb25Qcm9ncmVzc1xuICAgICAqIEB0aHJvd3Mge0FwcHdyaXRlRXhjZXB0aW9ufVxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlfVxuICAgICAqL1xuICAgIGFzeW5jIGNyZWF0ZUZpbGUoYnVja2V0SWQsIGZpbGVJZCwgZmlsZSwgcGVybWlzc2lvbnMsIG9uUHJvZ3Jlc3MgPSAoKSA9PiB7fSkge1xuICAgICAgICBjb25zdCBhcGlQYXRoID0gJy9zdG9yYWdlL2J1Y2tldHMve2J1Y2tldElkfS9maWxlcycucmVwbGFjZSgne2J1Y2tldElkfScsIGJ1Y2tldElkKTtcbiAgICAgICAgbGV0IHBheWxvYWQgPSB7fTtcbiAgICAgICAgaWYgKHR5cGVvZiBidWNrZXRJZCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBBcHB3cml0ZUV4Y2VwdGlvbignTWlzc2luZyByZXF1aXJlZCBwYXJhbWV0ZXI6IFwiYnVja2V0SWRcIicpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHR5cGVvZiBmaWxlSWQgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgQXBwd3JpdGVFeGNlcHRpb24oJ01pc3NpbmcgcmVxdWlyZWQgcGFyYW1ldGVyOiBcImZpbGVJZFwiJyk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodHlwZW9mIGZpbGUgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgQXBwd3JpdGVFeGNlcHRpb24oJ01pc3NpbmcgcmVxdWlyZWQgcGFyYW1ldGVyOiBcImZpbGVcIicpO1xuICAgICAgICB9XG5cblxuICAgICAgICBpZiAodHlwZW9mIGZpbGVJZCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHBheWxvYWRbJ2ZpbGVJZCddID0gZmlsZUlkO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHR5cGVvZiBmaWxlICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgcGF5bG9hZFsnZmlsZSddID0gZmlsZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0eXBlb2YgcGVybWlzc2lvbnMgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICBwYXlsb2FkWydwZXJtaXNzaW9ucyddID0gcGVybWlzc2lvbnM7XG4gICAgICAgIH1cblxuXG4gICAgICAgIGNvbnN0IHNpemUgPSBmaWxlLnNpemU7XG4gICAgICAgIFxuICAgICAgICBjb25zdCBhcGlIZWFkZXJzID0ge1xuICAgICAgICAgICAgJ2NvbnRlbnQtdHlwZSc6ICdtdWx0aXBhcnQvZm9ybS1kYXRhJyxcbiAgICAgICAgfTtcblxuICAgICAgICBsZXQgaWQgPSB1bmRlZmluZWQ7XG4gICAgICAgIGxldCByZXNwb25zZSA9IHVuZGVmaW5lZDtcblxuICAgICAgICBsZXQgY2h1bmtzVXBsb2FkZWQgPSAwO1xuXG4gICAgICAgIGlmKGZpbGVJZCAhPSAndW5pcXVlKCknKSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIHJlc3BvbnNlID0gYXdhaXQgdGhpcy5jbGllbnQuY2FsbCgnZ2V0JywgYXBpUGF0aCArICcvJyArIGZpbGVJZCwgYXBpSGVhZGVycyk7XG4gICAgICAgICAgICAgICAgY2h1bmtzVXBsb2FkZWQgPSByZXNwb25zZS5jaHVua3NVcGxvYWRlZDtcbiAgICAgICAgICAgIH0gY2F0Y2goZSkge1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgbGV0IGN1cnJlbnRDaHVuayA9IDE7XG4gICAgICAgIGxldCBjdXJyZW50UG9zaXRpb24gPSAwO1xuICAgICAgICBsZXQgdXBsb2FkYWJsZUNodW5rID0gbmV3IFVpbnQ4QXJyYXkoY2xpZW50LkNIVU5LX1NJWkUpO1xuICAgIFxuXG4gICAgICAgIGNvbnN0IHVwbG9hZENodW5rID0gYXN5bmMgKGxhc3RVcGxvYWQgPSBmYWxzZSkgPT4ge1xuICAgICAgICAgICAgaWYoY3VycmVudENodW5rIDw9IGNodW5rc1VwbG9hZGVkKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBjb25zdCBzdGFydCA9ICgoY3VycmVudENodW5rIC0gMSkgKiBjbGllbnQuQ0hVTktfU0laRSk7XG4gICAgICAgICAgICBsZXQgZW5kID0gc3RhcnQgKyBjdXJyZW50UG9zaXRpb24gLSAxO1xuXG4gICAgICAgICAgICBpZighbGFzdFVwbG9hZCB8fCBjdXJyZW50Q2h1bmsgIT09IDEpIHtcbiAgICAgICAgICAgICAgICBhcGlIZWFkZXJzWydjb250ZW50LXJhbmdlJ10gPSAnYnl0ZXMgJyArIHN0YXJ0ICsgJy0nICsgZW5kICsgJy8nICsgc2l6ZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgbGV0IHVwbG9hZGFibGVDaHVua1RyaW1tZWQ7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIGlmKGN1cnJlbnRQb3NpdGlvbiArIDEgPj0gY2xpZW50LkNIVU5LX1NJWkUpIHtcbiAgICAgICAgICAgICAgICB1cGxvYWRhYmxlQ2h1bmtUcmltbWVkID0gdXBsb2FkYWJsZUNodW5rO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB1cGxvYWRhYmxlQ2h1bmtUcmltbWVkID0gbmV3IFVpbnQ4QXJyYXkoY3VycmVudFBvc2l0aW9uKTtcbiAgICAgICAgICAgICAgICBmb3IobGV0IGkgPSAwOyBpIDw9IGN1cnJlbnRQb3NpdGlvbjsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIHVwbG9hZGFibGVDaHVua1RyaW1tZWRbaV0gPSB1cGxvYWRhYmxlQ2h1bmtbaV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoaWQpIHtcbiAgICAgICAgICAgICAgICBhcGlIZWFkZXJzWyd4LWFwcHdyaXRlLWlkJ10gPSBpZDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcGF5bG9hZFsnZmlsZSddID0geyB0eXBlOiAnZmlsZScsIGZpbGU6IG5ldyBGaWxlKFt1cGxvYWRhYmxlQ2h1bmtUcmltbWVkXSwgZmlsZS5maWxlbmFtZSksIGZpbGVuYW1lOiBmaWxlLmZpbGVuYW1lIH07XG5cbiAgICAgICAgICAgIHJlc3BvbnNlID0gYXdhaXQgdGhpcy5jbGllbnQuY2FsbCgncG9zdCcsIGFwaVBhdGgsIGFwaUhlYWRlcnMsIHBheWxvYWQpO1xuXG4gICAgICAgICAgICBpZiAoIWlkKSB7XG4gICAgICAgICAgICAgICAgaWQgPSByZXNwb25zZVsnJGlkJ107XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChvblByb2dyZXNzICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgb25Qcm9ncmVzcyh7XG4gICAgICAgICAgICAgICAgICAgICRpZDogcmVzcG9uc2VbJyRpZCddLFxuICAgICAgICAgICAgICAgICAgICBwcm9ncmVzczogTWF0aC5taW4oKGN1cnJlbnRDaHVuaykgKiBjbGllbnQuQ0hVTktfU0laRSwgc2l6ZSkgLyBzaXplICogMTAwLFxuICAgICAgICAgICAgICAgICAgICBzaXplVXBsb2FkZWQ6IGVuZCsxLFxuICAgICAgICAgICAgICAgICAgICBjaHVua3NUb3RhbDogcmVzcG9uc2VbJ2NodW5rc1RvdGFsJ10sXG4gICAgICAgICAgICAgICAgICAgIGNodW5rc1VwbG9hZGVkOiByZXNwb25zZVsnY2h1bmtzVXBsb2FkZWQnXVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB1cGxvYWRhYmxlQ2h1bmsgPSBuZXcgVWludDhBcnJheShjbGllbnQuQ0hVTktfU0laRSk7XG4gICAgICAgICAgICBjdXJyZW50Q2h1bmsrKztcbiAgICAgICAgICAgIGN1cnJlbnRQb3NpdGlvbiA9IDA7XG4gICAgICAgIH1cblxuICAgICAgICBmb3IgYXdhaXQgKGNvbnN0IGNodW5rIG9mIGZpbGUuc3RyZWFtKSB7XG4gICAgICAgICAgICBmb3IoY29uc3QgYiBvZiBjaHVuaykge1xuICAgICAgICAgICAgICAgIHVwbG9hZGFibGVDaHVua1tjdXJyZW50UG9zaXRpb25dID0gYjtcblxuICAgICAgICAgICAgICAgIGN1cnJlbnRQb3NpdGlvbisrO1xuICAgICAgICAgICAgICAgIGlmKGN1cnJlbnRQb3NpdGlvbiA+PSBjbGllbnQuQ0hVTktfU0laRSkge1xuICAgICAgICAgICAgICAgICAgICBhd2FpdCB1cGxvYWRDaHVuaygpO1xuICAgICAgICAgICAgICAgICAgICBjdXJyZW50UG9zaXRpb24gPSAwO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChjdXJyZW50UG9zaXRpb24gPiAwKSB7IC8vIENoZWNrIGlmIHRoZXJlJ3MgYW55IHJlbWFpbmluZyBkYXRhIGZvciB0aGUgbGFzdCBjaHVua1xuICAgICAgICAgICAgYXdhaXQgdXBsb2FkQ2h1bmsodHJ1ZSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcmVzcG9uc2U7XG5cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZXQgZmlsZVxuICAgICAqXG4gICAgICogR2V0IGEgZmlsZSBieSBpdHMgdW5pcXVlIElELiBUaGlzIGVuZHBvaW50IHJlc3BvbnNlIHJldHVybnMgYSBKU09OIG9iamVjdFxuICAgICAqIHdpdGggdGhlIGZpbGUgbWV0YWRhdGEuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gYnVja2V0SWRcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gZmlsZUlkXG4gICAgICogQHRocm93cyB7QXBwd3JpdGVFeGNlcHRpb259XG4gICAgICogQHJldHVybnMge1Byb21pc2V9XG4gICAgICovXG4gICAgYXN5bmMgZ2V0RmlsZShidWNrZXRJZCwgZmlsZUlkKSB7XG4gICAgICAgIGNvbnN0IGFwaVBhdGggPSAnL3N0b3JhZ2UvYnVja2V0cy97YnVja2V0SWR9L2ZpbGVzL3tmaWxlSWR9Jy5yZXBsYWNlKCd7YnVja2V0SWR9JywgYnVja2V0SWQpLnJlcGxhY2UoJ3tmaWxlSWR9JywgZmlsZUlkKTtcbiAgICAgICAgbGV0IHBheWxvYWQgPSB7fTtcbiAgICAgICAgaWYgKHR5cGVvZiBidWNrZXRJZCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBBcHB3cml0ZUV4Y2VwdGlvbignTWlzc2luZyByZXF1aXJlZCBwYXJhbWV0ZXI6IFwiYnVja2V0SWRcIicpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHR5cGVvZiBmaWxlSWQgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgQXBwd3JpdGVFeGNlcHRpb24oJ01pc3NpbmcgcmVxdWlyZWQgcGFyYW1ldGVyOiBcImZpbGVJZFwiJyk7XG4gICAgICAgIH1cblxuXG4gICAgICAgIHJldHVybiBhd2FpdCB0aGlzLmNsaWVudC5jYWxsKCdnZXQnLCBhcGlQYXRoLCB7XG4gICAgICAgICAgICAnY29udGVudC10eXBlJzogJ2FwcGxpY2F0aW9uL2pzb24nLFxuICAgICAgICB9LCBwYXlsb2FkKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBVcGRhdGUgZmlsZVxuICAgICAqXG4gICAgICogVXBkYXRlIGEgZmlsZSBieSBpdHMgdW5pcXVlIElELiBPbmx5IHVzZXJzIHdpdGggd3JpdGUgcGVybWlzc2lvbnMgaGF2ZVxuICAgICAqIGFjY2VzcyB0byB1cGRhdGUgdGhpcyByZXNvdXJjZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBidWNrZXRJZFxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBmaWxlSWRcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gbmFtZVxuICAgICAqIEBwYXJhbSB7c3RyaW5nW119IHBlcm1pc3Npb25zXG4gICAgICogQHRocm93cyB7QXBwd3JpdGVFeGNlcHRpb259XG4gICAgICogQHJldHVybnMge1Byb21pc2V9XG4gICAgICovXG4gICAgYXN5bmMgdXBkYXRlRmlsZShidWNrZXRJZCwgZmlsZUlkLCBuYW1lLCBwZXJtaXNzaW9ucykge1xuICAgICAgICBjb25zdCBhcGlQYXRoID0gJy9zdG9yYWdlL2J1Y2tldHMve2J1Y2tldElkfS9maWxlcy97ZmlsZUlkfScucmVwbGFjZSgne2J1Y2tldElkfScsIGJ1Y2tldElkKS5yZXBsYWNlKCd7ZmlsZUlkfScsIGZpbGVJZCk7XG4gICAgICAgIGxldCBwYXlsb2FkID0ge307XG4gICAgICAgIGlmICh0eXBlb2YgYnVja2V0SWQgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgQXBwd3JpdGVFeGNlcHRpb24oJ01pc3NpbmcgcmVxdWlyZWQgcGFyYW1ldGVyOiBcImJ1Y2tldElkXCInKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0eXBlb2YgZmlsZUlkID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEFwcHdyaXRlRXhjZXB0aW9uKCdNaXNzaW5nIHJlcXVpcmVkIHBhcmFtZXRlcjogXCJmaWxlSWRcIicpO1xuICAgICAgICB9XG5cblxuICAgICAgICBpZiAodHlwZW9mIG5hbWUgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICBwYXlsb2FkWyduYW1lJ10gPSBuYW1lO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHR5cGVvZiBwZXJtaXNzaW9ucyAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHBheWxvYWRbJ3Blcm1pc3Npb25zJ10gPSBwZXJtaXNzaW9ucztcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBhd2FpdCB0aGlzLmNsaWVudC5jYWxsKCdwdXQnLCBhcGlQYXRoLCB7XG4gICAgICAgICAgICAnY29udGVudC10eXBlJzogJ2FwcGxpY2F0aW9uL2pzb24nLFxuICAgICAgICB9LCBwYXlsb2FkKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBEZWxldGUgRmlsZVxuICAgICAqXG4gICAgICogRGVsZXRlIGEgZmlsZSBieSBpdHMgdW5pcXVlIElELiBPbmx5IHVzZXJzIHdpdGggd3JpdGUgcGVybWlzc2lvbnMgaGF2ZVxuICAgICAqIGFjY2VzcyB0byBkZWxldGUgdGhpcyByZXNvdXJjZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBidWNrZXRJZFxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBmaWxlSWRcbiAgICAgKiBAdGhyb3dzIHtBcHB3cml0ZUV4Y2VwdGlvbn1cbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZX1cbiAgICAgKi9cbiAgICBhc3luYyBkZWxldGVGaWxlKGJ1Y2tldElkLCBmaWxlSWQpIHtcbiAgICAgICAgY29uc3QgYXBpUGF0aCA9ICcvc3RvcmFnZS9idWNrZXRzL3tidWNrZXRJZH0vZmlsZXMve2ZpbGVJZH0nLnJlcGxhY2UoJ3tidWNrZXRJZH0nLCBidWNrZXRJZCkucmVwbGFjZSgne2ZpbGVJZH0nLCBmaWxlSWQpO1xuICAgICAgICBsZXQgcGF5bG9hZCA9IHt9O1xuICAgICAgICBpZiAodHlwZW9mIGJ1Y2tldElkID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEFwcHdyaXRlRXhjZXB0aW9uKCdNaXNzaW5nIHJlcXVpcmVkIHBhcmFtZXRlcjogXCJidWNrZXRJZFwiJyk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodHlwZW9mIGZpbGVJZCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBBcHB3cml0ZUV4Y2VwdGlvbignTWlzc2luZyByZXF1aXJlZCBwYXJhbWV0ZXI6IFwiZmlsZUlkXCInKTtcbiAgICAgICAgfVxuXG5cbiAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMuY2xpZW50LmNhbGwoJ2RlbGV0ZScsIGFwaVBhdGgsIHtcbiAgICAgICAgICAgICdjb250ZW50LXR5cGUnOiAnYXBwbGljYXRpb24vanNvbicsXG4gICAgICAgIH0sIHBheWxvYWQpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdldCBmaWxlIGZvciBkb3dubG9hZFxuICAgICAqXG4gICAgICogR2V0IGEgZmlsZSBjb250ZW50IGJ5IGl0cyB1bmlxdWUgSUQuIFRoZSBlbmRwb2ludCByZXNwb25zZSByZXR1cm4gd2l0aCBhXG4gICAgICogJ0NvbnRlbnQtRGlzcG9zaXRpb246IGF0dGFjaG1lbnQnIGhlYWRlciB0aGF0IHRlbGxzIHRoZSBicm93c2VyIHRvIHN0YXJ0XG4gICAgICogZG93bmxvYWRpbmcgdGhlIGZpbGUgdG8gdXNlciBkb3dubG9hZHMgZGlyZWN0b3J5LlxuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGJ1Y2tldElkXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGZpbGVJZFxuICAgICAqIEB0aHJvd3Mge0FwcHdyaXRlRXhjZXB0aW9ufVxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlfVxuICAgICAqL1xuICAgIGFzeW5jIGdldEZpbGVEb3dubG9hZChidWNrZXRJZCwgZmlsZUlkKSB7XG4gICAgICAgIGNvbnN0IGFwaVBhdGggPSAnL3N0b3JhZ2UvYnVja2V0cy97YnVja2V0SWR9L2ZpbGVzL3tmaWxlSWR9L2Rvd25sb2FkJy5yZXBsYWNlKCd7YnVja2V0SWR9JywgYnVja2V0SWQpLnJlcGxhY2UoJ3tmaWxlSWR9JywgZmlsZUlkKTtcbiAgICAgICAgbGV0IHBheWxvYWQgPSB7fTtcbiAgICAgICAgaWYgKHR5cGVvZiBidWNrZXRJZCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBBcHB3cml0ZUV4Y2VwdGlvbignTWlzc2luZyByZXF1aXJlZCBwYXJhbWV0ZXI6IFwiYnVja2V0SWRcIicpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHR5cGVvZiBmaWxlSWQgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgQXBwd3JpdGVFeGNlcHRpb24oJ01pc3NpbmcgcmVxdWlyZWQgcGFyYW1ldGVyOiBcImZpbGVJZFwiJyk7XG4gICAgICAgIH1cblxuXG4gICAgICAgIHJldHVybiBhd2FpdCB0aGlzLmNsaWVudC5jYWxsKCdnZXQnLCBhcGlQYXRoLCB7XG4gICAgICAgICAgICAnY29udGVudC10eXBlJzogJ2FwcGxpY2F0aW9uL2pzb24nLFxuICAgICAgICB9LCBwYXlsb2FkLCAnYXJyYXlidWZmZXInKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZXQgZmlsZSBwcmV2aWV3XG4gICAgICpcbiAgICAgKiBHZXQgYSBmaWxlIHByZXZpZXcgaW1hZ2UuIEN1cnJlbnRseSwgdGhpcyBtZXRob2Qgc3VwcG9ydHMgcHJldmlldyBmb3IgaW1hZ2VcbiAgICAgKiBmaWxlcyAoanBnLCBwbmcsIGFuZCBnaWYpLCBvdGhlciBzdXBwb3J0ZWQgZm9ybWF0cywgbGlrZSBwZGYsIGRvY3MsIHNsaWRlcyxcbiAgICAgKiBhbmQgc3ByZWFkc2hlZXRzLCB3aWxsIHJldHVybiB0aGUgZmlsZSBpY29uIGltYWdlLiBZb3UgY2FuIGFsc28gcGFzcyBxdWVyeVxuICAgICAqIHN0cmluZyBhcmd1bWVudHMgZm9yIGN1dHRpbmcgYW5kIHJlc2l6aW5nIHlvdXIgcHJldmlldyBpbWFnZS4gUHJldmlldyBpc1xuICAgICAqIHN1cHBvcnRlZCBvbmx5IGZvciBpbWFnZSBmaWxlcyBzbWFsbGVyIHRoYW4gMTBNQi5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBidWNrZXRJZFxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBmaWxlSWRcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gd2lkdGhcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gaGVpZ2h0XG4gICAgICogQHBhcmFtIHtJbWFnZUdyYXZpdHl9IGdyYXZpdHlcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gcXVhbGl0eVxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBib3JkZXJXaWR0aFxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBib3JkZXJDb2xvclxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBib3JkZXJSYWRpdXNcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gb3BhY2l0eVxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSByb3RhdGlvblxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBiYWNrZ3JvdW5kXG4gICAgICogQHBhcmFtIHtJbWFnZUZvcm1hdH0gb3V0cHV0XG4gICAgICogQHRocm93cyB7QXBwd3JpdGVFeGNlcHRpb259XG4gICAgICogQHJldHVybnMge1Byb21pc2V9XG4gICAgICovXG4gICAgYXN5bmMgZ2V0RmlsZVByZXZpZXcoYnVja2V0SWQsIGZpbGVJZCwgd2lkdGgsIGhlaWdodCwgZ3Jhdml0eSwgcXVhbGl0eSwgYm9yZGVyV2lkdGgsIGJvcmRlckNvbG9yLCBib3JkZXJSYWRpdXMsIG9wYWNpdHksIHJvdGF0aW9uLCBiYWNrZ3JvdW5kLCBvdXRwdXQpIHtcbiAgICAgICAgY29uc3QgYXBpUGF0aCA9ICcvc3RvcmFnZS9idWNrZXRzL3tidWNrZXRJZH0vZmlsZXMve2ZpbGVJZH0vcHJldmlldycucmVwbGFjZSgne2J1Y2tldElkfScsIGJ1Y2tldElkKS5yZXBsYWNlKCd7ZmlsZUlkfScsIGZpbGVJZCk7XG4gICAgICAgIGxldCBwYXlsb2FkID0ge307XG4gICAgICAgIGlmICh0eXBlb2YgYnVja2V0SWQgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgQXBwd3JpdGVFeGNlcHRpb24oJ01pc3NpbmcgcmVxdWlyZWQgcGFyYW1ldGVyOiBcImJ1Y2tldElkXCInKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0eXBlb2YgZmlsZUlkID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEFwcHdyaXRlRXhjZXB0aW9uKCdNaXNzaW5nIHJlcXVpcmVkIHBhcmFtZXRlcjogXCJmaWxlSWRcIicpO1xuICAgICAgICB9XG5cblxuICAgICAgICBpZiAodHlwZW9mIHdpZHRoICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgcGF5bG9hZFsnd2lkdGgnXSA9IHdpZHRoO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHR5cGVvZiBoZWlnaHQgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICBwYXlsb2FkWydoZWlnaHQnXSA9IGhlaWdodDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0eXBlb2YgZ3Jhdml0eSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHBheWxvYWRbJ2dyYXZpdHknXSA9IGdyYXZpdHk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodHlwZW9mIHF1YWxpdHkgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICBwYXlsb2FkWydxdWFsaXR5J10gPSBxdWFsaXR5O1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHR5cGVvZiBib3JkZXJXaWR0aCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHBheWxvYWRbJ2JvcmRlcldpZHRoJ10gPSBib3JkZXJXaWR0aDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0eXBlb2YgYm9yZGVyQ29sb3IgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICBwYXlsb2FkWydib3JkZXJDb2xvciddID0gYm9yZGVyQ29sb3I7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodHlwZW9mIGJvcmRlclJhZGl1cyAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHBheWxvYWRbJ2JvcmRlclJhZGl1cyddID0gYm9yZGVyUmFkaXVzO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHR5cGVvZiBvcGFjaXR5ICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgcGF5bG9hZFsnb3BhY2l0eSddID0gb3BhY2l0eTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0eXBlb2Ygcm90YXRpb24gIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICBwYXlsb2FkWydyb3RhdGlvbiddID0gcm90YXRpb247XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodHlwZW9mIGJhY2tncm91bmQgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICBwYXlsb2FkWydiYWNrZ3JvdW5kJ10gPSBiYWNrZ3JvdW5kO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHR5cGVvZiBvdXRwdXQgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICBwYXlsb2FkWydvdXRwdXQnXSA9IG91dHB1dDtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBhd2FpdCB0aGlzLmNsaWVudC5jYWxsKCdnZXQnLCBhcGlQYXRoLCB7XG4gICAgICAgICAgICAnY29udGVudC10eXBlJzogJ2FwcGxpY2F0aW9uL2pzb24nLFxuICAgICAgICB9LCBwYXlsb2FkLCAnYXJyYXlidWZmZXInKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZXQgZmlsZSBmb3Igdmlld1xuICAgICAqXG4gICAgICogR2V0IGEgZmlsZSBjb250ZW50IGJ5IGl0cyB1bmlxdWUgSUQuIFRoaXMgZW5kcG9pbnQgaXMgc2ltaWxhciB0byB0aGVcbiAgICAgKiBkb3dubG9hZCBtZXRob2QgYnV0IHJldHVybnMgd2l0aCBubyAgJ0NvbnRlbnQtRGlzcG9zaXRpb246IGF0dGFjaG1lbnQnXG4gICAgICogaGVhZGVyLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGJ1Y2tldElkXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGZpbGVJZFxuICAgICAqIEB0aHJvd3Mge0FwcHdyaXRlRXhjZXB0aW9ufVxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlfVxuICAgICAqL1xuICAgIGFzeW5jIGdldEZpbGVWaWV3KGJ1Y2tldElkLCBmaWxlSWQpIHtcbiAgICAgICAgY29uc3QgYXBpUGF0aCA9ICcvc3RvcmFnZS9idWNrZXRzL3tidWNrZXRJZH0vZmlsZXMve2ZpbGVJZH0vdmlldycucmVwbGFjZSgne2J1Y2tldElkfScsIGJ1Y2tldElkKS5yZXBsYWNlKCd7ZmlsZUlkfScsIGZpbGVJZCk7XG4gICAgICAgIGxldCBwYXlsb2FkID0ge307XG4gICAgICAgIGlmICh0eXBlb2YgYnVja2V0SWQgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgQXBwd3JpdGVFeGNlcHRpb24oJ01pc3NpbmcgcmVxdWlyZWQgcGFyYW1ldGVyOiBcImJ1Y2tldElkXCInKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0eXBlb2YgZmlsZUlkID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEFwcHdyaXRlRXhjZXB0aW9uKCdNaXNzaW5nIHJlcXVpcmVkIHBhcmFtZXRlcjogXCJmaWxlSWRcIicpO1xuICAgICAgICB9XG5cblxuICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy5jbGllbnQuY2FsbCgnZ2V0JywgYXBpUGF0aCwge1xuICAgICAgICAgICAgJ2NvbnRlbnQtdHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJyxcbiAgICAgICAgfSwgcGF5bG9hZCwgJ2FycmF5YnVmZmVyJyk7XG4gICAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IFN0b3JhZ2U7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/node-appwrite/lib/services/storage.js\n");

/***/ }),

/***/ "(action-browser)/./node_modules/node-appwrite/lib/services/teams.js":
/*!**********************************************************!*\
  !*** ./node_modules/node-appwrite/lib/services/teams.js ***!
  \**********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("const Service = __webpack_require__(/*! ../service.js */ \"(action-browser)/./node_modules/node-appwrite/lib/service.js\");\nconst AppwriteException = __webpack_require__(/*! ../exception.js */ \"(action-browser)/./node_modules/node-appwrite/lib/exception.js\");\nconst InputFile = __webpack_require__(/*! ../inputFile.js */ \"(action-browser)/./node_modules/node-appwrite/lib/inputFile.js\");\nconst client = __webpack_require__(/*! ../client.js */ \"(action-browser)/./node_modules/node-appwrite/lib/client.js\");\nconst Stream = __webpack_require__(/*! stream */ \"stream\");\nconst { promisify } = __webpack_require__(/*! util */ \"util\");\nconst fs = __webpack_require__(/*! fs */ \"fs\");\nconst { File } = __webpack_require__(/*! undici */ \"undici\");\nconst Query = __webpack_require__(/*! ../query.js */ \"(action-browser)/./node_modules/node-appwrite/lib/query.js\");\n\nclass Teams extends Service {\n\n     constructor(client)\n     {\n        super(client);\n     }\n\n\n    /**\n     * List teams\n     *\n     * Get a list of all the teams in which the current user is a member. You can\n     * use the parameters to filter your results.\n     *\n     * @param {string[]} queries\n     * @param {string} search\n     * @throws {AppwriteException}\n     * @returns {Promise}\n     */\n    async list(queries, search) {\n        const apiPath = '/teams';\n        let payload = {};\n\n        if (typeof queries !== 'undefined') {\n            payload['queries'] = queries;\n        }\n\n        if (typeof search !== 'undefined') {\n            payload['search'] = search;\n        }\n\n        return await this.client.call('get', apiPath, {\n            'content-type': 'application/json',\n        }, payload);\n    }\n\n    /**\n     * Create team\n     *\n     * Create a new team. The user who creates the team will automatically be\n     * assigned as the owner of the team. Only the users with the owner role can\n     * invite new members, add new owners and delete or update the team.\n     *\n     * @param {string} teamId\n     * @param {string} name\n     * @param {string[]} roles\n     * @throws {AppwriteException}\n     * @returns {Promise}\n     */\n    async create(teamId, name, roles) {\n        const apiPath = '/teams';\n        let payload = {};\n        if (typeof teamId === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"teamId\"');\n        }\n\n        if (typeof name === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"name\"');\n        }\n\n\n        if (typeof teamId !== 'undefined') {\n            payload['teamId'] = teamId;\n        }\n\n        if (typeof name !== 'undefined') {\n            payload['name'] = name;\n        }\n\n        if (typeof roles !== 'undefined') {\n            payload['roles'] = roles;\n        }\n\n        return await this.client.call('post', apiPath, {\n            'content-type': 'application/json',\n        }, payload);\n    }\n\n    /**\n     * Get team\n     *\n     * Get a team by its ID. All team members have read access for this resource.\n     *\n     * @param {string} teamId\n     * @throws {AppwriteException}\n     * @returns {Promise}\n     */\n    async get(teamId) {\n        const apiPath = '/teams/{teamId}'.replace('{teamId}', teamId);\n        let payload = {};\n        if (typeof teamId === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"teamId\"');\n        }\n\n\n        return await this.client.call('get', apiPath, {\n            'content-type': 'application/json',\n        }, payload);\n    }\n\n    /**\n     * Update name\n     *\n     * Update the team's name by its unique ID.\n     *\n     * @param {string} teamId\n     * @param {string} name\n     * @throws {AppwriteException}\n     * @returns {Promise}\n     */\n    async updateName(teamId, name) {\n        const apiPath = '/teams/{teamId}'.replace('{teamId}', teamId);\n        let payload = {};\n        if (typeof teamId === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"teamId\"');\n        }\n\n        if (typeof name === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"name\"');\n        }\n\n\n        if (typeof name !== 'undefined') {\n            payload['name'] = name;\n        }\n\n        return await this.client.call('put', apiPath, {\n            'content-type': 'application/json',\n        }, payload);\n    }\n\n    /**\n     * Delete team\n     *\n     * Delete a team using its ID. Only team members with the owner role can\n     * delete the team.\n     *\n     * @param {string} teamId\n     * @throws {AppwriteException}\n     * @returns {Promise}\n     */\n    async delete(teamId) {\n        const apiPath = '/teams/{teamId}'.replace('{teamId}', teamId);\n        let payload = {};\n        if (typeof teamId === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"teamId\"');\n        }\n\n\n        return await this.client.call('delete', apiPath, {\n            'content-type': 'application/json',\n        }, payload);\n    }\n\n    /**\n     * List team memberships\n     *\n     * Use this endpoint to list a team's members using the team's ID. All team\n     * members have read access to this endpoint.\n     *\n     * @param {string} teamId\n     * @param {string[]} queries\n     * @param {string} search\n     * @throws {AppwriteException}\n     * @returns {Promise}\n     */\n    async listMemberships(teamId, queries, search) {\n        const apiPath = '/teams/{teamId}/memberships'.replace('{teamId}', teamId);\n        let payload = {};\n        if (typeof teamId === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"teamId\"');\n        }\n\n\n        if (typeof queries !== 'undefined') {\n            payload['queries'] = queries;\n        }\n\n        if (typeof search !== 'undefined') {\n            payload['search'] = search;\n        }\n\n        return await this.client.call('get', apiPath, {\n            'content-type': 'application/json',\n        }, payload);\n    }\n\n    /**\n     * Create team membership\n     *\n     * Invite a new member to join your team. Provide an ID for existing users, or\n     * invite unregistered users using an email or phone number. If initiated from\n     * a Client SDK, Appwrite will send an email or sms with a link to join the\n     * team to the invited user, and an account will be created for them if one\n     * doesn't exist. If initiated from a Server SDK, the new member will be added\n     * automatically to the team.\n     * \n     * You only need to provide one of a user ID, email, or phone number. Appwrite\n     * will prioritize accepting the user ID > email > phone number if you provide\n     * more than one of these parameters.\n     * \n     * Use the `url` parameter to redirect the user from the invitation email to\n     * your app. After the user is redirected, use the [Update Team Membership\n     * Status](https://appwrite.io/docs/references/cloud/client-web/teams#updateMembershipStatus)\n     * endpoint to allow the user to accept the invitation to the team. \n     * \n     * Please note that to avoid a [Redirect\n     * Attack](https://github.com/OWASP/CheatSheetSeries/blob/master/cheatsheets/Unvalidated_Redirects_and_Forwards_Cheat_Sheet.md)\n     * Appwrite will accept the only redirect URLs under the domains you have\n     * added as a platform on the Appwrite Console.\n     * \n     *\n     * @param {string} teamId\n     * @param {string[]} roles\n     * @param {string} email\n     * @param {string} userId\n     * @param {string} phone\n     * @param {string} url\n     * @param {string} name\n     * @throws {AppwriteException}\n     * @returns {Promise}\n     */\n    async createMembership(teamId, roles, email, userId, phone, url, name) {\n        const apiPath = '/teams/{teamId}/memberships'.replace('{teamId}', teamId);\n        let payload = {};\n        if (typeof teamId === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"teamId\"');\n        }\n\n        if (typeof roles === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"roles\"');\n        }\n\n\n        if (typeof email !== 'undefined') {\n            payload['email'] = email;\n        }\n\n        if (typeof userId !== 'undefined') {\n            payload['userId'] = userId;\n        }\n\n        if (typeof phone !== 'undefined') {\n            payload['phone'] = phone;\n        }\n\n        if (typeof roles !== 'undefined') {\n            payload['roles'] = roles;\n        }\n\n        if (typeof url !== 'undefined') {\n            payload['url'] = url;\n        }\n\n        if (typeof name !== 'undefined') {\n            payload['name'] = name;\n        }\n\n        return await this.client.call('post', apiPath, {\n            'content-type': 'application/json',\n        }, payload);\n    }\n\n    /**\n     * Get team membership\n     *\n     * Get a team member by the membership unique id. All team members have read\n     * access for this resource.\n     *\n     * @param {string} teamId\n     * @param {string} membershipId\n     * @throws {AppwriteException}\n     * @returns {Promise}\n     */\n    async getMembership(teamId, membershipId) {\n        const apiPath = '/teams/{teamId}/memberships/{membershipId}'.replace('{teamId}', teamId).replace('{membershipId}', membershipId);\n        let payload = {};\n        if (typeof teamId === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"teamId\"');\n        }\n\n        if (typeof membershipId === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"membershipId\"');\n        }\n\n\n        return await this.client.call('get', apiPath, {\n            'content-type': 'application/json',\n        }, payload);\n    }\n\n    /**\n     * Update membership\n     *\n     * Modify the roles of a team member. Only team members with the owner role\n     * have access to this endpoint. Learn more about [roles and\n     * permissions](https://appwrite.io/docs/permissions).\n     * \n     *\n     * @param {string} teamId\n     * @param {string} membershipId\n     * @param {string[]} roles\n     * @throws {AppwriteException}\n     * @returns {Promise}\n     */\n    async updateMembership(teamId, membershipId, roles) {\n        const apiPath = '/teams/{teamId}/memberships/{membershipId}'.replace('{teamId}', teamId).replace('{membershipId}', membershipId);\n        let payload = {};\n        if (typeof teamId === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"teamId\"');\n        }\n\n        if (typeof membershipId === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"membershipId\"');\n        }\n\n        if (typeof roles === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"roles\"');\n        }\n\n\n        if (typeof roles !== 'undefined') {\n            payload['roles'] = roles;\n        }\n\n        return await this.client.call('patch', apiPath, {\n            'content-type': 'application/json',\n        }, payload);\n    }\n\n    /**\n     * Delete team membership\n     *\n     * This endpoint allows a user to leave a team or for a team owner to delete\n     * the membership of any other team member. You can also use this endpoint to\n     * delete a user membership even if it is not accepted.\n     *\n     * @param {string} teamId\n     * @param {string} membershipId\n     * @throws {AppwriteException}\n     * @returns {Promise}\n     */\n    async deleteMembership(teamId, membershipId) {\n        const apiPath = '/teams/{teamId}/memberships/{membershipId}'.replace('{teamId}', teamId).replace('{membershipId}', membershipId);\n        let payload = {};\n        if (typeof teamId === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"teamId\"');\n        }\n\n        if (typeof membershipId === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"membershipId\"');\n        }\n\n\n        return await this.client.call('delete', apiPath, {\n            'content-type': 'application/json',\n        }, payload);\n    }\n\n    /**\n     * Update team membership status\n     *\n     * Use this endpoint to allow a user to accept an invitation to join a team\n     * after being redirected back to your app from the invitation email received\n     * by the user.\n     * \n     * If the request is successful, a session for the user is automatically\n     * created.\n     * \n     *\n     * @param {string} teamId\n     * @param {string} membershipId\n     * @param {string} userId\n     * @param {string} secret\n     * @throws {AppwriteException}\n     * @returns {Promise}\n     */\n    async updateMembershipStatus(teamId, membershipId, userId, secret) {\n        const apiPath = '/teams/{teamId}/memberships/{membershipId}/status'.replace('{teamId}', teamId).replace('{membershipId}', membershipId);\n        let payload = {};\n        if (typeof teamId === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"teamId\"');\n        }\n\n        if (typeof membershipId === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"membershipId\"');\n        }\n\n        if (typeof userId === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"userId\"');\n        }\n\n        if (typeof secret === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"secret\"');\n        }\n\n\n        if (typeof userId !== 'undefined') {\n            payload['userId'] = userId;\n        }\n\n        if (typeof secret !== 'undefined') {\n            payload['secret'] = secret;\n        }\n\n        return await this.client.call('patch', apiPath, {\n            'content-type': 'application/json',\n        }, payload);\n    }\n\n    /**\n     * Get team preferences\n     *\n     * Get the team's shared preferences by its unique ID. If a preference doesn't\n     * need to be shared by all team members, prefer storing them in [user\n     * preferences](https://appwrite.io/docs/references/cloud/client-web/account#getPrefs).\n     *\n     * @param {string} teamId\n     * @throws {AppwriteException}\n     * @returns {Promise}\n     */\n    async getPrefs(teamId) {\n        const apiPath = '/teams/{teamId}/prefs'.replace('{teamId}', teamId);\n        let payload = {};\n        if (typeof teamId === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"teamId\"');\n        }\n\n\n        return await this.client.call('get', apiPath, {\n            'content-type': 'application/json',\n        }, payload);\n    }\n\n    /**\n     * Update preferences\n     *\n     * Update the team's preferences by its unique ID. The object you pass is\n     * stored as is and replaces any previous value. The maximum allowed prefs\n     * size is 64kB and throws an error if exceeded.\n     *\n     * @param {string} teamId\n     * @param {object} prefs\n     * @throws {AppwriteException}\n     * @returns {Promise}\n     */\n    async updatePrefs(teamId, prefs) {\n        const apiPath = '/teams/{teamId}/prefs'.replace('{teamId}', teamId);\n        let payload = {};\n        if (typeof teamId === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"teamId\"');\n        }\n\n        if (typeof prefs === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"prefs\"');\n        }\n\n\n        if (typeof prefs !== 'undefined') {\n            payload['prefs'] = prefs;\n        }\n\n        return await this.client.call('put', apiPath, {\n            'content-type': 'application/json',\n        }, payload);\n    }\n}\n\nmodule.exports = Teams;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFjdGlvbi1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9ub2RlLWFwcHdyaXRlL2xpYi9zZXJ2aWNlcy90ZWFtcy5qcyIsIm1hcHBpbmdzIjoiQUFBQSxnQkFBZ0IsbUJBQU8sQ0FBQyxtRkFBZTtBQUN2QywwQkFBMEIsbUJBQU8sQ0FBQyx1RkFBaUI7QUFDbkQsa0JBQWtCLG1CQUFPLENBQUMsdUZBQWlCO0FBQzNDLGVBQWUsbUJBQU8sQ0FBQyxpRkFBYztBQUNyQyxlQUFlLG1CQUFPLENBQUMsc0JBQVE7QUFDL0IsUUFBUSxZQUFZLEVBQUUsbUJBQU8sQ0FBQyxrQkFBTTtBQUNwQyxXQUFXLG1CQUFPLENBQUMsY0FBSTtBQUN2QixRQUFRLE9BQU8sRUFBRSxtQkFBTyxDQUFDLHNCQUFRO0FBQ2pDLGNBQWMsbUJBQU8sQ0FBQywrRUFBYTs7QUFFbkM7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsVUFBVTtBQUN6QixlQUFlLFFBQVE7QUFDdkIsZ0JBQWdCO0FBQ2hCLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkIsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsVUFBVTtBQUN6QixnQkFBZ0I7QUFDaEIsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFNBQVM7QUFDVDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCLGdCQUFnQjtBQUNoQixpQkFBaUI7QUFDakI7QUFDQTtBQUNBLGlDQUFp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U0FBUztBQUNUOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkIsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsUUFBUTtBQUN2QixlQUFlLFFBQVE7QUFDdkIsZ0JBQWdCO0FBQ2hCLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0EsaUNBQWlDLE9BQU8sY0FBYyxhQUFhLG1CQUFtQixPQUFPLHFCQUFxQixhQUFhO0FBQy9IO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkIsZ0JBQWdCO0FBQ2hCLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0EsaUNBQWlDLE9BQU8sa0JBQWtCLE9BQU87QUFDakU7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkIsZUFBZSxRQUFRO0FBQ3ZCLGdCQUFnQjtBQUNoQixpQkFBaUI7QUFDakI7QUFDQTtBQUNBLGlDQUFpQyxPQUFPLGtCQUFrQixPQUFPO0FBQ2pFO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTs7QUFFQSIsInNvdXJjZXMiOlsid2VicGFjazovL2pzbV9iYW5raW5nLy4vbm9kZV9tb2R1bGVzL25vZGUtYXBwd3JpdGUvbGliL3NlcnZpY2VzL3RlYW1zLmpzPzRiZGEiXSwic291cmNlc0NvbnRlbnQiOlsiY29uc3QgU2VydmljZSA9IHJlcXVpcmUoJy4uL3NlcnZpY2UuanMnKTtcbmNvbnN0IEFwcHdyaXRlRXhjZXB0aW9uID0gcmVxdWlyZSgnLi4vZXhjZXB0aW9uLmpzJyk7XG5jb25zdCBJbnB1dEZpbGUgPSByZXF1aXJlKCcuLi9pbnB1dEZpbGUuanMnKTtcbmNvbnN0IGNsaWVudCA9IHJlcXVpcmUoJy4uL2NsaWVudC5qcycpO1xuY29uc3QgU3RyZWFtID0gcmVxdWlyZSgnc3RyZWFtJyk7XG5jb25zdCB7IHByb21pc2lmeSB9ID0gcmVxdWlyZSgndXRpbCcpO1xuY29uc3QgZnMgPSByZXF1aXJlKCdmcycpO1xuY29uc3QgeyBGaWxlIH0gPSByZXF1aXJlKCd1bmRpY2knKTtcbmNvbnN0IFF1ZXJ5ID0gcmVxdWlyZSgnLi4vcXVlcnkuanMnKTtcblxuY2xhc3MgVGVhbXMgZXh0ZW5kcyBTZXJ2aWNlIHtcblxuICAgICBjb25zdHJ1Y3RvcihjbGllbnQpXG4gICAgIHtcbiAgICAgICAgc3VwZXIoY2xpZW50KTtcbiAgICAgfVxuXG5cbiAgICAvKipcbiAgICAgKiBMaXN0IHRlYW1zXG4gICAgICpcbiAgICAgKiBHZXQgYSBsaXN0IG9mIGFsbCB0aGUgdGVhbXMgaW4gd2hpY2ggdGhlIGN1cnJlbnQgdXNlciBpcyBhIG1lbWJlci4gWW91IGNhblxuICAgICAqIHVzZSB0aGUgcGFyYW1ldGVycyB0byBmaWx0ZXIgeW91ciByZXN1bHRzLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmdbXX0gcXVlcmllc1xuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBzZWFyY2hcbiAgICAgKiBAdGhyb3dzIHtBcHB3cml0ZUV4Y2VwdGlvbn1cbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZX1cbiAgICAgKi9cbiAgICBhc3luYyBsaXN0KHF1ZXJpZXMsIHNlYXJjaCkge1xuICAgICAgICBjb25zdCBhcGlQYXRoID0gJy90ZWFtcyc7XG4gICAgICAgIGxldCBwYXlsb2FkID0ge307XG5cbiAgICAgICAgaWYgKHR5cGVvZiBxdWVyaWVzICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgcGF5bG9hZFsncXVlcmllcyddID0gcXVlcmllcztcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0eXBlb2Ygc2VhcmNoICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgcGF5bG9hZFsnc2VhcmNoJ10gPSBzZWFyY2g7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy5jbGllbnQuY2FsbCgnZ2V0JywgYXBpUGF0aCwge1xuICAgICAgICAgICAgJ2NvbnRlbnQtdHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJyxcbiAgICAgICAgfSwgcGF5bG9hZCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlIHRlYW1cbiAgICAgKlxuICAgICAqIENyZWF0ZSBhIG5ldyB0ZWFtLiBUaGUgdXNlciB3aG8gY3JlYXRlcyB0aGUgdGVhbSB3aWxsIGF1dG9tYXRpY2FsbHkgYmVcbiAgICAgKiBhc3NpZ25lZCBhcyB0aGUgb3duZXIgb2YgdGhlIHRlYW0uIE9ubHkgdGhlIHVzZXJzIHdpdGggdGhlIG93bmVyIHJvbGUgY2FuXG4gICAgICogaW52aXRlIG5ldyBtZW1iZXJzLCBhZGQgbmV3IG93bmVycyBhbmQgZGVsZXRlIG9yIHVwZGF0ZSB0aGUgdGVhbS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSB0ZWFtSWRcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gbmFtZVxuICAgICAqIEBwYXJhbSB7c3RyaW5nW119IHJvbGVzXG4gICAgICogQHRocm93cyB7QXBwd3JpdGVFeGNlcHRpb259XG4gICAgICogQHJldHVybnMge1Byb21pc2V9XG4gICAgICovXG4gICAgYXN5bmMgY3JlYXRlKHRlYW1JZCwgbmFtZSwgcm9sZXMpIHtcbiAgICAgICAgY29uc3QgYXBpUGF0aCA9ICcvdGVhbXMnO1xuICAgICAgICBsZXQgcGF5bG9hZCA9IHt9O1xuICAgICAgICBpZiAodHlwZW9mIHRlYW1JZCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBBcHB3cml0ZUV4Y2VwdGlvbignTWlzc2luZyByZXF1aXJlZCBwYXJhbWV0ZXI6IFwidGVhbUlkXCInKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0eXBlb2YgbmFtZSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBBcHB3cml0ZUV4Y2VwdGlvbignTWlzc2luZyByZXF1aXJlZCBwYXJhbWV0ZXI6IFwibmFtZVwiJyk7XG4gICAgICAgIH1cblxuXG4gICAgICAgIGlmICh0eXBlb2YgdGVhbUlkICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgcGF5bG9hZFsndGVhbUlkJ10gPSB0ZWFtSWQ7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodHlwZW9mIG5hbWUgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICBwYXlsb2FkWyduYW1lJ10gPSBuYW1lO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHR5cGVvZiByb2xlcyAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHBheWxvYWRbJ3JvbGVzJ10gPSByb2xlcztcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBhd2FpdCB0aGlzLmNsaWVudC5jYWxsKCdwb3N0JywgYXBpUGF0aCwge1xuICAgICAgICAgICAgJ2NvbnRlbnQtdHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJyxcbiAgICAgICAgfSwgcGF5bG9hZCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2V0IHRlYW1cbiAgICAgKlxuICAgICAqIEdldCBhIHRlYW0gYnkgaXRzIElELiBBbGwgdGVhbSBtZW1iZXJzIGhhdmUgcmVhZCBhY2Nlc3MgZm9yIHRoaXMgcmVzb3VyY2UuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gdGVhbUlkXG4gICAgICogQHRocm93cyB7QXBwd3JpdGVFeGNlcHRpb259XG4gICAgICogQHJldHVybnMge1Byb21pc2V9XG4gICAgICovXG4gICAgYXN5bmMgZ2V0KHRlYW1JZCkge1xuICAgICAgICBjb25zdCBhcGlQYXRoID0gJy90ZWFtcy97dGVhbUlkfScucmVwbGFjZSgne3RlYW1JZH0nLCB0ZWFtSWQpO1xuICAgICAgICBsZXQgcGF5bG9hZCA9IHt9O1xuICAgICAgICBpZiAodHlwZW9mIHRlYW1JZCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBBcHB3cml0ZUV4Y2VwdGlvbignTWlzc2luZyByZXF1aXJlZCBwYXJhbWV0ZXI6IFwidGVhbUlkXCInKTtcbiAgICAgICAgfVxuXG5cbiAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMuY2xpZW50LmNhbGwoJ2dldCcsIGFwaVBhdGgsIHtcbiAgICAgICAgICAgICdjb250ZW50LXR5cGUnOiAnYXBwbGljYXRpb24vanNvbicsXG4gICAgICAgIH0sIHBheWxvYWQpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFVwZGF0ZSBuYW1lXG4gICAgICpcbiAgICAgKiBVcGRhdGUgdGhlIHRlYW0ncyBuYW1lIGJ5IGl0cyB1bmlxdWUgSUQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gdGVhbUlkXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IG5hbWVcbiAgICAgKiBAdGhyb3dzIHtBcHB3cml0ZUV4Y2VwdGlvbn1cbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZX1cbiAgICAgKi9cbiAgICBhc3luYyB1cGRhdGVOYW1lKHRlYW1JZCwgbmFtZSkge1xuICAgICAgICBjb25zdCBhcGlQYXRoID0gJy90ZWFtcy97dGVhbUlkfScucmVwbGFjZSgne3RlYW1JZH0nLCB0ZWFtSWQpO1xuICAgICAgICBsZXQgcGF5bG9hZCA9IHt9O1xuICAgICAgICBpZiAodHlwZW9mIHRlYW1JZCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBBcHB3cml0ZUV4Y2VwdGlvbignTWlzc2luZyByZXF1aXJlZCBwYXJhbWV0ZXI6IFwidGVhbUlkXCInKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0eXBlb2YgbmFtZSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBBcHB3cml0ZUV4Y2VwdGlvbignTWlzc2luZyByZXF1aXJlZCBwYXJhbWV0ZXI6IFwibmFtZVwiJyk7XG4gICAgICAgIH1cblxuXG4gICAgICAgIGlmICh0eXBlb2YgbmFtZSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHBheWxvYWRbJ25hbWUnXSA9IG5hbWU7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy5jbGllbnQuY2FsbCgncHV0JywgYXBpUGF0aCwge1xuICAgICAgICAgICAgJ2NvbnRlbnQtdHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJyxcbiAgICAgICAgfSwgcGF5bG9hZCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRGVsZXRlIHRlYW1cbiAgICAgKlxuICAgICAqIERlbGV0ZSBhIHRlYW0gdXNpbmcgaXRzIElELiBPbmx5IHRlYW0gbWVtYmVycyB3aXRoIHRoZSBvd25lciByb2xlIGNhblxuICAgICAqIGRlbGV0ZSB0aGUgdGVhbS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSB0ZWFtSWRcbiAgICAgKiBAdGhyb3dzIHtBcHB3cml0ZUV4Y2VwdGlvbn1cbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZX1cbiAgICAgKi9cbiAgICBhc3luYyBkZWxldGUodGVhbUlkKSB7XG4gICAgICAgIGNvbnN0IGFwaVBhdGggPSAnL3RlYW1zL3t0ZWFtSWR9Jy5yZXBsYWNlKCd7dGVhbUlkfScsIHRlYW1JZCk7XG4gICAgICAgIGxldCBwYXlsb2FkID0ge307XG4gICAgICAgIGlmICh0eXBlb2YgdGVhbUlkID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEFwcHdyaXRlRXhjZXB0aW9uKCdNaXNzaW5nIHJlcXVpcmVkIHBhcmFtZXRlcjogXCJ0ZWFtSWRcIicpO1xuICAgICAgICB9XG5cblxuICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy5jbGllbnQuY2FsbCgnZGVsZXRlJywgYXBpUGF0aCwge1xuICAgICAgICAgICAgJ2NvbnRlbnQtdHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJyxcbiAgICAgICAgfSwgcGF5bG9hZCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogTGlzdCB0ZWFtIG1lbWJlcnNoaXBzXG4gICAgICpcbiAgICAgKiBVc2UgdGhpcyBlbmRwb2ludCB0byBsaXN0IGEgdGVhbSdzIG1lbWJlcnMgdXNpbmcgdGhlIHRlYW0ncyBJRC4gQWxsIHRlYW1cbiAgICAgKiBtZW1iZXJzIGhhdmUgcmVhZCBhY2Nlc3MgdG8gdGhpcyBlbmRwb2ludC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSB0ZWFtSWRcbiAgICAgKiBAcGFyYW0ge3N0cmluZ1tdfSBxdWVyaWVzXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHNlYXJjaFxuICAgICAqIEB0aHJvd3Mge0FwcHdyaXRlRXhjZXB0aW9ufVxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlfVxuICAgICAqL1xuICAgIGFzeW5jIGxpc3RNZW1iZXJzaGlwcyh0ZWFtSWQsIHF1ZXJpZXMsIHNlYXJjaCkge1xuICAgICAgICBjb25zdCBhcGlQYXRoID0gJy90ZWFtcy97dGVhbUlkfS9tZW1iZXJzaGlwcycucmVwbGFjZSgne3RlYW1JZH0nLCB0ZWFtSWQpO1xuICAgICAgICBsZXQgcGF5bG9hZCA9IHt9O1xuICAgICAgICBpZiAodHlwZW9mIHRlYW1JZCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBBcHB3cml0ZUV4Y2VwdGlvbignTWlzc2luZyByZXF1aXJlZCBwYXJhbWV0ZXI6IFwidGVhbUlkXCInKTtcbiAgICAgICAgfVxuXG5cbiAgICAgICAgaWYgKHR5cGVvZiBxdWVyaWVzICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgcGF5bG9hZFsncXVlcmllcyddID0gcXVlcmllcztcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0eXBlb2Ygc2VhcmNoICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgcGF5bG9hZFsnc2VhcmNoJ10gPSBzZWFyY2g7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy5jbGllbnQuY2FsbCgnZ2V0JywgYXBpUGF0aCwge1xuICAgICAgICAgICAgJ2NvbnRlbnQtdHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJyxcbiAgICAgICAgfSwgcGF5bG9hZCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlIHRlYW0gbWVtYmVyc2hpcFxuICAgICAqXG4gICAgICogSW52aXRlIGEgbmV3IG1lbWJlciB0byBqb2luIHlvdXIgdGVhbS4gUHJvdmlkZSBhbiBJRCBmb3IgZXhpc3RpbmcgdXNlcnMsIG9yXG4gICAgICogaW52aXRlIHVucmVnaXN0ZXJlZCB1c2VycyB1c2luZyBhbiBlbWFpbCBvciBwaG9uZSBudW1iZXIuIElmIGluaXRpYXRlZCBmcm9tXG4gICAgICogYSBDbGllbnQgU0RLLCBBcHB3cml0ZSB3aWxsIHNlbmQgYW4gZW1haWwgb3Igc21zIHdpdGggYSBsaW5rIHRvIGpvaW4gdGhlXG4gICAgICogdGVhbSB0byB0aGUgaW52aXRlZCB1c2VyLCBhbmQgYW4gYWNjb3VudCB3aWxsIGJlIGNyZWF0ZWQgZm9yIHRoZW0gaWYgb25lXG4gICAgICogZG9lc24ndCBleGlzdC4gSWYgaW5pdGlhdGVkIGZyb20gYSBTZXJ2ZXIgU0RLLCB0aGUgbmV3IG1lbWJlciB3aWxsIGJlIGFkZGVkXG4gICAgICogYXV0b21hdGljYWxseSB0byB0aGUgdGVhbS5cbiAgICAgKiBcbiAgICAgKiBZb3Ugb25seSBuZWVkIHRvIHByb3ZpZGUgb25lIG9mIGEgdXNlciBJRCwgZW1haWwsIG9yIHBob25lIG51bWJlci4gQXBwd3JpdGVcbiAgICAgKiB3aWxsIHByaW9yaXRpemUgYWNjZXB0aW5nIHRoZSB1c2VyIElEID4gZW1haWwgPiBwaG9uZSBudW1iZXIgaWYgeW91IHByb3ZpZGVcbiAgICAgKiBtb3JlIHRoYW4gb25lIG9mIHRoZXNlIHBhcmFtZXRlcnMuXG4gICAgICogXG4gICAgICogVXNlIHRoZSBgdXJsYCBwYXJhbWV0ZXIgdG8gcmVkaXJlY3QgdGhlIHVzZXIgZnJvbSB0aGUgaW52aXRhdGlvbiBlbWFpbCB0b1xuICAgICAqIHlvdXIgYXBwLiBBZnRlciB0aGUgdXNlciBpcyByZWRpcmVjdGVkLCB1c2UgdGhlIFtVcGRhdGUgVGVhbSBNZW1iZXJzaGlwXG4gICAgICogU3RhdHVzXShodHRwczovL2FwcHdyaXRlLmlvL2RvY3MvcmVmZXJlbmNlcy9jbG91ZC9jbGllbnQtd2ViL3RlYW1zI3VwZGF0ZU1lbWJlcnNoaXBTdGF0dXMpXG4gICAgICogZW5kcG9pbnQgdG8gYWxsb3cgdGhlIHVzZXIgdG8gYWNjZXB0IHRoZSBpbnZpdGF0aW9uIHRvIHRoZSB0ZWFtLiBcbiAgICAgKiBcbiAgICAgKiBQbGVhc2Ugbm90ZSB0aGF0IHRvIGF2b2lkIGEgW1JlZGlyZWN0XG4gICAgICogQXR0YWNrXShodHRwczovL2dpdGh1Yi5jb20vT1dBU1AvQ2hlYXRTaGVldFNlcmllcy9ibG9iL21hc3Rlci9jaGVhdHNoZWV0cy9VbnZhbGlkYXRlZF9SZWRpcmVjdHNfYW5kX0ZvcndhcmRzX0NoZWF0X1NoZWV0Lm1kKVxuICAgICAqIEFwcHdyaXRlIHdpbGwgYWNjZXB0IHRoZSBvbmx5IHJlZGlyZWN0IFVSTHMgdW5kZXIgdGhlIGRvbWFpbnMgeW91IGhhdmVcbiAgICAgKiBhZGRlZCBhcyBhIHBsYXRmb3JtIG9uIHRoZSBBcHB3cml0ZSBDb25zb2xlLlxuICAgICAqIFxuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHRlYW1JZFxuICAgICAqIEBwYXJhbSB7c3RyaW5nW119IHJvbGVzXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGVtYWlsXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHVzZXJJZFxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBwaG9uZVxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSB1cmxcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gbmFtZVxuICAgICAqIEB0aHJvd3Mge0FwcHdyaXRlRXhjZXB0aW9ufVxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlfVxuICAgICAqL1xuICAgIGFzeW5jIGNyZWF0ZU1lbWJlcnNoaXAodGVhbUlkLCByb2xlcywgZW1haWwsIHVzZXJJZCwgcGhvbmUsIHVybCwgbmFtZSkge1xuICAgICAgICBjb25zdCBhcGlQYXRoID0gJy90ZWFtcy97dGVhbUlkfS9tZW1iZXJzaGlwcycucmVwbGFjZSgne3RlYW1JZH0nLCB0ZWFtSWQpO1xuICAgICAgICBsZXQgcGF5bG9hZCA9IHt9O1xuICAgICAgICBpZiAodHlwZW9mIHRlYW1JZCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBBcHB3cml0ZUV4Y2VwdGlvbignTWlzc2luZyByZXF1aXJlZCBwYXJhbWV0ZXI6IFwidGVhbUlkXCInKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0eXBlb2Ygcm9sZXMgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgQXBwd3JpdGVFeGNlcHRpb24oJ01pc3NpbmcgcmVxdWlyZWQgcGFyYW1ldGVyOiBcInJvbGVzXCInKTtcbiAgICAgICAgfVxuXG5cbiAgICAgICAgaWYgKHR5cGVvZiBlbWFpbCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHBheWxvYWRbJ2VtYWlsJ10gPSBlbWFpbDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0eXBlb2YgdXNlcklkICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgcGF5bG9hZFsndXNlcklkJ10gPSB1c2VySWQ7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodHlwZW9mIHBob25lICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgcGF5bG9hZFsncGhvbmUnXSA9IHBob25lO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHR5cGVvZiByb2xlcyAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHBheWxvYWRbJ3JvbGVzJ10gPSByb2xlcztcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0eXBlb2YgdXJsICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgcGF5bG9hZFsndXJsJ10gPSB1cmw7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodHlwZW9mIG5hbWUgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICBwYXlsb2FkWyduYW1lJ10gPSBuYW1lO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMuY2xpZW50LmNhbGwoJ3Bvc3QnLCBhcGlQYXRoLCB7XG4gICAgICAgICAgICAnY29udGVudC10eXBlJzogJ2FwcGxpY2F0aW9uL2pzb24nLFxuICAgICAgICB9LCBwYXlsb2FkKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZXQgdGVhbSBtZW1iZXJzaGlwXG4gICAgICpcbiAgICAgKiBHZXQgYSB0ZWFtIG1lbWJlciBieSB0aGUgbWVtYmVyc2hpcCB1bmlxdWUgaWQuIEFsbCB0ZWFtIG1lbWJlcnMgaGF2ZSByZWFkXG4gICAgICogYWNjZXNzIGZvciB0aGlzIHJlc291cmNlLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHRlYW1JZFxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBtZW1iZXJzaGlwSWRcbiAgICAgKiBAdGhyb3dzIHtBcHB3cml0ZUV4Y2VwdGlvbn1cbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZX1cbiAgICAgKi9cbiAgICBhc3luYyBnZXRNZW1iZXJzaGlwKHRlYW1JZCwgbWVtYmVyc2hpcElkKSB7XG4gICAgICAgIGNvbnN0IGFwaVBhdGggPSAnL3RlYW1zL3t0ZWFtSWR9L21lbWJlcnNoaXBzL3ttZW1iZXJzaGlwSWR9Jy5yZXBsYWNlKCd7dGVhbUlkfScsIHRlYW1JZCkucmVwbGFjZSgne21lbWJlcnNoaXBJZH0nLCBtZW1iZXJzaGlwSWQpO1xuICAgICAgICBsZXQgcGF5bG9hZCA9IHt9O1xuICAgICAgICBpZiAodHlwZW9mIHRlYW1JZCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBBcHB3cml0ZUV4Y2VwdGlvbignTWlzc2luZyByZXF1aXJlZCBwYXJhbWV0ZXI6IFwidGVhbUlkXCInKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0eXBlb2YgbWVtYmVyc2hpcElkID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEFwcHdyaXRlRXhjZXB0aW9uKCdNaXNzaW5nIHJlcXVpcmVkIHBhcmFtZXRlcjogXCJtZW1iZXJzaGlwSWRcIicpO1xuICAgICAgICB9XG5cblxuICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy5jbGllbnQuY2FsbCgnZ2V0JywgYXBpUGF0aCwge1xuICAgICAgICAgICAgJ2NvbnRlbnQtdHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJyxcbiAgICAgICAgfSwgcGF5bG9hZCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVXBkYXRlIG1lbWJlcnNoaXBcbiAgICAgKlxuICAgICAqIE1vZGlmeSB0aGUgcm9sZXMgb2YgYSB0ZWFtIG1lbWJlci4gT25seSB0ZWFtIG1lbWJlcnMgd2l0aCB0aGUgb3duZXIgcm9sZVxuICAgICAqIGhhdmUgYWNjZXNzIHRvIHRoaXMgZW5kcG9pbnQuIExlYXJuIG1vcmUgYWJvdXQgW3JvbGVzIGFuZFxuICAgICAqIHBlcm1pc3Npb25zXShodHRwczovL2FwcHdyaXRlLmlvL2RvY3MvcGVybWlzc2lvbnMpLlxuICAgICAqIFxuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHRlYW1JZFxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBtZW1iZXJzaGlwSWRcbiAgICAgKiBAcGFyYW0ge3N0cmluZ1tdfSByb2xlc1xuICAgICAqIEB0aHJvd3Mge0FwcHdyaXRlRXhjZXB0aW9ufVxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlfVxuICAgICAqL1xuICAgIGFzeW5jIHVwZGF0ZU1lbWJlcnNoaXAodGVhbUlkLCBtZW1iZXJzaGlwSWQsIHJvbGVzKSB7XG4gICAgICAgIGNvbnN0IGFwaVBhdGggPSAnL3RlYW1zL3t0ZWFtSWR9L21lbWJlcnNoaXBzL3ttZW1iZXJzaGlwSWR9Jy5yZXBsYWNlKCd7dGVhbUlkfScsIHRlYW1JZCkucmVwbGFjZSgne21lbWJlcnNoaXBJZH0nLCBtZW1iZXJzaGlwSWQpO1xuICAgICAgICBsZXQgcGF5bG9hZCA9IHt9O1xuICAgICAgICBpZiAodHlwZW9mIHRlYW1JZCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBBcHB3cml0ZUV4Y2VwdGlvbignTWlzc2luZyByZXF1aXJlZCBwYXJhbWV0ZXI6IFwidGVhbUlkXCInKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0eXBlb2YgbWVtYmVyc2hpcElkID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEFwcHdyaXRlRXhjZXB0aW9uKCdNaXNzaW5nIHJlcXVpcmVkIHBhcmFtZXRlcjogXCJtZW1iZXJzaGlwSWRcIicpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHR5cGVvZiByb2xlcyA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBBcHB3cml0ZUV4Y2VwdGlvbignTWlzc2luZyByZXF1aXJlZCBwYXJhbWV0ZXI6IFwicm9sZXNcIicpO1xuICAgICAgICB9XG5cblxuICAgICAgICBpZiAodHlwZW9mIHJvbGVzICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgcGF5bG9hZFsncm9sZXMnXSA9IHJvbGVzO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMuY2xpZW50LmNhbGwoJ3BhdGNoJywgYXBpUGF0aCwge1xuICAgICAgICAgICAgJ2NvbnRlbnQtdHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJyxcbiAgICAgICAgfSwgcGF5bG9hZCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRGVsZXRlIHRlYW0gbWVtYmVyc2hpcFxuICAgICAqXG4gICAgICogVGhpcyBlbmRwb2ludCBhbGxvd3MgYSB1c2VyIHRvIGxlYXZlIGEgdGVhbSBvciBmb3IgYSB0ZWFtIG93bmVyIHRvIGRlbGV0ZVxuICAgICAqIHRoZSBtZW1iZXJzaGlwIG9mIGFueSBvdGhlciB0ZWFtIG1lbWJlci4gWW91IGNhbiBhbHNvIHVzZSB0aGlzIGVuZHBvaW50IHRvXG4gICAgICogZGVsZXRlIGEgdXNlciBtZW1iZXJzaGlwIGV2ZW4gaWYgaXQgaXMgbm90IGFjY2VwdGVkLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHRlYW1JZFxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBtZW1iZXJzaGlwSWRcbiAgICAgKiBAdGhyb3dzIHtBcHB3cml0ZUV4Y2VwdGlvbn1cbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZX1cbiAgICAgKi9cbiAgICBhc3luYyBkZWxldGVNZW1iZXJzaGlwKHRlYW1JZCwgbWVtYmVyc2hpcElkKSB7XG4gICAgICAgIGNvbnN0IGFwaVBhdGggPSAnL3RlYW1zL3t0ZWFtSWR9L21lbWJlcnNoaXBzL3ttZW1iZXJzaGlwSWR9Jy5yZXBsYWNlKCd7dGVhbUlkfScsIHRlYW1JZCkucmVwbGFjZSgne21lbWJlcnNoaXBJZH0nLCBtZW1iZXJzaGlwSWQpO1xuICAgICAgICBsZXQgcGF5bG9hZCA9IHt9O1xuICAgICAgICBpZiAodHlwZW9mIHRlYW1JZCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBBcHB3cml0ZUV4Y2VwdGlvbignTWlzc2luZyByZXF1aXJlZCBwYXJhbWV0ZXI6IFwidGVhbUlkXCInKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0eXBlb2YgbWVtYmVyc2hpcElkID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEFwcHdyaXRlRXhjZXB0aW9uKCdNaXNzaW5nIHJlcXVpcmVkIHBhcmFtZXRlcjogXCJtZW1iZXJzaGlwSWRcIicpO1xuICAgICAgICB9XG5cblxuICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy5jbGllbnQuY2FsbCgnZGVsZXRlJywgYXBpUGF0aCwge1xuICAgICAgICAgICAgJ2NvbnRlbnQtdHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJyxcbiAgICAgICAgfSwgcGF5bG9hZCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVXBkYXRlIHRlYW0gbWVtYmVyc2hpcCBzdGF0dXNcbiAgICAgKlxuICAgICAqIFVzZSB0aGlzIGVuZHBvaW50IHRvIGFsbG93IGEgdXNlciB0byBhY2NlcHQgYW4gaW52aXRhdGlvbiB0byBqb2luIGEgdGVhbVxuICAgICAqIGFmdGVyIGJlaW5nIHJlZGlyZWN0ZWQgYmFjayB0byB5b3VyIGFwcCBmcm9tIHRoZSBpbnZpdGF0aW9uIGVtYWlsIHJlY2VpdmVkXG4gICAgICogYnkgdGhlIHVzZXIuXG4gICAgICogXG4gICAgICogSWYgdGhlIHJlcXVlc3QgaXMgc3VjY2Vzc2Z1bCwgYSBzZXNzaW9uIGZvciB0aGUgdXNlciBpcyBhdXRvbWF0aWNhbGx5XG4gICAgICogY3JlYXRlZC5cbiAgICAgKiBcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSB0ZWFtSWRcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gbWVtYmVyc2hpcElkXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHVzZXJJZFxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBzZWNyZXRcbiAgICAgKiBAdGhyb3dzIHtBcHB3cml0ZUV4Y2VwdGlvbn1cbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZX1cbiAgICAgKi9cbiAgICBhc3luYyB1cGRhdGVNZW1iZXJzaGlwU3RhdHVzKHRlYW1JZCwgbWVtYmVyc2hpcElkLCB1c2VySWQsIHNlY3JldCkge1xuICAgICAgICBjb25zdCBhcGlQYXRoID0gJy90ZWFtcy97dGVhbUlkfS9tZW1iZXJzaGlwcy97bWVtYmVyc2hpcElkfS9zdGF0dXMnLnJlcGxhY2UoJ3t0ZWFtSWR9JywgdGVhbUlkKS5yZXBsYWNlKCd7bWVtYmVyc2hpcElkfScsIG1lbWJlcnNoaXBJZCk7XG4gICAgICAgIGxldCBwYXlsb2FkID0ge307XG4gICAgICAgIGlmICh0eXBlb2YgdGVhbUlkID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEFwcHdyaXRlRXhjZXB0aW9uKCdNaXNzaW5nIHJlcXVpcmVkIHBhcmFtZXRlcjogXCJ0ZWFtSWRcIicpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHR5cGVvZiBtZW1iZXJzaGlwSWQgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgQXBwd3JpdGVFeGNlcHRpb24oJ01pc3NpbmcgcmVxdWlyZWQgcGFyYW1ldGVyOiBcIm1lbWJlcnNoaXBJZFwiJyk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodHlwZW9mIHVzZXJJZCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBBcHB3cml0ZUV4Y2VwdGlvbignTWlzc2luZyByZXF1aXJlZCBwYXJhbWV0ZXI6IFwidXNlcklkXCInKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0eXBlb2Ygc2VjcmV0ID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEFwcHdyaXRlRXhjZXB0aW9uKCdNaXNzaW5nIHJlcXVpcmVkIHBhcmFtZXRlcjogXCJzZWNyZXRcIicpO1xuICAgICAgICB9XG5cblxuICAgICAgICBpZiAodHlwZW9mIHVzZXJJZCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHBheWxvYWRbJ3VzZXJJZCddID0gdXNlcklkO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHR5cGVvZiBzZWNyZXQgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICBwYXlsb2FkWydzZWNyZXQnXSA9IHNlY3JldDtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBhd2FpdCB0aGlzLmNsaWVudC5jYWxsKCdwYXRjaCcsIGFwaVBhdGgsIHtcbiAgICAgICAgICAgICdjb250ZW50LXR5cGUnOiAnYXBwbGljYXRpb24vanNvbicsXG4gICAgICAgIH0sIHBheWxvYWQpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdldCB0ZWFtIHByZWZlcmVuY2VzXG4gICAgICpcbiAgICAgKiBHZXQgdGhlIHRlYW0ncyBzaGFyZWQgcHJlZmVyZW5jZXMgYnkgaXRzIHVuaXF1ZSBJRC4gSWYgYSBwcmVmZXJlbmNlIGRvZXNuJ3RcbiAgICAgKiBuZWVkIHRvIGJlIHNoYXJlZCBieSBhbGwgdGVhbSBtZW1iZXJzLCBwcmVmZXIgc3RvcmluZyB0aGVtIGluIFt1c2VyXG4gICAgICogcHJlZmVyZW5jZXNdKGh0dHBzOi8vYXBwd3JpdGUuaW8vZG9jcy9yZWZlcmVuY2VzL2Nsb3VkL2NsaWVudC13ZWIvYWNjb3VudCNnZXRQcmVmcykuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gdGVhbUlkXG4gICAgICogQHRocm93cyB7QXBwd3JpdGVFeGNlcHRpb259XG4gICAgICogQHJldHVybnMge1Byb21pc2V9XG4gICAgICovXG4gICAgYXN5bmMgZ2V0UHJlZnModGVhbUlkKSB7XG4gICAgICAgIGNvbnN0IGFwaVBhdGggPSAnL3RlYW1zL3t0ZWFtSWR9L3ByZWZzJy5yZXBsYWNlKCd7dGVhbUlkfScsIHRlYW1JZCk7XG4gICAgICAgIGxldCBwYXlsb2FkID0ge307XG4gICAgICAgIGlmICh0eXBlb2YgdGVhbUlkID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEFwcHdyaXRlRXhjZXB0aW9uKCdNaXNzaW5nIHJlcXVpcmVkIHBhcmFtZXRlcjogXCJ0ZWFtSWRcIicpO1xuICAgICAgICB9XG5cblxuICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy5jbGllbnQuY2FsbCgnZ2V0JywgYXBpUGF0aCwge1xuICAgICAgICAgICAgJ2NvbnRlbnQtdHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJyxcbiAgICAgICAgfSwgcGF5bG9hZCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVXBkYXRlIHByZWZlcmVuY2VzXG4gICAgICpcbiAgICAgKiBVcGRhdGUgdGhlIHRlYW0ncyBwcmVmZXJlbmNlcyBieSBpdHMgdW5pcXVlIElELiBUaGUgb2JqZWN0IHlvdSBwYXNzIGlzXG4gICAgICogc3RvcmVkIGFzIGlzIGFuZCByZXBsYWNlcyBhbnkgcHJldmlvdXMgdmFsdWUuIFRoZSBtYXhpbXVtIGFsbG93ZWQgcHJlZnNcbiAgICAgKiBzaXplIGlzIDY0a0IgYW5kIHRocm93cyBhbiBlcnJvciBpZiBleGNlZWRlZC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSB0ZWFtSWRcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gcHJlZnNcbiAgICAgKiBAdGhyb3dzIHtBcHB3cml0ZUV4Y2VwdGlvbn1cbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZX1cbiAgICAgKi9cbiAgICBhc3luYyB1cGRhdGVQcmVmcyh0ZWFtSWQsIHByZWZzKSB7XG4gICAgICAgIGNvbnN0IGFwaVBhdGggPSAnL3RlYW1zL3t0ZWFtSWR9L3ByZWZzJy5yZXBsYWNlKCd7dGVhbUlkfScsIHRlYW1JZCk7XG4gICAgICAgIGxldCBwYXlsb2FkID0ge307XG4gICAgICAgIGlmICh0eXBlb2YgdGVhbUlkID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEFwcHdyaXRlRXhjZXB0aW9uKCdNaXNzaW5nIHJlcXVpcmVkIHBhcmFtZXRlcjogXCJ0ZWFtSWRcIicpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHR5cGVvZiBwcmVmcyA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBBcHB3cml0ZUV4Y2VwdGlvbignTWlzc2luZyByZXF1aXJlZCBwYXJhbWV0ZXI6IFwicHJlZnNcIicpO1xuICAgICAgICB9XG5cblxuICAgICAgICBpZiAodHlwZW9mIHByZWZzICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgcGF5bG9hZFsncHJlZnMnXSA9IHByZWZzO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMuY2xpZW50LmNhbGwoJ3B1dCcsIGFwaVBhdGgsIHtcbiAgICAgICAgICAgICdjb250ZW50LXR5cGUnOiAnYXBwbGljYXRpb24vanNvbicsXG4gICAgICAgIH0sIHBheWxvYWQpO1xuICAgIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBUZWFtcztcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(action-browser)/./node_modules/node-appwrite/lib/services/teams.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/node-appwrite/lib/services/teams.js":
/*!**********************************************************!*\
  !*** ./node_modules/node-appwrite/lib/services/teams.js ***!
  \**********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("const Service = __webpack_require__(/*! ../service.js */ \"(rsc)/./node_modules/node-appwrite/lib/service.js\");\nconst AppwriteException = __webpack_require__(/*! ../exception.js */ \"(rsc)/./node_modules/node-appwrite/lib/exception.js\");\nconst InputFile = __webpack_require__(/*! ../inputFile.js */ \"(rsc)/./node_modules/node-appwrite/lib/inputFile.js\");\nconst client = __webpack_require__(/*! ../client.js */ \"(rsc)/./node_modules/node-appwrite/lib/client.js\");\nconst Stream = __webpack_require__(/*! stream */ \"stream\");\nconst { promisify } = __webpack_require__(/*! util */ \"util\");\nconst fs = __webpack_require__(/*! fs */ \"fs\");\nconst { File } = __webpack_require__(/*! undici */ \"undici\");\nconst Query = __webpack_require__(/*! ../query.js */ \"(rsc)/./node_modules/node-appwrite/lib/query.js\");\n\nclass Teams extends Service {\n\n     constructor(client)\n     {\n        super(client);\n     }\n\n\n    /**\n     * List teams\n     *\n     * Get a list of all the teams in which the current user is a member. You can\n     * use the parameters to filter your results.\n     *\n     * @param {string[]} queries\n     * @param {string} search\n     * @throws {AppwriteException}\n     * @returns {Promise}\n     */\n    async list(queries, search) {\n        const apiPath = '/teams';\n        let payload = {};\n\n        if (typeof queries !== 'undefined') {\n            payload['queries'] = queries;\n        }\n\n        if (typeof search !== 'undefined') {\n            payload['search'] = search;\n        }\n\n        return await this.client.call('get', apiPath, {\n            'content-type': 'application/json',\n        }, payload);\n    }\n\n    /**\n     * Create team\n     *\n     * Create a new team. The user who creates the team will automatically be\n     * assigned as the owner of the team. Only the users with the owner role can\n     * invite new members, add new owners and delete or update the team.\n     *\n     * @param {string} teamId\n     * @param {string} name\n     * @param {string[]} roles\n     * @throws {AppwriteException}\n     * @returns {Promise}\n     */\n    async create(teamId, name, roles) {\n        const apiPath = '/teams';\n        let payload = {};\n        if (typeof teamId === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"teamId\"');\n        }\n\n        if (typeof name === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"name\"');\n        }\n\n\n        if (typeof teamId !== 'undefined') {\n            payload['teamId'] = teamId;\n        }\n\n        if (typeof name !== 'undefined') {\n            payload['name'] = name;\n        }\n\n        if (typeof roles !== 'undefined') {\n            payload['roles'] = roles;\n        }\n\n        return await this.client.call('post', apiPath, {\n            'content-type': 'application/json',\n        }, payload);\n    }\n\n    /**\n     * Get team\n     *\n     * Get a team by its ID. All team members have read access for this resource.\n     *\n     * @param {string} teamId\n     * @throws {AppwriteException}\n     * @returns {Promise}\n     */\n    async get(teamId) {\n        const apiPath = '/teams/{teamId}'.replace('{teamId}', teamId);\n        let payload = {};\n        if (typeof teamId === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"teamId\"');\n        }\n\n\n        return await this.client.call('get', apiPath, {\n            'content-type': 'application/json',\n        }, payload);\n    }\n\n    /**\n     * Update name\n     *\n     * Update the team's name by its unique ID.\n     *\n     * @param {string} teamId\n     * @param {string} name\n     * @throws {AppwriteException}\n     * @returns {Promise}\n     */\n    async updateName(teamId, name) {\n        const apiPath = '/teams/{teamId}'.replace('{teamId}', teamId);\n        let payload = {};\n        if (typeof teamId === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"teamId\"');\n        }\n\n        if (typeof name === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"name\"');\n        }\n\n\n        if (typeof name !== 'undefined') {\n            payload['name'] = name;\n        }\n\n        return await this.client.call('put', apiPath, {\n            'content-type': 'application/json',\n        }, payload);\n    }\n\n    /**\n     * Delete team\n     *\n     * Delete a team using its ID. Only team members with the owner role can\n     * delete the team.\n     *\n     * @param {string} teamId\n     * @throws {AppwriteException}\n     * @returns {Promise}\n     */\n    async delete(teamId) {\n        const apiPath = '/teams/{teamId}'.replace('{teamId}', teamId);\n        let payload = {};\n        if (typeof teamId === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"teamId\"');\n        }\n\n\n        return await this.client.call('delete', apiPath, {\n            'content-type': 'application/json',\n        }, payload);\n    }\n\n    /**\n     * List team memberships\n     *\n     * Use this endpoint to list a team's members using the team's ID. All team\n     * members have read access to this endpoint.\n     *\n     * @param {string} teamId\n     * @param {string[]} queries\n     * @param {string} search\n     * @throws {AppwriteException}\n     * @returns {Promise}\n     */\n    async listMemberships(teamId, queries, search) {\n        const apiPath = '/teams/{teamId}/memberships'.replace('{teamId}', teamId);\n        let payload = {};\n        if (typeof teamId === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"teamId\"');\n        }\n\n\n        if (typeof queries !== 'undefined') {\n            payload['queries'] = queries;\n        }\n\n        if (typeof search !== 'undefined') {\n            payload['search'] = search;\n        }\n\n        return await this.client.call('get', apiPath, {\n            'content-type': 'application/json',\n        }, payload);\n    }\n\n    /**\n     * Create team membership\n     *\n     * Invite a new member to join your team. Provide an ID for existing users, or\n     * invite unregistered users using an email or phone number. If initiated from\n     * a Client SDK, Appwrite will send an email or sms with a link to join the\n     * team to the invited user, and an account will be created for them if one\n     * doesn't exist. If initiated from a Server SDK, the new member will be added\n     * automatically to the team.\n     * \n     * You only need to provide one of a user ID, email, or phone number. Appwrite\n     * will prioritize accepting the user ID > email > phone number if you provide\n     * more than one of these parameters.\n     * \n     * Use the `url` parameter to redirect the user from the invitation email to\n     * your app. After the user is redirected, use the [Update Team Membership\n     * Status](https://appwrite.io/docs/references/cloud/client-web/teams#updateMembershipStatus)\n     * endpoint to allow the user to accept the invitation to the team. \n     * \n     * Please note that to avoid a [Redirect\n     * Attack](https://github.com/OWASP/CheatSheetSeries/blob/master/cheatsheets/Unvalidated_Redirects_and_Forwards_Cheat_Sheet.md)\n     * Appwrite will accept the only redirect URLs under the domains you have\n     * added as a platform on the Appwrite Console.\n     * \n     *\n     * @param {string} teamId\n     * @param {string[]} roles\n     * @param {string} email\n     * @param {string} userId\n     * @param {string} phone\n     * @param {string} url\n     * @param {string} name\n     * @throws {AppwriteException}\n     * @returns {Promise}\n     */\n    async createMembership(teamId, roles, email, userId, phone, url, name) {\n        const apiPath = '/teams/{teamId}/memberships'.replace('{teamId}', teamId);\n        let payload = {};\n        if (typeof teamId === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"teamId\"');\n        }\n\n        if (typeof roles === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"roles\"');\n        }\n\n\n        if (typeof email !== 'undefined') {\n            payload['email'] = email;\n        }\n\n        if (typeof userId !== 'undefined') {\n            payload['userId'] = userId;\n        }\n\n        if (typeof phone !== 'undefined') {\n            payload['phone'] = phone;\n        }\n\n        if (typeof roles !== 'undefined') {\n            payload['roles'] = roles;\n        }\n\n        if (typeof url !== 'undefined') {\n            payload['url'] = url;\n        }\n\n        if (typeof name !== 'undefined') {\n            payload['name'] = name;\n        }\n\n        return await this.client.call('post', apiPath, {\n            'content-type': 'application/json',\n        }, payload);\n    }\n\n    /**\n     * Get team membership\n     *\n     * Get a team member by the membership unique id. All team members have read\n     * access for this resource.\n     *\n     * @param {string} teamId\n     * @param {string} membershipId\n     * @throws {AppwriteException}\n     * @returns {Promise}\n     */\n    async getMembership(teamId, membershipId) {\n        const apiPath = '/teams/{teamId}/memberships/{membershipId}'.replace('{teamId}', teamId).replace('{membershipId}', membershipId);\n        let payload = {};\n        if (typeof teamId === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"teamId\"');\n        }\n\n        if (typeof membershipId === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"membershipId\"');\n        }\n\n\n        return await this.client.call('get', apiPath, {\n            'content-type': 'application/json',\n        }, payload);\n    }\n\n    /**\n     * Update membership\n     *\n     * Modify the roles of a team member. Only team members with the owner role\n     * have access to this endpoint. Learn more about [roles and\n     * permissions](https://appwrite.io/docs/permissions).\n     * \n     *\n     * @param {string} teamId\n     * @param {string} membershipId\n     * @param {string[]} roles\n     * @throws {AppwriteException}\n     * @returns {Promise}\n     */\n    async updateMembership(teamId, membershipId, roles) {\n        const apiPath = '/teams/{teamId}/memberships/{membershipId}'.replace('{teamId}', teamId).replace('{membershipId}', membershipId);\n        let payload = {};\n        if (typeof teamId === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"teamId\"');\n        }\n\n        if (typeof membershipId === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"membershipId\"');\n        }\n\n        if (typeof roles === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"roles\"');\n        }\n\n\n        if (typeof roles !== 'undefined') {\n            payload['roles'] = roles;\n        }\n\n        return await this.client.call('patch', apiPath, {\n            'content-type': 'application/json',\n        }, payload);\n    }\n\n    /**\n     * Delete team membership\n     *\n     * This endpoint allows a user to leave a team or for a team owner to delete\n     * the membership of any other team member. You can also use this endpoint to\n     * delete a user membership even if it is not accepted.\n     *\n     * @param {string} teamId\n     * @param {string} membershipId\n     * @throws {AppwriteException}\n     * @returns {Promise}\n     */\n    async deleteMembership(teamId, membershipId) {\n        const apiPath = '/teams/{teamId}/memberships/{membershipId}'.replace('{teamId}', teamId).replace('{membershipId}', membershipId);\n        let payload = {};\n        if (typeof teamId === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"teamId\"');\n        }\n\n        if (typeof membershipId === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"membershipId\"');\n        }\n\n\n        return await this.client.call('delete', apiPath, {\n            'content-type': 'application/json',\n        }, payload);\n    }\n\n    /**\n     * Update team membership status\n     *\n     * Use this endpoint to allow a user to accept an invitation to join a team\n     * after being redirected back to your app from the invitation email received\n     * by the user.\n     * \n     * If the request is successful, a session for the user is automatically\n     * created.\n     * \n     *\n     * @param {string} teamId\n     * @param {string} membershipId\n     * @param {string} userId\n     * @param {string} secret\n     * @throws {AppwriteException}\n     * @returns {Promise}\n     */\n    async updateMembershipStatus(teamId, membershipId, userId, secret) {\n        const apiPath = '/teams/{teamId}/memberships/{membershipId}/status'.replace('{teamId}', teamId).replace('{membershipId}', membershipId);\n        let payload = {};\n        if (typeof teamId === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"teamId\"');\n        }\n\n        if (typeof membershipId === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"membershipId\"');\n        }\n\n        if (typeof userId === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"userId\"');\n        }\n\n        if (typeof secret === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"secret\"');\n        }\n\n\n        if (typeof userId !== 'undefined') {\n            payload['userId'] = userId;\n        }\n\n        if (typeof secret !== 'undefined') {\n            payload['secret'] = secret;\n        }\n\n        return await this.client.call('patch', apiPath, {\n            'content-type': 'application/json',\n        }, payload);\n    }\n\n    /**\n     * Get team preferences\n     *\n     * Get the team's shared preferences by its unique ID. If a preference doesn't\n     * need to be shared by all team members, prefer storing them in [user\n     * preferences](https://appwrite.io/docs/references/cloud/client-web/account#getPrefs).\n     *\n     * @param {string} teamId\n     * @throws {AppwriteException}\n     * @returns {Promise}\n     */\n    async getPrefs(teamId) {\n        const apiPath = '/teams/{teamId}/prefs'.replace('{teamId}', teamId);\n        let payload = {};\n        if (typeof teamId === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"teamId\"');\n        }\n\n\n        return await this.client.call('get', apiPath, {\n            'content-type': 'application/json',\n        }, payload);\n    }\n\n    /**\n     * Update preferences\n     *\n     * Update the team's preferences by its unique ID. The object you pass is\n     * stored as is and replaces any previous value. The maximum allowed prefs\n     * size is 64kB and throws an error if exceeded.\n     *\n     * @param {string} teamId\n     * @param {object} prefs\n     * @throws {AppwriteException}\n     * @returns {Promise}\n     */\n    async updatePrefs(teamId, prefs) {\n        const apiPath = '/teams/{teamId}/prefs'.replace('{teamId}', teamId);\n        let payload = {};\n        if (typeof teamId === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"teamId\"');\n        }\n\n        if (typeof prefs === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"prefs\"');\n        }\n\n\n        if (typeof prefs !== 'undefined') {\n            payload['prefs'] = prefs;\n        }\n\n        return await this.client.call('put', apiPath, {\n            'content-type': 'application/json',\n        }, payload);\n    }\n}\n\nmodule.exports = Teams;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvbm9kZS1hcHB3cml0ZS9saWIvc2VydmljZXMvdGVhbXMuanMiLCJtYXBwaW5ncyI6IkFBQUEsZ0JBQWdCLG1CQUFPLENBQUMsd0VBQWU7QUFDdkMsMEJBQTBCLG1CQUFPLENBQUMsNEVBQWlCO0FBQ25ELGtCQUFrQixtQkFBTyxDQUFDLDRFQUFpQjtBQUMzQyxlQUFlLG1CQUFPLENBQUMsc0VBQWM7QUFDckMsZUFBZSxtQkFBTyxDQUFDLHNCQUFRO0FBQy9CLFFBQVEsWUFBWSxFQUFFLG1CQUFPLENBQUMsa0JBQU07QUFDcEMsV0FBVyxtQkFBTyxDQUFDLGNBQUk7QUFDdkIsUUFBUSxPQUFPLEVBQUUsbUJBQU8sQ0FBQyxzQkFBUTtBQUNqQyxjQUFjLG1CQUFPLENBQUMsb0VBQWE7O0FBRW5DOztBQUVBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFVBQVU7QUFDekIsZUFBZSxRQUFRO0FBQ3ZCLGdCQUFnQjtBQUNoQixpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsU0FBUztBQUNUOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsUUFBUTtBQUN2QixlQUFlLFVBQVU7QUFDekIsZ0JBQWdCO0FBQ2hCLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QixnQkFBZ0I7QUFDaEIsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQSxpQ0FBaUMsT0FBTyxZQUFZ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QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsUUFBUTtBQUN2QixlQUFlLFFBQVE7QUFDdkIsZUFBZSxRQUFRO0FBQ3ZCLGdCQUFnQjtBQUNoQixpQkFBaUI7QUFDakI7QUFDQTtBQUNBLGlDQUFpQyxPQUFPLGNBQWMsYUFBYSxtQkFBbUIsT0FBTyxxQkFBcUIsYUFBYTtBQUMvSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsU0FBUztBQUNUOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCLGdCQUFnQjtBQUNoQixpQkFBaUI7QUFDakI7QUFDQTtBQUNBLGlDQUFpQyxPQUFPLGtCQUFrQixPQUFPO0FBQ2pFO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0EsU0FBUztBQUNUOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsUUFBUTtBQUN2QixnQkFBZ0I7QUFDaEIsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQSxpQ0FBaUMsT0FBTyxrQkFBa0IsT0FBTztBQUNqRTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7O0FBRUEiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9qc21fYmFua2luZy8uL25vZGVfbW9kdWxlcy9ub2RlLWFwcHdyaXRlL2xpYi9zZXJ2aWNlcy90ZWFtcy5qcz9hOGM0Il0sInNvdXJjZXNDb250ZW50IjpbImNvbnN0IFNlcnZpY2UgPSByZXF1aXJlKCcuLi9zZXJ2aWNlLmpzJyk7XG5jb25zdCBBcHB3cml0ZUV4Y2VwdGlvbiA9IHJlcXVpcmUoJy4uL2V4Y2VwdGlvbi5qcycpO1xuY29uc3QgSW5wdXRGaWxlID0gcmVxdWlyZSgnLi4vaW5wdXRGaWxlLmpzJyk7XG5jb25zdCBjbGllbnQgPSByZXF1aXJlKCcuLi9jbGllbnQuanMnKTtcbmNvbnN0IFN0cmVhbSA9IHJlcXVpcmUoJ3N0cmVhbScpO1xuY29uc3QgeyBwcm9taXNpZnkgfSA9IHJlcXVpcmUoJ3V0aWwnKTtcbmNvbnN0IGZzID0gcmVxdWlyZSgnZnMnKTtcbmNvbnN0IHsgRmlsZSB9ID0gcmVxdWlyZSgndW5kaWNpJyk7XG5jb25zdCBRdWVyeSA9IHJlcXVpcmUoJy4uL3F1ZXJ5LmpzJyk7XG5cbmNsYXNzIFRlYW1zIGV4dGVuZHMgU2VydmljZSB7XG5cbiAgICAgY29uc3RydWN0b3IoY2xpZW50KVxuICAgICB7XG4gICAgICAgIHN1cGVyKGNsaWVudCk7XG4gICAgIH1cblxuXG4gICAgLyoqXG4gICAgICogTGlzdCB0ZWFtc1xuICAgICAqXG4gICAgICogR2V0IGEgbGlzdCBvZiBhbGwgdGhlIHRlYW1zIGluIHdoaWNoIHRoZSBjdXJyZW50IHVzZXIgaXMgYSBtZW1iZXIuIFlvdSBjYW5cbiAgICAgKiB1c2UgdGhlIHBhcmFtZXRlcnMgdG8gZmlsdGVyIHlvdXIgcmVzdWx0cy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nW119IHF1ZXJpZXNcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gc2VhcmNoXG4gICAgICogQHRocm93cyB7QXBwd3JpdGVFeGNlcHRpb259XG4gICAgICogQHJldHVybnMge1Byb21pc2V9XG4gICAgICovXG4gICAgYXN5bmMgbGlzdChxdWVyaWVzLCBzZWFyY2gpIHtcbiAgICAgICAgY29uc3QgYXBpUGF0aCA9ICcvdGVhbXMnO1xuICAgICAgICBsZXQgcGF5bG9hZCA9IHt9O1xuXG4gICAgICAgIGlmICh0eXBlb2YgcXVlcmllcyAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHBheWxvYWRbJ3F1ZXJpZXMnXSA9IHF1ZXJpZXM7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodHlwZW9mIHNlYXJjaCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHBheWxvYWRbJ3NlYXJjaCddID0gc2VhcmNoO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMuY2xpZW50LmNhbGwoJ2dldCcsIGFwaVBhdGgsIHtcbiAgICAgICAgICAgICdjb250ZW50LXR5cGUnOiAnYXBwbGljYXRpb24vanNvbicsXG4gICAgICAgIH0sIHBheWxvYWQpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZSB0ZWFtXG4gICAgICpcbiAgICAgKiBDcmVhdGUgYSBuZXcgdGVhbS4gVGhlIHVzZXIgd2hvIGNyZWF0ZXMgdGhlIHRlYW0gd2lsbCBhdXRvbWF0aWNhbGx5IGJlXG4gICAgICogYXNzaWduZWQgYXMgdGhlIG93bmVyIG9mIHRoZSB0ZWFtLiBPbmx5IHRoZSB1c2VycyB3aXRoIHRoZSBvd25lciByb2xlIGNhblxuICAgICAqIGludml0ZSBuZXcgbWVtYmVycywgYWRkIG5ldyBvd25lcnMgYW5kIGRlbGV0ZSBvciB1cGRhdGUgdGhlIHRlYW0uXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gdGVhbUlkXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IG5hbWVcbiAgICAgKiBAcGFyYW0ge3N0cmluZ1tdfSByb2xlc1xuICAgICAqIEB0aHJvd3Mge0FwcHdyaXRlRXhjZXB0aW9ufVxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlfVxuICAgICAqL1xuICAgIGFzeW5jIGNyZWF0ZSh0ZWFtSWQsIG5hbWUsIHJvbGVzKSB7XG4gICAgICAgIGNvbnN0IGFwaVBhdGggPSAnL3RlYW1zJztcbiAgICAgICAgbGV0IHBheWxvYWQgPSB7fTtcbiAgICAgICAgaWYgKHR5cGVvZiB0ZWFtSWQgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgQXBwd3JpdGVFeGNlcHRpb24oJ01pc3NpbmcgcmVxdWlyZWQgcGFyYW1ldGVyOiBcInRlYW1JZFwiJyk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodHlwZW9mIG5hbWUgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgQXBwd3JpdGVFeGNlcHRpb24oJ01pc3NpbmcgcmVxdWlyZWQgcGFyYW1ldGVyOiBcIm5hbWVcIicpO1xuICAgICAgICB9XG5cblxuICAgICAgICBpZiAodHlwZW9mIHRlYW1JZCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHBheWxvYWRbJ3RlYW1JZCddID0gdGVhbUlkO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHR5cGVvZiBuYW1lICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgcGF5bG9hZFsnbmFtZSddID0gbmFtZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0eXBlb2Ygcm9sZXMgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICBwYXlsb2FkWydyb2xlcyddID0gcm9sZXM7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy5jbGllbnQuY2FsbCgncG9zdCcsIGFwaVBhdGgsIHtcbiAgICAgICAgICAgICdjb250ZW50LXR5cGUnOiAnYXBwbGljYXRpb24vanNvbicsXG4gICAgICAgIH0sIHBheWxvYWQpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdldCB0ZWFtXG4gICAgICpcbiAgICAgKiBHZXQgYSB0ZWFtIGJ5IGl0cyBJRC4gQWxsIHRlYW0gbWVtYmVycyBoYXZlIHJlYWQgYWNjZXNzIGZvciB0aGlzIHJlc291cmNlLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHRlYW1JZFxuICAgICAqIEB0aHJvd3Mge0FwcHdyaXRlRXhjZXB0aW9ufVxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlfVxuICAgICAqL1xuICAgIGFzeW5jIGdldCh0ZWFtSWQpIHtcbiAgICAgICAgY29uc3QgYXBpUGF0aCA9ICcvdGVhbXMve3RlYW1JZH0nLnJlcGxhY2UoJ3t0ZWFtSWR9JywgdGVhbUlkKTtcbiAgICAgICAgbGV0IHBheWxvYWQgPSB7fTtcbiAgICAgICAgaWYgKHR5cGVvZiB0ZWFtSWQgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgQXBwd3JpdGVFeGNlcHRpb24oJ01pc3NpbmcgcmVxdWlyZWQgcGFyYW1ldGVyOiBcInRlYW1JZFwiJyk7XG4gICAgICAgIH1cblxuXG4gICAgICAgIHJldHVybiBhd2FpdCB0aGlzLmNsaWVudC5jYWxsKCdnZXQnLCBhcGlQYXRoLCB7XG4gICAgICAgICAgICAnY29udGVudC10eXBlJzogJ2FwcGxpY2F0aW9uL2pzb24nLFxuICAgICAgICB9LCBwYXlsb2FkKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBVcGRhdGUgbmFtZVxuICAgICAqXG4gICAgICogVXBkYXRlIHRoZSB0ZWFtJ3MgbmFtZSBieSBpdHMgdW5pcXVlIElELlxuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHRlYW1JZFxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lXG4gICAgICogQHRocm93cyB7QXBwd3JpdGVFeGNlcHRpb259XG4gICAgICogQHJldHVybnMge1Byb21pc2V9XG4gICAgICovXG4gICAgYXN5bmMgdXBkYXRlTmFtZSh0ZWFtSWQsIG5hbWUpIHtcbiAgICAgICAgY29uc3QgYXBpUGF0aCA9ICcvdGVhbXMve3RlYW1JZH0nLnJlcGxhY2UoJ3t0ZWFtSWR9JywgdGVhbUlkKTtcbiAgICAgICAgbGV0IHBheWxvYWQgPSB7fTtcbiAgICAgICAgaWYgKHR5cGVvZiB0ZWFtSWQgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgQXBwd3JpdGVFeGNlcHRpb24oJ01pc3NpbmcgcmVxdWlyZWQgcGFyYW1ldGVyOiBcInRlYW1JZFwiJyk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodHlwZW9mIG5hbWUgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgQXBwd3JpdGVFeGNlcHRpb24oJ01pc3NpbmcgcmVxdWlyZWQgcGFyYW1ldGVyOiBcIm5hbWVcIicpO1xuICAgICAgICB9XG5cblxuICAgICAgICBpZiAodHlwZW9mIG5hbWUgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICBwYXlsb2FkWyduYW1lJ10gPSBuYW1lO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMuY2xpZW50LmNhbGwoJ3B1dCcsIGFwaVBhdGgsIHtcbiAgICAgICAgICAgICdjb250ZW50LXR5cGUnOiAnYXBwbGljYXRpb24vanNvbicsXG4gICAgICAgIH0sIHBheWxvYWQpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIERlbGV0ZSB0ZWFtXG4gICAgICpcbiAgICAgKiBEZWxldGUgYSB0ZWFtIHVzaW5nIGl0cyBJRC4gT25seSB0ZWFtIG1lbWJlcnMgd2l0aCB0aGUgb3duZXIgcm9sZSBjYW5cbiAgICAgKiBkZWxldGUgdGhlIHRlYW0uXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gdGVhbUlkXG4gICAgICogQHRocm93cyB7QXBwd3JpdGVFeGNlcHRpb259XG4gICAgICogQHJldHVybnMge1Byb21pc2V9XG4gICAgICovXG4gICAgYXN5bmMgZGVsZXRlKHRlYW1JZCkge1xuICAgICAgICBjb25zdCBhcGlQYXRoID0gJy90ZWFtcy97dGVhbUlkfScucmVwbGFjZSgne3RlYW1JZH0nLCB0ZWFtSWQpO1xuICAgICAgICBsZXQgcGF5bG9hZCA9IHt9O1xuICAgICAgICBpZiAodHlwZW9mIHRlYW1JZCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBBcHB3cml0ZUV4Y2VwdGlvbignTWlzc2luZyByZXF1aXJlZCBwYXJhbWV0ZXI6IFwidGVhbUlkXCInKTtcbiAgICAgICAgfVxuXG5cbiAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMuY2xpZW50LmNhbGwoJ2RlbGV0ZScsIGFwaVBhdGgsIHtcbiAgICAgICAgICAgICdjb250ZW50LXR5cGUnOiAnYXBwbGljYXRpb24vanNvbicsXG4gICAgICAgIH0sIHBheWxvYWQpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIExpc3QgdGVhbSBtZW1iZXJzaGlwc1xuICAgICAqXG4gICAgICogVXNlIHRoaXMgZW5kcG9pbnQgdG8gbGlzdCBhIHRlYW0ncyBtZW1iZXJzIHVzaW5nIHRoZSB0ZWFtJ3MgSUQuIEFsbCB0ZWFtXG4gICAgICogbWVtYmVycyBoYXZlIHJlYWQgYWNjZXNzIHRvIHRoaXMgZW5kcG9pbnQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gdGVhbUlkXG4gICAgICogQHBhcmFtIHtzdHJpbmdbXX0gcXVlcmllc1xuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBzZWFyY2hcbiAgICAgKiBAdGhyb3dzIHtBcHB3cml0ZUV4Y2VwdGlvbn1cbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZX1cbiAgICAgKi9cbiAgICBhc3luYyBsaXN0TWVtYmVyc2hpcHModGVhbUlkLCBxdWVyaWVzLCBzZWFyY2gpIHtcbiAgICAgICAgY29uc3QgYXBpUGF0aCA9ICcvdGVhbXMve3RlYW1JZH0vbWVtYmVyc2hpcHMnLnJlcGxhY2UoJ3t0ZWFtSWR9JywgdGVhbUlkKTtcbiAgICAgICAgbGV0IHBheWxvYWQgPSB7fTtcbiAgICAgICAgaWYgKHR5cGVvZiB0ZWFtSWQgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgQXBwd3JpdGVFeGNlcHRpb24oJ01pc3NpbmcgcmVxdWlyZWQgcGFyYW1ldGVyOiBcInRlYW1JZFwiJyk7XG4gICAgICAgIH1cblxuXG4gICAgICAgIGlmICh0eXBlb2YgcXVlcmllcyAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHBheWxvYWRbJ3F1ZXJpZXMnXSA9IHF1ZXJpZXM7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodHlwZW9mIHNlYXJjaCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHBheWxvYWRbJ3NlYXJjaCddID0gc2VhcmNoO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMuY2xpZW50LmNhbGwoJ2dldCcsIGFwaVBhdGgsIHtcbiAgICAgICAgICAgICdjb250ZW50LXR5cGUnOiAnYXBwbGljYXRpb24vanNvbicsXG4gICAgICAgIH0sIHBheWxvYWQpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZSB0ZWFtIG1lbWJlcnNoaXBcbiAgICAgKlxuICAgICAqIEludml0ZSBhIG5ldyBtZW1iZXIgdG8gam9pbiB5b3VyIHRlYW0uIFByb3ZpZGUgYW4gSUQgZm9yIGV4aXN0aW5nIHVzZXJzLCBvclxuICAgICAqIGludml0ZSB1bnJlZ2lzdGVyZWQgdXNlcnMgdXNpbmcgYW4gZW1haWwgb3IgcGhvbmUgbnVtYmVyLiBJZiBpbml0aWF0ZWQgZnJvbVxuICAgICAqIGEgQ2xpZW50IFNESywgQXBwd3JpdGUgd2lsbCBzZW5kIGFuIGVtYWlsIG9yIHNtcyB3aXRoIGEgbGluayB0byBqb2luIHRoZVxuICAgICAqIHRlYW0gdG8gdGhlIGludml0ZWQgdXNlciwgYW5kIGFuIGFjY291bnQgd2lsbCBiZSBjcmVhdGVkIGZvciB0aGVtIGlmIG9uZVxuICAgICAqIGRvZXNuJ3QgZXhpc3QuIElmIGluaXRpYXRlZCBmcm9tIGEgU2VydmVyIFNESywgdGhlIG5ldyBtZW1iZXIgd2lsbCBiZSBhZGRlZFxuICAgICAqIGF1dG9tYXRpY2FsbHkgdG8gdGhlIHRlYW0uXG4gICAgICogXG4gICAgICogWW91IG9ubHkgbmVlZCB0byBwcm92aWRlIG9uZSBvZiBhIHVzZXIgSUQsIGVtYWlsLCBvciBwaG9uZSBudW1iZXIuIEFwcHdyaXRlXG4gICAgICogd2lsbCBwcmlvcml0aXplIGFjY2VwdGluZyB0aGUgdXNlciBJRCA+IGVtYWlsID4gcGhvbmUgbnVtYmVyIGlmIHlvdSBwcm92aWRlXG4gICAgICogbW9yZSB0aGFuIG9uZSBvZiB0aGVzZSBwYXJhbWV0ZXJzLlxuICAgICAqIFxuICAgICAqIFVzZSB0aGUgYHVybGAgcGFyYW1ldGVyIHRvIHJlZGlyZWN0IHRoZSB1c2VyIGZyb20gdGhlIGludml0YXRpb24gZW1haWwgdG9cbiAgICAgKiB5b3VyIGFwcC4gQWZ0ZXIgdGhlIHVzZXIgaXMgcmVkaXJlY3RlZCwgdXNlIHRoZSBbVXBkYXRlIFRlYW0gTWVtYmVyc2hpcFxuICAgICAqIFN0YXR1c10oaHR0cHM6Ly9hcHB3cml0ZS5pby9kb2NzL3JlZmVyZW5jZXMvY2xvdWQvY2xpZW50LXdlYi90ZWFtcyN1cGRhdGVNZW1iZXJzaGlwU3RhdHVzKVxuICAgICAqIGVuZHBvaW50IHRvIGFsbG93IHRoZSB1c2VyIHRvIGFjY2VwdCB0aGUgaW52aXRhdGlvbiB0byB0aGUgdGVhbS4gXG4gICAgICogXG4gICAgICogUGxlYXNlIG5vdGUgdGhhdCB0byBhdm9pZCBhIFtSZWRpcmVjdFxuICAgICAqIEF0dGFja10oaHR0cHM6Ly9naXRodWIuY29tL09XQVNQL0NoZWF0U2hlZXRTZXJpZXMvYmxvYi9tYXN0ZXIvY2hlYXRzaGVldHMvVW52YWxpZGF0ZWRfUmVkaXJlY3RzX2FuZF9Gb3J3YXJkc19DaGVhdF9TaGVldC5tZClcbiAgICAgKiBBcHB3cml0ZSB3aWxsIGFjY2VwdCB0aGUgb25seSByZWRpcmVjdCBVUkxzIHVuZGVyIHRoZSBkb21haW5zIHlvdSBoYXZlXG4gICAgICogYWRkZWQgYXMgYSBwbGF0Zm9ybSBvbiB0aGUgQXBwd3JpdGUgQ29uc29sZS5cbiAgICAgKiBcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSB0ZWFtSWRcbiAgICAgKiBAcGFyYW0ge3N0cmluZ1tdfSByb2xlc1xuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBlbWFpbFxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSB1c2VySWRcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gcGhvbmVcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gdXJsXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IG5hbWVcbiAgICAgKiBAdGhyb3dzIHtBcHB3cml0ZUV4Y2VwdGlvbn1cbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZX1cbiAgICAgKi9cbiAgICBhc3luYyBjcmVhdGVNZW1iZXJzaGlwKHRlYW1JZCwgcm9sZXMsIGVtYWlsLCB1c2VySWQsIHBob25lLCB1cmwsIG5hbWUpIHtcbiAgICAgICAgY29uc3QgYXBpUGF0aCA9ICcvdGVhbXMve3RlYW1JZH0vbWVtYmVyc2hpcHMnLnJlcGxhY2UoJ3t0ZWFtSWR9JywgdGVhbUlkKTtcbiAgICAgICAgbGV0IHBheWxvYWQgPSB7fTtcbiAgICAgICAgaWYgKHR5cGVvZiB0ZWFtSWQgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgQXBwd3JpdGVFeGNlcHRpb24oJ01pc3NpbmcgcmVxdWlyZWQgcGFyYW1ldGVyOiBcInRlYW1JZFwiJyk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodHlwZW9mIHJvbGVzID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEFwcHdyaXRlRXhjZXB0aW9uKCdNaXNzaW5nIHJlcXVpcmVkIHBhcmFtZXRlcjogXCJyb2xlc1wiJyk7XG4gICAgICAgIH1cblxuXG4gICAgICAgIGlmICh0eXBlb2YgZW1haWwgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICBwYXlsb2FkWydlbWFpbCddID0gZW1haWw7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodHlwZW9mIHVzZXJJZCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHBheWxvYWRbJ3VzZXJJZCddID0gdXNlcklkO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHR5cGVvZiBwaG9uZSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHBheWxvYWRbJ3Bob25lJ10gPSBwaG9uZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0eXBlb2Ygcm9sZXMgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICBwYXlsb2FkWydyb2xlcyddID0gcm9sZXM7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodHlwZW9mIHVybCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHBheWxvYWRbJ3VybCddID0gdXJsO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHR5cGVvZiBuYW1lICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgcGF5bG9hZFsnbmFtZSddID0gbmFtZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBhd2FpdCB0aGlzLmNsaWVudC5jYWxsKCdwb3N0JywgYXBpUGF0aCwge1xuICAgICAgICAgICAgJ2NvbnRlbnQtdHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJyxcbiAgICAgICAgfSwgcGF5bG9hZCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2V0IHRlYW0gbWVtYmVyc2hpcFxuICAgICAqXG4gICAgICogR2V0IGEgdGVhbSBtZW1iZXIgYnkgdGhlIG1lbWJlcnNoaXAgdW5pcXVlIGlkLiBBbGwgdGVhbSBtZW1iZXJzIGhhdmUgcmVhZFxuICAgICAqIGFjY2VzcyBmb3IgdGhpcyByZXNvdXJjZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSB0ZWFtSWRcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gbWVtYmVyc2hpcElkXG4gICAgICogQHRocm93cyB7QXBwd3JpdGVFeGNlcHRpb259XG4gICAgICogQHJldHVybnMge1Byb21pc2V9XG4gICAgICovXG4gICAgYXN5bmMgZ2V0TWVtYmVyc2hpcCh0ZWFtSWQsIG1lbWJlcnNoaXBJZCkge1xuICAgICAgICBjb25zdCBhcGlQYXRoID0gJy90ZWFtcy97dGVhbUlkfS9tZW1iZXJzaGlwcy97bWVtYmVyc2hpcElkfScucmVwbGFjZSgne3RlYW1JZH0nLCB0ZWFtSWQpLnJlcGxhY2UoJ3ttZW1iZXJzaGlwSWR9JywgbWVtYmVyc2hpcElkKTtcbiAgICAgICAgbGV0IHBheWxvYWQgPSB7fTtcbiAgICAgICAgaWYgKHR5cGVvZiB0ZWFtSWQgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgQXBwd3JpdGVFeGNlcHRpb24oJ01pc3NpbmcgcmVxdWlyZWQgcGFyYW1ldGVyOiBcInRlYW1JZFwiJyk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodHlwZW9mIG1lbWJlcnNoaXBJZCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBBcHB3cml0ZUV4Y2VwdGlvbignTWlzc2luZyByZXF1aXJlZCBwYXJhbWV0ZXI6IFwibWVtYmVyc2hpcElkXCInKTtcbiAgICAgICAgfVxuXG5cbiAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMuY2xpZW50LmNhbGwoJ2dldCcsIGFwaVBhdGgsIHtcbiAgICAgICAgICAgICdjb250ZW50LXR5cGUnOiAnYXBwbGljYXRpb24vanNvbicsXG4gICAgICAgIH0sIHBheWxvYWQpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFVwZGF0ZSBtZW1iZXJzaGlwXG4gICAgICpcbiAgICAgKiBNb2RpZnkgdGhlIHJvbGVzIG9mIGEgdGVhbSBtZW1iZXIuIE9ubHkgdGVhbSBtZW1iZXJzIHdpdGggdGhlIG93bmVyIHJvbGVcbiAgICAgKiBoYXZlIGFjY2VzcyB0byB0aGlzIGVuZHBvaW50LiBMZWFybiBtb3JlIGFib3V0IFtyb2xlcyBhbmRcbiAgICAgKiBwZXJtaXNzaW9uc10oaHR0cHM6Ly9hcHB3cml0ZS5pby9kb2NzL3Blcm1pc3Npb25zKS5cbiAgICAgKiBcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSB0ZWFtSWRcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gbWVtYmVyc2hpcElkXG4gICAgICogQHBhcmFtIHtzdHJpbmdbXX0gcm9sZXNcbiAgICAgKiBAdGhyb3dzIHtBcHB3cml0ZUV4Y2VwdGlvbn1cbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZX1cbiAgICAgKi9cbiAgICBhc3luYyB1cGRhdGVNZW1iZXJzaGlwKHRlYW1JZCwgbWVtYmVyc2hpcElkLCByb2xlcykge1xuICAgICAgICBjb25zdCBhcGlQYXRoID0gJy90ZWFtcy97dGVhbUlkfS9tZW1iZXJzaGlwcy97bWVtYmVyc2hpcElkfScucmVwbGFjZSgne3RlYW1JZH0nLCB0ZWFtSWQpLnJlcGxhY2UoJ3ttZW1iZXJzaGlwSWR9JywgbWVtYmVyc2hpcElkKTtcbiAgICAgICAgbGV0IHBheWxvYWQgPSB7fTtcbiAgICAgICAgaWYgKHR5cGVvZiB0ZWFtSWQgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgQXBwd3JpdGVFeGNlcHRpb24oJ01pc3NpbmcgcmVxdWlyZWQgcGFyYW1ldGVyOiBcInRlYW1JZFwiJyk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodHlwZW9mIG1lbWJlcnNoaXBJZCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBBcHB3cml0ZUV4Y2VwdGlvbignTWlzc2luZyByZXF1aXJlZCBwYXJhbWV0ZXI6IFwibWVtYmVyc2hpcElkXCInKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0eXBlb2Ygcm9sZXMgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgQXBwd3JpdGVFeGNlcHRpb24oJ01pc3NpbmcgcmVxdWlyZWQgcGFyYW1ldGVyOiBcInJvbGVzXCInKTtcbiAgICAgICAgfVxuXG5cbiAgICAgICAgaWYgKHR5cGVvZiByb2xlcyAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHBheWxvYWRbJ3JvbGVzJ10gPSByb2xlcztcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBhd2FpdCB0aGlzLmNsaWVudC5jYWxsKCdwYXRjaCcsIGFwaVBhdGgsIHtcbiAgICAgICAgICAgICdjb250ZW50LXR5cGUnOiAnYXBwbGljYXRpb24vanNvbicsXG4gICAgICAgIH0sIHBheWxvYWQpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIERlbGV0ZSB0ZWFtIG1lbWJlcnNoaXBcbiAgICAgKlxuICAgICAqIFRoaXMgZW5kcG9pbnQgYWxsb3dzIGEgdXNlciB0byBsZWF2ZSBhIHRlYW0gb3IgZm9yIGEgdGVhbSBvd25lciB0byBkZWxldGVcbiAgICAgKiB0aGUgbWVtYmVyc2hpcCBvZiBhbnkgb3RoZXIgdGVhbSBtZW1iZXIuIFlvdSBjYW4gYWxzbyB1c2UgdGhpcyBlbmRwb2ludCB0b1xuICAgICAqIGRlbGV0ZSBhIHVzZXIgbWVtYmVyc2hpcCBldmVuIGlmIGl0IGlzIG5vdCBhY2NlcHRlZC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSB0ZWFtSWRcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gbWVtYmVyc2hpcElkXG4gICAgICogQHRocm93cyB7QXBwd3JpdGVFeGNlcHRpb259XG4gICAgICogQHJldHVybnMge1Byb21pc2V9XG4gICAgICovXG4gICAgYXN5bmMgZGVsZXRlTWVtYmVyc2hpcCh0ZWFtSWQsIG1lbWJlcnNoaXBJZCkge1xuICAgICAgICBjb25zdCBhcGlQYXRoID0gJy90ZWFtcy97dGVhbUlkfS9tZW1iZXJzaGlwcy97bWVtYmVyc2hpcElkfScucmVwbGFjZSgne3RlYW1JZH0nLCB0ZWFtSWQpLnJlcGxhY2UoJ3ttZW1iZXJzaGlwSWR9JywgbWVtYmVyc2hpcElkKTtcbiAgICAgICAgbGV0IHBheWxvYWQgPSB7fTtcbiAgICAgICAgaWYgKHR5cGVvZiB0ZWFtSWQgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgQXBwd3JpdGVFeGNlcHRpb24oJ01pc3NpbmcgcmVxdWlyZWQgcGFyYW1ldGVyOiBcInRlYW1JZFwiJyk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodHlwZW9mIG1lbWJlcnNoaXBJZCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBBcHB3cml0ZUV4Y2VwdGlvbignTWlzc2luZyByZXF1aXJlZCBwYXJhbWV0ZXI6IFwibWVtYmVyc2hpcElkXCInKTtcbiAgICAgICAgfVxuXG5cbiAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMuY2xpZW50LmNhbGwoJ2RlbGV0ZScsIGFwaVBhdGgsIHtcbiAgICAgICAgICAgICdjb250ZW50LXR5cGUnOiAnYXBwbGljYXRpb24vanNvbicsXG4gICAgICAgIH0sIHBheWxvYWQpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFVwZGF0ZSB0ZWFtIG1lbWJlcnNoaXAgc3RhdHVzXG4gICAgICpcbiAgICAgKiBVc2UgdGhpcyBlbmRwb2ludCB0byBhbGxvdyBhIHVzZXIgdG8gYWNjZXB0IGFuIGludml0YXRpb24gdG8gam9pbiBhIHRlYW1cbiAgICAgKiBhZnRlciBiZWluZyByZWRpcmVjdGVkIGJhY2sgdG8geW91ciBhcHAgZnJvbSB0aGUgaW52aXRhdGlvbiBlbWFpbCByZWNlaXZlZFxuICAgICAqIGJ5IHRoZSB1c2VyLlxuICAgICAqIFxuICAgICAqIElmIHRoZSByZXF1ZXN0IGlzIHN1Y2Nlc3NmdWwsIGEgc2Vzc2lvbiBmb3IgdGhlIHVzZXIgaXMgYXV0b21hdGljYWxseVxuICAgICAqIGNyZWF0ZWQuXG4gICAgICogXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gdGVhbUlkXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IG1lbWJlcnNoaXBJZFxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSB1c2VySWRcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gc2VjcmV0XG4gICAgICogQHRocm93cyB7QXBwd3JpdGVFeGNlcHRpb259XG4gICAgICogQHJldHVybnMge1Byb21pc2V9XG4gICAgICovXG4gICAgYXN5bmMgdXBkYXRlTWVtYmVyc2hpcFN0YXR1cyh0ZWFtSWQsIG1lbWJlcnNoaXBJZCwgdXNlcklkLCBzZWNyZXQpIHtcbiAgICAgICAgY29uc3QgYXBpUGF0aCA9ICcvdGVhbXMve3RlYW1JZH0vbWVtYmVyc2hpcHMve21lbWJlcnNoaXBJZH0vc3RhdHVzJy5yZXBsYWNlKCd7dGVhbUlkfScsIHRlYW1JZCkucmVwbGFjZSgne21lbWJlcnNoaXBJZH0nLCBtZW1iZXJzaGlwSWQpO1xuICAgICAgICBsZXQgcGF5bG9hZCA9IHt9O1xuICAgICAgICBpZiAodHlwZW9mIHRlYW1JZCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBBcHB3cml0ZUV4Y2VwdGlvbignTWlzc2luZyByZXF1aXJlZCBwYXJhbWV0ZXI6IFwidGVhbUlkXCInKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0eXBlb2YgbWVtYmVyc2hpcElkID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEFwcHdyaXRlRXhjZXB0aW9uKCdNaXNzaW5nIHJlcXVpcmVkIHBhcmFtZXRlcjogXCJtZW1iZXJzaGlwSWRcIicpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHR5cGVvZiB1c2VySWQgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgQXBwd3JpdGVFeGNlcHRpb24oJ01pc3NpbmcgcmVxdWlyZWQgcGFyYW1ldGVyOiBcInVzZXJJZFwiJyk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodHlwZW9mIHNlY3JldCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBBcHB3cml0ZUV4Y2VwdGlvbignTWlzc2luZyByZXF1aXJlZCBwYXJhbWV0ZXI6IFwic2VjcmV0XCInKTtcbiAgICAgICAgfVxuXG5cbiAgICAgICAgaWYgKHR5cGVvZiB1c2VySWQgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICBwYXlsb2FkWyd1c2VySWQnXSA9IHVzZXJJZDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0eXBlb2Ygc2VjcmV0ICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgcGF5bG9hZFsnc2VjcmV0J10gPSBzZWNyZXQ7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy5jbGllbnQuY2FsbCgncGF0Y2gnLCBhcGlQYXRoLCB7XG4gICAgICAgICAgICAnY29udGVudC10eXBlJzogJ2FwcGxpY2F0aW9uL2pzb24nLFxuICAgICAgICB9LCBwYXlsb2FkKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZXQgdGVhbSBwcmVmZXJlbmNlc1xuICAgICAqXG4gICAgICogR2V0IHRoZSB0ZWFtJ3Mgc2hhcmVkIHByZWZlcmVuY2VzIGJ5IGl0cyB1bmlxdWUgSUQuIElmIGEgcHJlZmVyZW5jZSBkb2Vzbid0XG4gICAgICogbmVlZCB0byBiZSBzaGFyZWQgYnkgYWxsIHRlYW0gbWVtYmVycywgcHJlZmVyIHN0b3JpbmcgdGhlbSBpbiBbdXNlclxuICAgICAqIHByZWZlcmVuY2VzXShodHRwczovL2FwcHdyaXRlLmlvL2RvY3MvcmVmZXJlbmNlcy9jbG91ZC9jbGllbnQtd2ViL2FjY291bnQjZ2V0UHJlZnMpLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHRlYW1JZFxuICAgICAqIEB0aHJvd3Mge0FwcHdyaXRlRXhjZXB0aW9ufVxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlfVxuICAgICAqL1xuICAgIGFzeW5jIGdldFByZWZzKHRlYW1JZCkge1xuICAgICAgICBjb25zdCBhcGlQYXRoID0gJy90ZWFtcy97dGVhbUlkfS9wcmVmcycucmVwbGFjZSgne3RlYW1JZH0nLCB0ZWFtSWQpO1xuICAgICAgICBsZXQgcGF5bG9hZCA9IHt9O1xuICAgICAgICBpZiAodHlwZW9mIHRlYW1JZCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBBcHB3cml0ZUV4Y2VwdGlvbignTWlzc2luZyByZXF1aXJlZCBwYXJhbWV0ZXI6IFwidGVhbUlkXCInKTtcbiAgICAgICAgfVxuXG5cbiAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMuY2xpZW50LmNhbGwoJ2dldCcsIGFwaVBhdGgsIHtcbiAgICAgICAgICAgICdjb250ZW50LXR5cGUnOiAnYXBwbGljYXRpb24vanNvbicsXG4gICAgICAgIH0sIHBheWxvYWQpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFVwZGF0ZSBwcmVmZXJlbmNlc1xuICAgICAqXG4gICAgICogVXBkYXRlIHRoZSB0ZWFtJ3MgcHJlZmVyZW5jZXMgYnkgaXRzIHVuaXF1ZSBJRC4gVGhlIG9iamVjdCB5b3UgcGFzcyBpc1xuICAgICAqIHN0b3JlZCBhcyBpcyBhbmQgcmVwbGFjZXMgYW55IHByZXZpb3VzIHZhbHVlLiBUaGUgbWF4aW11bSBhbGxvd2VkIHByZWZzXG4gICAgICogc2l6ZSBpcyA2NGtCIGFuZCB0aHJvd3MgYW4gZXJyb3IgaWYgZXhjZWVkZWQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gdGVhbUlkXG4gICAgICogQHBhcmFtIHtvYmplY3R9IHByZWZzXG4gICAgICogQHRocm93cyB7QXBwd3JpdGVFeGNlcHRpb259XG4gICAgICogQHJldHVybnMge1Byb21pc2V9XG4gICAgICovXG4gICAgYXN5bmMgdXBkYXRlUHJlZnModGVhbUlkLCBwcmVmcykge1xuICAgICAgICBjb25zdCBhcGlQYXRoID0gJy90ZWFtcy97dGVhbUlkfS9wcmVmcycucmVwbGFjZSgne3RlYW1JZH0nLCB0ZWFtSWQpO1xuICAgICAgICBsZXQgcGF5bG9hZCA9IHt9O1xuICAgICAgICBpZiAodHlwZW9mIHRlYW1JZCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBBcHB3cml0ZUV4Y2VwdGlvbignTWlzc2luZyByZXF1aXJlZCBwYXJhbWV0ZXI6IFwidGVhbUlkXCInKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0eXBlb2YgcHJlZnMgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgQXBwd3JpdGVFeGNlcHRpb24oJ01pc3NpbmcgcmVxdWlyZWQgcGFyYW1ldGVyOiBcInByZWZzXCInKTtcbiAgICAgICAgfVxuXG5cbiAgICAgICAgaWYgKHR5cGVvZiBwcmVmcyAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHBheWxvYWRbJ3ByZWZzJ10gPSBwcmVmcztcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBhd2FpdCB0aGlzLmNsaWVudC5jYWxsKCdwdXQnLCBhcGlQYXRoLCB7XG4gICAgICAgICAgICAnY29udGVudC10eXBlJzogJ2FwcGxpY2F0aW9uL2pzb24nLFxuICAgICAgICB9LCBwYXlsb2FkKTtcbiAgICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gVGVhbXM7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/node-appwrite/lib/services/teams.js\n");

/***/ }),

/***/ "(action-browser)/./node_modules/node-appwrite/lib/services/users.js":
/*!**********************************************************!*\
  !*** ./node_modules/node-appwrite/lib/services/users.js ***!
  \**********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("const Service = __webpack_require__(/*! ../service.js */ \"(action-browser)/./node_modules/node-appwrite/lib/service.js\");\nconst AppwriteException = __webpack_require__(/*! ../exception.js */ \"(action-browser)/./node_modules/node-appwrite/lib/exception.js\");\nconst InputFile = __webpack_require__(/*! ../inputFile.js */ \"(action-browser)/./node_modules/node-appwrite/lib/inputFile.js\");\nconst client = __webpack_require__(/*! ../client.js */ \"(action-browser)/./node_modules/node-appwrite/lib/client.js\");\nconst Stream = __webpack_require__(/*! stream */ \"stream\");\nconst { promisify } = __webpack_require__(/*! util */ \"util\");\nconst fs = __webpack_require__(/*! fs */ \"fs\");\nconst { File } = __webpack_require__(/*! undici */ \"undici\");\nconst Query = __webpack_require__(/*! ../query.js */ \"(action-browser)/./node_modules/node-appwrite/lib/query.js\");\n\nclass Users extends Service {\n\n     constructor(client)\n     {\n        super(client);\n     }\n\n\n    /**\n     * List users\n     *\n     * Get a list of all the project's users. You can use the query params to\n     * filter your results.\n     *\n     * @param {string[]} queries\n     * @param {string} search\n     * @throws {AppwriteException}\n     * @returns {Promise}\n     */\n    async list(queries, search) {\n        const apiPath = '/users';\n        let payload = {};\n\n        if (typeof queries !== 'undefined') {\n            payload['queries'] = queries;\n        }\n\n        if (typeof search !== 'undefined') {\n            payload['search'] = search;\n        }\n\n        return await this.client.call('get', apiPath, {\n            'content-type': 'application/json',\n        }, payload);\n    }\n\n    /**\n     * Create user\n     *\n     * Create a new user.\n     *\n     * @param {string} userId\n     * @param {string} email\n     * @param {string} phone\n     * @param {string} password\n     * @param {string} name\n     * @throws {AppwriteException}\n     * @returns {Promise}\n     */\n    async create(userId, email, phone, password, name) {\n        const apiPath = '/users';\n        let payload = {};\n        if (typeof userId === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"userId\"');\n        }\n\n\n        if (typeof userId !== 'undefined') {\n            payload['userId'] = userId;\n        }\n\n        if (typeof email !== 'undefined') {\n            payload['email'] = email;\n        }\n\n        if (typeof phone !== 'undefined') {\n            payload['phone'] = phone;\n        }\n\n        if (typeof password !== 'undefined') {\n            payload['password'] = password;\n        }\n\n        if (typeof name !== 'undefined') {\n            payload['name'] = name;\n        }\n\n        return await this.client.call('post', apiPath, {\n            'content-type': 'application/json',\n        }, payload);\n    }\n\n    /**\n     * Create user with Argon2 password\n     *\n     * Create a new user. Password provided must be hashed with the\n     * [Argon2](https://en.wikipedia.org/wiki/Argon2) algorithm. Use the [POST\n     * /users](https://appwrite.io/docs/server/users#usersCreate) endpoint to\n     * create users with a plain text password.\n     *\n     * @param {string} userId\n     * @param {string} email\n     * @param {string} password\n     * @param {string} name\n     * @throws {AppwriteException}\n     * @returns {Promise}\n     */\n    async createArgon2User(userId, email, password, name) {\n        const apiPath = '/users/argon2';\n        let payload = {};\n        if (typeof userId === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"userId\"');\n        }\n\n        if (typeof email === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"email\"');\n        }\n\n        if (typeof password === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"password\"');\n        }\n\n\n        if (typeof userId !== 'undefined') {\n            payload['userId'] = userId;\n        }\n\n        if (typeof email !== 'undefined') {\n            payload['email'] = email;\n        }\n\n        if (typeof password !== 'undefined') {\n            payload['password'] = password;\n        }\n\n        if (typeof name !== 'undefined') {\n            payload['name'] = name;\n        }\n\n        return await this.client.call('post', apiPath, {\n            'content-type': 'application/json',\n        }, payload);\n    }\n\n    /**\n     * Create user with bcrypt password\n     *\n     * Create a new user. Password provided must be hashed with the\n     * [Bcrypt](https://en.wikipedia.org/wiki/Bcrypt) algorithm. Use the [POST\n     * /users](https://appwrite.io/docs/server/users#usersCreate) endpoint to\n     * create users with a plain text password.\n     *\n     * @param {string} userId\n     * @param {string} email\n     * @param {string} password\n     * @param {string} name\n     * @throws {AppwriteException}\n     * @returns {Promise}\n     */\n    async createBcryptUser(userId, email, password, name) {\n        const apiPath = '/users/bcrypt';\n        let payload = {};\n        if (typeof userId === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"userId\"');\n        }\n\n        if (typeof email === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"email\"');\n        }\n\n        if (typeof password === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"password\"');\n        }\n\n\n        if (typeof userId !== 'undefined') {\n            payload['userId'] = userId;\n        }\n\n        if (typeof email !== 'undefined') {\n            payload['email'] = email;\n        }\n\n        if (typeof password !== 'undefined') {\n            payload['password'] = password;\n        }\n\n        if (typeof name !== 'undefined') {\n            payload['name'] = name;\n        }\n\n        return await this.client.call('post', apiPath, {\n            'content-type': 'application/json',\n        }, payload);\n    }\n\n    /**\n     * List Identities\n     *\n     * Get identities for all users.\n     *\n     * @param {string[]} queries\n     * @param {string} search\n     * @throws {AppwriteException}\n     * @returns {Promise}\n     */\n    async listIdentities(queries, search) {\n        const apiPath = '/users/identities';\n        let payload = {};\n\n        if (typeof queries !== 'undefined') {\n            payload['queries'] = queries;\n        }\n\n        if (typeof search !== 'undefined') {\n            payload['search'] = search;\n        }\n\n        return await this.client.call('get', apiPath, {\n            'content-type': 'application/json',\n        }, payload);\n    }\n\n    /**\n     * Delete identity\n     *\n     * Delete an identity by its unique ID.\n     *\n     * @param {string} identityId\n     * @throws {AppwriteException}\n     * @returns {Promise}\n     */\n    async deleteIdentity(identityId) {\n        const apiPath = '/users/identities/{identityId}'.replace('{identityId}', identityId);\n        let payload = {};\n        if (typeof identityId === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"identityId\"');\n        }\n\n\n        return await this.client.call('delete', apiPath, {\n            'content-type': 'application/json',\n        }, payload);\n    }\n\n    /**\n     * Create user with MD5 password\n     *\n     * Create a new user. Password provided must be hashed with the\n     * [MD5](https://en.wikipedia.org/wiki/MD5) algorithm. Use the [POST\n     * /users](https://appwrite.io/docs/server/users#usersCreate) endpoint to\n     * create users with a plain text password.\n     *\n     * @param {string} userId\n     * @param {string} email\n     * @param {string} password\n     * @param {string} name\n     * @throws {AppwriteException}\n     * @returns {Promise}\n     */\n    async createMD5User(userId, email, password, name) {\n        const apiPath = '/users/md5';\n        let payload = {};\n        if (typeof userId === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"userId\"');\n        }\n\n        if (typeof email === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"email\"');\n        }\n\n        if (typeof password === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"password\"');\n        }\n\n\n        if (typeof userId !== 'undefined') {\n            payload['userId'] = userId;\n        }\n\n        if (typeof email !== 'undefined') {\n            payload['email'] = email;\n        }\n\n        if (typeof password !== 'undefined') {\n            payload['password'] = password;\n        }\n\n        if (typeof name !== 'undefined') {\n            payload['name'] = name;\n        }\n\n        return await this.client.call('post', apiPath, {\n            'content-type': 'application/json',\n        }, payload);\n    }\n\n    /**\n     * Create user with PHPass password\n     *\n     * Create a new user. Password provided must be hashed with the\n     * [PHPass](https://www.openwall.com/phpass/) algorithm. Use the [POST\n     * /users](https://appwrite.io/docs/server/users#usersCreate) endpoint to\n     * create users with a plain text password.\n     *\n     * @param {string} userId\n     * @param {string} email\n     * @param {string} password\n     * @param {string} name\n     * @throws {AppwriteException}\n     * @returns {Promise}\n     */\n    async createPHPassUser(userId, email, password, name) {\n        const apiPath = '/users/phpass';\n        let payload = {};\n        if (typeof userId === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"userId\"');\n        }\n\n        if (typeof email === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"email\"');\n        }\n\n        if (typeof password === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"password\"');\n        }\n\n\n        if (typeof userId !== 'undefined') {\n            payload['userId'] = userId;\n        }\n\n        if (typeof email !== 'undefined') {\n            payload['email'] = email;\n        }\n\n        if (typeof password !== 'undefined') {\n            payload['password'] = password;\n        }\n\n        if (typeof name !== 'undefined') {\n            payload['name'] = name;\n        }\n\n        return await this.client.call('post', apiPath, {\n            'content-type': 'application/json',\n        }, payload);\n    }\n\n    /**\n     * Create user with Scrypt password\n     *\n     * Create a new user. Password provided must be hashed with the\n     * [Scrypt](https://github.com/Tarsnap/scrypt) algorithm. Use the [POST\n     * /users](https://appwrite.io/docs/server/users#usersCreate) endpoint to\n     * create users with a plain text password.\n     *\n     * @param {string} userId\n     * @param {string} email\n     * @param {string} password\n     * @param {string} passwordSalt\n     * @param {number} passwordCpu\n     * @param {number} passwordMemory\n     * @param {number} passwordParallel\n     * @param {number} passwordLength\n     * @param {string} name\n     * @throws {AppwriteException}\n     * @returns {Promise}\n     */\n    async createScryptUser(userId, email, password, passwordSalt, passwordCpu, passwordMemory, passwordParallel, passwordLength, name) {\n        const apiPath = '/users/scrypt';\n        let payload = {};\n        if (typeof userId === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"userId\"');\n        }\n\n        if (typeof email === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"email\"');\n        }\n\n        if (typeof password === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"password\"');\n        }\n\n        if (typeof passwordSalt === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"passwordSalt\"');\n        }\n\n        if (typeof passwordCpu === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"passwordCpu\"');\n        }\n\n        if (typeof passwordMemory === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"passwordMemory\"');\n        }\n\n        if (typeof passwordParallel === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"passwordParallel\"');\n        }\n\n        if (typeof passwordLength === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"passwordLength\"');\n        }\n\n\n        if (typeof userId !== 'undefined') {\n            payload['userId'] = userId;\n        }\n\n        if (typeof email !== 'undefined') {\n            payload['email'] = email;\n        }\n\n        if (typeof password !== 'undefined') {\n            payload['password'] = password;\n        }\n\n        if (typeof passwordSalt !== 'undefined') {\n            payload['passwordSalt'] = passwordSalt;\n        }\n\n        if (typeof passwordCpu !== 'undefined') {\n            payload['passwordCpu'] = passwordCpu;\n        }\n\n        if (typeof passwordMemory !== 'undefined') {\n            payload['passwordMemory'] = passwordMemory;\n        }\n\n        if (typeof passwordParallel !== 'undefined') {\n            payload['passwordParallel'] = passwordParallel;\n        }\n\n        if (typeof passwordLength !== 'undefined') {\n            payload['passwordLength'] = passwordLength;\n        }\n\n        if (typeof name !== 'undefined') {\n            payload['name'] = name;\n        }\n\n        return await this.client.call('post', apiPath, {\n            'content-type': 'application/json',\n        }, payload);\n    }\n\n    /**\n     * Create user with Scrypt modified password\n     *\n     * Create a new user. Password provided must be hashed with the [Scrypt\n     * Modified](https://gist.github.com/Meldiron/eecf84a0225eccb5a378d45bb27462cc)\n     * algorithm. Use the [POST\n     * /users](https://appwrite.io/docs/server/users#usersCreate) endpoint to\n     * create users with a plain text password.\n     *\n     * @param {string} userId\n     * @param {string} email\n     * @param {string} password\n     * @param {string} passwordSalt\n     * @param {string} passwordSaltSeparator\n     * @param {string} passwordSignerKey\n     * @param {string} name\n     * @throws {AppwriteException}\n     * @returns {Promise}\n     */\n    async createScryptModifiedUser(userId, email, password, passwordSalt, passwordSaltSeparator, passwordSignerKey, name) {\n        const apiPath = '/users/scrypt-modified';\n        let payload = {};\n        if (typeof userId === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"userId\"');\n        }\n\n        if (typeof email === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"email\"');\n        }\n\n        if (typeof password === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"password\"');\n        }\n\n        if (typeof passwordSalt === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"passwordSalt\"');\n        }\n\n        if (typeof passwordSaltSeparator === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"passwordSaltSeparator\"');\n        }\n\n        if (typeof passwordSignerKey === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"passwordSignerKey\"');\n        }\n\n\n        if (typeof userId !== 'undefined') {\n            payload['userId'] = userId;\n        }\n\n        if (typeof email !== 'undefined') {\n            payload['email'] = email;\n        }\n\n        if (typeof password !== 'undefined') {\n            payload['password'] = password;\n        }\n\n        if (typeof passwordSalt !== 'undefined') {\n            payload['passwordSalt'] = passwordSalt;\n        }\n\n        if (typeof passwordSaltSeparator !== 'undefined') {\n            payload['passwordSaltSeparator'] = passwordSaltSeparator;\n        }\n\n        if (typeof passwordSignerKey !== 'undefined') {\n            payload['passwordSignerKey'] = passwordSignerKey;\n        }\n\n        if (typeof name !== 'undefined') {\n            payload['name'] = name;\n        }\n\n        return await this.client.call('post', apiPath, {\n            'content-type': 'application/json',\n        }, payload);\n    }\n\n    /**\n     * Create user with SHA password\n     *\n     * Create a new user. Password provided must be hashed with the\n     * [SHA](https://en.wikipedia.org/wiki/Secure_Hash_Algorithm) algorithm. Use\n     * the [POST /users](https://appwrite.io/docs/server/users#usersCreate)\n     * endpoint to create users with a plain text password.\n     *\n     * @param {string} userId\n     * @param {string} email\n     * @param {string} password\n     * @param {PasswordHash} passwordVersion\n     * @param {string} name\n     * @throws {AppwriteException}\n     * @returns {Promise}\n     */\n    async createSHAUser(userId, email, password, passwordVersion, name) {\n        const apiPath = '/users/sha';\n        let payload = {};\n        if (typeof userId === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"userId\"');\n        }\n\n        if (typeof email === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"email\"');\n        }\n\n        if (typeof password === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"password\"');\n        }\n\n\n        if (typeof userId !== 'undefined') {\n            payload['userId'] = userId;\n        }\n\n        if (typeof email !== 'undefined') {\n            payload['email'] = email;\n        }\n\n        if (typeof password !== 'undefined') {\n            payload['password'] = password;\n        }\n\n        if (typeof passwordVersion !== 'undefined') {\n            payload['passwordVersion'] = passwordVersion;\n        }\n\n        if (typeof name !== 'undefined') {\n            payload['name'] = name;\n        }\n\n        return await this.client.call('post', apiPath, {\n            'content-type': 'application/json',\n        }, payload);\n    }\n\n    /**\n     * Get user\n     *\n     * Get a user by its unique ID.\n     *\n     * @param {string} userId\n     * @throws {AppwriteException}\n     * @returns {Promise}\n     */\n    async get(userId) {\n        const apiPath = '/users/{userId}'.replace('{userId}', userId);\n        let payload = {};\n        if (typeof userId === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"userId\"');\n        }\n\n\n        return await this.client.call('get', apiPath, {\n            'content-type': 'application/json',\n        }, payload);\n    }\n\n    /**\n     * Delete user\n     *\n     * Delete a user by its unique ID, thereby releasing it's ID. Since ID is\n     * released and can be reused, all user-related resources like documents or\n     * storage files should be deleted before user deletion. If you want to keep\n     * ID reserved, use the\n     * [updateStatus](https://appwrite.io/docs/server/users#usersUpdateStatus)\n     * endpoint instead.\n     *\n     * @param {string} userId\n     * @throws {AppwriteException}\n     * @returns {Promise}\n     */\n    async delete(userId) {\n        const apiPath = '/users/{userId}'.replace('{userId}', userId);\n        let payload = {};\n        if (typeof userId === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"userId\"');\n        }\n\n\n        return await this.client.call('delete', apiPath, {\n            'content-type': 'application/json',\n        }, payload);\n    }\n\n    /**\n     * Update email\n     *\n     * Update the user email by its unique ID.\n     *\n     * @param {string} userId\n     * @param {string} email\n     * @throws {AppwriteException}\n     * @returns {Promise}\n     */\n    async updateEmail(userId, email) {\n        const apiPath = '/users/{userId}/email'.replace('{userId}', userId);\n        let payload = {};\n        if (typeof userId === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"userId\"');\n        }\n\n        if (typeof email === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"email\"');\n        }\n\n\n        if (typeof email !== 'undefined') {\n            payload['email'] = email;\n        }\n\n        return await this.client.call('patch', apiPath, {\n            'content-type': 'application/json',\n        }, payload);\n    }\n\n    /**\n     * Update user labels\n     *\n     * Update the user labels by its unique ID. \n     * \n     * Labels can be used to grant access to resources. While teams are a way for\n     * user's to share access to a resource, labels can be defined by the\n     * developer to grant access without an invitation. See the [Permissions\n     * docs](https://appwrite.io/docs/permissions) for more info.\n     *\n     * @param {string} userId\n     * @param {string[]} labels\n     * @throws {AppwriteException}\n     * @returns {Promise}\n     */\n    async updateLabels(userId, labels) {\n        const apiPath = '/users/{userId}/labels'.replace('{userId}', userId);\n        let payload = {};\n        if (typeof userId === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"userId\"');\n        }\n\n        if (typeof labels === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"labels\"');\n        }\n\n\n        if (typeof labels !== 'undefined') {\n            payload['labels'] = labels;\n        }\n\n        return await this.client.call('put', apiPath, {\n            'content-type': 'application/json',\n        }, payload);\n    }\n\n    /**\n     * List user logs\n     *\n     * Get the user activity logs list by its unique ID.\n     *\n     * @param {string} userId\n     * @param {string[]} queries\n     * @throws {AppwriteException}\n     * @returns {Promise}\n     */\n    async listLogs(userId, queries) {\n        const apiPath = '/users/{userId}/logs'.replace('{userId}', userId);\n        let payload = {};\n        if (typeof userId === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"userId\"');\n        }\n\n\n        if (typeof queries !== 'undefined') {\n            payload['queries'] = queries;\n        }\n\n        return await this.client.call('get', apiPath, {\n            'content-type': 'application/json',\n        }, payload);\n    }\n\n    /**\n     * List user memberships\n     *\n     * Get the user membership list by its unique ID.\n     *\n     * @param {string} userId\n     * @throws {AppwriteException}\n     * @returns {Promise}\n     */\n    async listMemberships(userId) {\n        const apiPath = '/users/{userId}/memberships'.replace('{userId}', userId);\n        let payload = {};\n        if (typeof userId === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"userId\"');\n        }\n\n\n        return await this.client.call('get', apiPath, {\n            'content-type': 'application/json',\n        }, payload);\n    }\n\n    /**\n     * Update MFA\n     *\n     * Enable or disable MFA on a user account.\n     *\n     * @param {string} userId\n     * @param {boolean} mfa\n     * @throws {AppwriteException}\n     * @returns {Promise}\n     */\n    async updateMfa(userId, mfa) {\n        const apiPath = '/users/{userId}/mfa'.replace('{userId}', userId);\n        let payload = {};\n        if (typeof userId === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"userId\"');\n        }\n\n        if (typeof mfa === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"mfa\"');\n        }\n\n\n        if (typeof mfa !== 'undefined') {\n            payload['mfa'] = mfa;\n        }\n\n        return await this.client.call('patch', apiPath, {\n            'content-type': 'application/json',\n        }, payload);\n    }\n\n    /**\n     * Delete Authenticator\n     *\n     * Delete an authenticator app.\n     *\n     * @param {string} userId\n     * @param {AuthenticatorType} type\n     * @throws {AppwriteException}\n     * @returns {Promise}\n     */\n    async deleteMfaAuthenticator(userId, type) {\n        const apiPath = '/users/{userId}/mfa/authenticators/{type}'.replace('{userId}', userId).replace('{type}', type);\n        let payload = {};\n        if (typeof userId === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"userId\"');\n        }\n\n        if (typeof type === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"type\"');\n        }\n\n\n        return await this.client.call('delete', apiPath, {\n            'content-type': 'application/json',\n        }, payload);\n    }\n\n    /**\n     * List Factors\n     *\n     * List the factors available on the account to be used as a MFA challange.\n     *\n     * @param {string} userId\n     * @throws {AppwriteException}\n     * @returns {Promise}\n     */\n    async listMfaFactors(userId) {\n        const apiPath = '/users/{userId}/mfa/factors'.replace('{userId}', userId);\n        let payload = {};\n        if (typeof userId === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"userId\"');\n        }\n\n\n        return await this.client.call('get', apiPath, {\n            'content-type': 'application/json',\n        }, payload);\n    }\n\n    /**\n     * Get MFA Recovery Codes\n     *\n     * Get recovery codes that can be used as backup for MFA flow by User ID.\n     * Before getting codes, they must be generated using\n     * [createMfaRecoveryCodes](/docs/references/cloud/client-web/account#createMfaRecoveryCodes)\n     * method.\n     *\n     * @param {string} userId\n     * @throws {AppwriteException}\n     * @returns {Promise}\n     */\n    async getMfaRecoveryCodes(userId) {\n        const apiPath = '/users/{userId}/mfa/recovery-codes'.replace('{userId}', userId);\n        let payload = {};\n        if (typeof userId === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"userId\"');\n        }\n\n\n        return await this.client.call('get', apiPath, {\n            'content-type': 'application/json',\n        }, payload);\n    }\n\n    /**\n     * Regenerate MFA Recovery Codes\n     *\n     * Regenerate recovery codes that can be used as backup for MFA flow by User\n     * ID. Before regenerating codes, they must be first generated using\n     * [createMfaRecoveryCodes](/docs/references/cloud/client-web/account#createMfaRecoveryCodes)\n     * method.\n     *\n     * @param {string} userId\n     * @throws {AppwriteException}\n     * @returns {Promise}\n     */\n    async updateMfaRecoveryCodes(userId) {\n        const apiPath = '/users/{userId}/mfa/recovery-codes'.replace('{userId}', userId);\n        let payload = {};\n        if (typeof userId === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"userId\"');\n        }\n\n\n        return await this.client.call('put', apiPath, {\n            'content-type': 'application/json',\n        }, payload);\n    }\n\n    /**\n     * Create MFA Recovery Codes\n     *\n     * Generate recovery codes used as backup for MFA flow for User ID. Recovery\n     * codes can be used as a MFA verification type in\n     * [createMfaChallenge](/docs/references/cloud/client-web/account#createMfaChallenge)\n     * method by client SDK.\n     *\n     * @param {string} userId\n     * @throws {AppwriteException}\n     * @returns {Promise}\n     */\n    async createMfaRecoveryCodes(userId) {\n        const apiPath = '/users/{userId}/mfa/recovery-codes'.replace('{userId}', userId);\n        let payload = {};\n        if (typeof userId === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"userId\"');\n        }\n\n\n        return await this.client.call('patch', apiPath, {\n            'content-type': 'application/json',\n        }, payload);\n    }\n\n    /**\n     * Update name\n     *\n     * Update the user name by its unique ID.\n     *\n     * @param {string} userId\n     * @param {string} name\n     * @throws {AppwriteException}\n     * @returns {Promise}\n     */\n    async updateName(userId, name) {\n        const apiPath = '/users/{userId}/name'.replace('{userId}', userId);\n        let payload = {};\n        if (typeof userId === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"userId\"');\n        }\n\n        if (typeof name === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"name\"');\n        }\n\n\n        if (typeof name !== 'undefined') {\n            payload['name'] = name;\n        }\n\n        return await this.client.call('patch', apiPath, {\n            'content-type': 'application/json',\n        }, payload);\n    }\n\n    /**\n     * Update password\n     *\n     * Update the user password by its unique ID.\n     *\n     * @param {string} userId\n     * @param {string} password\n     * @throws {AppwriteException}\n     * @returns {Promise}\n     */\n    async updatePassword(userId, password) {\n        const apiPath = '/users/{userId}/password'.replace('{userId}', userId);\n        let payload = {};\n        if (typeof userId === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"userId\"');\n        }\n\n        if (typeof password === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"password\"');\n        }\n\n\n        if (typeof password !== 'undefined') {\n            payload['password'] = password;\n        }\n\n        return await this.client.call('patch', apiPath, {\n            'content-type': 'application/json',\n        }, payload);\n    }\n\n    /**\n     * Update phone\n     *\n     * Update the user phone by its unique ID.\n     *\n     * @param {string} userId\n     * @param {string} number\n     * @throws {AppwriteException}\n     * @returns {Promise}\n     */\n    async updatePhone(userId, number) {\n        const apiPath = '/users/{userId}/phone'.replace('{userId}', userId);\n        let payload = {};\n        if (typeof userId === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"userId\"');\n        }\n\n        if (typeof number === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"number\"');\n        }\n\n\n        if (typeof number !== 'undefined') {\n            payload['number'] = number;\n        }\n\n        return await this.client.call('patch', apiPath, {\n            'content-type': 'application/json',\n        }, payload);\n    }\n\n    /**\n     * Get user preferences\n     *\n     * Get the user preferences by its unique ID.\n     *\n     * @param {string} userId\n     * @throws {AppwriteException}\n     * @returns {Promise}\n     */\n    async getPrefs(userId) {\n        const apiPath = '/users/{userId}/prefs'.replace('{userId}', userId);\n        let payload = {};\n        if (typeof userId === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"userId\"');\n        }\n\n\n        return await this.client.call('get', apiPath, {\n            'content-type': 'application/json',\n        }, payload);\n    }\n\n    /**\n     * Update user preferences\n     *\n     * Update the user preferences by its unique ID. The object you pass is stored\n     * as is, and replaces any previous value. The maximum allowed prefs size is\n     * 64kB and throws error if exceeded.\n     *\n     * @param {string} userId\n     * @param {object} prefs\n     * @throws {AppwriteException}\n     * @returns {Promise}\n     */\n    async updatePrefs(userId, prefs) {\n        const apiPath = '/users/{userId}/prefs'.replace('{userId}', userId);\n        let payload = {};\n        if (typeof userId === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"userId\"');\n        }\n\n        if (typeof prefs === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"prefs\"');\n        }\n\n\n        if (typeof prefs !== 'undefined') {\n            payload['prefs'] = prefs;\n        }\n\n        return await this.client.call('patch', apiPath, {\n            'content-type': 'application/json',\n        }, payload);\n    }\n\n    /**\n     * List user sessions\n     *\n     * Get the user sessions list by its unique ID.\n     *\n     * @param {string} userId\n     * @throws {AppwriteException}\n     * @returns {Promise}\n     */\n    async listSessions(userId) {\n        const apiPath = '/users/{userId}/sessions'.replace('{userId}', userId);\n        let payload = {};\n        if (typeof userId === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"userId\"');\n        }\n\n\n        return await this.client.call('get', apiPath, {\n            'content-type': 'application/json',\n        }, payload);\n    }\n\n    /**\n     * Create session\n     *\n     * Creates a session for a user. Returns an immediately usable session object.\n     * \n     * If you want to generate a token for a custom authentication flow, use the\n     * [POST\n     * /users/{userId}/tokens](https://appwrite.io/docs/server/users#createToken)\n     * endpoint.\n     *\n     * @param {string} userId\n     * @throws {AppwriteException}\n     * @returns {Promise}\n     */\n    async createSession(userId) {\n        const apiPath = '/users/{userId}/sessions'.replace('{userId}', userId);\n        let payload = {};\n        if (typeof userId === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"userId\"');\n        }\n\n\n        return await this.client.call('post', apiPath, {\n            'content-type': 'application/json',\n        }, payload);\n    }\n\n    /**\n     * Delete user sessions\n     *\n     * Delete all user's sessions by using the user's unique ID.\n     *\n     * @param {string} userId\n     * @throws {AppwriteException}\n     * @returns {Promise}\n     */\n    async deleteSessions(userId) {\n        const apiPath = '/users/{userId}/sessions'.replace('{userId}', userId);\n        let payload = {};\n        if (typeof userId === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"userId\"');\n        }\n\n\n        return await this.client.call('delete', apiPath, {\n            'content-type': 'application/json',\n        }, payload);\n    }\n\n    /**\n     * Delete user session\n     *\n     * Delete a user sessions by its unique ID.\n     *\n     * @param {string} userId\n     * @param {string} sessionId\n     * @throws {AppwriteException}\n     * @returns {Promise}\n     */\n    async deleteSession(userId, sessionId) {\n        const apiPath = '/users/{userId}/sessions/{sessionId}'.replace('{userId}', userId).replace('{sessionId}', sessionId);\n        let payload = {};\n        if (typeof userId === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"userId\"');\n        }\n\n        if (typeof sessionId === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"sessionId\"');\n        }\n\n\n        return await this.client.call('delete', apiPath, {\n            'content-type': 'application/json',\n        }, payload);\n    }\n\n    /**\n     * Update user status\n     *\n     * Update the user status by its unique ID. Use this endpoint as an\n     * alternative to deleting a user if you want to keep user's ID reserved.\n     *\n     * @param {string} userId\n     * @param {boolean} status\n     * @throws {AppwriteException}\n     * @returns {Promise}\n     */\n    async updateStatus(userId, status) {\n        const apiPath = '/users/{userId}/status'.replace('{userId}', userId);\n        let payload = {};\n        if (typeof userId === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"userId\"');\n        }\n\n        if (typeof status === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"status\"');\n        }\n\n\n        if (typeof status !== 'undefined') {\n            payload['status'] = status;\n        }\n\n        return await this.client.call('patch', apiPath, {\n            'content-type': 'application/json',\n        }, payload);\n    }\n\n    /**\n     * List User Targets\n     *\n     * List the messaging targets that are associated with a user.\n     *\n     * @param {string} userId\n     * @param {string[]} queries\n     * @throws {AppwriteException}\n     * @returns {Promise}\n     */\n    async listTargets(userId, queries) {\n        const apiPath = '/users/{userId}/targets'.replace('{userId}', userId);\n        let payload = {};\n        if (typeof userId === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"userId\"');\n        }\n\n\n        if (typeof queries !== 'undefined') {\n            payload['queries'] = queries;\n        }\n\n        return await this.client.call('get', apiPath, {\n            'content-type': 'application/json',\n        }, payload);\n    }\n\n    /**\n     * Create User Target\n     *\n     * Create a messaging target.\n     *\n     * @param {string} userId\n     * @param {string} targetId\n     * @param {MessagingProviderType} providerType\n     * @param {string} identifier\n     * @param {string} providerId\n     * @param {string} name\n     * @throws {AppwriteException}\n     * @returns {Promise}\n     */\n    async createTarget(userId, targetId, providerType, identifier, providerId, name) {\n        const apiPath = '/users/{userId}/targets'.replace('{userId}', userId);\n        let payload = {};\n        if (typeof userId === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"userId\"');\n        }\n\n        if (typeof targetId === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"targetId\"');\n        }\n\n        if (typeof providerType === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"providerType\"');\n        }\n\n        if (typeof identifier === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"identifier\"');\n        }\n\n\n        if (typeof targetId !== 'undefined') {\n            payload['targetId'] = targetId;\n        }\n\n        if (typeof providerType !== 'undefined') {\n            payload['providerType'] = providerType;\n        }\n\n        if (typeof identifier !== 'undefined') {\n            payload['identifier'] = identifier;\n        }\n\n        if (typeof providerId !== 'undefined') {\n            payload['providerId'] = providerId;\n        }\n\n        if (typeof name !== 'undefined') {\n            payload['name'] = name;\n        }\n\n        return await this.client.call('post', apiPath, {\n            'content-type': 'application/json',\n        }, payload);\n    }\n\n    /**\n     * Get User Target\n     *\n     * Get a user's push notification target by ID.\n     *\n     * @param {string} userId\n     * @param {string} targetId\n     * @throws {AppwriteException}\n     * @returns {Promise}\n     */\n    async getTarget(userId, targetId) {\n        const apiPath = '/users/{userId}/targets/{targetId}'.replace('{userId}', userId).replace('{targetId}', targetId);\n        let payload = {};\n        if (typeof userId === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"userId\"');\n        }\n\n        if (typeof targetId === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"targetId\"');\n        }\n\n\n        return await this.client.call('get', apiPath, {\n            'content-type': 'application/json',\n        }, payload);\n    }\n\n    /**\n     * Update User target\n     *\n     * Update a messaging target.\n     *\n     * @param {string} userId\n     * @param {string} targetId\n     * @param {string} identifier\n     * @param {string} providerId\n     * @param {string} name\n     * @throws {AppwriteException}\n     * @returns {Promise}\n     */\n    async updateTarget(userId, targetId, identifier, providerId, name) {\n        const apiPath = '/users/{userId}/targets/{targetId}'.replace('{userId}', userId).replace('{targetId}', targetId);\n        let payload = {};\n        if (typeof userId === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"userId\"');\n        }\n\n        if (typeof targetId === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"targetId\"');\n        }\n\n\n        if (typeof identifier !== 'undefined') {\n            payload['identifier'] = identifier;\n        }\n\n        if (typeof providerId !== 'undefined') {\n            payload['providerId'] = providerId;\n        }\n\n        if (typeof name !== 'undefined') {\n            payload['name'] = name;\n        }\n\n        return await this.client.call('patch', apiPath, {\n            'content-type': 'application/json',\n        }, payload);\n    }\n\n    /**\n     * Delete user target\n     *\n     * Delete a messaging target.\n     *\n     * @param {string} userId\n     * @param {string} targetId\n     * @throws {AppwriteException}\n     * @returns {Promise}\n     */\n    async deleteTarget(userId, targetId) {\n        const apiPath = '/users/{userId}/targets/{targetId}'.replace('{userId}', userId).replace('{targetId}', targetId);\n        let payload = {};\n        if (typeof userId === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"userId\"');\n        }\n\n        if (typeof targetId === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"targetId\"');\n        }\n\n\n        return await this.client.call('delete', apiPath, {\n            'content-type': 'application/json',\n        }, payload);\n    }\n\n    /**\n     * Create token\n     *\n     * Returns a token with a secret key for creating a session. If the provided\n     * user ID has not be registered, a new user will be created. Use the returned\n     * user ID and secret and submit a request to the [PUT\n     * /account/sessions/custom](https://appwrite.io/docs/references/cloud/client-web/account#updateCustomSession)\n     * endpoint to complete the login process.\n     *\n     * @param {string} userId\n     * @param {number} length\n     * @param {number} expire\n     * @throws {AppwriteException}\n     * @returns {Promise}\n     */\n    async createToken(userId, length, expire) {\n        const apiPath = '/users/{userId}/tokens'.replace('{userId}', userId);\n        let payload = {};\n        if (typeof userId === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"userId\"');\n        }\n\n\n        if (typeof length !== 'undefined') {\n            payload['length'] = length;\n        }\n\n        if (typeof expire !== 'undefined') {\n            payload['expire'] = expire;\n        }\n\n        return await this.client.call('post', apiPath, {\n            'content-type': 'application/json',\n        }, payload);\n    }\n\n    /**\n     * Update email verification\n     *\n     * Update the user email verification status by its unique ID.\n     *\n     * @param {string} userId\n     * @param {boolean} emailVerification\n     * @throws {AppwriteException}\n     * @returns {Promise}\n     */\n    async updateEmailVerification(userId, emailVerification) {\n        const apiPath = '/users/{userId}/verification'.replace('{userId}', userId);\n        let payload = {};\n        if (typeof userId === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"userId\"');\n        }\n\n        if (typeof emailVerification === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"emailVerification\"');\n        }\n\n\n        if (typeof emailVerification !== 'undefined') {\n            payload['emailVerification'] = emailVerification;\n        }\n\n        return await this.client.call('patch', apiPath, {\n            'content-type': 'application/json',\n        }, payload);\n    }\n\n    /**\n     * Update phone verification\n     *\n     * Update the user phone verification status by its unique ID.\n     *\n     * @param {string} userId\n     * @param {boolean} phoneVerification\n     * @throws {AppwriteException}\n     * @returns {Promise}\n     */\n    async updatePhoneVerification(userId, phoneVerification) {\n        const apiPath = '/users/{userId}/verification/phone'.replace('{userId}', userId);\n        let payload = {};\n        if (typeof userId === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"userId\"');\n        }\n\n        if (typeof phoneVerification === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"phoneVerification\"');\n        }\n\n\n        if (typeof phoneVerification !== 'undefined') {\n            payload['phoneVerification'] = phoneVerification;\n        }\n\n        return await this.client.call('patch', apiPath, {\n            'content-type': 'application/json',\n        }, payload);\n    }\n}\n\nmodule.exports = Users;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFjdGlvbi1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9ub2RlLWFwcHdyaXRlL2xpYi9zZXJ2aWNlcy91c2Vycy5qcyIsIm1hcHBpbmdzIjoiQUFBQSxnQkFBZ0IsbUJBQU8sQ0FBQyxtRkFBZTtBQUN2QywwQkFBMEIsbUJBQU8sQ0FBQyx1RkFBaUI7QUFDbkQsa0JBQWtCLG1CQUFPLENBQUMsdUZBQWlCO0FBQzNDLGVBQWUsbUJBQU8sQ0FBQyxpRkFBYztBQUNyQyxlQUFlLG1CQUFPLENBQUMsc0JBQVE7QUFDL0IsUUFBUSxZQUFZLEVBQUUsbUJBQU8sQ0FBQyxrQkFBTTtBQUNwQyxXQUFXLG1CQUFPLENBQUMsY0FBSTtBQUN2QixRQUFRLE9BQU8sRUFBRSxtQkFBTyxDQUFDLHNCQUFRO0FBQ2pDLGNBQWMsbUJBQU8sQ0FBQywrRUFBYTs7QUFFbkM7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsVUFBVTtBQUN6QixlQUFlLFFBQVE7QUFDdkIsZ0JBQWdCO0FBQ2hCLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QixlQUFlLFFBQVE7QUFDdkIsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsUUFBUTtBQUN2QixlQUFlLFFBQVE7QUFDdkIsZ0JBQWdCO0FBQ2hCLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsU0FBUztBQUNUOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkIsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsUUFBUTtBQUN2QixlQUFlLFFBQVE7QUFDdkIsZ0JBQWdCO0FBQ2hCLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFNBQVM7QUFDVDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsUUFBUTtBQUN2QixlQUFlLFFBQVE7QUFDdkIsZUFBZSxRQUFRO0FBQ3ZCLGdCQUFnQjtBQUNoQixpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsVUFBVTtBQUN6QixlQUFlLFFBQVE7QUFDdkIsZ0JBQWdCO0FBQ2hCLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QixnQkFBZ0I7QUFDaEIsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQSw0Q0FBNEMsV0FBVyxZQUFZLFdBQVc7QUFDOUU7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QixlQUFlLFFBQVE7QUFDdkIsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsUUFBUTtBQUN2QixnQkFBZ0I7QUFDaEIsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsU0FBUztBQUNUOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkIsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsUUFBUTtBQUN2QixlQUFlLFFBQVE7QUFDdkIsZ0JBQWdCO0FBQ2hCLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFNBQVM7QUFDVDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsUUFBUTtBQUN2QixlQUFlLFFBQVE7QUFDdkIsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsUUFBUTtBQUN2QixlQUFlLFFBQVE7QUFDdkIsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsUUFBUTtBQUN2QixlQUFlLFFBQVE7QUFDdkIsZ0JBQWdCO0FBQ2hCLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTs7QUFF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QUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFNBQVM7QUFDVDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsUUFBUTtBQUN2QixnQkFBZ0I7QUFDaEIsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQSxpQ0FBaUMsT0FBTyxVQUFVLFNBQVMsWUFBWSxPQUFPLHFCQUFxQixTQUFTO0FBQzVHO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBLFNBQVM7QUFDVDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsUUFBUTtBQUN2QixlQUFlLFFBQVE7QUFDdkIsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsUUFBUTtBQUN2QixnQkFBZ0I7QUFDaEIsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQSxpQ0FBaUMsT0FBTyxVQUFVLFNBQVMsWUFBWSxPQUFPLHFCQUFxQixTQUFTO0FBQzVHO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFNBQVM7QUFDVDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsUUFBUTtBQUN2QixnQkFBZ0I7QUFDaEIsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQSxpQ0FBaUMsT0FBTyxVQUFVLFNBQVMsWUFBWSxPQUFPLHFCQUFxQixTQUFTO0FBQzVHO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBLFNBQVM7QUFDVDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkIsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsUUFBUTtBQUN2QixnQkFBZ0I7QUFDaEIsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQSxpQ0FBaUMsT0FBTyxtQkFBbUIsT0FBTztBQUNsRTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsU0FBUztBQUNUOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkIsZUFBZSxTQUFTO0FBQ3hCLGdCQUFnQjtBQUNoQixpQkFBaUI7QUFDakI7QUFDQTtBQUNBLGlDQUFpQyxPQUFPLHlCQUF5QixPQUFPO0FBQ3hFO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QixlQUFlLFNBQVM7QUFDeEIsZ0JBQWdCO0FBQ2hCLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0EsaUNBQWlDLE9BQU8sK0JBQStCLE9BQU87QUFDOUU7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBOztBQUVBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vanNtX2JhbmtpbmcvLi9ub2RlX21vZHVsZXMvbm9kZS1hcHB3cml0ZS9saWIvc2VydmljZXMvdXNlcnMuanM/M2E3ZiJdLCJzb3VyY2VzQ29udGVudCI6WyJjb25zdCBTZXJ2aWNlID0gcmVxdWlyZSgnLi4vc2VydmljZS5qcycpO1xuY29uc3QgQXBwd3JpdGVFeGNlcHRpb24gPSByZXF1aXJlKCcuLi9leGNlcHRpb24uanMnKTtcbmNvbnN0IElucHV0RmlsZSA9IHJlcXVpcmUoJy4uL2lucHV0RmlsZS5qcycpO1xuY29uc3QgY2xpZW50ID0gcmVxdWlyZSgnLi4vY2xpZW50LmpzJyk7XG5jb25zdCBTdHJlYW0gPSByZXF1aXJlKCdzdHJlYW0nKTtcbmNvbnN0IHsgcHJvbWlzaWZ5IH0gPSByZXF1aXJlKCd1dGlsJyk7XG5jb25zdCBmcyA9IHJlcXVpcmUoJ2ZzJyk7XG5jb25zdCB7IEZpbGUgfSA9IHJlcXVpcmUoJ3VuZGljaScpO1xuY29uc3QgUXVlcnkgPSByZXF1aXJlKCcuLi9xdWVyeS5qcycpO1xuXG5jbGFzcyBVc2VycyBleHRlbmRzIFNlcnZpY2Uge1xuXG4gICAgIGNvbnN0cnVjdG9yKGNsaWVudClcbiAgICAge1xuICAgICAgICBzdXBlcihjbGllbnQpO1xuICAgICB9XG5cblxuICAgIC8qKlxuICAgICAqIExpc3QgdXNlcnNcbiAgICAgKlxuICAgICAqIEdldCBhIGxpc3Qgb2YgYWxsIHRoZSBwcm9qZWN0J3MgdXNlcnMuIFlvdSBjYW4gdXNlIHRoZSBxdWVyeSBwYXJhbXMgdG9cbiAgICAgKiBmaWx0ZXIgeW91ciByZXN1bHRzLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmdbXX0gcXVlcmllc1xuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBzZWFyY2hcbiAgICAgKiBAdGhyb3dzIHtBcHB3cml0ZUV4Y2VwdGlvbn1cbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZX1cbiAgICAgKi9cbiAgICBhc3luYyBsaXN0KHF1ZXJpZXMsIHNlYXJjaCkge1xuICAgICAgICBjb25zdCBhcGlQYXRoID0gJy91c2Vycyc7XG4gICAgICAgIGxldCBwYXlsb2FkID0ge307XG5cbiAgICAgICAgaWYgKHR5cGVvZiBxdWVyaWVzICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgcGF5bG9hZFsncXVlcmllcyddID0gcXVlcmllcztcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0eXBlb2Ygc2VhcmNoICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgcGF5bG9hZFsnc2VhcmNoJ10gPSBzZWFyY2g7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy5jbGllbnQuY2FsbCgnZ2V0JywgYXBpUGF0aCwge1xuICAgICAgICAgICAgJ2NvbnRlbnQtdHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJyxcbiAgICAgICAgfSwgcGF5bG9hZCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlIHVzZXJcbiAgICAgKlxuICAgICAqIENyZWF0ZSBhIG5ldyB1c2VyLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHVzZXJJZFxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBlbWFpbFxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBwaG9uZVxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBwYXNzd29yZFxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lXG4gICAgICogQHRocm93cyB7QXBwd3JpdGVFeGNlcHRpb259XG4gICAgICogQHJldHVybnMge1Byb21pc2V9XG4gICAgICovXG4gICAgYXN5bmMgY3JlYXRlKHVzZXJJZCwgZW1haWwsIHBob25lLCBwYXNzd29yZCwgbmFtZSkge1xuICAgICAgICBjb25zdCBhcGlQYXRoID0gJy91c2Vycyc7XG4gICAgICAgIGxldCBwYXlsb2FkID0ge307XG4gICAgICAgIGlmICh0eXBlb2YgdXNlcklkID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEFwcHdyaXRlRXhjZXB0aW9uKCdNaXNzaW5nIHJlcXVpcmVkIHBhcmFtZXRlcjogXCJ1c2VySWRcIicpO1xuICAgICAgICB9XG5cblxuICAgICAgICBpZiAodHlwZW9mIHVzZXJJZCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHBheWxvYWRbJ3VzZXJJZCddID0gdXNlcklkO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHR5cGVvZiBlbWFpbCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHBheWxvYWRbJ2VtYWlsJ10gPSBlbWFpbDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0eXBlb2YgcGhvbmUgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICBwYXlsb2FkWydwaG9uZSddID0gcGhvbmU7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodHlwZW9mIHBhc3N3b3JkICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgcGF5bG9hZFsncGFzc3dvcmQnXSA9IHBhc3N3b3JkO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHR5cGVvZiBuYW1lICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgcGF5bG9hZFsnbmFtZSddID0gbmFtZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBhd2FpdCB0aGlzLmNsaWVudC5jYWxsKCdwb3N0JywgYXBpUGF0aCwge1xuICAgICAgICAgICAgJ2NvbnRlbnQtdHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJyxcbiAgICAgICAgfSwgcGF5bG9hZCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlIHVzZXIgd2l0aCBBcmdvbjIgcGFzc3dvcmRcbiAgICAgKlxuICAgICAqIENyZWF0ZSBhIG5ldyB1c2VyLiBQYXNzd29yZCBwcm92aWRlZCBtdXN0IGJlIGhhc2hlZCB3aXRoIHRoZVxuICAgICAqIFtBcmdvbjJdKGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0FyZ29uMikgYWxnb3JpdGhtLiBVc2UgdGhlIFtQT1NUXG4gICAgICogL3VzZXJzXShodHRwczovL2FwcHdyaXRlLmlvL2RvY3Mvc2VydmVyL3VzZXJzI3VzZXJzQ3JlYXRlKSBlbmRwb2ludCB0b1xuICAgICAqIGNyZWF0ZSB1c2VycyB3aXRoIGEgcGxhaW4gdGV4dCBwYXNzd29yZC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSB1c2VySWRcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gZW1haWxcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gcGFzc3dvcmRcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gbmFtZVxuICAgICAqIEB0aHJvd3Mge0FwcHdyaXRlRXhjZXB0aW9ufVxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlfVxuICAgICAqL1xuICAgIGFzeW5jIGNyZWF0ZUFyZ29uMlVzZXIodXNlcklkLCBlbWFpbCwgcGFzc3dvcmQsIG5hbWUpIHtcbiAgICAgICAgY29uc3QgYXBpUGF0aCA9ICcvdXNlcnMvYXJnb24yJztcbiAgICAgICAgbGV0IHBheWxvYWQgPSB7fTtcbiAgICAgICAgaWYgKHR5cGVvZiB1c2VySWQgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgQXBwd3JpdGVFeGNlcHRpb24oJ01pc3NpbmcgcmVxdWlyZWQgcGFyYW1ldGVyOiBcInVzZXJJZFwiJyk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodHlwZW9mIGVtYWlsID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEFwcHdyaXRlRXhjZXB0aW9uKCdNaXNzaW5nIHJlcXVpcmVkIHBhcmFtZXRlcjogXCJlbWFpbFwiJyk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodHlwZW9mIHBhc3N3b3JkID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEFwcHdyaXRlRXhjZXB0aW9uKCdNaXNzaW5nIHJlcXVpcmVkIHBhcmFtZXRlcjogXCJwYXNzd29yZFwiJyk7XG4gICAgICAgIH1cblxuXG4gICAgICAgIGlmICh0eXBlb2YgdXNlcklkICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgcGF5bG9hZFsndXNlcklkJ10gPSB1c2VySWQ7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodHlwZW9mIGVtYWlsICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgcGF5bG9hZFsnZW1haWwnXSA9IGVtYWlsO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHR5cGVvZiBwYXNzd29yZCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHBheWxvYWRbJ3Bhc3N3b3JkJ10gPSBwYXNzd29yZDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0eXBlb2YgbmFtZSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHBheWxvYWRbJ25hbWUnXSA9IG5hbWU7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy5jbGllbnQuY2FsbCgncG9zdCcsIGFwaVBhdGgsIHtcbiAgICAgICAgICAgICdjb250ZW50LXR5cGUnOiAnYXBwbGljYXRpb24vanNvbicsXG4gICAgICAgIH0sIHBheWxvYWQpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZSB1c2VyIHdpdGggYmNyeXB0IHBhc3N3b3JkXG4gICAgICpcbiAgICAgKiBDcmVhdGUgYSBuZXcgdXNlci4gUGFzc3dvcmQgcHJvdmlkZWQgbXVzdCBiZSBoYXNoZWQgd2l0aCB0aGVcbiAgICAgKiBbQmNyeXB0XShodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9CY3J5cHQpIGFsZ29yaXRobS4gVXNlIHRoZSBbUE9TVFxuICAgICAqIC91c2Vyc10oaHR0cHM6Ly9hcHB3cml0ZS5pby9kb2NzL3NlcnZlci91c2VycyN1c2Vyc0NyZWF0ZSkgZW5kcG9pbnQgdG9cbiAgICAgKiBjcmVhdGUgdXNlcnMgd2l0aCBhIHBsYWluIHRleHQgcGFzc3dvcmQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gdXNlcklkXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGVtYWlsXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHBhc3N3b3JkXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IG5hbWVcbiAgICAgKiBAdGhyb3dzIHtBcHB3cml0ZUV4Y2VwdGlvbn1cbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZX1cbiAgICAgKi9cbiAgICBhc3luYyBjcmVhdGVCY3J5cHRVc2VyKHVzZXJJZCwgZW1haWwsIHBhc3N3b3JkLCBuYW1lKSB7XG4gICAgICAgIGNvbnN0IGFwaVBhdGggPSAnL3VzZXJzL2JjcnlwdCc7XG4gICAgICAgIGxldCBwYXlsb2FkID0ge307XG4gICAgICAgIGlmICh0eXBlb2YgdXNlcklkID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEFwcHdyaXRlRXhjZXB0aW9uKCdNaXNzaW5nIHJlcXVpcmVkIHBhcmFtZXRlcjogXCJ1c2VySWRcIicpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHR5cGVvZiBlbWFpbCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBBcHB3cml0ZUV4Y2VwdGlvbignTWlzc2luZyByZXF1aXJlZCBwYXJhbWV0ZXI6IFwiZW1haWxcIicpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHR5cGVvZiBwYXNzd29yZCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBBcHB3cml0ZUV4Y2VwdGlvbignTWlzc2luZyByZXF1aXJlZCBwYXJhbWV0ZXI6IFwicGFzc3dvcmRcIicpO1xuICAgICAgICB9XG5cblxuICAgICAgICBpZiAodHlwZW9mIHVzZXJJZCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHBheWxvYWRbJ3VzZXJJZCddID0gdXNlcklkO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHR5cGVvZiBlbWFpbCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHBheWxvYWRbJ2VtYWlsJ10gPSBlbWFpbDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0eXBlb2YgcGFzc3dvcmQgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICBwYXlsb2FkWydwYXNzd29yZCddID0gcGFzc3dvcmQ7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodHlwZW9mIG5hbWUgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICBwYXlsb2FkWyduYW1lJ10gPSBuYW1lO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMuY2xpZW50LmNhbGwoJ3Bvc3QnLCBhcGlQYXRoLCB7XG4gICAgICAgICAgICAnY29udGVudC10eXBlJzogJ2FwcGxpY2F0aW9uL2pzb24nLFxuICAgICAgICB9LCBwYXlsb2FkKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBMaXN0IElkZW50aXRpZXNcbiAgICAgKlxuICAgICAqIEdldCBpZGVudGl0aWVzIGZvciBhbGwgdXNlcnMuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZ1tdfSBxdWVyaWVzXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHNlYXJjaFxuICAgICAqIEB0aHJvd3Mge0FwcHdyaXRlRXhjZXB0aW9ufVxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlfVxuICAgICAqL1xuICAgIGFzeW5jIGxpc3RJZGVudGl0aWVzKHF1ZXJpZXMsIHNlYXJjaCkge1xuICAgICAgICBjb25zdCBhcGlQYXRoID0gJy91c2Vycy9pZGVudGl0aWVzJztcbiAgICAgICAgbGV0IHBheWxvYWQgPSB7fTtcblxuICAgICAgICBpZiAodHlwZW9mIHF1ZXJpZXMgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICBwYXlsb2FkWydxdWVyaWVzJ10gPSBxdWVyaWVzO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHR5cGVvZiBzZWFyY2ggIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICBwYXlsb2FkWydzZWFyY2gnXSA9IHNlYXJjaDtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBhd2FpdCB0aGlzLmNsaWVudC5jYWxsKCdnZXQnLCBhcGlQYXRoLCB7XG4gICAgICAgICAgICAnY29udGVudC10eXBlJzogJ2FwcGxpY2F0aW9uL2pzb24nLFxuICAgICAgICB9LCBwYXlsb2FkKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBEZWxldGUgaWRlbnRpdHlcbiAgICAgKlxuICAgICAqIERlbGV0ZSBhbiBpZGVudGl0eSBieSBpdHMgdW5pcXVlIElELlxuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGlkZW50aXR5SWRcbiAgICAgKiBAdGhyb3dzIHtBcHB3cml0ZUV4Y2VwdGlvbn1cbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZX1cbiAgICAgKi9cbiAgICBhc3luYyBkZWxldGVJZGVudGl0eShpZGVudGl0eUlkKSB7XG4gICAgICAgIGNvbnN0IGFwaVBhdGggPSAnL3VzZXJzL2lkZW50aXRpZXMve2lkZW50aXR5SWR9Jy5yZXBsYWNlKCd7aWRlbnRpdHlJZH0nLCBpZGVudGl0eUlkKTtcbiAgICAgICAgbGV0IHBheWxvYWQgPSB7fTtcbiAgICAgICAgaWYgKHR5cGVvZiBpZGVudGl0eUlkID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEFwcHdyaXRlRXhjZXB0aW9uKCdNaXNzaW5nIHJlcXVpcmVkIHBhcmFtZXRlcjogXCJpZGVudGl0eUlkXCInKTtcbiAgICAgICAgfVxuXG5cbiAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMuY2xpZW50LmNhbGwoJ2RlbGV0ZScsIGFwaVBhdGgsIHtcbiAgICAgICAgICAgICdjb250ZW50LXR5cGUnOiAnYXBwbGljYXRpb24vanNvbicsXG4gICAgICAgIH0sIHBheWxvYWQpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZSB1c2VyIHdpdGggTUQ1IHBhc3N3b3JkXG4gICAgICpcbiAgICAgKiBDcmVhdGUgYSBuZXcgdXNlci4gUGFzc3dvcmQgcHJvdmlkZWQgbXVzdCBiZSBoYXNoZWQgd2l0aCB0aGVcbiAgICAgKiBbTUQ1XShodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9NRDUpIGFsZ29yaXRobS4gVXNlIHRoZSBbUE9TVFxuICAgICAqIC91c2Vyc10oaHR0cHM6Ly9hcHB3cml0ZS5pby9kb2NzL3NlcnZlci91c2VycyN1c2Vyc0NyZWF0ZSkgZW5kcG9pbnQgdG9cbiAgICAgKiBjcmVhdGUgdXNlcnMgd2l0aCBhIHBsYWluIHRleHQgcGFzc3dvcmQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gdXNlcklkXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGVtYWlsXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHBhc3N3b3JkXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IG5hbWVcbiAgICAgKiBAdGhyb3dzIHtBcHB3cml0ZUV4Y2VwdGlvbn1cbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZX1cbiAgICAgKi9cbiAgICBhc3luYyBjcmVhdGVNRDVVc2VyKHVzZXJJZCwgZW1haWwsIHBhc3N3b3JkLCBuYW1lKSB7XG4gICAgICAgIGNvbnN0IGFwaVBhdGggPSAnL3VzZXJzL21kNSc7XG4gICAgICAgIGxldCBwYXlsb2FkID0ge307XG4gICAgICAgIGlmICh0eXBlb2YgdXNlcklkID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEFwcHdyaXRlRXhjZXB0aW9uKCdNaXNzaW5nIHJlcXVpcmVkIHBhcmFtZXRlcjogXCJ1c2VySWRcIicpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHR5cGVvZiBlbWFpbCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBBcHB3cml0ZUV4Y2VwdGlvbignTWlzc2luZyByZXF1aXJlZCBwYXJhbWV0ZXI6IFwiZW1haWxcIicpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHR5cGVvZiBwYXNzd29yZCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBBcHB3cml0ZUV4Y2VwdGlvbignTWlzc2luZyByZXF1aXJlZCBwYXJhbWV0ZXI6IFwicGFzc3dvcmRcIicpO1xuICAgICAgICB9XG5cblxuICAgICAgICBpZiAodHlwZW9mIHVzZXJJZCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHBheWxvYWRbJ3VzZXJJZCddID0gdXNlcklkO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHR5cGVvZiBlbWFpbCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHBheWxvYWRbJ2VtYWlsJ10gPSBlbWFpbDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0eXBlb2YgcGFzc3dvcmQgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICBwYXlsb2FkWydwYXNzd29yZCddID0gcGFzc3dvcmQ7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodHlwZW9mIG5hbWUgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICBwYXlsb2FkWyduYW1lJ10gPSBuYW1lO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMuY2xpZW50LmNhbGwoJ3Bvc3QnLCBhcGlQYXRoLCB7XG4gICAgICAgICAgICAnY29udGVudC10eXBlJzogJ2FwcGxpY2F0aW9uL2pzb24nLFxuICAgICAgICB9LCBwYXlsb2FkKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGUgdXNlciB3aXRoIFBIUGFzcyBwYXNzd29yZFxuICAgICAqXG4gICAgICogQ3JlYXRlIGEgbmV3IHVzZXIuIFBhc3N3b3JkIHByb3ZpZGVkIG11c3QgYmUgaGFzaGVkIHdpdGggdGhlXG4gICAgICogW1BIUGFzc10oaHR0cHM6Ly93d3cub3BlbndhbGwuY29tL3BocGFzcy8pIGFsZ29yaXRobS4gVXNlIHRoZSBbUE9TVFxuICAgICAqIC91c2Vyc10oaHR0cHM6Ly9hcHB3cml0ZS5pby9kb2NzL3NlcnZlci91c2VycyN1c2Vyc0NyZWF0ZSkgZW5kcG9pbnQgdG9cbiAgICAgKiBjcmVhdGUgdXNlcnMgd2l0aCBhIHBsYWluIHRleHQgcGFzc3dvcmQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gdXNlcklkXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGVtYWlsXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHBhc3N3b3JkXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IG5hbWVcbiAgICAgKiBAdGhyb3dzIHtBcHB3cml0ZUV4Y2VwdGlvbn1cbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZX1cbiAgICAgKi9cbiAgICBhc3luYyBjcmVhdGVQSFBhc3NVc2VyKHVzZXJJZCwgZW1haWwsIHBhc3N3b3JkLCBuYW1lKSB7XG4gICAgICAgIGNvbnN0IGFwaVBhdGggPSAnL3VzZXJzL3BocGFzcyc7XG4gICAgICAgIGxldCBwYXlsb2FkID0ge307XG4gICAgICAgIGlmICh0eXBlb2YgdXNlcklkID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEFwcHdyaXRlRXhjZXB0aW9uKCdNaXNzaW5nIHJlcXVpcmVkIHBhcmFtZXRlcjogXCJ1c2VySWRcIicpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHR5cGVvZiBlbWFpbCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBBcHB3cml0ZUV4Y2VwdGlvbignTWlzc2luZyByZXF1aXJlZCBwYXJhbWV0ZXI6IFwiZW1haWxcIicpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHR5cGVvZiBwYXNzd29yZCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBBcHB3cml0ZUV4Y2VwdGlvbignTWlzc2luZyByZXF1aXJlZCBwYXJhbWV0ZXI6IFwicGFzc3dvcmRcIicpO1xuICAgICAgICB9XG5cblxuICAgICAgICBpZiAodHlwZW9mIHVzZXJJZCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHBheWxvYWRbJ3VzZXJJZCddID0gdXNlcklkO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHR5cGVvZiBlbWFpbCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHBheWxvYWRbJ2VtYWlsJ10gPSBlbWFpbDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0eXBlb2YgcGFzc3dvcmQgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICBwYXlsb2FkWydwYXNzd29yZCddID0gcGFzc3dvcmQ7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodHlwZW9mIG5hbWUgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICBwYXlsb2FkWyduYW1lJ10gPSBuYW1lO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMuY2xpZW50LmNhbGwoJ3Bvc3QnLCBhcGlQYXRoLCB7XG4gICAgICAgICAgICAnY29udGVudC10eXBlJzogJ2FwcGxpY2F0aW9uL2pzb24nLFxuICAgICAgICB9LCBwYXlsb2FkKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGUgdXNlciB3aXRoIFNjcnlwdCBwYXNzd29yZFxuICAgICAqXG4gICAgICogQ3JlYXRlIGEgbmV3IHVzZXIuIFBhc3N3b3JkIHByb3ZpZGVkIG11c3QgYmUgaGFzaGVkIHdpdGggdGhlXG4gICAgICogW1NjcnlwdF0oaHR0cHM6Ly9naXRodWIuY29tL1RhcnNuYXAvc2NyeXB0KSBhbGdvcml0aG0uIFVzZSB0aGUgW1BPU1RcbiAgICAgKiAvdXNlcnNdKGh0dHBzOi8vYXBwd3JpdGUuaW8vZG9jcy9zZXJ2ZXIvdXNlcnMjdXNlcnNDcmVhdGUpIGVuZHBvaW50IHRvXG4gICAgICogY3JlYXRlIHVzZXJzIHdpdGggYSBwbGFpbiB0ZXh0IHBhc3N3b3JkLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHVzZXJJZFxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBlbWFpbFxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBwYXNzd29yZFxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBwYXNzd29yZFNhbHRcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gcGFzc3dvcmRDcHVcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gcGFzc3dvcmRNZW1vcnlcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gcGFzc3dvcmRQYXJhbGxlbFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBwYXNzd29yZExlbmd0aFxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lXG4gICAgICogQHRocm93cyB7QXBwd3JpdGVFeGNlcHRpb259XG4gICAgICogQHJldHVybnMge1Byb21pc2V9XG4gICAgICovXG4gICAgYXN5bmMgY3JlYXRlU2NyeXB0VXNlcih1c2VySWQsIGVtYWlsLCBwYXNzd29yZCwgcGFzc3dvcmRTYWx0LCBwYXNzd29yZENwdSwgcGFzc3dvcmRNZW1vcnksIHBhc3N3b3JkUGFyYWxsZWwsIHBhc3N3b3JkTGVuZ3RoLCBuYW1lKSB7XG4gICAgICAgIGNvbnN0IGFwaVBhdGggPSAnL3VzZXJzL3NjcnlwdCc7XG4gICAgICAgIGxldCBwYXlsb2FkID0ge307XG4gICAgICAgIGlmICh0eXBlb2YgdXNlcklkID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEFwcHdyaXRlRXhjZXB0aW9uKCdNaXNzaW5nIHJlcXVpcmVkIHBhcmFtZXRlcjogXCJ1c2VySWRcIicpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHR5cGVvZiBlbWFpbCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBBcHB3cml0ZUV4Y2VwdGlvbignTWlzc2luZyByZXF1aXJlZCBwYXJhbWV0ZXI6IFwiZW1haWxcIicpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHR5cGVvZiBwYXNzd29yZCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBBcHB3cml0ZUV4Y2VwdGlvbignTWlzc2luZyByZXF1aXJlZCBwYXJhbWV0ZXI6IFwicGFzc3dvcmRcIicpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHR5cGVvZiBwYXNzd29yZFNhbHQgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgQXBwd3JpdGVFeGNlcHRpb24oJ01pc3NpbmcgcmVxdWlyZWQgcGFyYW1ldGVyOiBcInBhc3N3b3JkU2FsdFwiJyk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodHlwZW9mIHBhc3N3b3JkQ3B1ID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEFwcHdyaXRlRXhjZXB0aW9uKCdNaXNzaW5nIHJlcXVpcmVkIHBhcmFtZXRlcjogXCJwYXNzd29yZENwdVwiJyk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodHlwZW9mIHBhc3N3b3JkTWVtb3J5ID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEFwcHdyaXRlRXhjZXB0aW9uKCdNaXNzaW5nIHJlcXVpcmVkIHBhcmFtZXRlcjogXCJwYXNzd29yZE1lbW9yeVwiJyk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodHlwZW9mIHBhc3N3b3JkUGFyYWxsZWwgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgQXBwd3JpdGVFeGNlcHRpb24oJ01pc3NpbmcgcmVxdWlyZWQgcGFyYW1ldGVyOiBcInBhc3N3b3JkUGFyYWxsZWxcIicpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHR5cGVvZiBwYXNzd29yZExlbmd0aCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBBcHB3cml0ZUV4Y2VwdGlvbignTWlzc2luZyByZXF1aXJlZCBwYXJhbWV0ZXI6IFwicGFzc3dvcmRMZW5ndGhcIicpO1xuICAgICAgICB9XG5cblxuICAgICAgICBpZiAodHlwZW9mIHVzZXJJZCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHBheWxvYWRbJ3VzZXJJZCddID0gdXNlcklkO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHR5cGVvZiBlbWFpbCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHBheWxvYWRbJ2VtYWlsJ10gPSBlbWFpbDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0eXBlb2YgcGFzc3dvcmQgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICBwYXlsb2FkWydwYXNzd29yZCddID0gcGFzc3dvcmQ7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodHlwZW9mIHBhc3N3b3JkU2FsdCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHBheWxvYWRbJ3Bhc3N3b3JkU2FsdCddID0gcGFzc3dvcmRTYWx0O1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHR5cGVvZiBwYXNzd29yZENwdSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHBheWxvYWRbJ3Bhc3N3b3JkQ3B1J10gPSBwYXNzd29yZENwdTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0eXBlb2YgcGFzc3dvcmRNZW1vcnkgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICBwYXlsb2FkWydwYXNzd29yZE1lbW9yeSddID0gcGFzc3dvcmRNZW1vcnk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodHlwZW9mIHBhc3N3b3JkUGFyYWxsZWwgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICBwYXlsb2FkWydwYXNzd29yZFBhcmFsbGVsJ10gPSBwYXNzd29yZFBhcmFsbGVsO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHR5cGVvZiBwYXNzd29yZExlbmd0aCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHBheWxvYWRbJ3Bhc3N3b3JkTGVuZ3RoJ10gPSBwYXNzd29yZExlbmd0aDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0eXBlb2YgbmFtZSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHBheWxvYWRbJ25hbWUnXSA9IG5hbWU7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy5jbGllbnQuY2FsbCgncG9zdCcsIGFwaVBhdGgsIHtcbiAgICAgICAgICAgICdjb250ZW50LXR5cGUnOiAnYXBwbGljYXRpb24vanNvbicsXG4gICAgICAgIH0sIHBheWxvYWQpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZSB1c2VyIHdpdGggU2NyeXB0IG1vZGlmaWVkIHBhc3N3b3JkXG4gICAgICpcbiAgICAgKiBDcmVhdGUgYSBuZXcgdXNlci4gUGFzc3dvcmQgcHJvdmlkZWQgbXVzdCBiZSBoYXNoZWQgd2l0aCB0aGUgW1NjcnlwdFxuICAgICAqIE1vZGlmaWVkXShodHRwczovL2dpc3QuZ2l0aHViLmNvbS9NZWxkaXJvbi9lZWNmODRhMDIyNWVjY2I1YTM3OGQ0NWJiMjc0NjJjYylcbiAgICAgKiBhbGdvcml0aG0uIFVzZSB0aGUgW1BPU1RcbiAgICAgKiAvdXNlcnNdKGh0dHBzOi8vYXBwd3JpdGUuaW8vZG9jcy9zZXJ2ZXIvdXNlcnMjdXNlcnNDcmVhdGUpIGVuZHBvaW50IHRvXG4gICAgICogY3JlYXRlIHVzZXJzIHdpdGggYSBwbGFpbiB0ZXh0IHBhc3N3b3JkLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHVzZXJJZFxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBlbWFpbFxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBwYXNzd29yZFxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBwYXNzd29yZFNhbHRcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gcGFzc3dvcmRTYWx0U2VwYXJhdG9yXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHBhc3N3b3JkU2lnbmVyS2V5XG4gICAgICogQHBhcmFtIHtzdHJpbmd9IG5hbWVcbiAgICAgKiBAdGhyb3dzIHtBcHB3cml0ZUV4Y2VwdGlvbn1cbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZX1cbiAgICAgKi9cbiAgICBhc3luYyBjcmVhdGVTY3J5cHRNb2RpZmllZFVzZXIodXNlcklkLCBlbWFpbCwgcGFzc3dvcmQsIHBhc3N3b3JkU2FsdCwgcGFzc3dvcmRTYWx0U2VwYXJhdG9yLCBwYXNzd29yZFNpZ25lcktleSwgbmFtZSkge1xuICAgICAgICBjb25zdCBhcGlQYXRoID0gJy91c2Vycy9zY3J5cHQtbW9kaWZpZWQnO1xuICAgICAgICBsZXQgcGF5bG9hZCA9IHt9O1xuICAgICAgICBpZiAodHlwZW9mIHVzZXJJZCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBBcHB3cml0ZUV4Y2VwdGlvbignTWlzc2luZyByZXF1aXJlZCBwYXJhbWV0ZXI6IFwidXNlcklkXCInKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0eXBlb2YgZW1haWwgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgQXBwd3JpdGVFeGNlcHRpb24oJ01pc3NpbmcgcmVxdWlyZWQgcGFyYW1ldGVyOiBcImVtYWlsXCInKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0eXBlb2YgcGFzc3dvcmQgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgQXBwd3JpdGVFeGNlcHRpb24oJ01pc3NpbmcgcmVxdWlyZWQgcGFyYW1ldGVyOiBcInBhc3N3b3JkXCInKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0eXBlb2YgcGFzc3dvcmRTYWx0ID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEFwcHdyaXRlRXhjZXB0aW9uKCdNaXNzaW5nIHJlcXVpcmVkIHBhcmFtZXRlcjogXCJwYXNzd29yZFNhbHRcIicpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHR5cGVvZiBwYXNzd29yZFNhbHRTZXBhcmF0b3IgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgQXBwd3JpdGVFeGNlcHRpb24oJ01pc3NpbmcgcmVxdWlyZWQgcGFyYW1ldGVyOiBcInBhc3N3b3JkU2FsdFNlcGFyYXRvclwiJyk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodHlwZW9mIHBhc3N3b3JkU2lnbmVyS2V5ID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEFwcHdyaXRlRXhjZXB0aW9uKCdNaXNzaW5nIHJlcXVpcmVkIHBhcmFtZXRlcjogXCJwYXNzd29yZFNpZ25lcktleVwiJyk7XG4gICAgICAgIH1cblxuXG4gICAgICAgIGlmICh0eXBlb2YgdXNlcklkICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgcGF5bG9hZFsndXNlcklkJ10gPSB1c2VySWQ7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodHlwZW9mIGVtYWlsICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgcGF5bG9hZFsnZW1haWwnXSA9IGVtYWlsO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHR5cGVvZiBwYXNzd29yZCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHBheWxvYWRbJ3Bhc3N3b3JkJ10gPSBwYXNzd29yZDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0eXBlb2YgcGFzc3dvcmRTYWx0ICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgcGF5bG9hZFsncGFzc3dvcmRTYWx0J10gPSBwYXNzd29yZFNhbHQ7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodHlwZW9mIHBhc3N3b3JkU2FsdFNlcGFyYXRvciAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHBheWxvYWRbJ3Bhc3N3b3JkU2FsdFNlcGFyYXRvciddID0gcGFzc3dvcmRTYWx0U2VwYXJhdG9yO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHR5cGVvZiBwYXNzd29yZFNpZ25lcktleSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHBheWxvYWRbJ3Bhc3N3b3JkU2lnbmVyS2V5J10gPSBwYXNzd29yZFNpZ25lcktleTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0eXBlb2YgbmFtZSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHBheWxvYWRbJ25hbWUnXSA9IG5hbWU7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy5jbGllbnQuY2FsbCgncG9zdCcsIGFwaVBhdGgsIHtcbiAgICAgICAgICAgICdjb250ZW50LXR5cGUnOiAnYXBwbGljYXRpb24vanNvbicsXG4gICAgICAgIH0sIHBheWxvYWQpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZSB1c2VyIHdpdGggU0hBIHBhc3N3b3JkXG4gICAgICpcbiAgICAgKiBDcmVhdGUgYSBuZXcgdXNlci4gUGFzc3dvcmQgcHJvdmlkZWQgbXVzdCBiZSBoYXNoZWQgd2l0aCB0aGVcbiAgICAgKiBbU0hBXShodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9TZWN1cmVfSGFzaF9BbGdvcml0aG0pIGFsZ29yaXRobS4gVXNlXG4gICAgICogdGhlIFtQT1NUIC91c2Vyc10oaHR0cHM6Ly9hcHB3cml0ZS5pby9kb2NzL3NlcnZlci91c2VycyN1c2Vyc0NyZWF0ZSlcbiAgICAgKiBlbmRwb2ludCB0byBjcmVhdGUgdXNlcnMgd2l0aCBhIHBsYWluIHRleHQgcGFzc3dvcmQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gdXNlcklkXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGVtYWlsXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHBhc3N3b3JkXG4gICAgICogQHBhcmFtIHtQYXNzd29yZEhhc2h9IHBhc3N3b3JkVmVyc2lvblxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lXG4gICAgICogQHRocm93cyB7QXBwd3JpdGVFeGNlcHRpb259XG4gICAgICogQHJldHVybnMge1Byb21pc2V9XG4gICAgICovXG4gICAgYXN5bmMgY3JlYXRlU0hBVXNlcih1c2VySWQsIGVtYWlsLCBwYXNzd29yZCwgcGFzc3dvcmRWZXJzaW9uLCBuYW1lKSB7XG4gICAgICAgIGNvbnN0IGFwaVBhdGggPSAnL3VzZXJzL3NoYSc7XG4gICAgICAgIGxldCBwYXlsb2FkID0ge307XG4gICAgICAgIGlmICh0eXBlb2YgdXNlcklkID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEFwcHdyaXRlRXhjZXB0aW9uKCdNaXNzaW5nIHJlcXVpcmVkIHBhcmFtZXRlcjogXCJ1c2VySWRcIicpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHR5cGVvZiBlbWFpbCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBBcHB3cml0ZUV4Y2VwdGlvbignTWlzc2luZyByZXF1aXJlZCBwYXJhbWV0ZXI6IFwiZW1haWxcIicpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHR5cGVvZiBwYXNzd29yZCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBBcHB3cml0ZUV4Y2VwdGlvbignTWlzc2luZyByZXF1aXJlZCBwYXJhbWV0ZXI6IFwicGFzc3dvcmRcIicpO1xuICAgICAgICB9XG5cblxuICAgICAgICBpZiAodHlwZW9mIHVzZXJJZCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHBheWxvYWRbJ3VzZXJJZCddID0gdXNlcklkO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHR5cGVvZiBlbWFpbCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHBheWxvYWRbJ2VtYWlsJ10gPSBlbWFpbDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0eXBlb2YgcGFzc3dvcmQgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICBwYXlsb2FkWydwYXNzd29yZCddID0gcGFzc3dvcmQ7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodHlwZW9mIHBhc3N3b3JkVmVyc2lvbiAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHBheWxvYWRbJ3Bhc3N3b3JkVmVyc2lvbiddID0gcGFzc3dvcmRWZXJzaW9uO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHR5cGVvZiBuYW1lICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgcGF5bG9hZFsnbmFtZSddID0gbmFtZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBhd2FpdCB0aGlzLmNsaWVudC5jYWxsKCdwb3N0JywgYXBpUGF0aCwge1xuICAgICAgICAgICAgJ2NvbnRlbnQtdHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJyxcbiAgICAgICAgfSwgcGF5bG9hZCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2V0IHVzZXJcbiAgICAgKlxuICAgICAqIEdldCBhIHVzZXIgYnkgaXRzIHVuaXF1ZSBJRC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSB1c2VySWRcbiAgICAgKiBAdGhyb3dzIHtBcHB3cml0ZUV4Y2VwdGlvbn1cbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZX1cbiAgICAgKi9cbiAgICBhc3luYyBnZXQodXNlcklkKSB7XG4gICAgICAgIGNvbnN0IGFwaVBhdGggPSAnL3VzZXJzL3t1c2VySWR9Jy5yZXBsYWNlKCd7dXNlcklkfScsIHVzZXJJZCk7XG4gICAgICAgIGxldCBwYXlsb2FkID0ge307XG4gICAgICAgIGlmICh0eXBlb2YgdXNlcklkID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEFwcHdyaXRlRXhjZXB0aW9uKCdNaXNzaW5nIHJlcXVpcmVkIHBhcmFtZXRlcjogXCJ1c2VySWRcIicpO1xuICAgICAgICB9XG5cblxuICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy5jbGllbnQuY2FsbCgnZ2V0JywgYXBpUGF0aCwge1xuICAgICAgICAgICAgJ2NvbnRlbnQtdHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJyxcbiAgICAgICAgfSwgcGF5bG9hZCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRGVsZXRlIHVzZXJcbiAgICAgKlxuICAgICAqIERlbGV0ZSBhIHVzZXIgYnkgaXRzIHVuaXF1ZSBJRCwgdGhlcmVieSByZWxlYXNpbmcgaXQncyBJRC4gU2luY2UgSUQgaXNcbiAgICAgKiByZWxlYXNlZCBhbmQgY2FuIGJlIHJldXNlZCwgYWxsIHVzZXItcmVsYXRlZCByZXNvdXJjZXMgbGlrZSBkb2N1bWVudHMgb3JcbiAgICAgKiBzdG9yYWdlIGZpbGVzIHNob3VsZCBiZSBkZWxldGVkIGJlZm9yZSB1c2VyIGRlbGV0aW9uLiBJZiB5b3Ugd2FudCB0byBrZWVwXG4gICAgICogSUQgcmVzZXJ2ZWQsIHVzZSB0aGVcbiAgICAgKiBbdXBkYXRlU3RhdHVzXShodHRwczovL2FwcHdyaXRlLmlvL2RvY3Mvc2VydmVyL3VzZXJzI3VzZXJzVXBkYXRlU3RhdHVzKVxuICAgICAqIGVuZHBvaW50IGluc3RlYWQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gdXNlcklkXG4gICAgICogQHRocm93cyB7QXBwd3JpdGVFeGNlcHRpb259XG4gICAgICogQHJldHVybnMge1Byb21pc2V9XG4gICAgICovXG4gICAgYXN5bmMgZGVsZXRlKHVzZXJJZCkge1xuICAgICAgICBjb25zdCBhcGlQYXRoID0gJy91c2Vycy97dXNlcklkfScucmVwbGFjZSgne3VzZXJJZH0nLCB1c2VySWQpO1xuICAgICAgICBsZXQgcGF5bG9hZCA9IHt9O1xuICAgICAgICBpZiAodHlwZW9mIHVzZXJJZCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBBcHB3cml0ZUV4Y2VwdGlvbignTWlzc2luZyByZXF1aXJlZCBwYXJhbWV0ZXI6IFwidXNlcklkXCInKTtcbiAgICAgICAgfVxuXG5cbiAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMuY2xpZW50LmNhbGwoJ2RlbGV0ZScsIGFwaVBhdGgsIHtcbiAgICAgICAgICAgICdjb250ZW50LXR5cGUnOiAnYXBwbGljYXRpb24vanNvbicsXG4gICAgICAgIH0sIHBheWxvYWQpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFVwZGF0ZSBlbWFpbFxuICAgICAqXG4gICAgICogVXBkYXRlIHRoZSB1c2VyIGVtYWlsIGJ5IGl0cyB1bmlxdWUgSUQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gdXNlcklkXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGVtYWlsXG4gICAgICogQHRocm93cyB7QXBwd3JpdGVFeGNlcHRpb259XG4gICAgICogQHJldHVybnMge1Byb21pc2V9XG4gICAgICovXG4gICAgYXN5bmMgdXBkYXRlRW1haWwodXNlcklkLCBlbWFpbCkge1xuICAgICAgICBjb25zdCBhcGlQYXRoID0gJy91c2Vycy97dXNlcklkfS9lbWFpbCcucmVwbGFjZSgne3VzZXJJZH0nLCB1c2VySWQpO1xuICAgICAgICBsZXQgcGF5bG9hZCA9IHt9O1xuICAgICAgICBpZiAodHlwZW9mIHVzZXJJZCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBBcHB3cml0ZUV4Y2VwdGlvbignTWlzc2luZyByZXF1aXJlZCBwYXJhbWV0ZXI6IFwidXNlcklkXCInKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0eXBlb2YgZW1haWwgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgQXBwd3JpdGVFeGNlcHRpb24oJ01pc3NpbmcgcmVxdWlyZWQgcGFyYW1ldGVyOiBcImVtYWlsXCInKTtcbiAgICAgICAgfVxuXG5cbiAgICAgICAgaWYgKHR5cGVvZiBlbWFpbCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHBheWxvYWRbJ2VtYWlsJ10gPSBlbWFpbDtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBhd2FpdCB0aGlzLmNsaWVudC5jYWxsKCdwYXRjaCcsIGFwaVBhdGgsIHtcbiAgICAgICAgICAgICdjb250ZW50LXR5cGUnOiAnYXBwbGljYXRpb24vanNvbicsXG4gICAgICAgIH0sIHBheWxvYWQpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFVwZGF0ZSB1c2VyIGxhYmVsc1xuICAgICAqXG4gICAgICogVXBkYXRlIHRoZSB1c2VyIGxhYmVscyBieSBpdHMgdW5pcXVlIElELiBcbiAgICAgKiBcbiAgICAgKiBMYWJlbHMgY2FuIGJlIHVzZWQgdG8gZ3JhbnQgYWNjZXNzIHRvIHJlc291cmNlcy4gV2hpbGUgdGVhbXMgYXJlIGEgd2F5IGZvclxuICAgICAqIHVzZXIncyB0byBzaGFyZSBhY2Nlc3MgdG8gYSByZXNvdXJjZSwgbGFiZWxzIGNhbiBiZSBkZWZpbmVkIGJ5IHRoZVxuICAgICAqIGRldmVsb3BlciB0byBncmFudCBhY2Nlc3Mgd2l0aG91dCBhbiBpbnZpdGF0aW9uLiBTZWUgdGhlIFtQZXJtaXNzaW9uc1xuICAgICAqIGRvY3NdKGh0dHBzOi8vYXBwd3JpdGUuaW8vZG9jcy9wZXJtaXNzaW9ucykgZm9yIG1vcmUgaW5mby5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSB1c2VySWRcbiAgICAgKiBAcGFyYW0ge3N0cmluZ1tdfSBsYWJlbHNcbiAgICAgKiBAdGhyb3dzIHtBcHB3cml0ZUV4Y2VwdGlvbn1cbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZX1cbiAgICAgKi9cbiAgICBhc3luYyB1cGRhdGVMYWJlbHModXNlcklkLCBsYWJlbHMpIHtcbiAgICAgICAgY29uc3QgYXBpUGF0aCA9ICcvdXNlcnMve3VzZXJJZH0vbGFiZWxzJy5yZXBsYWNlKCd7dXNlcklkfScsIHVzZXJJZCk7XG4gICAgICAgIGxldCBwYXlsb2FkID0ge307XG4gICAgICAgIGlmICh0eXBlb2YgdXNlcklkID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEFwcHdyaXRlRXhjZXB0aW9uKCdNaXNzaW5nIHJlcXVpcmVkIHBhcmFtZXRlcjogXCJ1c2VySWRcIicpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHR5cGVvZiBsYWJlbHMgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgQXBwd3JpdGVFeGNlcHRpb24oJ01pc3NpbmcgcmVxdWlyZWQgcGFyYW1ldGVyOiBcImxhYmVsc1wiJyk7XG4gICAgICAgIH1cblxuXG4gICAgICAgIGlmICh0eXBlb2YgbGFiZWxzICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgcGF5bG9hZFsnbGFiZWxzJ10gPSBsYWJlbHM7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy5jbGllbnQuY2FsbCgncHV0JywgYXBpUGF0aCwge1xuICAgICAgICAgICAgJ2NvbnRlbnQtdHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJyxcbiAgICAgICAgfSwgcGF5bG9hZCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogTGlzdCB1c2VyIGxvZ3NcbiAgICAgKlxuICAgICAqIEdldCB0aGUgdXNlciBhY3Rpdml0eSBsb2dzIGxpc3QgYnkgaXRzIHVuaXF1ZSBJRC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSB1c2VySWRcbiAgICAgKiBAcGFyYW0ge3N0cmluZ1tdfSBxdWVyaWVzXG4gICAgICogQHRocm93cyB7QXBwd3JpdGVFeGNlcHRpb259XG4gICAgICogQHJldHVybnMge1Byb21pc2V9XG4gICAgICovXG4gICAgYXN5bmMgbGlzdExvZ3ModXNlcklkLCBxdWVyaWVzKSB7XG4gICAgICAgIGNvbnN0IGFwaVBhdGggPSAnL3VzZXJzL3t1c2VySWR9L2xvZ3MnLnJlcGxhY2UoJ3t1c2VySWR9JywgdXNlcklkKTtcbiAgICAgICAgbGV0IHBheWxvYWQgPSB7fTtcbiAgICAgICAgaWYgKHR5cGVvZiB1c2VySWQgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgQXBwd3JpdGVFeGNlcHRpb24oJ01pc3NpbmcgcmVxdWlyZWQgcGFyYW1ldGVyOiBcInVzZXJJZFwiJyk7XG4gICAgICAgIH1cblxuXG4gICAgICAgIGlmICh0eXBlb2YgcXVlcmllcyAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHBheWxvYWRbJ3F1ZXJpZXMnXSA9IHF1ZXJpZXM7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy5jbGllbnQuY2FsbCgnZ2V0JywgYXBpUGF0aCwge1xuICAgICAgICAgICAgJ2NvbnRlbnQtdHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJyxcbiAgICAgICAgfSwgcGF5bG9hZCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogTGlzdCB1c2VyIG1lbWJlcnNoaXBzXG4gICAgICpcbiAgICAgKiBHZXQgdGhlIHVzZXIgbWVtYmVyc2hpcCBsaXN0IGJ5IGl0cyB1bmlxdWUgSUQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gdXNlcklkXG4gICAgICogQHRocm93cyB7QXBwd3JpdGVFeGNlcHRpb259XG4gICAgICogQHJldHVybnMge1Byb21pc2V9XG4gICAgICovXG4gICAgYXN5bmMgbGlzdE1lbWJlcnNoaXBzKHVzZXJJZCkge1xuICAgICAgICBjb25zdCBhcGlQYXRoID0gJy91c2Vycy97dXNlcklkfS9tZW1iZXJzaGlwcycucmVwbGFjZSgne3VzZXJJZH0nLCB1c2VySWQpO1xuICAgICAgICBsZXQgcGF5bG9hZCA9IHt9O1xuICAgICAgICBpZiAodHlwZW9mIHVzZXJJZCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBBcHB3cml0ZUV4Y2VwdGlvbignTWlzc2luZyByZXF1aXJlZCBwYXJhbWV0ZXI6IFwidXNlcklkXCInKTtcbiAgICAgICAgfVxuXG5cbiAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMuY2xpZW50LmNhbGwoJ2dldCcsIGFwaVBhdGgsIHtcbiAgICAgICAgICAgICdjb250ZW50LXR5cGUnOiAnYXBwbGljYXRpb24vanNvbicsXG4gICAgICAgIH0sIHBheWxvYWQpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFVwZGF0ZSBNRkFcbiAgICAgKlxuICAgICAqIEVuYWJsZSBvciBkaXNhYmxlIE1GQSBvbiBhIHVzZXIgYWNjb3VudC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSB1c2VySWRcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IG1mYVxuICAgICAqIEB0aHJvd3Mge0FwcHdyaXRlRXhjZXB0aW9ufVxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlfVxuICAgICAqL1xuICAgIGFzeW5jIHVwZGF0ZU1mYSh1c2VySWQsIG1mYSkge1xuICAgICAgICBjb25zdCBhcGlQYXRoID0gJy91c2Vycy97dXNlcklkfS9tZmEnLnJlcGxhY2UoJ3t1c2VySWR9JywgdXNlcklkKTtcbiAgICAgICAgbGV0IHBheWxvYWQgPSB7fTtcbiAgICAgICAgaWYgKHR5cGVvZiB1c2VySWQgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgQXBwd3JpdGVFeGNlcHRpb24oJ01pc3NpbmcgcmVxdWlyZWQgcGFyYW1ldGVyOiBcInVzZXJJZFwiJyk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodHlwZW9mIG1mYSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBBcHB3cml0ZUV4Y2VwdGlvbignTWlzc2luZyByZXF1aXJlZCBwYXJhbWV0ZXI6IFwibWZhXCInKTtcbiAgICAgICAgfVxuXG5cbiAgICAgICAgaWYgKHR5cGVvZiBtZmEgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICBwYXlsb2FkWydtZmEnXSA9IG1mYTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBhd2FpdCB0aGlzLmNsaWVudC5jYWxsKCdwYXRjaCcsIGFwaVBhdGgsIHtcbiAgICAgICAgICAgICdjb250ZW50LXR5cGUnOiAnYXBwbGljYXRpb24vanNvbicsXG4gICAgICAgIH0sIHBheWxvYWQpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIERlbGV0ZSBBdXRoZW50aWNhdG9yXG4gICAgICpcbiAgICAgKiBEZWxldGUgYW4gYXV0aGVudGljYXRvciBhcHAuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gdXNlcklkXG4gICAgICogQHBhcmFtIHtBdXRoZW50aWNhdG9yVHlwZX0gdHlwZVxuICAgICAqIEB0aHJvd3Mge0FwcHdyaXRlRXhjZXB0aW9ufVxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlfVxuICAgICAqL1xuICAgIGFzeW5jIGRlbGV0ZU1mYUF1dGhlbnRpY2F0b3IodXNlcklkLCB0eXBlKSB7XG4gICAgICAgIGNvbnN0IGFwaVBhdGggPSAnL3VzZXJzL3t1c2VySWR9L21mYS9hdXRoZW50aWNhdG9ycy97dHlwZX0nLnJlcGxhY2UoJ3t1c2VySWR9JywgdXNlcklkKS5yZXBsYWNlKCd7dHlwZX0nLCB0eXBlKTtcbiAgICAgICAgbGV0IHBheWxvYWQgPSB7fTtcbiAgICAgICAgaWYgKHR5cGVvZiB1c2VySWQgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgQXBwd3JpdGVFeGNlcHRpb24oJ01pc3NpbmcgcmVxdWlyZWQgcGFyYW1ldGVyOiBcInVzZXJJZFwiJyk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodHlwZW9mIHR5cGUgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgQXBwd3JpdGVFeGNlcHRpb24oJ01pc3NpbmcgcmVxdWlyZWQgcGFyYW1ldGVyOiBcInR5cGVcIicpO1xuICAgICAgICB9XG5cblxuICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy5jbGllbnQuY2FsbCgnZGVsZXRlJywgYXBpUGF0aCwge1xuICAgICAgICAgICAgJ2NvbnRlbnQtdHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJyxcbiAgICAgICAgfSwgcGF5bG9hZCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogTGlzdCBGYWN0b3JzXG4gICAgICpcbiAgICAgKiBMaXN0IHRoZSBmYWN0b3JzIGF2YWlsYWJsZSBvbiB0aGUgYWNjb3VudCB0byBiZSB1c2VkIGFzIGEgTUZBIGNoYWxsYW5nZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSB1c2VySWRcbiAgICAgKiBAdGhyb3dzIHtBcHB3cml0ZUV4Y2VwdGlvbn1cbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZX1cbiAgICAgKi9cbiAgICBhc3luYyBsaXN0TWZhRmFjdG9ycyh1c2VySWQpIHtcbiAgICAgICAgY29uc3QgYXBpUGF0aCA9ICcvdXNlcnMve3VzZXJJZH0vbWZhL2ZhY3RvcnMnLnJlcGxhY2UoJ3t1c2VySWR9JywgdXNlcklkKTtcbiAgICAgICAgbGV0IHBheWxvYWQgPSB7fTtcbiAgICAgICAgaWYgKHR5cGVvZiB1c2VySWQgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgQXBwd3JpdGVFeGNlcHRpb24oJ01pc3NpbmcgcmVxdWlyZWQgcGFyYW1ldGVyOiBcInVzZXJJZFwiJyk7XG4gICAgICAgIH1cblxuXG4gICAgICAgIHJldHVybiBhd2FpdCB0aGlzLmNsaWVudC5jYWxsKCdnZXQnLCBhcGlQYXRoLCB7XG4gICAgICAgICAgICAnY29udGVudC10eXBlJzogJ2FwcGxpY2F0aW9uL2pzb24nLFxuICAgICAgICB9LCBwYXlsb2FkKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZXQgTUZBIFJlY292ZXJ5IENvZGVzXG4gICAgICpcbiAgICAgKiBHZXQgcmVjb3ZlcnkgY29kZXMgdGhhdCBjYW4gYmUgdXNlZCBhcyBiYWNrdXAgZm9yIE1GQSBmbG93IGJ5IFVzZXIgSUQuXG4gICAgICogQmVmb3JlIGdldHRpbmcgY29kZXMsIHRoZXkgbXVzdCBiZSBnZW5lcmF0ZWQgdXNpbmdcbiAgICAgKiBbY3JlYXRlTWZhUmVjb3ZlcnlDb2Rlc10oL2RvY3MvcmVmZXJlbmNlcy9jbG91ZC9jbGllbnQtd2ViL2FjY291bnQjY3JlYXRlTWZhUmVjb3ZlcnlDb2RlcylcbiAgICAgKiBtZXRob2QuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gdXNlcklkXG4gICAgICogQHRocm93cyB7QXBwd3JpdGVFeGNlcHRpb259XG4gICAgICogQHJldHVybnMge1Byb21pc2V9XG4gICAgICovXG4gICAgYXN5bmMgZ2V0TWZhUmVjb3ZlcnlDb2Rlcyh1c2VySWQpIHtcbiAgICAgICAgY29uc3QgYXBpUGF0aCA9ICcvdXNlcnMve3VzZXJJZH0vbWZhL3JlY292ZXJ5LWNvZGVzJy5yZXBsYWNlKCd7dXNlcklkfScsIHVzZXJJZCk7XG4gICAgICAgIGxldCBwYXlsb2FkID0ge307XG4gICAgICAgIGlmICh0eXBlb2YgdXNlcklkID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEFwcHdyaXRlRXhjZXB0aW9uKCdNaXNzaW5nIHJlcXVpcmVkIHBhcmFtZXRlcjogXCJ1c2VySWRcIicpO1xuICAgICAgICB9XG5cblxuICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy5jbGllbnQuY2FsbCgnZ2V0JywgYXBpUGF0aCwge1xuICAgICAgICAgICAgJ2NvbnRlbnQtdHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJyxcbiAgICAgICAgfSwgcGF5bG9hZCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmVnZW5lcmF0ZSBNRkEgUmVjb3ZlcnkgQ29kZXNcbiAgICAgKlxuICAgICAqIFJlZ2VuZXJhdGUgcmVjb3ZlcnkgY29kZXMgdGhhdCBjYW4gYmUgdXNlZCBhcyBiYWNrdXAgZm9yIE1GQSBmbG93IGJ5IFVzZXJcbiAgICAgKiBJRC4gQmVmb3JlIHJlZ2VuZXJhdGluZyBjb2RlcywgdGhleSBtdXN0IGJlIGZpcnN0IGdlbmVyYXRlZCB1c2luZ1xuICAgICAqIFtjcmVhdGVNZmFSZWNvdmVyeUNvZGVzXSgvZG9jcy9yZWZlcmVuY2VzL2Nsb3VkL2NsaWVudC13ZWIvYWNjb3VudCNjcmVhdGVNZmFSZWNvdmVyeUNvZGVzKVxuICAgICAqIG1ldGhvZC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSB1c2VySWRcbiAgICAgKiBAdGhyb3dzIHtBcHB3cml0ZUV4Y2VwdGlvbn1cbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZX1cbiAgICAgKi9cbiAgICBhc3luYyB1cGRhdGVNZmFSZWNvdmVyeUNvZGVzKHVzZXJJZCkge1xuICAgICAgICBjb25zdCBhcGlQYXRoID0gJy91c2Vycy97dXNlcklkfS9tZmEvcmVjb3ZlcnktY29kZXMnLnJlcGxhY2UoJ3t1c2VySWR9JywgdXNlcklkKTtcbiAgICAgICAgbGV0IHBheWxvYWQgPSB7fTtcbiAgICAgICAgaWYgKHR5cGVvZiB1c2VySWQgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgQXBwd3JpdGVFeGNlcHRpb24oJ01pc3NpbmcgcmVxdWlyZWQgcGFyYW1ldGVyOiBcInVzZXJJZFwiJyk7XG4gICAgICAgIH1cblxuXG4gICAgICAgIHJldHVybiBhd2FpdCB0aGlzLmNsaWVudC5jYWxsKCdwdXQnLCBhcGlQYXRoLCB7XG4gICAgICAgICAgICAnY29udGVudC10eXBlJzogJ2FwcGxpY2F0aW9uL2pzb24nLFxuICAgICAgICB9LCBwYXlsb2FkKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGUgTUZBIFJlY292ZXJ5IENvZGVzXG4gICAgICpcbiAgICAgKiBHZW5lcmF0ZSByZWNvdmVyeSBjb2RlcyB1c2VkIGFzIGJhY2t1cCBmb3IgTUZBIGZsb3cgZm9yIFVzZXIgSUQuIFJlY292ZXJ5XG4gICAgICogY29kZXMgY2FuIGJlIHVzZWQgYXMgYSBNRkEgdmVyaWZpY2F0aW9uIHR5cGUgaW5cbiAgICAgKiBbY3JlYXRlTWZhQ2hhbGxlbmdlXSgvZG9jcy9yZWZlcmVuY2VzL2Nsb3VkL2NsaWVudC13ZWIvYWNjb3VudCNjcmVhdGVNZmFDaGFsbGVuZ2UpXG4gICAgICogbWV0aG9kIGJ5IGNsaWVudCBTREsuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gdXNlcklkXG4gICAgICogQHRocm93cyB7QXBwd3JpdGVFeGNlcHRpb259XG4gICAgICogQHJldHVybnMge1Byb21pc2V9XG4gICAgICovXG4gICAgYXN5bmMgY3JlYXRlTWZhUmVjb3ZlcnlDb2Rlcyh1c2VySWQpIHtcbiAgICAgICAgY29uc3QgYXBpUGF0aCA9ICcvdXNlcnMve3VzZXJJZH0vbWZhL3JlY292ZXJ5LWNvZGVzJy5yZXBsYWNlKCd7dXNlcklkfScsIHVzZXJJZCk7XG4gICAgICAgIGxldCBwYXlsb2FkID0ge307XG4gICAgICAgIGlmICh0eXBlb2YgdXNlcklkID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEFwcHdyaXRlRXhjZXB0aW9uKCdNaXNzaW5nIHJlcXVpcmVkIHBhcmFtZXRlcjogXCJ1c2VySWRcIicpO1xuICAgICAgICB9XG5cblxuICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy5jbGllbnQuY2FsbCgncGF0Y2gnLCBhcGlQYXRoLCB7XG4gICAgICAgICAgICAnY29udGVudC10eXBlJzogJ2FwcGxpY2F0aW9uL2pzb24nLFxuICAgICAgICB9LCBwYXlsb2FkKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBVcGRhdGUgbmFtZVxuICAgICAqXG4gICAgICogVXBkYXRlIHRoZSB1c2VyIG5hbWUgYnkgaXRzIHVuaXF1ZSBJRC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSB1c2VySWRcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gbmFtZVxuICAgICAqIEB0aHJvd3Mge0FwcHdyaXRlRXhjZXB0aW9ufVxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlfVxuICAgICAqL1xuICAgIGFzeW5jIHVwZGF0ZU5hbWUodXNlcklkLCBuYW1lKSB7XG4gICAgICAgIGNvbnN0IGFwaVBhdGggPSAnL3VzZXJzL3t1c2VySWR9L25hbWUnLnJlcGxhY2UoJ3t1c2VySWR9JywgdXNlcklkKTtcbiAgICAgICAgbGV0IHBheWxvYWQgPSB7fTtcbiAgICAgICAgaWYgKHR5cGVvZiB1c2VySWQgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgQXBwd3JpdGVFeGNlcHRpb24oJ01pc3NpbmcgcmVxdWlyZWQgcGFyYW1ldGVyOiBcInVzZXJJZFwiJyk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodHlwZW9mIG5hbWUgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgQXBwd3JpdGVFeGNlcHRpb24oJ01pc3NpbmcgcmVxdWlyZWQgcGFyYW1ldGVyOiBcIm5hbWVcIicpO1xuICAgICAgICB9XG5cblxuICAgICAgICBpZiAodHlwZW9mIG5hbWUgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICBwYXlsb2FkWyduYW1lJ10gPSBuYW1lO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMuY2xpZW50LmNhbGwoJ3BhdGNoJywgYXBpUGF0aCwge1xuICAgICAgICAgICAgJ2NvbnRlbnQtdHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJyxcbiAgICAgICAgfSwgcGF5bG9hZCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVXBkYXRlIHBhc3N3b3JkXG4gICAgICpcbiAgICAgKiBVcGRhdGUgdGhlIHVzZXIgcGFzc3dvcmQgYnkgaXRzIHVuaXF1ZSBJRC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSB1c2VySWRcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gcGFzc3dvcmRcbiAgICAgKiBAdGhyb3dzIHtBcHB3cml0ZUV4Y2VwdGlvbn1cbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZX1cbiAgICAgKi9cbiAgICBhc3luYyB1cGRhdGVQYXNzd29yZCh1c2VySWQsIHBhc3N3b3JkKSB7XG4gICAgICAgIGNvbnN0IGFwaVBhdGggPSAnL3VzZXJzL3t1c2VySWR9L3Bhc3N3b3JkJy5yZXBsYWNlKCd7dXNlcklkfScsIHVzZXJJZCk7XG4gICAgICAgIGxldCBwYXlsb2FkID0ge307XG4gICAgICAgIGlmICh0eXBlb2YgdXNlcklkID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEFwcHdyaXRlRXhjZXB0aW9uKCdNaXNzaW5nIHJlcXVpcmVkIHBhcmFtZXRlcjogXCJ1c2VySWRcIicpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHR5cGVvZiBwYXNzd29yZCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBBcHB3cml0ZUV4Y2VwdGlvbignTWlzc2luZyByZXF1aXJlZCBwYXJhbWV0ZXI6IFwicGFzc3dvcmRcIicpO1xuICAgICAgICB9XG5cblxuICAgICAgICBpZiAodHlwZW9mIHBhc3N3b3JkICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgcGF5bG9hZFsncGFzc3dvcmQnXSA9IHBhc3N3b3JkO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMuY2xpZW50LmNhbGwoJ3BhdGNoJywgYXBpUGF0aCwge1xuICAgICAgICAgICAgJ2NvbnRlbnQtdHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJyxcbiAgICAgICAgfSwgcGF5bG9hZCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVXBkYXRlIHBob25lXG4gICAgICpcbiAgICAgKiBVcGRhdGUgdGhlIHVzZXIgcGhvbmUgYnkgaXRzIHVuaXF1ZSBJRC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSB1c2VySWRcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gbnVtYmVyXG4gICAgICogQHRocm93cyB7QXBwd3JpdGVFeGNlcHRpb259XG4gICAgICogQHJldHVybnMge1Byb21pc2V9XG4gICAgICovXG4gICAgYXN5bmMgdXBkYXRlUGhvbmUodXNlcklkLCBudW1iZXIpIHtcbiAgICAgICAgY29uc3QgYXBpUGF0aCA9ICcvdXNlcnMve3VzZXJJZH0vcGhvbmUnLnJlcGxhY2UoJ3t1c2VySWR9JywgdXNlcklkKTtcbiAgICAgICAgbGV0IHBheWxvYWQgPSB7fTtcbiAgICAgICAgaWYgKHR5cGVvZiB1c2VySWQgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgQXBwd3JpdGVFeGNlcHRpb24oJ01pc3NpbmcgcmVxdWlyZWQgcGFyYW1ldGVyOiBcInVzZXJJZFwiJyk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodHlwZW9mIG51bWJlciA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBBcHB3cml0ZUV4Y2VwdGlvbignTWlzc2luZyByZXF1aXJlZCBwYXJhbWV0ZXI6IFwibnVtYmVyXCInKTtcbiAgICAgICAgfVxuXG5cbiAgICAgICAgaWYgKHR5cGVvZiBudW1iZXIgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICBwYXlsb2FkWydudW1iZXInXSA9IG51bWJlcjtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBhd2FpdCB0aGlzLmNsaWVudC5jYWxsKCdwYXRjaCcsIGFwaVBhdGgsIHtcbiAgICAgICAgICAgICdjb250ZW50LXR5cGUnOiAnYXBwbGljYXRpb24vanNvbicsXG4gICAgICAgIH0sIHBheWxvYWQpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdldCB1c2VyIHByZWZlcmVuY2VzXG4gICAgICpcbiAgICAgKiBHZXQgdGhlIHVzZXIgcHJlZmVyZW5jZXMgYnkgaXRzIHVuaXF1ZSBJRC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSB1c2VySWRcbiAgICAgKiBAdGhyb3dzIHtBcHB3cml0ZUV4Y2VwdGlvbn1cbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZX1cbiAgICAgKi9cbiAgICBhc3luYyBnZXRQcmVmcyh1c2VySWQpIHtcbiAgICAgICAgY29uc3QgYXBpUGF0aCA9ICcvdXNlcnMve3VzZXJJZH0vcHJlZnMnLnJlcGxhY2UoJ3t1c2VySWR9JywgdXNlcklkKTtcbiAgICAgICAgbGV0IHBheWxvYWQgPSB7fTtcbiAgICAgICAgaWYgKHR5cGVvZiB1c2VySWQgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgQXBwd3JpdGVFeGNlcHRpb24oJ01pc3NpbmcgcmVxdWlyZWQgcGFyYW1ldGVyOiBcInVzZXJJZFwiJyk7XG4gICAgICAgIH1cblxuXG4gICAgICAgIHJldHVybiBhd2FpdCB0aGlzLmNsaWVudC5jYWxsKCdnZXQnLCBhcGlQYXRoLCB7XG4gICAgICAgICAgICAnY29udGVudC10eXBlJzogJ2FwcGxpY2F0aW9uL2pzb24nLFxuICAgICAgICB9LCBwYXlsb2FkKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBVcGRhdGUgdXNlciBwcmVmZXJlbmNlc1xuICAgICAqXG4gICAgICogVXBkYXRlIHRoZSB1c2VyIHByZWZlcmVuY2VzIGJ5IGl0cyB1bmlxdWUgSUQuIFRoZSBvYmplY3QgeW91IHBhc3MgaXMgc3RvcmVkXG4gICAgICogYXMgaXMsIGFuZCByZXBsYWNlcyBhbnkgcHJldmlvdXMgdmFsdWUuIFRoZSBtYXhpbXVtIGFsbG93ZWQgcHJlZnMgc2l6ZSBpc1xuICAgICAqIDY0a0IgYW5kIHRocm93cyBlcnJvciBpZiBleGNlZWRlZC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSB1c2VySWRcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gcHJlZnNcbiAgICAgKiBAdGhyb3dzIHtBcHB3cml0ZUV4Y2VwdGlvbn1cbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZX1cbiAgICAgKi9cbiAgICBhc3luYyB1cGRhdGVQcmVmcyh1c2VySWQsIHByZWZzKSB7XG4gICAgICAgIGNvbnN0IGFwaVBhdGggPSAnL3VzZXJzL3t1c2VySWR9L3ByZWZzJy5yZXBsYWNlKCd7dXNlcklkfScsIHVzZXJJZCk7XG4gICAgICAgIGxldCBwYXlsb2FkID0ge307XG4gICAgICAgIGlmICh0eXBlb2YgdXNlcklkID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEFwcHdyaXRlRXhjZXB0aW9uKCdNaXNzaW5nIHJlcXVpcmVkIHBhcmFtZXRlcjogXCJ1c2VySWRcIicpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHR5cGVvZiBwcmVmcyA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBBcHB3cml0ZUV4Y2VwdGlvbignTWlzc2luZyByZXF1aXJlZCBwYXJhbWV0ZXI6IFwicHJlZnNcIicpO1xuICAgICAgICB9XG5cblxuICAgICAgICBpZiAodHlwZW9mIHByZWZzICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgcGF5bG9hZFsncHJlZnMnXSA9IHByZWZzO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMuY2xpZW50LmNhbGwoJ3BhdGNoJywgYXBpUGF0aCwge1xuICAgICAgICAgICAgJ2NvbnRlbnQtdHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJyxcbiAgICAgICAgfSwgcGF5bG9hZCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogTGlzdCB1c2VyIHNlc3Npb25zXG4gICAgICpcbiAgICAgKiBHZXQgdGhlIHVzZXIgc2Vzc2lvbnMgbGlzdCBieSBpdHMgdW5pcXVlIElELlxuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHVzZXJJZFxuICAgICAqIEB0aHJvd3Mge0FwcHdyaXRlRXhjZXB0aW9ufVxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlfVxuICAgICAqL1xuICAgIGFzeW5jIGxpc3RTZXNzaW9ucyh1c2VySWQpIHtcbiAgICAgICAgY29uc3QgYXBpUGF0aCA9ICcvdXNlcnMve3VzZXJJZH0vc2Vzc2lvbnMnLnJlcGxhY2UoJ3t1c2VySWR9JywgdXNlcklkKTtcbiAgICAgICAgbGV0IHBheWxvYWQgPSB7fTtcbiAgICAgICAgaWYgKHR5cGVvZiB1c2VySWQgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgQXBwd3JpdGVFeGNlcHRpb24oJ01pc3NpbmcgcmVxdWlyZWQgcGFyYW1ldGVyOiBcInVzZXJJZFwiJyk7XG4gICAgICAgIH1cblxuXG4gICAgICAgIHJldHVybiBhd2FpdCB0aGlzLmNsaWVudC5jYWxsKCdnZXQnLCBhcGlQYXRoLCB7XG4gICAgICAgICAgICAnY29udGVudC10eXBlJzogJ2FwcGxpY2F0aW9uL2pzb24nLFxuICAgICAgICB9LCBwYXlsb2FkKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGUgc2Vzc2lvblxuICAgICAqXG4gICAgICogQ3JlYXRlcyBhIHNlc3Npb24gZm9yIGEgdXNlci4gUmV0dXJucyBhbiBpbW1lZGlhdGVseSB1c2FibGUgc2Vzc2lvbiBvYmplY3QuXG4gICAgICogXG4gICAgICogSWYgeW91IHdhbnQgdG8gZ2VuZXJhdGUgYSB0b2tlbiBmb3IgYSBjdXN0b20gYXV0aGVudGljYXRpb24gZmxvdywgdXNlIHRoZVxuICAgICAqIFtQT1NUXG4gICAgICogL3VzZXJzL3t1c2VySWR9L3Rva2Vuc10oaHR0cHM6Ly9hcHB3cml0ZS5pby9kb2NzL3NlcnZlci91c2VycyNjcmVhdGVUb2tlbilcbiAgICAgKiBlbmRwb2ludC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSB1c2VySWRcbiAgICAgKiBAdGhyb3dzIHtBcHB3cml0ZUV4Y2VwdGlvbn1cbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZX1cbiAgICAgKi9cbiAgICBhc3luYyBjcmVhdGVTZXNzaW9uKHVzZXJJZCkge1xuICAgICAgICBjb25zdCBhcGlQYXRoID0gJy91c2Vycy97dXNlcklkfS9zZXNzaW9ucycucmVwbGFjZSgne3VzZXJJZH0nLCB1c2VySWQpO1xuICAgICAgICBsZXQgcGF5bG9hZCA9IHt9O1xuICAgICAgICBpZiAodHlwZW9mIHVzZXJJZCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBBcHB3cml0ZUV4Y2VwdGlvbignTWlzc2luZyByZXF1aXJlZCBwYXJhbWV0ZXI6IFwidXNlcklkXCInKTtcbiAgICAgICAgfVxuXG5cbiAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMuY2xpZW50LmNhbGwoJ3Bvc3QnLCBhcGlQYXRoLCB7XG4gICAgICAgICAgICAnY29udGVudC10eXBlJzogJ2FwcGxpY2F0aW9uL2pzb24nLFxuICAgICAgICB9LCBwYXlsb2FkKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBEZWxldGUgdXNlciBzZXNzaW9uc1xuICAgICAqXG4gICAgICogRGVsZXRlIGFsbCB1c2VyJ3Mgc2Vzc2lvbnMgYnkgdXNpbmcgdGhlIHVzZXIncyB1bmlxdWUgSUQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gdXNlcklkXG4gICAgICogQHRocm93cyB7QXBwd3JpdGVFeGNlcHRpb259XG4gICAgICogQHJldHVybnMge1Byb21pc2V9XG4gICAgICovXG4gICAgYXN5bmMgZGVsZXRlU2Vzc2lvbnModXNlcklkKSB7XG4gICAgICAgIGNvbnN0IGFwaVBhdGggPSAnL3VzZXJzL3t1c2VySWR9L3Nlc3Npb25zJy5yZXBsYWNlKCd7dXNlcklkfScsIHVzZXJJZCk7XG4gICAgICAgIGxldCBwYXlsb2FkID0ge307XG4gICAgICAgIGlmICh0eXBlb2YgdXNlcklkID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEFwcHdyaXRlRXhjZXB0aW9uKCdNaXNzaW5nIHJlcXVpcmVkIHBhcmFtZXRlcjogXCJ1c2VySWRcIicpO1xuICAgICAgICB9XG5cblxuICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy5jbGllbnQuY2FsbCgnZGVsZXRlJywgYXBpUGF0aCwge1xuICAgICAgICAgICAgJ2NvbnRlbnQtdHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJyxcbiAgICAgICAgfSwgcGF5bG9hZCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRGVsZXRlIHVzZXIgc2Vzc2lvblxuICAgICAqXG4gICAgICogRGVsZXRlIGEgdXNlciBzZXNzaW9ucyBieSBpdHMgdW5pcXVlIElELlxuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHVzZXJJZFxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBzZXNzaW9uSWRcbiAgICAgKiBAdGhyb3dzIHtBcHB3cml0ZUV4Y2VwdGlvbn1cbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZX1cbiAgICAgKi9cbiAgICBhc3luYyBkZWxldGVTZXNzaW9uKHVzZXJJZCwgc2Vzc2lvbklkKSB7XG4gICAgICAgIGNvbnN0IGFwaVBhdGggPSAnL3VzZXJzL3t1c2VySWR9L3Nlc3Npb25zL3tzZXNzaW9uSWR9Jy5yZXBsYWNlKCd7dXNlcklkfScsIHVzZXJJZCkucmVwbGFjZSgne3Nlc3Npb25JZH0nLCBzZXNzaW9uSWQpO1xuICAgICAgICBsZXQgcGF5bG9hZCA9IHt9O1xuICAgICAgICBpZiAodHlwZW9mIHVzZXJJZCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBBcHB3cml0ZUV4Y2VwdGlvbignTWlzc2luZyByZXF1aXJlZCBwYXJhbWV0ZXI6IFwidXNlcklkXCInKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0eXBlb2Ygc2Vzc2lvbklkID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEFwcHdyaXRlRXhjZXB0aW9uKCdNaXNzaW5nIHJlcXVpcmVkIHBhcmFtZXRlcjogXCJzZXNzaW9uSWRcIicpO1xuICAgICAgICB9XG5cblxuICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy5jbGllbnQuY2FsbCgnZGVsZXRlJywgYXBpUGF0aCwge1xuICAgICAgICAgICAgJ2NvbnRlbnQtdHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJyxcbiAgICAgICAgfSwgcGF5bG9hZCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVXBkYXRlIHVzZXIgc3RhdHVzXG4gICAgICpcbiAgICAgKiBVcGRhdGUgdGhlIHVzZXIgc3RhdHVzIGJ5IGl0cyB1bmlxdWUgSUQuIFVzZSB0aGlzIGVuZHBvaW50IGFzIGFuXG4gICAgICogYWx0ZXJuYXRpdmUgdG8gZGVsZXRpbmcgYSB1c2VyIGlmIHlvdSB3YW50IHRvIGtlZXAgdXNlcidzIElEIHJlc2VydmVkLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHVzZXJJZFxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gc3RhdHVzXG4gICAgICogQHRocm93cyB7QXBwd3JpdGVFeGNlcHRpb259XG4gICAgICogQHJldHVybnMge1Byb21pc2V9XG4gICAgICovXG4gICAgYXN5bmMgdXBkYXRlU3RhdHVzKHVzZXJJZCwgc3RhdHVzKSB7XG4gICAgICAgIGNvbnN0IGFwaVBhdGggPSAnL3VzZXJzL3t1c2VySWR9L3N0YXR1cycucmVwbGFjZSgne3VzZXJJZH0nLCB1c2VySWQpO1xuICAgICAgICBsZXQgcGF5bG9hZCA9IHt9O1xuICAgICAgICBpZiAodHlwZW9mIHVzZXJJZCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBBcHB3cml0ZUV4Y2VwdGlvbignTWlzc2luZyByZXF1aXJlZCBwYXJhbWV0ZXI6IFwidXNlcklkXCInKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0eXBlb2Ygc3RhdHVzID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEFwcHdyaXRlRXhjZXB0aW9uKCdNaXNzaW5nIHJlcXVpcmVkIHBhcmFtZXRlcjogXCJzdGF0dXNcIicpO1xuICAgICAgICB9XG5cblxuICAgICAgICBpZiAodHlwZW9mIHN0YXR1cyAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHBheWxvYWRbJ3N0YXR1cyddID0gc3RhdHVzO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMuY2xpZW50LmNhbGwoJ3BhdGNoJywgYXBpUGF0aCwge1xuICAgICAgICAgICAgJ2NvbnRlbnQtdHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJyxcbiAgICAgICAgfSwgcGF5bG9hZCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogTGlzdCBVc2VyIFRhcmdldHNcbiAgICAgKlxuICAgICAqIExpc3QgdGhlIG1lc3NhZ2luZyB0YXJnZXRzIHRoYXQgYXJlIGFzc29jaWF0ZWQgd2l0aCBhIHVzZXIuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gdXNlcklkXG4gICAgICogQHBhcmFtIHtzdHJpbmdbXX0gcXVlcmllc1xuICAgICAqIEB0aHJvd3Mge0FwcHdyaXRlRXhjZXB0aW9ufVxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlfVxuICAgICAqL1xuICAgIGFzeW5jIGxpc3RUYXJnZXRzKHVzZXJJZCwgcXVlcmllcykge1xuICAgICAgICBjb25zdCBhcGlQYXRoID0gJy91c2Vycy97dXNlcklkfS90YXJnZXRzJy5yZXBsYWNlKCd7dXNlcklkfScsIHVzZXJJZCk7XG4gICAgICAgIGxldCBwYXlsb2FkID0ge307XG4gICAgICAgIGlmICh0eXBlb2YgdXNlcklkID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEFwcHdyaXRlRXhjZXB0aW9uKCdNaXNzaW5nIHJlcXVpcmVkIHBhcmFtZXRlcjogXCJ1c2VySWRcIicpO1xuICAgICAgICB9XG5cblxuICAgICAgICBpZiAodHlwZW9mIHF1ZXJpZXMgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICBwYXlsb2FkWydxdWVyaWVzJ10gPSBxdWVyaWVzO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMuY2xpZW50LmNhbGwoJ2dldCcsIGFwaVBhdGgsIHtcbiAgICAgICAgICAgICdjb250ZW50LXR5cGUnOiAnYXBwbGljYXRpb24vanNvbicsXG4gICAgICAgIH0sIHBheWxvYWQpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZSBVc2VyIFRhcmdldFxuICAgICAqXG4gICAgICogQ3JlYXRlIGEgbWVzc2FnaW5nIHRhcmdldC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSB1c2VySWRcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gdGFyZ2V0SWRcbiAgICAgKiBAcGFyYW0ge01lc3NhZ2luZ1Byb3ZpZGVyVHlwZX0gcHJvdmlkZXJUeXBlXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGlkZW50aWZpZXJcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gcHJvdmlkZXJJZFxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lXG4gICAgICogQHRocm93cyB7QXBwd3JpdGVFeGNlcHRpb259XG4gICAgICogQHJldHVybnMge1Byb21pc2V9XG4gICAgICovXG4gICAgYXN5bmMgY3JlYXRlVGFyZ2V0KHVzZXJJZCwgdGFyZ2V0SWQsIHByb3ZpZGVyVHlwZSwgaWRlbnRpZmllciwgcHJvdmlkZXJJZCwgbmFtZSkge1xuICAgICAgICBjb25zdCBhcGlQYXRoID0gJy91c2Vycy97dXNlcklkfS90YXJnZXRzJy5yZXBsYWNlKCd7dXNlcklkfScsIHVzZXJJZCk7XG4gICAgICAgIGxldCBwYXlsb2FkID0ge307XG4gICAgICAgIGlmICh0eXBlb2YgdXNlcklkID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEFwcHdyaXRlRXhjZXB0aW9uKCdNaXNzaW5nIHJlcXVpcmVkIHBhcmFtZXRlcjogXCJ1c2VySWRcIicpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHR5cGVvZiB0YXJnZXRJZCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBBcHB3cml0ZUV4Y2VwdGlvbignTWlzc2luZyByZXF1aXJlZCBwYXJhbWV0ZXI6IFwidGFyZ2V0SWRcIicpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHR5cGVvZiBwcm92aWRlclR5cGUgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgQXBwd3JpdGVFeGNlcHRpb24oJ01pc3NpbmcgcmVxdWlyZWQgcGFyYW1ldGVyOiBcInByb3ZpZGVyVHlwZVwiJyk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodHlwZW9mIGlkZW50aWZpZXIgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgQXBwd3JpdGVFeGNlcHRpb24oJ01pc3NpbmcgcmVxdWlyZWQgcGFyYW1ldGVyOiBcImlkZW50aWZpZXJcIicpO1xuICAgICAgICB9XG5cblxuICAgICAgICBpZiAodHlwZW9mIHRhcmdldElkICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgcGF5bG9hZFsndGFyZ2V0SWQnXSA9IHRhcmdldElkO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHR5cGVvZiBwcm92aWRlclR5cGUgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICBwYXlsb2FkWydwcm92aWRlclR5cGUnXSA9IHByb3ZpZGVyVHlwZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0eXBlb2YgaWRlbnRpZmllciAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHBheWxvYWRbJ2lkZW50aWZpZXInXSA9IGlkZW50aWZpZXI7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodHlwZW9mIHByb3ZpZGVySWQgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICBwYXlsb2FkWydwcm92aWRlcklkJ10gPSBwcm92aWRlcklkO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHR5cGVvZiBuYW1lICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgcGF5bG9hZFsnbmFtZSddID0gbmFtZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBhd2FpdCB0aGlzLmNsaWVudC5jYWxsKCdwb3N0JywgYXBpUGF0aCwge1xuICAgICAgICAgICAgJ2NvbnRlbnQtdHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJyxcbiAgICAgICAgfSwgcGF5bG9hZCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2V0IFVzZXIgVGFyZ2V0XG4gICAgICpcbiAgICAgKiBHZXQgYSB1c2VyJ3MgcHVzaCBub3RpZmljYXRpb24gdGFyZ2V0IGJ5IElELlxuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHVzZXJJZFxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSB0YXJnZXRJZFxuICAgICAqIEB0aHJvd3Mge0FwcHdyaXRlRXhjZXB0aW9ufVxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlfVxuICAgICAqL1xuICAgIGFzeW5jIGdldFRhcmdldCh1c2VySWQsIHRhcmdldElkKSB7XG4gICAgICAgIGNvbnN0IGFwaVBhdGggPSAnL3VzZXJzL3t1c2VySWR9L3RhcmdldHMve3RhcmdldElkfScucmVwbGFjZSgne3VzZXJJZH0nLCB1c2VySWQpLnJlcGxhY2UoJ3t0YXJnZXRJZH0nLCB0YXJnZXRJZCk7XG4gICAgICAgIGxldCBwYXlsb2FkID0ge307XG4gICAgICAgIGlmICh0eXBlb2YgdXNlcklkID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEFwcHdyaXRlRXhjZXB0aW9uKCdNaXNzaW5nIHJlcXVpcmVkIHBhcmFtZXRlcjogXCJ1c2VySWRcIicpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHR5cGVvZiB0YXJnZXRJZCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBBcHB3cml0ZUV4Y2VwdGlvbignTWlzc2luZyByZXF1aXJlZCBwYXJhbWV0ZXI6IFwidGFyZ2V0SWRcIicpO1xuICAgICAgICB9XG5cblxuICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy5jbGllbnQuY2FsbCgnZ2V0JywgYXBpUGF0aCwge1xuICAgICAgICAgICAgJ2NvbnRlbnQtdHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJyxcbiAgICAgICAgfSwgcGF5bG9hZCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVXBkYXRlIFVzZXIgdGFyZ2V0XG4gICAgICpcbiAgICAgKiBVcGRhdGUgYSBtZXNzYWdpbmcgdGFyZ2V0LlxuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHVzZXJJZFxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSB0YXJnZXRJZFxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBpZGVudGlmaWVyXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHByb3ZpZGVySWRcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gbmFtZVxuICAgICAqIEB0aHJvd3Mge0FwcHdyaXRlRXhjZXB0aW9ufVxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlfVxuICAgICAqL1xuICAgIGFzeW5jIHVwZGF0ZVRhcmdldCh1c2VySWQsIHRhcmdldElkLCBpZGVudGlmaWVyLCBwcm92aWRlcklkLCBuYW1lKSB7XG4gICAgICAgIGNvbnN0IGFwaVBhdGggPSAnL3VzZXJzL3t1c2VySWR9L3RhcmdldHMve3RhcmdldElkfScucmVwbGFjZSgne3VzZXJJZH0nLCB1c2VySWQpLnJlcGxhY2UoJ3t0YXJnZXRJZH0nLCB0YXJnZXRJZCk7XG4gICAgICAgIGxldCBwYXlsb2FkID0ge307XG4gICAgICAgIGlmICh0eXBlb2YgdXNlcklkID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEFwcHdyaXRlRXhjZXB0aW9uKCdNaXNzaW5nIHJlcXVpcmVkIHBhcmFtZXRlcjogXCJ1c2VySWRcIicpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHR5cGVvZiB0YXJnZXRJZCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBBcHB3cml0ZUV4Y2VwdGlvbignTWlzc2luZyByZXF1aXJlZCBwYXJhbWV0ZXI6IFwidGFyZ2V0SWRcIicpO1xuICAgICAgICB9XG5cblxuICAgICAgICBpZiAodHlwZW9mIGlkZW50aWZpZXIgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICBwYXlsb2FkWydpZGVudGlmaWVyJ10gPSBpZGVudGlmaWVyO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHR5cGVvZiBwcm92aWRlcklkICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgcGF5bG9hZFsncHJvdmlkZXJJZCddID0gcHJvdmlkZXJJZDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0eXBlb2YgbmFtZSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHBheWxvYWRbJ25hbWUnXSA9IG5hbWU7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy5jbGllbnQuY2FsbCgncGF0Y2gnLCBhcGlQYXRoLCB7XG4gICAgICAgICAgICAnY29udGVudC10eXBlJzogJ2FwcGxpY2F0aW9uL2pzb24nLFxuICAgICAgICB9LCBwYXlsb2FkKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBEZWxldGUgdXNlciB0YXJnZXRcbiAgICAgKlxuICAgICAqIERlbGV0ZSBhIG1lc3NhZ2luZyB0YXJnZXQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gdXNlcklkXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHRhcmdldElkXG4gICAgICogQHRocm93cyB7QXBwd3JpdGVFeGNlcHRpb259XG4gICAgICogQHJldHVybnMge1Byb21pc2V9XG4gICAgICovXG4gICAgYXN5bmMgZGVsZXRlVGFyZ2V0KHVzZXJJZCwgdGFyZ2V0SWQpIHtcbiAgICAgICAgY29uc3QgYXBpUGF0aCA9ICcvdXNlcnMve3VzZXJJZH0vdGFyZ2V0cy97dGFyZ2V0SWR9Jy5yZXBsYWNlKCd7dXNlcklkfScsIHVzZXJJZCkucmVwbGFjZSgne3RhcmdldElkfScsIHRhcmdldElkKTtcbiAgICAgICAgbGV0IHBheWxvYWQgPSB7fTtcbiAgICAgICAgaWYgKHR5cGVvZiB1c2VySWQgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgQXBwd3JpdGVFeGNlcHRpb24oJ01pc3NpbmcgcmVxdWlyZWQgcGFyYW1ldGVyOiBcInVzZXJJZFwiJyk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodHlwZW9mIHRhcmdldElkID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEFwcHdyaXRlRXhjZXB0aW9uKCdNaXNzaW5nIHJlcXVpcmVkIHBhcmFtZXRlcjogXCJ0YXJnZXRJZFwiJyk7XG4gICAgICAgIH1cblxuXG4gICAgICAgIHJldHVybiBhd2FpdCB0aGlzLmNsaWVudC5jYWxsKCdkZWxldGUnLCBhcGlQYXRoLCB7XG4gICAgICAgICAgICAnY29udGVudC10eXBlJzogJ2FwcGxpY2F0aW9uL2pzb24nLFxuICAgICAgICB9LCBwYXlsb2FkKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGUgdG9rZW5cbiAgICAgKlxuICAgICAqIFJldHVybnMgYSB0b2tlbiB3aXRoIGEgc2VjcmV0IGtleSBmb3IgY3JlYXRpbmcgYSBzZXNzaW9uLiBJZiB0aGUgcHJvdmlkZWRcbiAgICAgKiB1c2VyIElEIGhhcyBub3QgYmUgcmVnaXN0ZXJlZCwgYSBuZXcgdXNlciB3aWxsIGJlIGNyZWF0ZWQuIFVzZSB0aGUgcmV0dXJuZWRcbiAgICAgKiB1c2VyIElEIGFuZCBzZWNyZXQgYW5kIHN1Ym1pdCBhIHJlcXVlc3QgdG8gdGhlIFtQVVRcbiAgICAgKiAvYWNjb3VudC9zZXNzaW9ucy9jdXN0b21dKGh0dHBzOi8vYXBwd3JpdGUuaW8vZG9jcy9yZWZlcmVuY2VzL2Nsb3VkL2NsaWVudC13ZWIvYWNjb3VudCN1cGRhdGVDdXN0b21TZXNzaW9uKVxuICAgICAqIGVuZHBvaW50IHRvIGNvbXBsZXRlIHRoZSBsb2dpbiBwcm9jZXNzLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHVzZXJJZFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBsZW5ndGhcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gZXhwaXJlXG4gICAgICogQHRocm93cyB7QXBwd3JpdGVFeGNlcHRpb259XG4gICAgICogQHJldHVybnMge1Byb21pc2V9XG4gICAgICovXG4gICAgYXN5bmMgY3JlYXRlVG9rZW4odXNlcklkLCBsZW5ndGgsIGV4cGlyZSkge1xuICAgICAgICBjb25zdCBhcGlQYXRoID0gJy91c2Vycy97dXNlcklkfS90b2tlbnMnLnJlcGxhY2UoJ3t1c2VySWR9JywgdXNlcklkKTtcbiAgICAgICAgbGV0IHBheWxvYWQgPSB7fTtcbiAgICAgICAgaWYgKHR5cGVvZiB1c2VySWQgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgQXBwd3JpdGVFeGNlcHRpb24oJ01pc3NpbmcgcmVxdWlyZWQgcGFyYW1ldGVyOiBcInVzZXJJZFwiJyk7XG4gICAgICAgIH1cblxuXG4gICAgICAgIGlmICh0eXBlb2YgbGVuZ3RoICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgcGF5bG9hZFsnbGVuZ3RoJ10gPSBsZW5ndGg7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodHlwZW9mIGV4cGlyZSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHBheWxvYWRbJ2V4cGlyZSddID0gZXhwaXJlO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMuY2xpZW50LmNhbGwoJ3Bvc3QnLCBhcGlQYXRoLCB7XG4gICAgICAgICAgICAnY29udGVudC10eXBlJzogJ2FwcGxpY2F0aW9uL2pzb24nLFxuICAgICAgICB9LCBwYXlsb2FkKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBVcGRhdGUgZW1haWwgdmVyaWZpY2F0aW9uXG4gICAgICpcbiAgICAgKiBVcGRhdGUgdGhlIHVzZXIgZW1haWwgdmVyaWZpY2F0aW9uIHN0YXR1cyBieSBpdHMgdW5pcXVlIElELlxuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHVzZXJJZFxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gZW1haWxWZXJpZmljYXRpb25cbiAgICAgKiBAdGhyb3dzIHtBcHB3cml0ZUV4Y2VwdGlvbn1cbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZX1cbiAgICAgKi9cbiAgICBhc3luYyB1cGRhdGVFbWFpbFZlcmlmaWNhdGlvbih1c2VySWQsIGVtYWlsVmVyaWZpY2F0aW9uKSB7XG4gICAgICAgIGNvbnN0IGFwaVBhdGggPSAnL3VzZXJzL3t1c2VySWR9L3ZlcmlmaWNhdGlvbicucmVwbGFjZSgne3VzZXJJZH0nLCB1c2VySWQpO1xuICAgICAgICBsZXQgcGF5bG9hZCA9IHt9O1xuICAgICAgICBpZiAodHlwZW9mIHVzZXJJZCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBBcHB3cml0ZUV4Y2VwdGlvbignTWlzc2luZyByZXF1aXJlZCBwYXJhbWV0ZXI6IFwidXNlcklkXCInKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0eXBlb2YgZW1haWxWZXJpZmljYXRpb24gPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgQXBwd3JpdGVFeGNlcHRpb24oJ01pc3NpbmcgcmVxdWlyZWQgcGFyYW1ldGVyOiBcImVtYWlsVmVyaWZpY2F0aW9uXCInKTtcbiAgICAgICAgfVxuXG5cbiAgICAgICAgaWYgKHR5cGVvZiBlbWFpbFZlcmlmaWNhdGlvbiAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHBheWxvYWRbJ2VtYWlsVmVyaWZpY2F0aW9uJ10gPSBlbWFpbFZlcmlmaWNhdGlvbjtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBhd2FpdCB0aGlzLmNsaWVudC5jYWxsKCdwYXRjaCcsIGFwaVBhdGgsIHtcbiAgICAgICAgICAgICdjb250ZW50LXR5cGUnOiAnYXBwbGljYXRpb24vanNvbicsXG4gICAgICAgIH0sIHBheWxvYWQpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFVwZGF0ZSBwaG9uZSB2ZXJpZmljYXRpb25cbiAgICAgKlxuICAgICAqIFVwZGF0ZSB0aGUgdXNlciBwaG9uZSB2ZXJpZmljYXRpb24gc3RhdHVzIGJ5IGl0cyB1bmlxdWUgSUQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gdXNlcklkXG4gICAgICogQHBhcmFtIHtib29sZWFufSBwaG9uZVZlcmlmaWNhdGlvblxuICAgICAqIEB0aHJvd3Mge0FwcHdyaXRlRXhjZXB0aW9ufVxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlfVxuICAgICAqL1xuICAgIGFzeW5jIHVwZGF0ZVBob25lVmVyaWZpY2F0aW9uKHVzZXJJZCwgcGhvbmVWZXJpZmljYXRpb24pIHtcbiAgICAgICAgY29uc3QgYXBpUGF0aCA9ICcvdXNlcnMve3VzZXJJZH0vdmVyaWZpY2F0aW9uL3Bob25lJy5yZXBsYWNlKCd7dXNlcklkfScsIHVzZXJJZCk7XG4gICAgICAgIGxldCBwYXlsb2FkID0ge307XG4gICAgICAgIGlmICh0eXBlb2YgdXNlcklkID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEFwcHdyaXRlRXhjZXB0aW9uKCdNaXNzaW5nIHJlcXVpcmVkIHBhcmFtZXRlcjogXCJ1c2VySWRcIicpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHR5cGVvZiBwaG9uZVZlcmlmaWNhdGlvbiA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBBcHB3cml0ZUV4Y2VwdGlvbignTWlzc2luZyByZXF1aXJlZCBwYXJhbWV0ZXI6IFwicGhvbmVWZXJpZmljYXRpb25cIicpO1xuICAgICAgICB9XG5cblxuICAgICAgICBpZiAodHlwZW9mIHBob25lVmVyaWZpY2F0aW9uICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgcGF5bG9hZFsncGhvbmVWZXJpZmljYXRpb24nXSA9IHBob25lVmVyaWZpY2F0aW9uO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMuY2xpZW50LmNhbGwoJ3BhdGNoJywgYXBpUGF0aCwge1xuICAgICAgICAgICAgJ2NvbnRlbnQtdHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJyxcbiAgICAgICAgfSwgcGF5bG9hZCk7XG4gICAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IFVzZXJzO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(action-browser)/./node_modules/node-appwrite/lib/services/users.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/node-appwrite/lib/services/users.js":
/*!**********************************************************!*\
  !*** ./node_modules/node-appwrite/lib/services/users.js ***!
  \**********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("const Service = __webpack_require__(/*! ../service.js */ \"(rsc)/./node_modules/node-appwrite/lib/service.js\");\nconst AppwriteException = __webpack_require__(/*! ../exception.js */ \"(rsc)/./node_modules/node-appwrite/lib/exception.js\");\nconst InputFile = __webpack_require__(/*! ../inputFile.js */ \"(rsc)/./node_modules/node-appwrite/lib/inputFile.js\");\nconst client = __webpack_require__(/*! ../client.js */ \"(rsc)/./node_modules/node-appwrite/lib/client.js\");\nconst Stream = __webpack_require__(/*! stream */ \"stream\");\nconst { promisify } = __webpack_require__(/*! util */ \"util\");\nconst fs = __webpack_require__(/*! fs */ \"fs\");\nconst { File } = __webpack_require__(/*! undici */ \"undici\");\nconst Query = __webpack_require__(/*! ../query.js */ \"(rsc)/./node_modules/node-appwrite/lib/query.js\");\n\nclass Users extends Service {\n\n     constructor(client)\n     {\n        super(client);\n     }\n\n\n    /**\n     * List users\n     *\n     * Get a list of all the project's users. You can use the query params to\n     * filter your results.\n     *\n     * @param {string[]} queries\n     * @param {string} search\n     * @throws {AppwriteException}\n     * @returns {Promise}\n     */\n    async list(queries, search) {\n        const apiPath = '/users';\n        let payload = {};\n\n        if (typeof queries !== 'undefined') {\n            payload['queries'] = queries;\n        }\n\n        if (typeof search !== 'undefined') {\n            payload['search'] = search;\n        }\n\n        return await this.client.call('get', apiPath, {\n            'content-type': 'application/json',\n        }, payload);\n    }\n\n    /**\n     * Create user\n     *\n     * Create a new user.\n     *\n     * @param {string} userId\n     * @param {string} email\n     * @param {string} phone\n     * @param {string} password\n     * @param {string} name\n     * @throws {AppwriteException}\n     * @returns {Promise}\n     */\n    async create(userId, email, phone, password, name) {\n        const apiPath = '/users';\n        let payload = {};\n        if (typeof userId === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"userId\"');\n        }\n\n\n        if (typeof userId !== 'undefined') {\n            payload['userId'] = userId;\n        }\n\n        if (typeof email !== 'undefined') {\n            payload['email'] = email;\n        }\n\n        if (typeof phone !== 'undefined') {\n            payload['phone'] = phone;\n        }\n\n        if (typeof password !== 'undefined') {\n            payload['password'] = password;\n        }\n\n        if (typeof name !== 'undefined') {\n            payload['name'] = name;\n        }\n\n        return await this.client.call('post', apiPath, {\n            'content-type': 'application/json',\n        }, payload);\n    }\n\n    /**\n     * Create user with Argon2 password\n     *\n     * Create a new user. Password provided must be hashed with the\n     * [Argon2](https://en.wikipedia.org/wiki/Argon2) algorithm. Use the [POST\n     * /users](https://appwrite.io/docs/server/users#usersCreate) endpoint to\n     * create users with a plain text password.\n     *\n     * @param {string} userId\n     * @param {string} email\n     * @param {string} password\n     * @param {string} name\n     * @throws {AppwriteException}\n     * @returns {Promise}\n     */\n    async createArgon2User(userId, email, password, name) {\n        const apiPath = '/users/argon2';\n        let payload = {};\n        if (typeof userId === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"userId\"');\n        }\n\n        if (typeof email === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"email\"');\n        }\n\n        if (typeof password === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"password\"');\n        }\n\n\n        if (typeof userId !== 'undefined') {\n            payload['userId'] = userId;\n        }\n\n        if (typeof email !== 'undefined') {\n            payload['email'] = email;\n        }\n\n        if (typeof password !== 'undefined') {\n            payload['password'] = password;\n        }\n\n        if (typeof name !== 'undefined') {\n            payload['name'] = name;\n        }\n\n        return await this.client.call('post', apiPath, {\n            'content-type': 'application/json',\n        }, payload);\n    }\n\n    /**\n     * Create user with bcrypt password\n     *\n     * Create a new user. Password provided must be hashed with the\n     * [Bcrypt](https://en.wikipedia.org/wiki/Bcrypt) algorithm. Use the [POST\n     * /users](https://appwrite.io/docs/server/users#usersCreate) endpoint to\n     * create users with a plain text password.\n     *\n     * @param {string} userId\n     * @param {string} email\n     * @param {string} password\n     * @param {string} name\n     * @throws {AppwriteException}\n     * @returns {Promise}\n     */\n    async createBcryptUser(userId, email, password, name) {\n        const apiPath = '/users/bcrypt';\n        let payload = {};\n        if (typeof userId === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"userId\"');\n        }\n\n        if (typeof email === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"email\"');\n        }\n\n        if (typeof password === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"password\"');\n        }\n\n\n        if (typeof userId !== 'undefined') {\n            payload['userId'] = userId;\n        }\n\n        if (typeof email !== 'undefined') {\n            payload['email'] = email;\n        }\n\n        if (typeof password !== 'undefined') {\n            payload['password'] = password;\n        }\n\n        if (typeof name !== 'undefined') {\n            payload['name'] = name;\n        }\n\n        return await this.client.call('post', apiPath, {\n            'content-type': 'application/json',\n        }, payload);\n    }\n\n    /**\n     * List Identities\n     *\n     * Get identities for all users.\n     *\n     * @param {string[]} queries\n     * @param {string} search\n     * @throws {AppwriteException}\n     * @returns {Promise}\n     */\n    async listIdentities(queries, search) {\n        const apiPath = '/users/identities';\n        let payload = {};\n\n        if (typeof queries !== 'undefined') {\n            payload['queries'] = queries;\n        }\n\n        if (typeof search !== 'undefined') {\n            payload['search'] = search;\n        }\n\n        return await this.client.call('get', apiPath, {\n            'content-type': 'application/json',\n        }, payload);\n    }\n\n    /**\n     * Delete identity\n     *\n     * Delete an identity by its unique ID.\n     *\n     * @param {string} identityId\n     * @throws {AppwriteException}\n     * @returns {Promise}\n     */\n    async deleteIdentity(identityId) {\n        const apiPath = '/users/identities/{identityId}'.replace('{identityId}', identityId);\n        let payload = {};\n        if (typeof identityId === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"identityId\"');\n        }\n\n\n        return await this.client.call('delete', apiPath, {\n            'content-type': 'application/json',\n        }, payload);\n    }\n\n    /**\n     * Create user with MD5 password\n     *\n     * Create a new user. Password provided must be hashed with the\n     * [MD5](https://en.wikipedia.org/wiki/MD5) algorithm. Use the [POST\n     * /users](https://appwrite.io/docs/server/users#usersCreate) endpoint to\n     * create users with a plain text password.\n     *\n     * @param {string} userId\n     * @param {string} email\n     * @param {string} password\n     * @param {string} name\n     * @throws {AppwriteException}\n     * @returns {Promise}\n     */\n    async createMD5User(userId, email, password, name) {\n        const apiPath = '/users/md5';\n        let payload = {};\n        if (typeof userId === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"userId\"');\n        }\n\n        if (typeof email === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"email\"');\n        }\n\n        if (typeof password === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"password\"');\n        }\n\n\n        if (typeof userId !== 'undefined') {\n            payload['userId'] = userId;\n        }\n\n        if (typeof email !== 'undefined') {\n            payload['email'] = email;\n        }\n\n        if (typeof password !== 'undefined') {\n            payload['password'] = password;\n        }\n\n        if (typeof name !== 'undefined') {\n            payload['name'] = name;\n        }\n\n        return await this.client.call('post', apiPath, {\n            'content-type': 'application/json',\n        }, payload);\n    }\n\n    /**\n     * Create user with PHPass password\n     *\n     * Create a new user. Password provided must be hashed with the\n     * [PHPass](https://www.openwall.com/phpass/) algorithm. Use the [POST\n     * /users](https://appwrite.io/docs/server/users#usersCreate) endpoint to\n     * create users with a plain text password.\n     *\n     * @param {string} userId\n     * @param {string} email\n     * @param {string} password\n     * @param {string} name\n     * @throws {AppwriteException}\n     * @returns {Promise}\n     */\n    async createPHPassUser(userId, email, password, name) {\n        const apiPath = '/users/phpass';\n        let payload = {};\n        if (typeof userId === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"userId\"');\n        }\n\n        if (typeof email === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"email\"');\n        }\n\n        if (typeof password === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"password\"');\n        }\n\n\n        if (typeof userId !== 'undefined') {\n            payload['userId'] = userId;\n        }\n\n        if (typeof email !== 'undefined') {\n            payload['email'] = email;\n        }\n\n        if (typeof password !== 'undefined') {\n            payload['password'] = password;\n        }\n\n        if (typeof name !== 'undefined') {\n            payload['name'] = name;\n        }\n\n        return await this.client.call('post', apiPath, {\n            'content-type': 'application/json',\n        }, payload);\n    }\n\n    /**\n     * Create user with Scrypt password\n     *\n     * Create a new user. Password provided must be hashed with the\n     * [Scrypt](https://github.com/Tarsnap/scrypt) algorithm. Use the [POST\n     * /users](https://appwrite.io/docs/server/users#usersCreate) endpoint to\n     * create users with a plain text password.\n     *\n     * @param {string} userId\n     * @param {string} email\n     * @param {string} password\n     * @param {string} passwordSalt\n     * @param {number} passwordCpu\n     * @param {number} passwordMemory\n     * @param {number} passwordParallel\n     * @param {number} passwordLength\n     * @param {string} name\n     * @throws {AppwriteException}\n     * @returns {Promise}\n     */\n    async createScryptUser(userId, email, password, passwordSalt, passwordCpu, passwordMemory, passwordParallel, passwordLength, name) {\n        const apiPath = '/users/scrypt';\n        let payload = {};\n        if (typeof userId === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"userId\"');\n        }\n\n        if (typeof email === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"email\"');\n        }\n\n        if (typeof password === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"password\"');\n        }\n\n        if (typeof passwordSalt === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"passwordSalt\"');\n        }\n\n        if (typeof passwordCpu === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"passwordCpu\"');\n        }\n\n        if (typeof passwordMemory === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"passwordMemory\"');\n        }\n\n        if (typeof passwordParallel === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"passwordParallel\"');\n        }\n\n        if (typeof passwordLength === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"passwordLength\"');\n        }\n\n\n        if (typeof userId !== 'undefined') {\n            payload['userId'] = userId;\n        }\n\n        if (typeof email !== 'undefined') {\n            payload['email'] = email;\n        }\n\n        if (typeof password !== 'undefined') {\n            payload['password'] = password;\n        }\n\n        if (typeof passwordSalt !== 'undefined') {\n            payload['passwordSalt'] = passwordSalt;\n        }\n\n        if (typeof passwordCpu !== 'undefined') {\n            payload['passwordCpu'] = passwordCpu;\n        }\n\n        if (typeof passwordMemory !== 'undefined') {\n            payload['passwordMemory'] = passwordMemory;\n        }\n\n        if (typeof passwordParallel !== 'undefined') {\n            payload['passwordParallel'] = passwordParallel;\n        }\n\n        if (typeof passwordLength !== 'undefined') {\n            payload['passwordLength'] = passwordLength;\n        }\n\n        if (typeof name !== 'undefined') {\n            payload['name'] = name;\n        }\n\n        return await this.client.call('post', apiPath, {\n            'content-type': 'application/json',\n        }, payload);\n    }\n\n    /**\n     * Create user with Scrypt modified password\n     *\n     * Create a new user. Password provided must be hashed with the [Scrypt\n     * Modified](https://gist.github.com/Meldiron/eecf84a0225eccb5a378d45bb27462cc)\n     * algorithm. Use the [POST\n     * /users](https://appwrite.io/docs/server/users#usersCreate) endpoint to\n     * create users with a plain text password.\n     *\n     * @param {string} userId\n     * @param {string} email\n     * @param {string} password\n     * @param {string} passwordSalt\n     * @param {string} passwordSaltSeparator\n     * @param {string} passwordSignerKey\n     * @param {string} name\n     * @throws {AppwriteException}\n     * @returns {Promise}\n     */\n    async createScryptModifiedUser(userId, email, password, passwordSalt, passwordSaltSeparator, passwordSignerKey, name) {\n        const apiPath = '/users/scrypt-modified';\n        let payload = {};\n        if (typeof userId === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"userId\"');\n        }\n\n        if (typeof email === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"email\"');\n        }\n\n        if (typeof password === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"password\"');\n        }\n\n        if (typeof passwordSalt === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"passwordSalt\"');\n        }\n\n        if (typeof passwordSaltSeparator === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"passwordSaltSeparator\"');\n        }\n\n        if (typeof passwordSignerKey === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"passwordSignerKey\"');\n        }\n\n\n        if (typeof userId !== 'undefined') {\n            payload['userId'] = userId;\n        }\n\n        if (typeof email !== 'undefined') {\n            payload['email'] = email;\n        }\n\n        if (typeof password !== 'undefined') {\n            payload['password'] = password;\n        }\n\n        if (typeof passwordSalt !== 'undefined') {\n            payload['passwordSalt'] = passwordSalt;\n        }\n\n        if (typeof passwordSaltSeparator !== 'undefined') {\n            payload['passwordSaltSeparator'] = passwordSaltSeparator;\n        }\n\n        if (typeof passwordSignerKey !== 'undefined') {\n            payload['passwordSignerKey'] = passwordSignerKey;\n        }\n\n        if (typeof name !== 'undefined') {\n            payload['name'] = name;\n        }\n\n        return await this.client.call('post', apiPath, {\n            'content-type': 'application/json',\n        }, payload);\n    }\n\n    /**\n     * Create user with SHA password\n     *\n     * Create a new user. Password provided must be hashed with the\n     * [SHA](https://en.wikipedia.org/wiki/Secure_Hash_Algorithm) algorithm. Use\n     * the [POST /users](https://appwrite.io/docs/server/users#usersCreate)\n     * endpoint to create users with a plain text password.\n     *\n     * @param {string} userId\n     * @param {string} email\n     * @param {string} password\n     * @param {PasswordHash} passwordVersion\n     * @param {string} name\n     * @throws {AppwriteException}\n     * @returns {Promise}\n     */\n    async createSHAUser(userId, email, password, passwordVersion, name) {\n        const apiPath = '/users/sha';\n        let payload = {};\n        if (typeof userId === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"userId\"');\n        }\n\n        if (typeof email === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"email\"');\n        }\n\n        if (typeof password === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"password\"');\n        }\n\n\n        if (typeof userId !== 'undefined') {\n            payload['userId'] = userId;\n        }\n\n        if (typeof email !== 'undefined') {\n            payload['email'] = email;\n        }\n\n        if (typeof password !== 'undefined') {\n            payload['password'] = password;\n        }\n\n        if (typeof passwordVersion !== 'undefined') {\n            payload['passwordVersion'] = passwordVersion;\n        }\n\n        if (typeof name !== 'undefined') {\n            payload['name'] = name;\n        }\n\n        return await this.client.call('post', apiPath, {\n            'content-type': 'application/json',\n        }, payload);\n    }\n\n    /**\n     * Get user\n     *\n     * Get a user by its unique ID.\n     *\n     * @param {string} userId\n     * @throws {AppwriteException}\n     * @returns {Promise}\n     */\n    async get(userId) {\n        const apiPath = '/users/{userId}'.replace('{userId}', userId);\n        let payload = {};\n        if (typeof userId === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"userId\"');\n        }\n\n\n        return await this.client.call('get', apiPath, {\n            'content-type': 'application/json',\n        }, payload);\n    }\n\n    /**\n     * Delete user\n     *\n     * Delete a user by its unique ID, thereby releasing it's ID. Since ID is\n     * released and can be reused, all user-related resources like documents or\n     * storage files should be deleted before user deletion. If you want to keep\n     * ID reserved, use the\n     * [updateStatus](https://appwrite.io/docs/server/users#usersUpdateStatus)\n     * endpoint instead.\n     *\n     * @param {string} userId\n     * @throws {AppwriteException}\n     * @returns {Promise}\n     */\n    async delete(userId) {\n        const apiPath = '/users/{userId}'.replace('{userId}', userId);\n        let payload = {};\n        if (typeof userId === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"userId\"');\n        }\n\n\n        return await this.client.call('delete', apiPath, {\n            'content-type': 'application/json',\n        }, payload);\n    }\n\n    /**\n     * Update email\n     *\n     * Update the user email by its unique ID.\n     *\n     * @param {string} userId\n     * @param {string} email\n     * @throws {AppwriteException}\n     * @returns {Promise}\n     */\n    async updateEmail(userId, email) {\n        const apiPath = '/users/{userId}/email'.replace('{userId}', userId);\n        let payload = {};\n        if (typeof userId === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"userId\"');\n        }\n\n        if (typeof email === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"email\"');\n        }\n\n\n        if (typeof email !== 'undefined') {\n            payload['email'] = email;\n        }\n\n        return await this.client.call('patch', apiPath, {\n            'content-type': 'application/json',\n        }, payload);\n    }\n\n    /**\n     * Update user labels\n     *\n     * Update the user labels by its unique ID. \n     * \n     * Labels can be used to grant access to resources. While teams are a way for\n     * user's to share access to a resource, labels can be defined by the\n     * developer to grant access without an invitation. See the [Permissions\n     * docs](https://appwrite.io/docs/permissions) for more info.\n     *\n     * @param {string} userId\n     * @param {string[]} labels\n     * @throws {AppwriteException}\n     * @returns {Promise}\n     */\n    async updateLabels(userId, labels) {\n        const apiPath = '/users/{userId}/labels'.replace('{userId}', userId);\n        let payload = {};\n        if (typeof userId === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"userId\"');\n        }\n\n        if (typeof labels === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"labels\"');\n        }\n\n\n        if (typeof labels !== 'undefined') {\n            payload['labels'] = labels;\n        }\n\n        return await this.client.call('put', apiPath, {\n            'content-type': 'application/json',\n        }, payload);\n    }\n\n    /**\n     * List user logs\n     *\n     * Get the user activity logs list by its unique ID.\n     *\n     * @param {string} userId\n     * @param {string[]} queries\n     * @throws {AppwriteException}\n     * @returns {Promise}\n     */\n    async listLogs(userId, queries) {\n        const apiPath = '/users/{userId}/logs'.replace('{userId}', userId);\n        let payload = {};\n        if (typeof userId === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"userId\"');\n        }\n\n\n        if (typeof queries !== 'undefined') {\n            payload['queries'] = queries;\n        }\n\n        return await this.client.call('get', apiPath, {\n            'content-type': 'application/json',\n        }, payload);\n    }\n\n    /**\n     * List user memberships\n     *\n     * Get the user membership list by its unique ID.\n     *\n     * @param {string} userId\n     * @throws {AppwriteException}\n     * @returns {Promise}\n     */\n    async listMemberships(userId) {\n        const apiPath = '/users/{userId}/memberships'.replace('{userId}', userId);\n        let payload = {};\n        if (typeof userId === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"userId\"');\n        }\n\n\n        return await this.client.call('get', apiPath, {\n            'content-type': 'application/json',\n        }, payload);\n    }\n\n    /**\n     * Update MFA\n     *\n     * Enable or disable MFA on a user account.\n     *\n     * @param {string} userId\n     * @param {boolean} mfa\n     * @throws {AppwriteException}\n     * @returns {Promise}\n     */\n    async updateMfa(userId, mfa) {\n        const apiPath = '/users/{userId}/mfa'.replace('{userId}', userId);\n        let payload = {};\n        if (typeof userId === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"userId\"');\n        }\n\n        if (typeof mfa === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"mfa\"');\n        }\n\n\n        if (typeof mfa !== 'undefined') {\n            payload['mfa'] = mfa;\n        }\n\n        return await this.client.call('patch', apiPath, {\n            'content-type': 'application/json',\n        }, payload);\n    }\n\n    /**\n     * Delete Authenticator\n     *\n     * Delete an authenticator app.\n     *\n     * @param {string} userId\n     * @param {AuthenticatorType} type\n     * @throws {AppwriteException}\n     * @returns {Promise}\n     */\n    async deleteMfaAuthenticator(userId, type) {\n        const apiPath = '/users/{userId}/mfa/authenticators/{type}'.replace('{userId}', userId).replace('{type}', type);\n        let payload = {};\n        if (typeof userId === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"userId\"');\n        }\n\n        if (typeof type === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"type\"');\n        }\n\n\n        return await this.client.call('delete', apiPath, {\n            'content-type': 'application/json',\n        }, payload);\n    }\n\n    /**\n     * List Factors\n     *\n     * List the factors available on the account to be used as a MFA challange.\n     *\n     * @param {string} userId\n     * @throws {AppwriteException}\n     * @returns {Promise}\n     */\n    async listMfaFactors(userId) {\n        const apiPath = '/users/{userId}/mfa/factors'.replace('{userId}', userId);\n        let payload = {};\n        if (typeof userId === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"userId\"');\n        }\n\n\n        return await this.client.call('get', apiPath, {\n            'content-type': 'application/json',\n        }, payload);\n    }\n\n    /**\n     * Get MFA Recovery Codes\n     *\n     * Get recovery codes that can be used as backup for MFA flow by User ID.\n     * Before getting codes, they must be generated using\n     * [createMfaRecoveryCodes](/docs/references/cloud/client-web/account#createMfaRecoveryCodes)\n     * method.\n     *\n     * @param {string} userId\n     * @throws {AppwriteException}\n     * @returns {Promise}\n     */\n    async getMfaRecoveryCodes(userId) {\n        const apiPath = '/users/{userId}/mfa/recovery-codes'.replace('{userId}', userId);\n        let payload = {};\n        if (typeof userId === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"userId\"');\n        }\n\n\n        return await this.client.call('get', apiPath, {\n            'content-type': 'application/json',\n        }, payload);\n    }\n\n    /**\n     * Regenerate MFA Recovery Codes\n     *\n     * Regenerate recovery codes that can be used as backup for MFA flow by User\n     * ID. Before regenerating codes, they must be first generated using\n     * [createMfaRecoveryCodes](/docs/references/cloud/client-web/account#createMfaRecoveryCodes)\n     * method.\n     *\n     * @param {string} userId\n     * @throws {AppwriteException}\n     * @returns {Promise}\n     */\n    async updateMfaRecoveryCodes(userId) {\n        const apiPath = '/users/{userId}/mfa/recovery-codes'.replace('{userId}', userId);\n        let payload = {};\n        if (typeof userId === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"userId\"');\n        }\n\n\n        return await this.client.call('put', apiPath, {\n            'content-type': 'application/json',\n        }, payload);\n    }\n\n    /**\n     * Create MFA Recovery Codes\n     *\n     * Generate recovery codes used as backup for MFA flow for User ID. Recovery\n     * codes can be used as a MFA verification type in\n     * [createMfaChallenge](/docs/references/cloud/client-web/account#createMfaChallenge)\n     * method by client SDK.\n     *\n     * @param {string} userId\n     * @throws {AppwriteException}\n     * @returns {Promise}\n     */\n    async createMfaRecoveryCodes(userId) {\n        const apiPath = '/users/{userId}/mfa/recovery-codes'.replace('{userId}', userId);\n        let payload = {};\n        if (typeof userId === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"userId\"');\n        }\n\n\n        return await this.client.call('patch', apiPath, {\n            'content-type': 'application/json',\n        }, payload);\n    }\n\n    /**\n     * Update name\n     *\n     * Update the user name by its unique ID.\n     *\n     * @param {string} userId\n     * @param {string} name\n     * @throws {AppwriteException}\n     * @returns {Promise}\n     */\n    async updateName(userId, name) {\n        const apiPath = '/users/{userId}/name'.replace('{userId}', userId);\n        let payload = {};\n        if (typeof userId === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"userId\"');\n        }\n\n        if (typeof name === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"name\"');\n        }\n\n\n        if (typeof name !== 'undefined') {\n            payload['name'] = name;\n        }\n\n        return await this.client.call('patch', apiPath, {\n            'content-type': 'application/json',\n        }, payload);\n    }\n\n    /**\n     * Update password\n     *\n     * Update the user password by its unique ID.\n     *\n     * @param {string} userId\n     * @param {string} password\n     * @throws {AppwriteException}\n     * @returns {Promise}\n     */\n    async updatePassword(userId, password) {\n        const apiPath = '/users/{userId}/password'.replace('{userId}', userId);\n        let payload = {};\n        if (typeof userId === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"userId\"');\n        }\n\n        if (typeof password === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"password\"');\n        }\n\n\n        if (typeof password !== 'undefined') {\n            payload['password'] = password;\n        }\n\n        return await this.client.call('patch', apiPath, {\n            'content-type': 'application/json',\n        }, payload);\n    }\n\n    /**\n     * Update phone\n     *\n     * Update the user phone by its unique ID.\n     *\n     * @param {string} userId\n     * @param {string} number\n     * @throws {AppwriteException}\n     * @returns {Promise}\n     */\n    async updatePhone(userId, number) {\n        const apiPath = '/users/{userId}/phone'.replace('{userId}', userId);\n        let payload = {};\n        if (typeof userId === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"userId\"');\n        }\n\n        if (typeof number === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"number\"');\n        }\n\n\n        if (typeof number !== 'undefined') {\n            payload['number'] = number;\n        }\n\n        return await this.client.call('patch', apiPath, {\n            'content-type': 'application/json',\n        }, payload);\n    }\n\n    /**\n     * Get user preferences\n     *\n     * Get the user preferences by its unique ID.\n     *\n     * @param {string} userId\n     * @throws {AppwriteException}\n     * @returns {Promise}\n     */\n    async getPrefs(userId) {\n        const apiPath = '/users/{userId}/prefs'.replace('{userId}', userId);\n        let payload = {};\n        if (typeof userId === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"userId\"');\n        }\n\n\n        return await this.client.call('get', apiPath, {\n            'content-type': 'application/json',\n        }, payload);\n    }\n\n    /**\n     * Update user preferences\n     *\n     * Update the user preferences by its unique ID. The object you pass is stored\n     * as is, and replaces any previous value. The maximum allowed prefs size is\n     * 64kB and throws error if exceeded.\n     *\n     * @param {string} userId\n     * @param {object} prefs\n     * @throws {AppwriteException}\n     * @returns {Promise}\n     */\n    async updatePrefs(userId, prefs) {\n        const apiPath = '/users/{userId}/prefs'.replace('{userId}', userId);\n        let payload = {};\n        if (typeof userId === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"userId\"');\n        }\n\n        if (typeof prefs === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"prefs\"');\n        }\n\n\n        if (typeof prefs !== 'undefined') {\n            payload['prefs'] = prefs;\n        }\n\n        return await this.client.call('patch', apiPath, {\n            'content-type': 'application/json',\n        }, payload);\n    }\n\n    /**\n     * List user sessions\n     *\n     * Get the user sessions list by its unique ID.\n     *\n     * @param {string} userId\n     * @throws {AppwriteException}\n     * @returns {Promise}\n     */\n    async listSessions(userId) {\n        const apiPath = '/users/{userId}/sessions'.replace('{userId}', userId);\n        let payload = {};\n        if (typeof userId === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"userId\"');\n        }\n\n\n        return await this.client.call('get', apiPath, {\n            'content-type': 'application/json',\n        }, payload);\n    }\n\n    /**\n     * Create session\n     *\n     * Creates a session for a user. Returns an immediately usable session object.\n     * \n     * If you want to generate a token for a custom authentication flow, use the\n     * [POST\n     * /users/{userId}/tokens](https://appwrite.io/docs/server/users#createToken)\n     * endpoint.\n     *\n     * @param {string} userId\n     * @throws {AppwriteException}\n     * @returns {Promise}\n     */\n    async createSession(userId) {\n        const apiPath = '/users/{userId}/sessions'.replace('{userId}', userId);\n        let payload = {};\n        if (typeof userId === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"userId\"');\n        }\n\n\n        return await this.client.call('post', apiPath, {\n            'content-type': 'application/json',\n        }, payload);\n    }\n\n    /**\n     * Delete user sessions\n     *\n     * Delete all user's sessions by using the user's unique ID.\n     *\n     * @param {string} userId\n     * @throws {AppwriteException}\n     * @returns {Promise}\n     */\n    async deleteSessions(userId) {\n        const apiPath = '/users/{userId}/sessions'.replace('{userId}', userId);\n        let payload = {};\n        if (typeof userId === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"userId\"');\n        }\n\n\n        return await this.client.call('delete', apiPath, {\n            'content-type': 'application/json',\n        }, payload);\n    }\n\n    /**\n     * Delete user session\n     *\n     * Delete a user sessions by its unique ID.\n     *\n     * @param {string} userId\n     * @param {string} sessionId\n     * @throws {AppwriteException}\n     * @returns {Promise}\n     */\n    async deleteSession(userId, sessionId) {\n        const apiPath = '/users/{userId}/sessions/{sessionId}'.replace('{userId}', userId).replace('{sessionId}', sessionId);\n        let payload = {};\n        if (typeof userId === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"userId\"');\n        }\n\n        if (typeof sessionId === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"sessionId\"');\n        }\n\n\n        return await this.client.call('delete', apiPath, {\n            'content-type': 'application/json',\n        }, payload);\n    }\n\n    /**\n     * Update user status\n     *\n     * Update the user status by its unique ID. Use this endpoint as an\n     * alternative to deleting a user if you want to keep user's ID reserved.\n     *\n     * @param {string} userId\n     * @param {boolean} status\n     * @throws {AppwriteException}\n     * @returns {Promise}\n     */\n    async updateStatus(userId, status) {\n        const apiPath = '/users/{userId}/status'.replace('{userId}', userId);\n        let payload = {};\n        if (typeof userId === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"userId\"');\n        }\n\n        if (typeof status === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"status\"');\n        }\n\n\n        if (typeof status !== 'undefined') {\n            payload['status'] = status;\n        }\n\n        return await this.client.call('patch', apiPath, {\n            'content-type': 'application/json',\n        }, payload);\n    }\n\n    /**\n     * List User Targets\n     *\n     * List the messaging targets that are associated with a user.\n     *\n     * @param {string} userId\n     * @param {string[]} queries\n     * @throws {AppwriteException}\n     * @returns {Promise}\n     */\n    async listTargets(userId, queries) {\n        const apiPath = '/users/{userId}/targets'.replace('{userId}', userId);\n        let payload = {};\n        if (typeof userId === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"userId\"');\n        }\n\n\n        if (typeof queries !== 'undefined') {\n            payload['queries'] = queries;\n        }\n\n        return await this.client.call('get', apiPath, {\n            'content-type': 'application/json',\n        }, payload);\n    }\n\n    /**\n     * Create User Target\n     *\n     * Create a messaging target.\n     *\n     * @param {string} userId\n     * @param {string} targetId\n     * @param {MessagingProviderType} providerType\n     * @param {string} identifier\n     * @param {string} providerId\n     * @param {string} name\n     * @throws {AppwriteException}\n     * @returns {Promise}\n     */\n    async createTarget(userId, targetId, providerType, identifier, providerId, name) {\n        const apiPath = '/users/{userId}/targets'.replace('{userId}', userId);\n        let payload = {};\n        if (typeof userId === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"userId\"');\n        }\n\n        if (typeof targetId === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"targetId\"');\n        }\n\n        if (typeof providerType === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"providerType\"');\n        }\n\n        if (typeof identifier === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"identifier\"');\n        }\n\n\n        if (typeof targetId !== 'undefined') {\n            payload['targetId'] = targetId;\n        }\n\n        if (typeof providerType !== 'undefined') {\n            payload['providerType'] = providerType;\n        }\n\n        if (typeof identifier !== 'undefined') {\n            payload['identifier'] = identifier;\n        }\n\n        if (typeof providerId !== 'undefined') {\n            payload['providerId'] = providerId;\n        }\n\n        if (typeof name !== 'undefined') {\n            payload['name'] = name;\n        }\n\n        return await this.client.call('post', apiPath, {\n            'content-type': 'application/json',\n        }, payload);\n    }\n\n    /**\n     * Get User Target\n     *\n     * Get a user's push notification target by ID.\n     *\n     * @param {string} userId\n     * @param {string} targetId\n     * @throws {AppwriteException}\n     * @returns {Promise}\n     */\n    async getTarget(userId, targetId) {\n        const apiPath = '/users/{userId}/targets/{targetId}'.replace('{userId}', userId).replace('{targetId}', targetId);\n        let payload = {};\n        if (typeof userId === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"userId\"');\n        }\n\n        if (typeof targetId === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"targetId\"');\n        }\n\n\n        return await this.client.call('get', apiPath, {\n            'content-type': 'application/json',\n        }, payload);\n    }\n\n    /**\n     * Update User target\n     *\n     * Update a messaging target.\n     *\n     * @param {string} userId\n     * @param {string} targetId\n     * @param {string} identifier\n     * @param {string} providerId\n     * @param {string} name\n     * @throws {AppwriteException}\n     * @returns {Promise}\n     */\n    async updateTarget(userId, targetId, identifier, providerId, name) {\n        const apiPath = '/users/{userId}/targets/{targetId}'.replace('{userId}', userId).replace('{targetId}', targetId);\n        let payload = {};\n        if (typeof userId === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"userId\"');\n        }\n\n        if (typeof targetId === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"targetId\"');\n        }\n\n\n        if (typeof identifier !== 'undefined') {\n            payload['identifier'] = identifier;\n        }\n\n        if (typeof providerId !== 'undefined') {\n            payload['providerId'] = providerId;\n        }\n\n        if (typeof name !== 'undefined') {\n            payload['name'] = name;\n        }\n\n        return await this.client.call('patch', apiPath, {\n            'content-type': 'application/json',\n        }, payload);\n    }\n\n    /**\n     * Delete user target\n     *\n     * Delete a messaging target.\n     *\n     * @param {string} userId\n     * @param {string} targetId\n     * @throws {AppwriteException}\n     * @returns {Promise}\n     */\n    async deleteTarget(userId, targetId) {\n        const apiPath = '/users/{userId}/targets/{targetId}'.replace('{userId}', userId).replace('{targetId}', targetId);\n        let payload = {};\n        if (typeof userId === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"userId\"');\n        }\n\n        if (typeof targetId === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"targetId\"');\n        }\n\n\n        return await this.client.call('delete', apiPath, {\n            'content-type': 'application/json',\n        }, payload);\n    }\n\n    /**\n     * Create token\n     *\n     * Returns a token with a secret key for creating a session. If the provided\n     * user ID has not be registered, a new user will be created. Use the returned\n     * user ID and secret and submit a request to the [PUT\n     * /account/sessions/custom](https://appwrite.io/docs/references/cloud/client-web/account#updateCustomSession)\n     * endpoint to complete the login process.\n     *\n     * @param {string} userId\n     * @param {number} length\n     * @param {number} expire\n     * @throws {AppwriteException}\n     * @returns {Promise}\n     */\n    async createToken(userId, length, expire) {\n        const apiPath = '/users/{userId}/tokens'.replace('{userId}', userId);\n        let payload = {};\n        if (typeof userId === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"userId\"');\n        }\n\n\n        if (typeof length !== 'undefined') {\n            payload['length'] = length;\n        }\n\n        if (typeof expire !== 'undefined') {\n            payload['expire'] = expire;\n        }\n\n        return await this.client.call('post', apiPath, {\n            'content-type': 'application/json',\n        }, payload);\n    }\n\n    /**\n     * Update email verification\n     *\n     * Update the user email verification status by its unique ID.\n     *\n     * @param {string} userId\n     * @param {boolean} emailVerification\n     * @throws {AppwriteException}\n     * @returns {Promise}\n     */\n    async updateEmailVerification(userId, emailVerification) {\n        const apiPath = '/users/{userId}/verification'.replace('{userId}', userId);\n        let payload = {};\n        if (typeof userId === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"userId\"');\n        }\n\n        if (typeof emailVerification === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"emailVerification\"');\n        }\n\n\n        if (typeof emailVerification !== 'undefined') {\n            payload['emailVerification'] = emailVerification;\n        }\n\n        return await this.client.call('patch', apiPath, {\n            'content-type': 'application/json',\n        }, payload);\n    }\n\n    /**\n     * Update phone verification\n     *\n     * Update the user phone verification status by its unique ID.\n     *\n     * @param {string} userId\n     * @param {boolean} phoneVerification\n     * @throws {AppwriteException}\n     * @returns {Promise}\n     */\n    async updatePhoneVerification(userId, phoneVerification) {\n        const apiPath = '/users/{userId}/verification/phone'.replace('{userId}', userId);\n        let payload = {};\n        if (typeof userId === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"userId\"');\n        }\n\n        if (typeof phoneVerification === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"phoneVerification\"');\n        }\n\n\n        if (typeof phoneVerification !== 'undefined') {\n            payload['phoneVerification'] = phoneVerification;\n        }\n\n        return await this.client.call('patch', apiPath, {\n            'content-type': 'application/json',\n        }, payload);\n    }\n}\n\nmodule.exports = Users;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvbm9kZS1hcHB3cml0ZS9saWIvc2VydmljZXMvdXNlcnMuanMiLCJtYXBwaW5ncyI6IkFBQUEsZ0JBQWdCLG1CQUFPLENBQUMsd0VBQWU7QUFDdkMsMEJBQTBCLG1CQUFPLENBQUMsNEVBQWlCO0FBQ25ELGtCQUFrQixtQkFBTyxDQUFDLDRFQUFpQjtBQUMzQyxlQUFlLG1CQUFPLENBQUMsc0VBQWM7QUFDckMsZUFBZSxtQkFBTyxDQUFDLHNCQUFRO0FBQy9CLFFBQVEsWUFBWSxFQUFFLG1CQUFPLENBQUMsa0JBQU07QUFDcEMsV0FBVyxtQkFBTyxDQUFDLGNBQUk7QUFDdkIsUUFBUSxPQUFPLEVBQUUsbUJBQU8sQ0FBQyxzQkFBUTtBQUNqQyxjQUFjLG1CQUFPLENBQUMsb0VBQWE7O0FBRW5DOztBQUVBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFVBQVU7QUFDekIsZUFBZSxRQUFRO0FBQ3ZCLGdCQUFnQjtBQUNoQixpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsU0FBUztBQUNUOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkIsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsUUFBUTtBQUN2QixlQUFlLFFBQVE7QUFDdkIsZUFBZSxRQUFRO0FBQ3ZCLGdCQUFnQjtBQUNoQixpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFNBQVM7QUFDVDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsUUFBUTtBQUN2QixlQUFlLFFBQVE7QUFDdkIsZUFBZSxRQUFRO0FBQ3ZCLGdCQUFnQjtBQUNoQixpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QixlQUFlLFFBQVE7QUFDdkIsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsUUFBUTtBQUN2QixnQkFBZ0I7QUFDaEIsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsU0FBUztBQUNUOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFVBQVU7QUFDekIsZUFBZSxRQUFRO0FBQ3ZCLGdCQUFnQjtBQUNoQixpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsU0FBUztBQUNUOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkIsZ0JBQWdCO0FBQ2hCLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0EsNENBQTRDLFdBQVcsWUFBWSxXQUFXO0FBQzlFO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0EsU0FBUztBQUNUOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkIsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsUUFBUTtBQUN2QixlQUFlLFFBQVE7QUFDdkIsZ0JBQWdCO0FBQ2hCLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFNBQVM7QUFDVDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsUUFBUTtBQUN2QixlQUFlLFFBQVE7QUFDdkIsZUFBZSxRQUFRO0FBQ3ZCLGdCQUFnQjtBQUNoQixpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QixlQUFlLFFBQVE7QUFDdkIsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsUUFBUTtBQUN2QixlQUFlLFFBQVE7QUFDdkIsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsUUFBUTtBQUN2QixlQUFlLFFBQVE7QUFDdkIsZUFBZSxRQUFRO0FBQ3ZCLGdCQUFnQjtBQUNoQixpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsU0FBUztBQUNUOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QixlQUFlLFFBQVE7QUFDdkIsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsUUFBUTtBQUN2QixlQUFlLFFBQVE7QUFDdkIsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsUUFBUTtBQUN2QixnQkFBZ0I7QUFDaEIsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsU0FBUztBQUNUOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkIsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsUUFBUTtBQUN2QixlQUFlLGNBQWM7QUFDN0IsZUFBZSxRQUFRO0FBQ3ZCLGdCQUFnQjtBQUNoQixpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsU0FBUztBQUNUOztB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QUFRO0FBQ3ZCLGVBQWUsUUFBUTtBQUN2QixlQUFlLFFBQVE7QUFDdkIsZ0JBQWdCO0FBQ2hCLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0EsaUNBQWlDLE9BQU8sbUJBQW1CLE9BQU87QUFDbEU7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFNBQVM7QUFDVDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsU0FBUztBQUN4QixnQkFBZ0I7QUFDaEIsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQSxpQ0FBaUMsT0FBTyx5QkFBeUIsT0FBTztBQUN4RTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsU0FBUztBQUNUOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkIsZUFBZSxTQUFTO0FBQ3hCLGdCQUFnQjtBQUNoQixpQkFBaUI7QUFDakI7QUFDQTtBQUNBLGlDQUFpQyxPQUFPLCtCQUErQixPQUFPO0FBQzlFO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTs7QUFFQSIsInNvdXJjZXMiOlsid2VicGFjazovL2pzbV9iYW5raW5nLy4vbm9kZV9tb2R1bGVzL25vZGUtYXBwd3JpdGUvbGliL3NlcnZpY2VzL3VzZXJzLmpzPzFjYzIiXSwic291cmNlc0NvbnRlbnQiOlsiY29uc3QgU2VydmljZSA9IHJlcXVpcmUoJy4uL3NlcnZpY2UuanMnKTtcbmNvbnN0IEFwcHdyaXRlRXhjZXB0aW9uID0gcmVxdWlyZSgnLi4vZXhjZXB0aW9uLmpzJyk7XG5jb25zdCBJbnB1dEZpbGUgPSByZXF1aXJlKCcuLi9pbnB1dEZpbGUuanMnKTtcbmNvbnN0IGNsaWVudCA9IHJlcXVpcmUoJy4uL2NsaWVudC5qcycpO1xuY29uc3QgU3RyZWFtID0gcmVxdWlyZSgnc3RyZWFtJyk7XG5jb25zdCB7IHByb21pc2lmeSB9ID0gcmVxdWlyZSgndXRpbCcpO1xuY29uc3QgZnMgPSByZXF1aXJlKCdmcycpO1xuY29uc3QgeyBGaWxlIH0gPSByZXF1aXJlKCd1bmRpY2knKTtcbmNvbnN0IFF1ZXJ5ID0gcmVxdWlyZSgnLi4vcXVlcnkuanMnKTtcblxuY2xhc3MgVXNlcnMgZXh0ZW5kcyBTZXJ2aWNlIHtcblxuICAgICBjb25zdHJ1Y3RvcihjbGllbnQpXG4gICAgIHtcbiAgICAgICAgc3VwZXIoY2xpZW50KTtcbiAgICAgfVxuXG5cbiAgICAvKipcbiAgICAgKiBMaXN0IHVzZXJzXG4gICAgICpcbiAgICAgKiBHZXQgYSBsaXN0IG9mIGFsbCB0aGUgcHJvamVjdCdzIHVzZXJzLiBZb3UgY2FuIHVzZSB0aGUgcXVlcnkgcGFyYW1zIHRvXG4gICAgICogZmlsdGVyIHlvdXIgcmVzdWx0cy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nW119IHF1ZXJpZXNcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gc2VhcmNoXG4gICAgICogQHRocm93cyB7QXBwd3JpdGVFeGNlcHRpb259XG4gICAgICogQHJldHVybnMge1Byb21pc2V9XG4gICAgICovXG4gICAgYXN5bmMgbGlzdChxdWVyaWVzLCBzZWFyY2gpIHtcbiAgICAgICAgY29uc3QgYXBpUGF0aCA9ICcvdXNlcnMnO1xuICAgICAgICBsZXQgcGF5bG9hZCA9IHt9O1xuXG4gICAgICAgIGlmICh0eXBlb2YgcXVlcmllcyAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHBheWxvYWRbJ3F1ZXJpZXMnXSA9IHF1ZXJpZXM7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodHlwZW9mIHNlYXJjaCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHBheWxvYWRbJ3NlYXJjaCddID0gc2VhcmNoO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMuY2xpZW50LmNhbGwoJ2dldCcsIGFwaVBhdGgsIHtcbiAgICAgICAgICAgICdjb250ZW50LXR5cGUnOiAnYXBwbGljYXRpb24vanNvbicsXG4gICAgICAgIH0sIHBheWxvYWQpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZSB1c2VyXG4gICAgICpcbiAgICAgKiBDcmVhdGUgYSBuZXcgdXNlci5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSB1c2VySWRcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gZW1haWxcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gcGhvbmVcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gcGFzc3dvcmRcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gbmFtZVxuICAgICAqIEB0aHJvd3Mge0FwcHdyaXRlRXhjZXB0aW9ufVxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlfVxuICAgICAqL1xuICAgIGFzeW5jIGNyZWF0ZSh1c2VySWQsIGVtYWlsLCBwaG9uZSwgcGFzc3dvcmQsIG5hbWUpIHtcbiAgICAgICAgY29uc3QgYXBpUGF0aCA9ICcvdXNlcnMnO1xuICAgICAgICBsZXQgcGF5bG9hZCA9IHt9O1xuICAgICAgICBpZiAodHlwZW9mIHVzZXJJZCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBBcHB3cml0ZUV4Y2VwdGlvbignTWlzc2luZyByZXF1aXJlZCBwYXJhbWV0ZXI6IFwidXNlcklkXCInKTtcbiAgICAgICAgfVxuXG5cbiAgICAgICAgaWYgKHR5cGVvZiB1c2VySWQgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICBwYXlsb2FkWyd1c2VySWQnXSA9IHVzZXJJZDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0eXBlb2YgZW1haWwgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICBwYXlsb2FkWydlbWFpbCddID0gZW1haWw7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodHlwZW9mIHBob25lICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgcGF5bG9hZFsncGhvbmUnXSA9IHBob25lO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHR5cGVvZiBwYXNzd29yZCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHBheWxvYWRbJ3Bhc3N3b3JkJ10gPSBwYXNzd29yZDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0eXBlb2YgbmFtZSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHBheWxvYWRbJ25hbWUnXSA9IG5hbWU7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy5jbGllbnQuY2FsbCgncG9zdCcsIGFwaVBhdGgsIHtcbiAgICAgICAgICAgICdjb250ZW50LXR5cGUnOiAnYXBwbGljYXRpb24vanNvbicsXG4gICAgICAgIH0sIHBheWxvYWQpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZSB1c2VyIHdpdGggQXJnb24yIHBhc3N3b3JkXG4gICAgICpcbiAgICAgKiBDcmVhdGUgYSBuZXcgdXNlci4gUGFzc3dvcmQgcHJvdmlkZWQgbXVzdCBiZSBoYXNoZWQgd2l0aCB0aGVcbiAgICAgKiBbQXJnb24yXShodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9BcmdvbjIpIGFsZ29yaXRobS4gVXNlIHRoZSBbUE9TVFxuICAgICAqIC91c2Vyc10oaHR0cHM6Ly9hcHB3cml0ZS5pby9kb2NzL3NlcnZlci91c2VycyN1c2Vyc0NyZWF0ZSkgZW5kcG9pbnQgdG9cbiAgICAgKiBjcmVhdGUgdXNlcnMgd2l0aCBhIHBsYWluIHRleHQgcGFzc3dvcmQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gdXNlcklkXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGVtYWlsXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHBhc3N3b3JkXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IG5hbWVcbiAgICAgKiBAdGhyb3dzIHtBcHB3cml0ZUV4Y2VwdGlvbn1cbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZX1cbiAgICAgKi9cbiAgICBhc3luYyBjcmVhdGVBcmdvbjJVc2VyKHVzZXJJZCwgZW1haWwsIHBhc3N3b3JkLCBuYW1lKSB7XG4gICAgICAgIGNvbnN0IGFwaVBhdGggPSAnL3VzZXJzL2FyZ29uMic7XG4gICAgICAgIGxldCBwYXlsb2FkID0ge307XG4gICAgICAgIGlmICh0eXBlb2YgdXNlcklkID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEFwcHdyaXRlRXhjZXB0aW9uKCdNaXNzaW5nIHJlcXVpcmVkIHBhcmFtZXRlcjogXCJ1c2VySWRcIicpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHR5cGVvZiBlbWFpbCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBBcHB3cml0ZUV4Y2VwdGlvbignTWlzc2luZyByZXF1aXJlZCBwYXJhbWV0ZXI6IFwiZW1haWxcIicpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHR5cGVvZiBwYXNzd29yZCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBBcHB3cml0ZUV4Y2VwdGlvbignTWlzc2luZyByZXF1aXJlZCBwYXJhbWV0ZXI6IFwicGFzc3dvcmRcIicpO1xuICAgICAgICB9XG5cblxuICAgICAgICBpZiAodHlwZW9mIHVzZXJJZCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHBheWxvYWRbJ3VzZXJJZCddID0gdXNlcklkO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHR5cGVvZiBlbWFpbCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHBheWxvYWRbJ2VtYWlsJ10gPSBlbWFpbDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0eXBlb2YgcGFzc3dvcmQgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICBwYXlsb2FkWydwYXNzd29yZCddID0gcGFzc3dvcmQ7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodHlwZW9mIG5hbWUgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICBwYXlsb2FkWyduYW1lJ10gPSBuYW1lO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMuY2xpZW50LmNhbGwoJ3Bvc3QnLCBhcGlQYXRoLCB7XG4gICAgICAgICAgICAnY29udGVudC10eXBlJzogJ2FwcGxpY2F0aW9uL2pzb24nLFxuICAgICAgICB9LCBwYXlsb2FkKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGUgdXNlciB3aXRoIGJjcnlwdCBwYXNzd29yZFxuICAgICAqXG4gICAgICogQ3JlYXRlIGEgbmV3IHVzZXIuIFBhc3N3b3JkIHByb3ZpZGVkIG11c3QgYmUgaGFzaGVkIHdpdGggdGhlXG4gICAgICogW0JjcnlwdF0oaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvQmNyeXB0KSBhbGdvcml0aG0uIFVzZSB0aGUgW1BPU1RcbiAgICAgKiAvdXNlcnNdKGh0dHBzOi8vYXBwd3JpdGUuaW8vZG9jcy9zZXJ2ZXIvdXNlcnMjdXNlcnNDcmVhdGUpIGVuZHBvaW50IHRvXG4gICAgICogY3JlYXRlIHVzZXJzIHdpdGggYSBwbGFpbiB0ZXh0IHBhc3N3b3JkLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHVzZXJJZFxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBlbWFpbFxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBwYXNzd29yZFxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lXG4gICAgICogQHRocm93cyB7QXBwd3JpdGVFeGNlcHRpb259XG4gICAgICogQHJldHVybnMge1Byb21pc2V9XG4gICAgICovXG4gICAgYXN5bmMgY3JlYXRlQmNyeXB0VXNlcih1c2VySWQsIGVtYWlsLCBwYXNzd29yZCwgbmFtZSkge1xuICAgICAgICBjb25zdCBhcGlQYXRoID0gJy91c2Vycy9iY3J5cHQnO1xuICAgICAgICBsZXQgcGF5bG9hZCA9IHt9O1xuICAgICAgICBpZiAodHlwZW9mIHVzZXJJZCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBBcHB3cml0ZUV4Y2VwdGlvbignTWlzc2luZyByZXF1aXJlZCBwYXJhbWV0ZXI6IFwidXNlcklkXCInKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0eXBlb2YgZW1haWwgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgQXBwd3JpdGVFeGNlcHRpb24oJ01pc3NpbmcgcmVxdWlyZWQgcGFyYW1ldGVyOiBcImVtYWlsXCInKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0eXBlb2YgcGFzc3dvcmQgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgQXBwd3JpdGVFeGNlcHRpb24oJ01pc3NpbmcgcmVxdWlyZWQgcGFyYW1ldGVyOiBcInBhc3N3b3JkXCInKTtcbiAgICAgICAgfVxuXG5cbiAgICAgICAgaWYgKHR5cGVvZiB1c2VySWQgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICBwYXlsb2FkWyd1c2VySWQnXSA9IHVzZXJJZDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0eXBlb2YgZW1haWwgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICBwYXlsb2FkWydlbWFpbCddID0gZW1haWw7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodHlwZW9mIHBhc3N3b3JkICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgcGF5bG9hZFsncGFzc3dvcmQnXSA9IHBhc3N3b3JkO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHR5cGVvZiBuYW1lICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgcGF5bG9hZFsnbmFtZSddID0gbmFtZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBhd2FpdCB0aGlzLmNsaWVudC5jYWxsKCdwb3N0JywgYXBpUGF0aCwge1xuICAgICAgICAgICAgJ2NvbnRlbnQtdHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJyxcbiAgICAgICAgfSwgcGF5bG9hZCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogTGlzdCBJZGVudGl0aWVzXG4gICAgICpcbiAgICAgKiBHZXQgaWRlbnRpdGllcyBmb3IgYWxsIHVzZXJzLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmdbXX0gcXVlcmllc1xuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBzZWFyY2hcbiAgICAgKiBAdGhyb3dzIHtBcHB3cml0ZUV4Y2VwdGlvbn1cbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZX1cbiAgICAgKi9cbiAgICBhc3luYyBsaXN0SWRlbnRpdGllcyhxdWVyaWVzLCBzZWFyY2gpIHtcbiAgICAgICAgY29uc3QgYXBpUGF0aCA9ICcvdXNlcnMvaWRlbnRpdGllcyc7XG4gICAgICAgIGxldCBwYXlsb2FkID0ge307XG5cbiAgICAgICAgaWYgKHR5cGVvZiBxdWVyaWVzICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgcGF5bG9hZFsncXVlcmllcyddID0gcXVlcmllcztcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0eXBlb2Ygc2VhcmNoICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgcGF5bG9hZFsnc2VhcmNoJ10gPSBzZWFyY2g7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy5jbGllbnQuY2FsbCgnZ2V0JywgYXBpUGF0aCwge1xuICAgICAgICAgICAgJ2NvbnRlbnQtdHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJyxcbiAgICAgICAgfSwgcGF5bG9hZCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRGVsZXRlIGlkZW50aXR5XG4gICAgICpcbiAgICAgKiBEZWxldGUgYW4gaWRlbnRpdHkgYnkgaXRzIHVuaXF1ZSBJRC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBpZGVudGl0eUlkXG4gICAgICogQHRocm93cyB7QXBwd3JpdGVFeGNlcHRpb259XG4gICAgICogQHJldHVybnMge1Byb21pc2V9XG4gICAgICovXG4gICAgYXN5bmMgZGVsZXRlSWRlbnRpdHkoaWRlbnRpdHlJZCkge1xuICAgICAgICBjb25zdCBhcGlQYXRoID0gJy91c2Vycy9pZGVudGl0aWVzL3tpZGVudGl0eUlkfScucmVwbGFjZSgne2lkZW50aXR5SWR9JywgaWRlbnRpdHlJZCk7XG4gICAgICAgIGxldCBwYXlsb2FkID0ge307XG4gICAgICAgIGlmICh0eXBlb2YgaWRlbnRpdHlJZCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBBcHB3cml0ZUV4Y2VwdGlvbignTWlzc2luZyByZXF1aXJlZCBwYXJhbWV0ZXI6IFwiaWRlbnRpdHlJZFwiJyk7XG4gICAgICAgIH1cblxuXG4gICAgICAgIHJldHVybiBhd2FpdCB0aGlzLmNsaWVudC5jYWxsKCdkZWxldGUnLCBhcGlQYXRoLCB7XG4gICAgICAgICAgICAnY29udGVudC10eXBlJzogJ2FwcGxpY2F0aW9uL2pzb24nLFxuICAgICAgICB9LCBwYXlsb2FkKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGUgdXNlciB3aXRoIE1ENSBwYXNzd29yZFxuICAgICAqXG4gICAgICogQ3JlYXRlIGEgbmV3IHVzZXIuIFBhc3N3b3JkIHByb3ZpZGVkIG11c3QgYmUgaGFzaGVkIHdpdGggdGhlXG4gICAgICogW01ENV0oaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvTUQ1KSBhbGdvcml0aG0uIFVzZSB0aGUgW1BPU1RcbiAgICAgKiAvdXNlcnNdKGh0dHBzOi8vYXBwd3JpdGUuaW8vZG9jcy9zZXJ2ZXIvdXNlcnMjdXNlcnNDcmVhdGUpIGVuZHBvaW50IHRvXG4gICAgICogY3JlYXRlIHVzZXJzIHdpdGggYSBwbGFpbiB0ZXh0IHBhc3N3b3JkLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHVzZXJJZFxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBlbWFpbFxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBwYXNzd29yZFxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lXG4gICAgICogQHRocm93cyB7QXBwd3JpdGVFeGNlcHRpb259XG4gICAgICogQHJldHVybnMge1Byb21pc2V9XG4gICAgICovXG4gICAgYXN5bmMgY3JlYXRlTUQ1VXNlcih1c2VySWQsIGVtYWlsLCBwYXNzd29yZCwgbmFtZSkge1xuICAgICAgICBjb25zdCBhcGlQYXRoID0gJy91c2Vycy9tZDUnO1xuICAgICAgICBsZXQgcGF5bG9hZCA9IHt9O1xuICAgICAgICBpZiAodHlwZW9mIHVzZXJJZCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBBcHB3cml0ZUV4Y2VwdGlvbignTWlzc2luZyByZXF1aXJlZCBwYXJhbWV0ZXI6IFwidXNlcklkXCInKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0eXBlb2YgZW1haWwgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgQXBwd3JpdGVFeGNlcHRpb24oJ01pc3NpbmcgcmVxdWlyZWQgcGFyYW1ldGVyOiBcImVtYWlsXCInKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0eXBlb2YgcGFzc3dvcmQgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgQXBwd3JpdGVFeGNlcHRpb24oJ01pc3NpbmcgcmVxdWlyZWQgcGFyYW1ldGVyOiBcInBhc3N3b3JkXCInKTtcbiAgICAgICAgfVxuXG5cbiAgICAgICAgaWYgKHR5cGVvZiB1c2VySWQgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICBwYXlsb2FkWyd1c2VySWQnXSA9IHVzZXJJZDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0eXBlb2YgZW1haWwgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICBwYXlsb2FkWydlbWFpbCddID0gZW1haWw7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodHlwZW9mIHBhc3N3b3JkICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgcGF5bG9hZFsncGFzc3dvcmQnXSA9IHBhc3N3b3JkO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHR5cGVvZiBuYW1lICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgcGF5bG9hZFsnbmFtZSddID0gbmFtZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBhd2FpdCB0aGlzLmNsaWVudC5jYWxsKCdwb3N0JywgYXBpUGF0aCwge1xuICAgICAgICAgICAgJ2NvbnRlbnQtdHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJyxcbiAgICAgICAgfSwgcGF5bG9hZCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlIHVzZXIgd2l0aCBQSFBhc3MgcGFzc3dvcmRcbiAgICAgKlxuICAgICAqIENyZWF0ZSBhIG5ldyB1c2VyLiBQYXNzd29yZCBwcm92aWRlZCBtdXN0IGJlIGhhc2hlZCB3aXRoIHRoZVxuICAgICAqIFtQSFBhc3NdKGh0dHBzOi8vd3d3Lm9wZW53YWxsLmNvbS9waHBhc3MvKSBhbGdvcml0aG0uIFVzZSB0aGUgW1BPU1RcbiAgICAgKiAvdXNlcnNdKGh0dHBzOi8vYXBwd3JpdGUuaW8vZG9jcy9zZXJ2ZXIvdXNlcnMjdXNlcnNDcmVhdGUpIGVuZHBvaW50IHRvXG4gICAgICogY3JlYXRlIHVzZXJzIHdpdGggYSBwbGFpbiB0ZXh0IHBhc3N3b3JkLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHVzZXJJZFxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBlbWFpbFxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBwYXNzd29yZFxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lXG4gICAgICogQHRocm93cyB7QXBwd3JpdGVFeGNlcHRpb259XG4gICAgICogQHJldHVybnMge1Byb21pc2V9XG4gICAgICovXG4gICAgYXN5bmMgY3JlYXRlUEhQYXNzVXNlcih1c2VySWQsIGVtYWlsLCBwYXNzd29yZCwgbmFtZSkge1xuICAgICAgICBjb25zdCBhcGlQYXRoID0gJy91c2Vycy9waHBhc3MnO1xuICAgICAgICBsZXQgcGF5bG9hZCA9IHt9O1xuICAgICAgICBpZiAodHlwZW9mIHVzZXJJZCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBBcHB3cml0ZUV4Y2VwdGlvbignTWlzc2luZyByZXF1aXJlZCBwYXJhbWV0ZXI6IFwidXNlcklkXCInKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0eXBlb2YgZW1haWwgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgQXBwd3JpdGVFeGNlcHRpb24oJ01pc3NpbmcgcmVxdWlyZWQgcGFyYW1ldGVyOiBcImVtYWlsXCInKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0eXBlb2YgcGFzc3dvcmQgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgQXBwd3JpdGVFeGNlcHRpb24oJ01pc3NpbmcgcmVxdWlyZWQgcGFyYW1ldGVyOiBcInBhc3N3b3JkXCInKTtcbiAgICAgICAgfVxuXG5cbiAgICAgICAgaWYgKHR5cGVvZiB1c2VySWQgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICBwYXlsb2FkWyd1c2VySWQnXSA9IHVzZXJJZDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0eXBlb2YgZW1haWwgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICBwYXlsb2FkWydlbWFpbCddID0gZW1haWw7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodHlwZW9mIHBhc3N3b3JkICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgcGF5bG9hZFsncGFzc3dvcmQnXSA9IHBhc3N3b3JkO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHR5cGVvZiBuYW1lICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgcGF5bG9hZFsnbmFtZSddID0gbmFtZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBhd2FpdCB0aGlzLmNsaWVudC5jYWxsKCdwb3N0JywgYXBpUGF0aCwge1xuICAgICAgICAgICAgJ2NvbnRlbnQtdHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJyxcbiAgICAgICAgfSwgcGF5bG9hZCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlIHVzZXIgd2l0aCBTY3J5cHQgcGFzc3dvcmRcbiAgICAgKlxuICAgICAqIENyZWF0ZSBhIG5ldyB1c2VyLiBQYXNzd29yZCBwcm92aWRlZCBtdXN0IGJlIGhhc2hlZCB3aXRoIHRoZVxuICAgICAqIFtTY3J5cHRdKGh0dHBzOi8vZ2l0aHViLmNvbS9UYXJzbmFwL3NjcnlwdCkgYWxnb3JpdGhtLiBVc2UgdGhlIFtQT1NUXG4gICAgICogL3VzZXJzXShodHRwczovL2FwcHdyaXRlLmlvL2RvY3Mvc2VydmVyL3VzZXJzI3VzZXJzQ3JlYXRlKSBlbmRwb2ludCB0b1xuICAgICAqIGNyZWF0ZSB1c2VycyB3aXRoIGEgcGxhaW4gdGV4dCBwYXNzd29yZC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSB1c2VySWRcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gZW1haWxcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gcGFzc3dvcmRcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gcGFzc3dvcmRTYWx0XG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHBhc3N3b3JkQ3B1XG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHBhc3N3b3JkTWVtb3J5XG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHBhc3N3b3JkUGFyYWxsZWxcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gcGFzc3dvcmRMZW5ndGhcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gbmFtZVxuICAgICAqIEB0aHJvd3Mge0FwcHdyaXRlRXhjZXB0aW9ufVxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlfVxuICAgICAqL1xuICAgIGFzeW5jIGNyZWF0ZVNjcnlwdFVzZXIodXNlcklkLCBlbWFpbCwgcGFzc3dvcmQsIHBhc3N3b3JkU2FsdCwgcGFzc3dvcmRDcHUsIHBhc3N3b3JkTWVtb3J5LCBwYXNzd29yZFBhcmFsbGVsLCBwYXNzd29yZExlbmd0aCwgbmFtZSkge1xuICAgICAgICBjb25zdCBhcGlQYXRoID0gJy91c2Vycy9zY3J5cHQnO1xuICAgICAgICBsZXQgcGF5bG9hZCA9IHt9O1xuICAgICAgICBpZiAodHlwZW9mIHVzZXJJZCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBBcHB3cml0ZUV4Y2VwdGlvbignTWlzc2luZyByZXF1aXJlZCBwYXJhbWV0ZXI6IFwidXNlcklkXCInKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0eXBlb2YgZW1haWwgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgQXBwd3JpdGVFeGNlcHRpb24oJ01pc3NpbmcgcmVxdWlyZWQgcGFyYW1ldGVyOiBcImVtYWlsXCInKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0eXBlb2YgcGFzc3dvcmQgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgQXBwd3JpdGVFeGNlcHRpb24oJ01pc3NpbmcgcmVxdWlyZWQgcGFyYW1ldGVyOiBcInBhc3N3b3JkXCInKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0eXBlb2YgcGFzc3dvcmRTYWx0ID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEFwcHdyaXRlRXhjZXB0aW9uKCdNaXNzaW5nIHJlcXVpcmVkIHBhcmFtZXRlcjogXCJwYXNzd29yZFNhbHRcIicpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHR5cGVvZiBwYXNzd29yZENwdSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBBcHB3cml0ZUV4Y2VwdGlvbignTWlzc2luZyByZXF1aXJlZCBwYXJhbWV0ZXI6IFwicGFzc3dvcmRDcHVcIicpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHR5cGVvZiBwYXNzd29yZE1lbW9yeSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBBcHB3cml0ZUV4Y2VwdGlvbignTWlzc2luZyByZXF1aXJlZCBwYXJhbWV0ZXI6IFwicGFzc3dvcmRNZW1vcnlcIicpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHR5cGVvZiBwYXNzd29yZFBhcmFsbGVsID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEFwcHdyaXRlRXhjZXB0aW9uKCdNaXNzaW5nIHJlcXVpcmVkIHBhcmFtZXRlcjogXCJwYXNzd29yZFBhcmFsbGVsXCInKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0eXBlb2YgcGFzc3dvcmRMZW5ndGggPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgQXBwd3JpdGVFeGNlcHRpb24oJ01pc3NpbmcgcmVxdWlyZWQgcGFyYW1ldGVyOiBcInBhc3N3b3JkTGVuZ3RoXCInKTtcbiAgICAgICAgfVxuXG5cbiAgICAgICAgaWYgKHR5cGVvZiB1c2VySWQgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICBwYXlsb2FkWyd1c2VySWQnXSA9IHVzZXJJZDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0eXBlb2YgZW1haWwgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICBwYXlsb2FkWydlbWFpbCddID0gZW1haWw7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodHlwZW9mIHBhc3N3b3JkICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgcGF5bG9hZFsncGFzc3dvcmQnXSA9IHBhc3N3b3JkO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHR5cGVvZiBwYXNzd29yZFNhbHQgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICBwYXlsb2FkWydwYXNzd29yZFNhbHQnXSA9IHBhc3N3b3JkU2FsdDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0eXBlb2YgcGFzc3dvcmRDcHUgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICBwYXlsb2FkWydwYXNzd29yZENwdSddID0gcGFzc3dvcmRDcHU7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodHlwZW9mIHBhc3N3b3JkTWVtb3J5ICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgcGF5bG9hZFsncGFzc3dvcmRNZW1vcnknXSA9IHBhc3N3b3JkTWVtb3J5O1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHR5cGVvZiBwYXNzd29yZFBhcmFsbGVsICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgcGF5bG9hZFsncGFzc3dvcmRQYXJhbGxlbCddID0gcGFzc3dvcmRQYXJhbGxlbDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0eXBlb2YgcGFzc3dvcmRMZW5ndGggIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICBwYXlsb2FkWydwYXNzd29yZExlbmd0aCddID0gcGFzc3dvcmRMZW5ndGg7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodHlwZW9mIG5hbWUgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICBwYXlsb2FkWyduYW1lJ10gPSBuYW1lO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMuY2xpZW50LmNhbGwoJ3Bvc3QnLCBhcGlQYXRoLCB7XG4gICAgICAgICAgICAnY29udGVudC10eXBlJzogJ2FwcGxpY2F0aW9uL2pzb24nLFxuICAgICAgICB9LCBwYXlsb2FkKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGUgdXNlciB3aXRoIFNjcnlwdCBtb2RpZmllZCBwYXNzd29yZFxuICAgICAqXG4gICAgICogQ3JlYXRlIGEgbmV3IHVzZXIuIFBhc3N3b3JkIHByb3ZpZGVkIG11c3QgYmUgaGFzaGVkIHdpdGggdGhlIFtTY3J5cHRcbiAgICAgKiBNb2RpZmllZF0oaHR0cHM6Ly9naXN0LmdpdGh1Yi5jb20vTWVsZGlyb24vZWVjZjg0YTAyMjVlY2NiNWEzNzhkNDViYjI3NDYyY2MpXG4gICAgICogYWxnb3JpdGhtLiBVc2UgdGhlIFtQT1NUXG4gICAgICogL3VzZXJzXShodHRwczovL2FwcHdyaXRlLmlvL2RvY3Mvc2VydmVyL3VzZXJzI3VzZXJzQ3JlYXRlKSBlbmRwb2ludCB0b1xuICAgICAqIGNyZWF0ZSB1c2VycyB3aXRoIGEgcGxhaW4gdGV4dCBwYXNzd29yZC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSB1c2VySWRcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gZW1haWxcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gcGFzc3dvcmRcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gcGFzc3dvcmRTYWx0XG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHBhc3N3b3JkU2FsdFNlcGFyYXRvclxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBwYXNzd29yZFNpZ25lcktleVxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lXG4gICAgICogQHRocm93cyB7QXBwd3JpdGVFeGNlcHRpb259XG4gICAgICogQHJldHVybnMge1Byb21pc2V9XG4gICAgICovXG4gICAgYXN5bmMgY3JlYXRlU2NyeXB0TW9kaWZpZWRVc2VyKHVzZXJJZCwgZW1haWwsIHBhc3N3b3JkLCBwYXNzd29yZFNhbHQsIHBhc3N3b3JkU2FsdFNlcGFyYXRvciwgcGFzc3dvcmRTaWduZXJLZXksIG5hbWUpIHtcbiAgICAgICAgY29uc3QgYXBpUGF0aCA9ICcvdXNlcnMvc2NyeXB0LW1vZGlmaWVkJztcbiAgICAgICAgbGV0IHBheWxvYWQgPSB7fTtcbiAgICAgICAgaWYgKHR5cGVvZiB1c2VySWQgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgQXBwd3JpdGVFeGNlcHRpb24oJ01pc3NpbmcgcmVxdWlyZWQgcGFyYW1ldGVyOiBcInVzZXJJZFwiJyk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodHlwZW9mIGVtYWlsID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEFwcHdyaXRlRXhjZXB0aW9uKCdNaXNzaW5nIHJlcXVpcmVkIHBhcmFtZXRlcjogXCJlbWFpbFwiJyk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodHlwZW9mIHBhc3N3b3JkID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEFwcHdyaXRlRXhjZXB0aW9uKCdNaXNzaW5nIHJlcXVpcmVkIHBhcmFtZXRlcjogXCJwYXNzd29yZFwiJyk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodHlwZW9mIHBhc3N3b3JkU2FsdCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBBcHB3cml0ZUV4Y2VwdGlvbignTWlzc2luZyByZXF1aXJlZCBwYXJhbWV0ZXI6IFwicGFzc3dvcmRTYWx0XCInKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0eXBlb2YgcGFzc3dvcmRTYWx0U2VwYXJhdG9yID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEFwcHdyaXRlRXhjZXB0aW9uKCdNaXNzaW5nIHJlcXVpcmVkIHBhcmFtZXRlcjogXCJwYXNzd29yZFNhbHRTZXBhcmF0b3JcIicpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHR5cGVvZiBwYXNzd29yZFNpZ25lcktleSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBBcHB3cml0ZUV4Y2VwdGlvbignTWlzc2luZyByZXF1aXJlZCBwYXJhbWV0ZXI6IFwicGFzc3dvcmRTaWduZXJLZXlcIicpO1xuICAgICAgICB9XG5cblxuICAgICAgICBpZiAodHlwZW9mIHVzZXJJZCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHBheWxvYWRbJ3VzZXJJZCddID0gdXNlcklkO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHR5cGVvZiBlbWFpbCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHBheWxvYWRbJ2VtYWlsJ10gPSBlbWFpbDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0eXBlb2YgcGFzc3dvcmQgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICBwYXlsb2FkWydwYXNzd29yZCddID0gcGFzc3dvcmQ7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodHlwZW9mIHBhc3N3b3JkU2FsdCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHBheWxvYWRbJ3Bhc3N3b3JkU2FsdCddID0gcGFzc3dvcmRTYWx0O1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHR5cGVvZiBwYXNzd29yZFNhbHRTZXBhcmF0b3IgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICBwYXlsb2FkWydwYXNzd29yZFNhbHRTZXBhcmF0b3InXSA9IHBhc3N3b3JkU2FsdFNlcGFyYXRvcjtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0eXBlb2YgcGFzc3dvcmRTaWduZXJLZXkgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICBwYXlsb2FkWydwYXNzd29yZFNpZ25lcktleSddID0gcGFzc3dvcmRTaWduZXJLZXk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodHlwZW9mIG5hbWUgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICBwYXlsb2FkWyduYW1lJ10gPSBuYW1lO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMuY2xpZW50LmNhbGwoJ3Bvc3QnLCBhcGlQYXRoLCB7XG4gICAgICAgICAgICAnY29udGVudC10eXBlJzogJ2FwcGxpY2F0aW9uL2pzb24nLFxuICAgICAgICB9LCBwYXlsb2FkKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGUgdXNlciB3aXRoIFNIQSBwYXNzd29yZFxuICAgICAqXG4gICAgICogQ3JlYXRlIGEgbmV3IHVzZXIuIFBhc3N3b3JkIHByb3ZpZGVkIG11c3QgYmUgaGFzaGVkIHdpdGggdGhlXG4gICAgICogW1NIQV0oaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvU2VjdXJlX0hhc2hfQWxnb3JpdGhtKSBhbGdvcml0aG0uIFVzZVxuICAgICAqIHRoZSBbUE9TVCAvdXNlcnNdKGh0dHBzOi8vYXBwd3JpdGUuaW8vZG9jcy9zZXJ2ZXIvdXNlcnMjdXNlcnNDcmVhdGUpXG4gICAgICogZW5kcG9pbnQgdG8gY3JlYXRlIHVzZXJzIHdpdGggYSBwbGFpbiB0ZXh0IHBhc3N3b3JkLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHVzZXJJZFxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBlbWFpbFxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBwYXNzd29yZFxuICAgICAqIEBwYXJhbSB7UGFzc3dvcmRIYXNofSBwYXNzd29yZFZlcnNpb25cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gbmFtZVxuICAgICAqIEB0aHJvd3Mge0FwcHdyaXRlRXhjZXB0aW9ufVxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlfVxuICAgICAqL1xuICAgIGFzeW5jIGNyZWF0ZVNIQVVzZXIodXNlcklkLCBlbWFpbCwgcGFzc3dvcmQsIHBhc3N3b3JkVmVyc2lvbiwgbmFtZSkge1xuICAgICAgICBjb25zdCBhcGlQYXRoID0gJy91c2Vycy9zaGEnO1xuICAgICAgICBsZXQgcGF5bG9hZCA9IHt9O1xuICAgICAgICBpZiAodHlwZW9mIHVzZXJJZCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBBcHB3cml0ZUV4Y2VwdGlvbignTWlzc2luZyByZXF1aXJlZCBwYXJhbWV0ZXI6IFwidXNlcklkXCInKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0eXBlb2YgZW1haWwgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgQXBwd3JpdGVFeGNlcHRpb24oJ01pc3NpbmcgcmVxdWlyZWQgcGFyYW1ldGVyOiBcImVtYWlsXCInKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0eXBlb2YgcGFzc3dvcmQgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgQXBwd3JpdGVFeGNlcHRpb24oJ01pc3NpbmcgcmVxdWlyZWQgcGFyYW1ldGVyOiBcInBhc3N3b3JkXCInKTtcbiAgICAgICAgfVxuXG5cbiAgICAgICAgaWYgKHR5cGVvZiB1c2VySWQgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICBwYXlsb2FkWyd1c2VySWQnXSA9IHVzZXJJZDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0eXBlb2YgZW1haWwgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICBwYXlsb2FkWydlbWFpbCddID0gZW1haWw7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodHlwZW9mIHBhc3N3b3JkICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgcGF5bG9hZFsncGFzc3dvcmQnXSA9IHBhc3N3b3JkO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHR5cGVvZiBwYXNzd29yZFZlcnNpb24gIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICBwYXlsb2FkWydwYXNzd29yZFZlcnNpb24nXSA9IHBhc3N3b3JkVmVyc2lvbjtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0eXBlb2YgbmFtZSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHBheWxvYWRbJ25hbWUnXSA9IG5hbWU7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy5jbGllbnQuY2FsbCgncG9zdCcsIGFwaVBhdGgsIHtcbiAgICAgICAgICAgICdjb250ZW50LXR5cGUnOiAnYXBwbGljYXRpb24vanNvbicsXG4gICAgICAgIH0sIHBheWxvYWQpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdldCB1c2VyXG4gICAgICpcbiAgICAgKiBHZXQgYSB1c2VyIGJ5IGl0cyB1bmlxdWUgSUQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gdXNlcklkXG4gICAgICogQHRocm93cyB7QXBwd3JpdGVFeGNlcHRpb259XG4gICAgICogQHJldHVybnMge1Byb21pc2V9XG4gICAgICovXG4gICAgYXN5bmMgZ2V0KHVzZXJJZCkge1xuICAgICAgICBjb25zdCBhcGlQYXRoID0gJy91c2Vycy97dXNlcklkfScucmVwbGFjZSgne3VzZXJJZH0nLCB1c2VySWQpO1xuICAgICAgICBsZXQgcGF5bG9hZCA9IHt9O1xuICAgICAgICBpZiAodHlwZW9mIHVzZXJJZCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBBcHB3cml0ZUV4Y2VwdGlvbignTWlzc2luZyByZXF1aXJlZCBwYXJhbWV0ZXI6IFwidXNlcklkXCInKTtcbiAgICAgICAgfVxuXG5cbiAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMuY2xpZW50LmNhbGwoJ2dldCcsIGFwaVBhdGgsIHtcbiAgICAgICAgICAgICdjb250ZW50LXR5cGUnOiAnYXBwbGljYXRpb24vanNvbicsXG4gICAgICAgIH0sIHBheWxvYWQpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIERlbGV0ZSB1c2VyXG4gICAgICpcbiAgICAgKiBEZWxldGUgYSB1c2VyIGJ5IGl0cyB1bmlxdWUgSUQsIHRoZXJlYnkgcmVsZWFzaW5nIGl0J3MgSUQuIFNpbmNlIElEIGlzXG4gICAgICogcmVsZWFzZWQgYW5kIGNhbiBiZSByZXVzZWQsIGFsbCB1c2VyLXJlbGF0ZWQgcmVzb3VyY2VzIGxpa2UgZG9jdW1lbnRzIG9yXG4gICAgICogc3RvcmFnZSBmaWxlcyBzaG91bGQgYmUgZGVsZXRlZCBiZWZvcmUgdXNlciBkZWxldGlvbi4gSWYgeW91IHdhbnQgdG8ga2VlcFxuICAgICAqIElEIHJlc2VydmVkLCB1c2UgdGhlXG4gICAgICogW3VwZGF0ZVN0YXR1c10oaHR0cHM6Ly9hcHB3cml0ZS5pby9kb2NzL3NlcnZlci91c2VycyN1c2Vyc1VwZGF0ZVN0YXR1cylcbiAgICAgKiBlbmRwb2ludCBpbnN0ZWFkLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHVzZXJJZFxuICAgICAqIEB0aHJvd3Mge0FwcHdyaXRlRXhjZXB0aW9ufVxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlfVxuICAgICAqL1xuICAgIGFzeW5jIGRlbGV0ZSh1c2VySWQpIHtcbiAgICAgICAgY29uc3QgYXBpUGF0aCA9ICcvdXNlcnMve3VzZXJJZH0nLnJlcGxhY2UoJ3t1c2VySWR9JywgdXNlcklkKTtcbiAgICAgICAgbGV0IHBheWxvYWQgPSB7fTtcbiAgICAgICAgaWYgKHR5cGVvZiB1c2VySWQgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgQXBwd3JpdGVFeGNlcHRpb24oJ01pc3NpbmcgcmVxdWlyZWQgcGFyYW1ldGVyOiBcInVzZXJJZFwiJyk7XG4gICAgICAgIH1cblxuXG4gICAgICAgIHJldHVybiBhd2FpdCB0aGlzLmNsaWVudC5jYWxsKCdkZWxldGUnLCBhcGlQYXRoLCB7XG4gICAgICAgICAgICAnY29udGVudC10eXBlJzogJ2FwcGxpY2F0aW9uL2pzb24nLFxuICAgICAgICB9LCBwYXlsb2FkKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBVcGRhdGUgZW1haWxcbiAgICAgKlxuICAgICAqIFVwZGF0ZSB0aGUgdXNlciBlbWFpbCBieSBpdHMgdW5pcXVlIElELlxuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHVzZXJJZFxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBlbWFpbFxuICAgICAqIEB0aHJvd3Mge0FwcHdyaXRlRXhjZXB0aW9ufVxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlfVxuICAgICAqL1xuICAgIGFzeW5jIHVwZGF0ZUVtYWlsKHVzZXJJZCwgZW1haWwpIHtcbiAgICAgICAgY29uc3QgYXBpUGF0aCA9ICcvdXNlcnMve3VzZXJJZH0vZW1haWwnLnJlcGxhY2UoJ3t1c2VySWR9JywgdXNlcklkKTtcbiAgICAgICAgbGV0IHBheWxvYWQgPSB7fTtcbiAgICAgICAgaWYgKHR5cGVvZiB1c2VySWQgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgQXBwd3JpdGVFeGNlcHRpb24oJ01pc3NpbmcgcmVxdWlyZWQgcGFyYW1ldGVyOiBcInVzZXJJZFwiJyk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodHlwZW9mIGVtYWlsID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEFwcHdyaXRlRXhjZXB0aW9uKCdNaXNzaW5nIHJlcXVpcmVkIHBhcmFtZXRlcjogXCJlbWFpbFwiJyk7XG4gICAgICAgIH1cblxuXG4gICAgICAgIGlmICh0eXBlb2YgZW1haWwgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICBwYXlsb2FkWydlbWFpbCddID0gZW1haWw7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy5jbGllbnQuY2FsbCgncGF0Y2gnLCBhcGlQYXRoLCB7XG4gICAgICAgICAgICAnY29udGVudC10eXBlJzogJ2FwcGxpY2F0aW9uL2pzb24nLFxuICAgICAgICB9LCBwYXlsb2FkKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBVcGRhdGUgdXNlciBsYWJlbHNcbiAgICAgKlxuICAgICAqIFVwZGF0ZSB0aGUgdXNlciBsYWJlbHMgYnkgaXRzIHVuaXF1ZSBJRC4gXG4gICAgICogXG4gICAgICogTGFiZWxzIGNhbiBiZSB1c2VkIHRvIGdyYW50IGFjY2VzcyB0byByZXNvdXJjZXMuIFdoaWxlIHRlYW1zIGFyZSBhIHdheSBmb3JcbiAgICAgKiB1c2VyJ3MgdG8gc2hhcmUgYWNjZXNzIHRvIGEgcmVzb3VyY2UsIGxhYmVscyBjYW4gYmUgZGVmaW5lZCBieSB0aGVcbiAgICAgKiBkZXZlbG9wZXIgdG8gZ3JhbnQgYWNjZXNzIHdpdGhvdXQgYW4gaW52aXRhdGlvbi4gU2VlIHRoZSBbUGVybWlzc2lvbnNcbiAgICAgKiBkb2NzXShodHRwczovL2FwcHdyaXRlLmlvL2RvY3MvcGVybWlzc2lvbnMpIGZvciBtb3JlIGluZm8uXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gdXNlcklkXG4gICAgICogQHBhcmFtIHtzdHJpbmdbXX0gbGFiZWxzXG4gICAgICogQHRocm93cyB7QXBwd3JpdGVFeGNlcHRpb259XG4gICAgICogQHJldHVybnMge1Byb21pc2V9XG4gICAgICovXG4gICAgYXN5bmMgdXBkYXRlTGFiZWxzKHVzZXJJZCwgbGFiZWxzKSB7XG4gICAgICAgIGNvbnN0IGFwaVBhdGggPSAnL3VzZXJzL3t1c2VySWR9L2xhYmVscycucmVwbGFjZSgne3VzZXJJZH0nLCB1c2VySWQpO1xuICAgICAgICBsZXQgcGF5bG9hZCA9IHt9O1xuICAgICAgICBpZiAodHlwZW9mIHVzZXJJZCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBBcHB3cml0ZUV4Y2VwdGlvbignTWlzc2luZyByZXF1aXJlZCBwYXJhbWV0ZXI6IFwidXNlcklkXCInKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0eXBlb2YgbGFiZWxzID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEFwcHdyaXRlRXhjZXB0aW9uKCdNaXNzaW5nIHJlcXVpcmVkIHBhcmFtZXRlcjogXCJsYWJlbHNcIicpO1xuICAgICAgICB9XG5cblxuICAgICAgICBpZiAodHlwZW9mIGxhYmVscyAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHBheWxvYWRbJ2xhYmVscyddID0gbGFiZWxzO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMuY2xpZW50LmNhbGwoJ3B1dCcsIGFwaVBhdGgsIHtcbiAgICAgICAgICAgICdjb250ZW50LXR5cGUnOiAnYXBwbGljYXRpb24vanNvbicsXG4gICAgICAgIH0sIHBheWxvYWQpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIExpc3QgdXNlciBsb2dzXG4gICAgICpcbiAgICAgKiBHZXQgdGhlIHVzZXIgYWN0aXZpdHkgbG9ncyBsaXN0IGJ5IGl0cyB1bmlxdWUgSUQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gdXNlcklkXG4gICAgICogQHBhcmFtIHtzdHJpbmdbXX0gcXVlcmllc1xuICAgICAqIEB0aHJvd3Mge0FwcHdyaXRlRXhjZXB0aW9ufVxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlfVxuICAgICAqL1xuICAgIGFzeW5jIGxpc3RMb2dzKHVzZXJJZCwgcXVlcmllcykge1xuICAgICAgICBjb25zdCBhcGlQYXRoID0gJy91c2Vycy97dXNlcklkfS9sb2dzJy5yZXBsYWNlKCd7dXNlcklkfScsIHVzZXJJZCk7XG4gICAgICAgIGxldCBwYXlsb2FkID0ge307XG4gICAgICAgIGlmICh0eXBlb2YgdXNlcklkID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEFwcHdyaXRlRXhjZXB0aW9uKCdNaXNzaW5nIHJlcXVpcmVkIHBhcmFtZXRlcjogXCJ1c2VySWRcIicpO1xuICAgICAgICB9XG5cblxuICAgICAgICBpZiAodHlwZW9mIHF1ZXJpZXMgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICBwYXlsb2FkWydxdWVyaWVzJ10gPSBxdWVyaWVzO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMuY2xpZW50LmNhbGwoJ2dldCcsIGFwaVBhdGgsIHtcbiAgICAgICAgICAgICdjb250ZW50LXR5cGUnOiAnYXBwbGljYXRpb24vanNvbicsXG4gICAgICAgIH0sIHBheWxvYWQpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIExpc3QgdXNlciBtZW1iZXJzaGlwc1xuICAgICAqXG4gICAgICogR2V0IHRoZSB1c2VyIG1lbWJlcnNoaXAgbGlzdCBieSBpdHMgdW5pcXVlIElELlxuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHVzZXJJZFxuICAgICAqIEB0aHJvd3Mge0FwcHdyaXRlRXhjZXB0aW9ufVxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlfVxuICAgICAqL1xuICAgIGFzeW5jIGxpc3RNZW1iZXJzaGlwcyh1c2VySWQpIHtcbiAgICAgICAgY29uc3QgYXBpUGF0aCA9ICcvdXNlcnMve3VzZXJJZH0vbWVtYmVyc2hpcHMnLnJlcGxhY2UoJ3t1c2VySWR9JywgdXNlcklkKTtcbiAgICAgICAgbGV0IHBheWxvYWQgPSB7fTtcbiAgICAgICAgaWYgKHR5cGVvZiB1c2VySWQgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgQXBwd3JpdGVFeGNlcHRpb24oJ01pc3NpbmcgcmVxdWlyZWQgcGFyYW1ldGVyOiBcInVzZXJJZFwiJyk7XG4gICAgICAgIH1cblxuXG4gICAgICAgIHJldHVybiBhd2FpdCB0aGlzLmNsaWVudC5jYWxsKCdnZXQnLCBhcGlQYXRoLCB7XG4gICAgICAgICAgICAnY29udGVudC10eXBlJzogJ2FwcGxpY2F0aW9uL2pzb24nLFxuICAgICAgICB9LCBwYXlsb2FkKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBVcGRhdGUgTUZBXG4gICAgICpcbiAgICAgKiBFbmFibGUgb3IgZGlzYWJsZSBNRkEgb24gYSB1c2VyIGFjY291bnQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gdXNlcklkXG4gICAgICogQHBhcmFtIHtib29sZWFufSBtZmFcbiAgICAgKiBAdGhyb3dzIHtBcHB3cml0ZUV4Y2VwdGlvbn1cbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZX1cbiAgICAgKi9cbiAgICBhc3luYyB1cGRhdGVNZmEodXNlcklkLCBtZmEpIHtcbiAgICAgICAgY29uc3QgYXBpUGF0aCA9ICcvdXNlcnMve3VzZXJJZH0vbWZhJy5yZXBsYWNlKCd7dXNlcklkfScsIHVzZXJJZCk7XG4gICAgICAgIGxldCBwYXlsb2FkID0ge307XG4gICAgICAgIGlmICh0eXBlb2YgdXNlcklkID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEFwcHdyaXRlRXhjZXB0aW9uKCdNaXNzaW5nIHJlcXVpcmVkIHBhcmFtZXRlcjogXCJ1c2VySWRcIicpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHR5cGVvZiBtZmEgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgQXBwd3JpdGVFeGNlcHRpb24oJ01pc3NpbmcgcmVxdWlyZWQgcGFyYW1ldGVyOiBcIm1mYVwiJyk7XG4gICAgICAgIH1cblxuXG4gICAgICAgIGlmICh0eXBlb2YgbWZhICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgcGF5bG9hZFsnbWZhJ10gPSBtZmE7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy5jbGllbnQuY2FsbCgncGF0Y2gnLCBhcGlQYXRoLCB7XG4gICAgICAgICAgICAnY29udGVudC10eXBlJzogJ2FwcGxpY2F0aW9uL2pzb24nLFxuICAgICAgICB9LCBwYXlsb2FkKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBEZWxldGUgQXV0aGVudGljYXRvclxuICAgICAqXG4gICAgICogRGVsZXRlIGFuIGF1dGhlbnRpY2F0b3IgYXBwLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHVzZXJJZFxuICAgICAqIEBwYXJhbSB7QXV0aGVudGljYXRvclR5cGV9IHR5cGVcbiAgICAgKiBAdGhyb3dzIHtBcHB3cml0ZUV4Y2VwdGlvbn1cbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZX1cbiAgICAgKi9cbiAgICBhc3luYyBkZWxldGVNZmFBdXRoZW50aWNhdG9yKHVzZXJJZCwgdHlwZSkge1xuICAgICAgICBjb25zdCBhcGlQYXRoID0gJy91c2Vycy97dXNlcklkfS9tZmEvYXV0aGVudGljYXRvcnMve3R5cGV9Jy5yZXBsYWNlKCd7dXNlcklkfScsIHVzZXJJZCkucmVwbGFjZSgne3R5cGV9JywgdHlwZSk7XG4gICAgICAgIGxldCBwYXlsb2FkID0ge307XG4gICAgICAgIGlmICh0eXBlb2YgdXNlcklkID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEFwcHdyaXRlRXhjZXB0aW9uKCdNaXNzaW5nIHJlcXVpcmVkIHBhcmFtZXRlcjogXCJ1c2VySWRcIicpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHR5cGVvZiB0eXBlID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEFwcHdyaXRlRXhjZXB0aW9uKCdNaXNzaW5nIHJlcXVpcmVkIHBhcmFtZXRlcjogXCJ0eXBlXCInKTtcbiAgICAgICAgfVxuXG5cbiAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMuY2xpZW50LmNhbGwoJ2RlbGV0ZScsIGFwaVBhdGgsIHtcbiAgICAgICAgICAgICdjb250ZW50LXR5cGUnOiAnYXBwbGljYXRpb24vanNvbicsXG4gICAgICAgIH0sIHBheWxvYWQpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIExpc3QgRmFjdG9yc1xuICAgICAqXG4gICAgICogTGlzdCB0aGUgZmFjdG9ycyBhdmFpbGFibGUgb24gdGhlIGFjY291bnQgdG8gYmUgdXNlZCBhcyBhIE1GQSBjaGFsbGFuZ2UuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gdXNlcklkXG4gICAgICogQHRocm93cyB7QXBwd3JpdGVFeGNlcHRpb259XG4gICAgICogQHJldHVybnMge1Byb21pc2V9XG4gICAgICovXG4gICAgYXN5bmMgbGlzdE1mYUZhY3RvcnModXNlcklkKSB7XG4gICAgICAgIGNvbnN0IGFwaVBhdGggPSAnL3VzZXJzL3t1c2VySWR9L21mYS9mYWN0b3JzJy5yZXBsYWNlKCd7dXNlcklkfScsIHVzZXJJZCk7XG4gICAgICAgIGxldCBwYXlsb2FkID0ge307XG4gICAgICAgIGlmICh0eXBlb2YgdXNlcklkID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEFwcHdyaXRlRXhjZXB0aW9uKCdNaXNzaW5nIHJlcXVpcmVkIHBhcmFtZXRlcjogXCJ1c2VySWRcIicpO1xuICAgICAgICB9XG5cblxuICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy5jbGllbnQuY2FsbCgnZ2V0JywgYXBpUGF0aCwge1xuICAgICAgICAgICAgJ2NvbnRlbnQtdHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJyxcbiAgICAgICAgfSwgcGF5bG9hZCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2V0IE1GQSBSZWNvdmVyeSBDb2Rlc1xuICAgICAqXG4gICAgICogR2V0IHJlY292ZXJ5IGNvZGVzIHRoYXQgY2FuIGJlIHVzZWQgYXMgYmFja3VwIGZvciBNRkEgZmxvdyBieSBVc2VyIElELlxuICAgICAqIEJlZm9yZSBnZXR0aW5nIGNvZGVzLCB0aGV5IG11c3QgYmUgZ2VuZXJhdGVkIHVzaW5nXG4gICAgICogW2NyZWF0ZU1mYVJlY292ZXJ5Q29kZXNdKC9kb2NzL3JlZmVyZW5jZXMvY2xvdWQvY2xpZW50LXdlYi9hY2NvdW50I2NyZWF0ZU1mYVJlY292ZXJ5Q29kZXMpXG4gICAgICogbWV0aG9kLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHVzZXJJZFxuICAgICAqIEB0aHJvd3Mge0FwcHdyaXRlRXhjZXB0aW9ufVxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlfVxuICAgICAqL1xuICAgIGFzeW5jIGdldE1mYVJlY292ZXJ5Q29kZXModXNlcklkKSB7XG4gICAgICAgIGNvbnN0IGFwaVBhdGggPSAnL3VzZXJzL3t1c2VySWR9L21mYS9yZWNvdmVyeS1jb2RlcycucmVwbGFjZSgne3VzZXJJZH0nLCB1c2VySWQpO1xuICAgICAgICBsZXQgcGF5bG9hZCA9IHt9O1xuICAgICAgICBpZiAodHlwZW9mIHVzZXJJZCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBBcHB3cml0ZUV4Y2VwdGlvbignTWlzc2luZyByZXF1aXJlZCBwYXJhbWV0ZXI6IFwidXNlcklkXCInKTtcbiAgICAgICAgfVxuXG5cbiAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMuY2xpZW50LmNhbGwoJ2dldCcsIGFwaVBhdGgsIHtcbiAgICAgICAgICAgICdjb250ZW50LXR5cGUnOiAnYXBwbGljYXRpb24vanNvbicsXG4gICAgICAgIH0sIHBheWxvYWQpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJlZ2VuZXJhdGUgTUZBIFJlY292ZXJ5IENvZGVzXG4gICAgICpcbiAgICAgKiBSZWdlbmVyYXRlIHJlY292ZXJ5IGNvZGVzIHRoYXQgY2FuIGJlIHVzZWQgYXMgYmFja3VwIGZvciBNRkEgZmxvdyBieSBVc2VyXG4gICAgICogSUQuIEJlZm9yZSByZWdlbmVyYXRpbmcgY29kZXMsIHRoZXkgbXVzdCBiZSBmaXJzdCBnZW5lcmF0ZWQgdXNpbmdcbiAgICAgKiBbY3JlYXRlTWZhUmVjb3ZlcnlDb2Rlc10oL2RvY3MvcmVmZXJlbmNlcy9jbG91ZC9jbGllbnQtd2ViL2FjY291bnQjY3JlYXRlTWZhUmVjb3ZlcnlDb2RlcylcbiAgICAgKiBtZXRob2QuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gdXNlcklkXG4gICAgICogQHRocm93cyB7QXBwd3JpdGVFeGNlcHRpb259XG4gICAgICogQHJldHVybnMge1Byb21pc2V9XG4gICAgICovXG4gICAgYXN5bmMgdXBkYXRlTWZhUmVjb3ZlcnlDb2Rlcyh1c2VySWQpIHtcbiAgICAgICAgY29uc3QgYXBpUGF0aCA9ICcvdXNlcnMve3VzZXJJZH0vbWZhL3JlY292ZXJ5LWNvZGVzJy5yZXBsYWNlKCd7dXNlcklkfScsIHVzZXJJZCk7XG4gICAgICAgIGxldCBwYXlsb2FkID0ge307XG4gICAgICAgIGlmICh0eXBlb2YgdXNlcklkID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEFwcHdyaXRlRXhjZXB0aW9uKCdNaXNzaW5nIHJlcXVpcmVkIHBhcmFtZXRlcjogXCJ1c2VySWRcIicpO1xuICAgICAgICB9XG5cblxuICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy5jbGllbnQuY2FsbCgncHV0JywgYXBpUGF0aCwge1xuICAgICAgICAgICAgJ2NvbnRlbnQtdHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJyxcbiAgICAgICAgfSwgcGF5bG9hZCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlIE1GQSBSZWNvdmVyeSBDb2Rlc1xuICAgICAqXG4gICAgICogR2VuZXJhdGUgcmVjb3ZlcnkgY29kZXMgdXNlZCBhcyBiYWNrdXAgZm9yIE1GQSBmbG93IGZvciBVc2VyIElELiBSZWNvdmVyeVxuICAgICAqIGNvZGVzIGNhbiBiZSB1c2VkIGFzIGEgTUZBIHZlcmlmaWNhdGlvbiB0eXBlIGluXG4gICAgICogW2NyZWF0ZU1mYUNoYWxsZW5nZV0oL2RvY3MvcmVmZXJlbmNlcy9jbG91ZC9jbGllbnQtd2ViL2FjY291bnQjY3JlYXRlTWZhQ2hhbGxlbmdlKVxuICAgICAqIG1ldGhvZCBieSBjbGllbnQgU0RLLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHVzZXJJZFxuICAgICAqIEB0aHJvd3Mge0FwcHdyaXRlRXhjZXB0aW9ufVxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlfVxuICAgICAqL1xuICAgIGFzeW5jIGNyZWF0ZU1mYVJlY292ZXJ5Q29kZXModXNlcklkKSB7XG4gICAgICAgIGNvbnN0IGFwaVBhdGggPSAnL3VzZXJzL3t1c2VySWR9L21mYS9yZWNvdmVyeS1jb2RlcycucmVwbGFjZSgne3VzZXJJZH0nLCB1c2VySWQpO1xuICAgICAgICBsZXQgcGF5bG9hZCA9IHt9O1xuICAgICAgICBpZiAodHlwZW9mIHVzZXJJZCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBBcHB3cml0ZUV4Y2VwdGlvbignTWlzc2luZyByZXF1aXJlZCBwYXJhbWV0ZXI6IFwidXNlcklkXCInKTtcbiAgICAgICAgfVxuXG5cbiAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMuY2xpZW50LmNhbGwoJ3BhdGNoJywgYXBpUGF0aCwge1xuICAgICAgICAgICAgJ2NvbnRlbnQtdHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJyxcbiAgICAgICAgfSwgcGF5bG9hZCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVXBkYXRlIG5hbWVcbiAgICAgKlxuICAgICAqIFVwZGF0ZSB0aGUgdXNlciBuYW1lIGJ5IGl0cyB1bmlxdWUgSUQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gdXNlcklkXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IG5hbWVcbiAgICAgKiBAdGhyb3dzIHtBcHB3cml0ZUV4Y2VwdGlvbn1cbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZX1cbiAgICAgKi9cbiAgICBhc3luYyB1cGRhdGVOYW1lKHVzZXJJZCwgbmFtZSkge1xuICAgICAgICBjb25zdCBhcGlQYXRoID0gJy91c2Vycy97dXNlcklkfS9uYW1lJy5yZXBsYWNlKCd7dXNlcklkfScsIHVzZXJJZCk7XG4gICAgICAgIGxldCBwYXlsb2FkID0ge307XG4gICAgICAgIGlmICh0eXBlb2YgdXNlcklkID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEFwcHdyaXRlRXhjZXB0aW9uKCdNaXNzaW5nIHJlcXVpcmVkIHBhcmFtZXRlcjogXCJ1c2VySWRcIicpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHR5cGVvZiBuYW1lID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEFwcHdyaXRlRXhjZXB0aW9uKCdNaXNzaW5nIHJlcXVpcmVkIHBhcmFtZXRlcjogXCJuYW1lXCInKTtcbiAgICAgICAgfVxuXG5cbiAgICAgICAgaWYgKHR5cGVvZiBuYW1lICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgcGF5bG9hZFsnbmFtZSddID0gbmFtZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBhd2FpdCB0aGlzLmNsaWVudC5jYWxsKCdwYXRjaCcsIGFwaVBhdGgsIHtcbiAgICAgICAgICAgICdjb250ZW50LXR5cGUnOiAnYXBwbGljYXRpb24vanNvbicsXG4gICAgICAgIH0sIHBheWxvYWQpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFVwZGF0ZSBwYXNzd29yZFxuICAgICAqXG4gICAgICogVXBkYXRlIHRoZSB1c2VyIHBhc3N3b3JkIGJ5IGl0cyB1bmlxdWUgSUQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gdXNlcklkXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHBhc3N3b3JkXG4gICAgICogQHRocm93cyB7QXBwd3JpdGVFeGNlcHRpb259XG4gICAgICogQHJldHVybnMge1Byb21pc2V9XG4gICAgICovXG4gICAgYXN5bmMgdXBkYXRlUGFzc3dvcmQodXNlcklkLCBwYXNzd29yZCkge1xuICAgICAgICBjb25zdCBhcGlQYXRoID0gJy91c2Vycy97dXNlcklkfS9wYXNzd29yZCcucmVwbGFjZSgne3VzZXJJZH0nLCB1c2VySWQpO1xuICAgICAgICBsZXQgcGF5bG9hZCA9IHt9O1xuICAgICAgICBpZiAodHlwZW9mIHVzZXJJZCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBBcHB3cml0ZUV4Y2VwdGlvbignTWlzc2luZyByZXF1aXJlZCBwYXJhbWV0ZXI6IFwidXNlcklkXCInKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0eXBlb2YgcGFzc3dvcmQgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgQXBwd3JpdGVFeGNlcHRpb24oJ01pc3NpbmcgcmVxdWlyZWQgcGFyYW1ldGVyOiBcInBhc3N3b3JkXCInKTtcbiAgICAgICAgfVxuXG5cbiAgICAgICAgaWYgKHR5cGVvZiBwYXNzd29yZCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHBheWxvYWRbJ3Bhc3N3b3JkJ10gPSBwYXNzd29yZDtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBhd2FpdCB0aGlzLmNsaWVudC5jYWxsKCdwYXRjaCcsIGFwaVBhdGgsIHtcbiAgICAgICAgICAgICdjb250ZW50LXR5cGUnOiAnYXBwbGljYXRpb24vanNvbicsXG4gICAgICAgIH0sIHBheWxvYWQpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFVwZGF0ZSBwaG9uZVxuICAgICAqXG4gICAgICogVXBkYXRlIHRoZSB1c2VyIHBob25lIGJ5IGl0cyB1bmlxdWUgSUQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gdXNlcklkXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IG51bWJlclxuICAgICAqIEB0aHJvd3Mge0FwcHdyaXRlRXhjZXB0aW9ufVxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlfVxuICAgICAqL1xuICAgIGFzeW5jIHVwZGF0ZVBob25lKHVzZXJJZCwgbnVtYmVyKSB7XG4gICAgICAgIGNvbnN0IGFwaVBhdGggPSAnL3VzZXJzL3t1c2VySWR9L3Bob25lJy5yZXBsYWNlKCd7dXNlcklkfScsIHVzZXJJZCk7XG4gICAgICAgIGxldCBwYXlsb2FkID0ge307XG4gICAgICAgIGlmICh0eXBlb2YgdXNlcklkID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEFwcHdyaXRlRXhjZXB0aW9uKCdNaXNzaW5nIHJlcXVpcmVkIHBhcmFtZXRlcjogXCJ1c2VySWRcIicpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHR5cGVvZiBudW1iZXIgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgQXBwd3JpdGVFeGNlcHRpb24oJ01pc3NpbmcgcmVxdWlyZWQgcGFyYW1ldGVyOiBcIm51bWJlclwiJyk7XG4gICAgICAgIH1cblxuXG4gICAgICAgIGlmICh0eXBlb2YgbnVtYmVyICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgcGF5bG9hZFsnbnVtYmVyJ10gPSBudW1iZXI7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy5jbGllbnQuY2FsbCgncGF0Y2gnLCBhcGlQYXRoLCB7XG4gICAgICAgICAgICAnY29udGVudC10eXBlJzogJ2FwcGxpY2F0aW9uL2pzb24nLFxuICAgICAgICB9LCBwYXlsb2FkKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZXQgdXNlciBwcmVmZXJlbmNlc1xuICAgICAqXG4gICAgICogR2V0IHRoZSB1c2VyIHByZWZlcmVuY2VzIGJ5IGl0cyB1bmlxdWUgSUQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gdXNlcklkXG4gICAgICogQHRocm93cyB7QXBwd3JpdGVFeGNlcHRpb259XG4gICAgICogQHJldHVybnMge1Byb21pc2V9XG4gICAgICovXG4gICAgYXN5bmMgZ2V0UHJlZnModXNlcklkKSB7XG4gICAgICAgIGNvbnN0IGFwaVBhdGggPSAnL3VzZXJzL3t1c2VySWR9L3ByZWZzJy5yZXBsYWNlKCd7dXNlcklkfScsIHVzZXJJZCk7XG4gICAgICAgIGxldCBwYXlsb2FkID0ge307XG4gICAgICAgIGlmICh0eXBlb2YgdXNlcklkID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEFwcHdyaXRlRXhjZXB0aW9uKCdNaXNzaW5nIHJlcXVpcmVkIHBhcmFtZXRlcjogXCJ1c2VySWRcIicpO1xuICAgICAgICB9XG5cblxuICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy5jbGllbnQuY2FsbCgnZ2V0JywgYXBpUGF0aCwge1xuICAgICAgICAgICAgJ2NvbnRlbnQtdHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJyxcbiAgICAgICAgfSwgcGF5bG9hZCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVXBkYXRlIHVzZXIgcHJlZmVyZW5jZXNcbiAgICAgKlxuICAgICAqIFVwZGF0ZSB0aGUgdXNlciBwcmVmZXJlbmNlcyBieSBpdHMgdW5pcXVlIElELiBUaGUgb2JqZWN0IHlvdSBwYXNzIGlzIHN0b3JlZFxuICAgICAqIGFzIGlzLCBhbmQgcmVwbGFjZXMgYW55IHByZXZpb3VzIHZhbHVlLiBUaGUgbWF4aW11bSBhbGxvd2VkIHByZWZzIHNpemUgaXNcbiAgICAgKiA2NGtCIGFuZCB0aHJvd3MgZXJyb3IgaWYgZXhjZWVkZWQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gdXNlcklkXG4gICAgICogQHBhcmFtIHtvYmplY3R9IHByZWZzXG4gICAgICogQHRocm93cyB7QXBwd3JpdGVFeGNlcHRpb259XG4gICAgICogQHJldHVybnMge1Byb21pc2V9XG4gICAgICovXG4gICAgYXN5bmMgdXBkYXRlUHJlZnModXNlcklkLCBwcmVmcykge1xuICAgICAgICBjb25zdCBhcGlQYXRoID0gJy91c2Vycy97dXNlcklkfS9wcmVmcycucmVwbGFjZSgne3VzZXJJZH0nLCB1c2VySWQpO1xuICAgICAgICBsZXQgcGF5bG9hZCA9IHt9O1xuICAgICAgICBpZiAodHlwZW9mIHVzZXJJZCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBBcHB3cml0ZUV4Y2VwdGlvbignTWlzc2luZyByZXF1aXJlZCBwYXJhbWV0ZXI6IFwidXNlcklkXCInKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0eXBlb2YgcHJlZnMgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgQXBwd3JpdGVFeGNlcHRpb24oJ01pc3NpbmcgcmVxdWlyZWQgcGFyYW1ldGVyOiBcInByZWZzXCInKTtcbiAgICAgICAgfVxuXG5cbiAgICAgICAgaWYgKHR5cGVvZiBwcmVmcyAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHBheWxvYWRbJ3ByZWZzJ10gPSBwcmVmcztcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBhd2FpdCB0aGlzLmNsaWVudC5jYWxsKCdwYXRjaCcsIGFwaVBhdGgsIHtcbiAgICAgICAgICAgICdjb250ZW50LXR5cGUnOiAnYXBwbGljYXRpb24vanNvbicsXG4gICAgICAgIH0sIHBheWxvYWQpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIExpc3QgdXNlciBzZXNzaW9uc1xuICAgICAqXG4gICAgICogR2V0IHRoZSB1c2VyIHNlc3Npb25zIGxpc3QgYnkgaXRzIHVuaXF1ZSBJRC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSB1c2VySWRcbiAgICAgKiBAdGhyb3dzIHtBcHB3cml0ZUV4Y2VwdGlvbn1cbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZX1cbiAgICAgKi9cbiAgICBhc3luYyBsaXN0U2Vzc2lvbnModXNlcklkKSB7XG4gICAgICAgIGNvbnN0IGFwaVBhdGggPSAnL3VzZXJzL3t1c2VySWR9L3Nlc3Npb25zJy5yZXBsYWNlKCd7dXNlcklkfScsIHVzZXJJZCk7XG4gICAgICAgIGxldCBwYXlsb2FkID0ge307XG4gICAgICAgIGlmICh0eXBlb2YgdXNlcklkID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEFwcHdyaXRlRXhjZXB0aW9uKCdNaXNzaW5nIHJlcXVpcmVkIHBhcmFtZXRlcjogXCJ1c2VySWRcIicpO1xuICAgICAgICB9XG5cblxuICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy5jbGllbnQuY2FsbCgnZ2V0JywgYXBpUGF0aCwge1xuICAgICAgICAgICAgJ2NvbnRlbnQtdHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJyxcbiAgICAgICAgfSwgcGF5bG9hZCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlIHNlc3Npb25cbiAgICAgKlxuICAgICAqIENyZWF0ZXMgYSBzZXNzaW9uIGZvciBhIHVzZXIuIFJldHVybnMgYW4gaW1tZWRpYXRlbHkgdXNhYmxlIHNlc3Npb24gb2JqZWN0LlxuICAgICAqIFxuICAgICAqIElmIHlvdSB3YW50IHRvIGdlbmVyYXRlIGEgdG9rZW4gZm9yIGEgY3VzdG9tIGF1dGhlbnRpY2F0aW9uIGZsb3csIHVzZSB0aGVcbiAgICAgKiBbUE9TVFxuICAgICAqIC91c2Vycy97dXNlcklkfS90b2tlbnNdKGh0dHBzOi8vYXBwd3JpdGUuaW8vZG9jcy9zZXJ2ZXIvdXNlcnMjY3JlYXRlVG9rZW4pXG4gICAgICogZW5kcG9pbnQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gdXNlcklkXG4gICAgICogQHRocm93cyB7QXBwd3JpdGVFeGNlcHRpb259XG4gICAgICogQHJldHVybnMge1Byb21pc2V9XG4gICAgICovXG4gICAgYXN5bmMgY3JlYXRlU2Vzc2lvbih1c2VySWQpIHtcbiAgICAgICAgY29uc3QgYXBpUGF0aCA9ICcvdXNlcnMve3VzZXJJZH0vc2Vzc2lvbnMnLnJlcGxhY2UoJ3t1c2VySWR9JywgdXNlcklkKTtcbiAgICAgICAgbGV0IHBheWxvYWQgPSB7fTtcbiAgICAgICAgaWYgKHR5cGVvZiB1c2VySWQgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgQXBwd3JpdGVFeGNlcHRpb24oJ01pc3NpbmcgcmVxdWlyZWQgcGFyYW1ldGVyOiBcInVzZXJJZFwiJyk7XG4gICAgICAgIH1cblxuXG4gICAgICAgIHJldHVybiBhd2FpdCB0aGlzLmNsaWVudC5jYWxsKCdwb3N0JywgYXBpUGF0aCwge1xuICAgICAgICAgICAgJ2NvbnRlbnQtdHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJyxcbiAgICAgICAgfSwgcGF5bG9hZCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRGVsZXRlIHVzZXIgc2Vzc2lvbnNcbiAgICAgKlxuICAgICAqIERlbGV0ZSBhbGwgdXNlcidzIHNlc3Npb25zIGJ5IHVzaW5nIHRoZSB1c2VyJ3MgdW5pcXVlIElELlxuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHVzZXJJZFxuICAgICAqIEB0aHJvd3Mge0FwcHdyaXRlRXhjZXB0aW9ufVxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlfVxuICAgICAqL1xuICAgIGFzeW5jIGRlbGV0ZVNlc3Npb25zKHVzZXJJZCkge1xuICAgICAgICBjb25zdCBhcGlQYXRoID0gJy91c2Vycy97dXNlcklkfS9zZXNzaW9ucycucmVwbGFjZSgne3VzZXJJZH0nLCB1c2VySWQpO1xuICAgICAgICBsZXQgcGF5bG9hZCA9IHt9O1xuICAgICAgICBpZiAodHlwZW9mIHVzZXJJZCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBBcHB3cml0ZUV4Y2VwdGlvbignTWlzc2luZyByZXF1aXJlZCBwYXJhbWV0ZXI6IFwidXNlcklkXCInKTtcbiAgICAgICAgfVxuXG5cbiAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMuY2xpZW50LmNhbGwoJ2RlbGV0ZScsIGFwaVBhdGgsIHtcbiAgICAgICAgICAgICdjb250ZW50LXR5cGUnOiAnYXBwbGljYXRpb24vanNvbicsXG4gICAgICAgIH0sIHBheWxvYWQpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIERlbGV0ZSB1c2VyIHNlc3Npb25cbiAgICAgKlxuICAgICAqIERlbGV0ZSBhIHVzZXIgc2Vzc2lvbnMgYnkgaXRzIHVuaXF1ZSBJRC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSB1c2VySWRcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gc2Vzc2lvbklkXG4gICAgICogQHRocm93cyB7QXBwd3JpdGVFeGNlcHRpb259XG4gICAgICogQHJldHVybnMge1Byb21pc2V9XG4gICAgICovXG4gICAgYXN5bmMgZGVsZXRlU2Vzc2lvbih1c2VySWQsIHNlc3Npb25JZCkge1xuICAgICAgICBjb25zdCBhcGlQYXRoID0gJy91c2Vycy97dXNlcklkfS9zZXNzaW9ucy97c2Vzc2lvbklkfScucmVwbGFjZSgne3VzZXJJZH0nLCB1c2VySWQpLnJlcGxhY2UoJ3tzZXNzaW9uSWR9Jywgc2Vzc2lvbklkKTtcbiAgICAgICAgbGV0IHBheWxvYWQgPSB7fTtcbiAgICAgICAgaWYgKHR5cGVvZiB1c2VySWQgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgQXBwd3JpdGVFeGNlcHRpb24oJ01pc3NpbmcgcmVxdWlyZWQgcGFyYW1ldGVyOiBcInVzZXJJZFwiJyk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodHlwZW9mIHNlc3Npb25JZCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBBcHB3cml0ZUV4Y2VwdGlvbignTWlzc2luZyByZXF1aXJlZCBwYXJhbWV0ZXI6IFwic2Vzc2lvbklkXCInKTtcbiAgICAgICAgfVxuXG5cbiAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMuY2xpZW50LmNhbGwoJ2RlbGV0ZScsIGFwaVBhdGgsIHtcbiAgICAgICAgICAgICdjb250ZW50LXR5cGUnOiAnYXBwbGljYXRpb24vanNvbicsXG4gICAgICAgIH0sIHBheWxvYWQpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFVwZGF0ZSB1c2VyIHN0YXR1c1xuICAgICAqXG4gICAgICogVXBkYXRlIHRoZSB1c2VyIHN0YXR1cyBieSBpdHMgdW5pcXVlIElELiBVc2UgdGhpcyBlbmRwb2ludCBhcyBhblxuICAgICAqIGFsdGVybmF0aXZlIHRvIGRlbGV0aW5nIGEgdXNlciBpZiB5b3Ugd2FudCB0byBrZWVwIHVzZXIncyBJRCByZXNlcnZlZC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSB1c2VySWRcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IHN0YXR1c1xuICAgICAqIEB0aHJvd3Mge0FwcHdyaXRlRXhjZXB0aW9ufVxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlfVxuICAgICAqL1xuICAgIGFzeW5jIHVwZGF0ZVN0YXR1cyh1c2VySWQsIHN0YXR1cykge1xuICAgICAgICBjb25zdCBhcGlQYXRoID0gJy91c2Vycy97dXNlcklkfS9zdGF0dXMnLnJlcGxhY2UoJ3t1c2VySWR9JywgdXNlcklkKTtcbiAgICAgICAgbGV0IHBheWxvYWQgPSB7fTtcbiAgICAgICAgaWYgKHR5cGVvZiB1c2VySWQgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgQXBwd3JpdGVFeGNlcHRpb24oJ01pc3NpbmcgcmVxdWlyZWQgcGFyYW1ldGVyOiBcInVzZXJJZFwiJyk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodHlwZW9mIHN0YXR1cyA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBBcHB3cml0ZUV4Y2VwdGlvbignTWlzc2luZyByZXF1aXJlZCBwYXJhbWV0ZXI6IFwic3RhdHVzXCInKTtcbiAgICAgICAgfVxuXG5cbiAgICAgICAgaWYgKHR5cGVvZiBzdGF0dXMgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICBwYXlsb2FkWydzdGF0dXMnXSA9IHN0YXR1cztcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBhd2FpdCB0aGlzLmNsaWVudC5jYWxsKCdwYXRjaCcsIGFwaVBhdGgsIHtcbiAgICAgICAgICAgICdjb250ZW50LXR5cGUnOiAnYXBwbGljYXRpb24vanNvbicsXG4gICAgICAgIH0sIHBheWxvYWQpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIExpc3QgVXNlciBUYXJnZXRzXG4gICAgICpcbiAgICAgKiBMaXN0IHRoZSBtZXNzYWdpbmcgdGFyZ2V0cyB0aGF0IGFyZSBhc3NvY2lhdGVkIHdpdGggYSB1c2VyLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHVzZXJJZFxuICAgICAqIEBwYXJhbSB7c3RyaW5nW119IHF1ZXJpZXNcbiAgICAgKiBAdGhyb3dzIHtBcHB3cml0ZUV4Y2VwdGlvbn1cbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZX1cbiAgICAgKi9cbiAgICBhc3luYyBsaXN0VGFyZ2V0cyh1c2VySWQsIHF1ZXJpZXMpIHtcbiAgICAgICAgY29uc3QgYXBpUGF0aCA9ICcvdXNlcnMve3VzZXJJZH0vdGFyZ2V0cycucmVwbGFjZSgne3VzZXJJZH0nLCB1c2VySWQpO1xuICAgICAgICBsZXQgcGF5bG9hZCA9IHt9O1xuICAgICAgICBpZiAodHlwZW9mIHVzZXJJZCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBBcHB3cml0ZUV4Y2VwdGlvbignTWlzc2luZyByZXF1aXJlZCBwYXJhbWV0ZXI6IFwidXNlcklkXCInKTtcbiAgICAgICAgfVxuXG5cbiAgICAgICAgaWYgKHR5cGVvZiBxdWVyaWVzICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgcGF5bG9hZFsncXVlcmllcyddID0gcXVlcmllcztcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBhd2FpdCB0aGlzLmNsaWVudC5jYWxsKCdnZXQnLCBhcGlQYXRoLCB7XG4gICAgICAgICAgICAnY29udGVudC10eXBlJzogJ2FwcGxpY2F0aW9uL2pzb24nLFxuICAgICAgICB9LCBwYXlsb2FkKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGUgVXNlciBUYXJnZXRcbiAgICAgKlxuICAgICAqIENyZWF0ZSBhIG1lc3NhZ2luZyB0YXJnZXQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gdXNlcklkXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHRhcmdldElkXG4gICAgICogQHBhcmFtIHtNZXNzYWdpbmdQcm92aWRlclR5cGV9IHByb3ZpZGVyVHlwZVxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBpZGVudGlmaWVyXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHByb3ZpZGVySWRcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gbmFtZVxuICAgICAqIEB0aHJvd3Mge0FwcHdyaXRlRXhjZXB0aW9ufVxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlfVxuICAgICAqL1xuICAgIGFzeW5jIGNyZWF0ZVRhcmdldCh1c2VySWQsIHRhcmdldElkLCBwcm92aWRlclR5cGUsIGlkZW50aWZpZXIsIHByb3ZpZGVySWQsIG5hbWUpIHtcbiAgICAgICAgY29uc3QgYXBpUGF0aCA9ICcvdXNlcnMve3VzZXJJZH0vdGFyZ2V0cycucmVwbGFjZSgne3VzZXJJZH0nLCB1c2VySWQpO1xuICAgICAgICBsZXQgcGF5bG9hZCA9IHt9O1xuICAgICAgICBpZiAodHlwZW9mIHVzZXJJZCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBBcHB3cml0ZUV4Y2VwdGlvbignTWlzc2luZyByZXF1aXJlZCBwYXJhbWV0ZXI6IFwidXNlcklkXCInKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0eXBlb2YgdGFyZ2V0SWQgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgQXBwd3JpdGVFeGNlcHRpb24oJ01pc3NpbmcgcmVxdWlyZWQgcGFyYW1ldGVyOiBcInRhcmdldElkXCInKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0eXBlb2YgcHJvdmlkZXJUeXBlID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEFwcHdyaXRlRXhjZXB0aW9uKCdNaXNzaW5nIHJlcXVpcmVkIHBhcmFtZXRlcjogXCJwcm92aWRlclR5cGVcIicpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHR5cGVvZiBpZGVudGlmaWVyID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEFwcHdyaXRlRXhjZXB0aW9uKCdNaXNzaW5nIHJlcXVpcmVkIHBhcmFtZXRlcjogXCJpZGVudGlmaWVyXCInKTtcbiAgICAgICAgfVxuXG5cbiAgICAgICAgaWYgKHR5cGVvZiB0YXJnZXRJZCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHBheWxvYWRbJ3RhcmdldElkJ10gPSB0YXJnZXRJZDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0eXBlb2YgcHJvdmlkZXJUeXBlICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgcGF5bG9hZFsncHJvdmlkZXJUeXBlJ10gPSBwcm92aWRlclR5cGU7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodHlwZW9mIGlkZW50aWZpZXIgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICBwYXlsb2FkWydpZGVudGlmaWVyJ10gPSBpZGVudGlmaWVyO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHR5cGVvZiBwcm92aWRlcklkICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgcGF5bG9hZFsncHJvdmlkZXJJZCddID0gcHJvdmlkZXJJZDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0eXBlb2YgbmFtZSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHBheWxvYWRbJ25hbWUnXSA9IG5hbWU7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy5jbGllbnQuY2FsbCgncG9zdCcsIGFwaVBhdGgsIHtcbiAgICAgICAgICAgICdjb250ZW50LXR5cGUnOiAnYXBwbGljYXRpb24vanNvbicsXG4gICAgICAgIH0sIHBheWxvYWQpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdldCBVc2VyIFRhcmdldFxuICAgICAqXG4gICAgICogR2V0IGEgdXNlcidzIHB1c2ggbm90aWZpY2F0aW9uIHRhcmdldCBieSBJRC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSB1c2VySWRcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gdGFyZ2V0SWRcbiAgICAgKiBAdGhyb3dzIHtBcHB3cml0ZUV4Y2VwdGlvbn1cbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZX1cbiAgICAgKi9cbiAgICBhc3luYyBnZXRUYXJnZXQodXNlcklkLCB0YXJnZXRJZCkge1xuICAgICAgICBjb25zdCBhcGlQYXRoID0gJy91c2Vycy97dXNlcklkfS90YXJnZXRzL3t0YXJnZXRJZH0nLnJlcGxhY2UoJ3t1c2VySWR9JywgdXNlcklkKS5yZXBsYWNlKCd7dGFyZ2V0SWR9JywgdGFyZ2V0SWQpO1xuICAgICAgICBsZXQgcGF5bG9hZCA9IHt9O1xuICAgICAgICBpZiAodHlwZW9mIHVzZXJJZCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBBcHB3cml0ZUV4Y2VwdGlvbignTWlzc2luZyByZXF1aXJlZCBwYXJhbWV0ZXI6IFwidXNlcklkXCInKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0eXBlb2YgdGFyZ2V0SWQgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgQXBwd3JpdGVFeGNlcHRpb24oJ01pc3NpbmcgcmVxdWlyZWQgcGFyYW1ldGVyOiBcInRhcmdldElkXCInKTtcbiAgICAgICAgfVxuXG5cbiAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMuY2xpZW50LmNhbGwoJ2dldCcsIGFwaVBhdGgsIHtcbiAgICAgICAgICAgICdjb250ZW50LXR5cGUnOiAnYXBwbGljYXRpb24vanNvbicsXG4gICAgICAgIH0sIHBheWxvYWQpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFVwZGF0ZSBVc2VyIHRhcmdldFxuICAgICAqXG4gICAgICogVXBkYXRlIGEgbWVzc2FnaW5nIHRhcmdldC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSB1c2VySWRcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gdGFyZ2V0SWRcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gaWRlbnRpZmllclxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBwcm92aWRlcklkXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IG5hbWVcbiAgICAgKiBAdGhyb3dzIHtBcHB3cml0ZUV4Y2VwdGlvbn1cbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZX1cbiAgICAgKi9cbiAgICBhc3luYyB1cGRhdGVUYXJnZXQodXNlcklkLCB0YXJnZXRJZCwgaWRlbnRpZmllciwgcHJvdmlkZXJJZCwgbmFtZSkge1xuICAgICAgICBjb25zdCBhcGlQYXRoID0gJy91c2Vycy97dXNlcklkfS90YXJnZXRzL3t0YXJnZXRJZH0nLnJlcGxhY2UoJ3t1c2VySWR9JywgdXNlcklkKS5yZXBsYWNlKCd7dGFyZ2V0SWR9JywgdGFyZ2V0SWQpO1xuICAgICAgICBsZXQgcGF5bG9hZCA9IHt9O1xuICAgICAgICBpZiAodHlwZW9mIHVzZXJJZCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBBcHB3cml0ZUV4Y2VwdGlvbignTWlzc2luZyByZXF1aXJlZCBwYXJhbWV0ZXI6IFwidXNlcklkXCInKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0eXBlb2YgdGFyZ2V0SWQgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgQXBwd3JpdGVFeGNlcHRpb24oJ01pc3NpbmcgcmVxdWlyZWQgcGFyYW1ldGVyOiBcInRhcmdldElkXCInKTtcbiAgICAgICAgfVxuXG5cbiAgICAgICAgaWYgKHR5cGVvZiBpZGVudGlmaWVyICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgcGF5bG9hZFsnaWRlbnRpZmllciddID0gaWRlbnRpZmllcjtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0eXBlb2YgcHJvdmlkZXJJZCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHBheWxvYWRbJ3Byb3ZpZGVySWQnXSA9IHByb3ZpZGVySWQ7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodHlwZW9mIG5hbWUgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICBwYXlsb2FkWyduYW1lJ10gPSBuYW1lO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMuY2xpZW50LmNhbGwoJ3BhdGNoJywgYXBpUGF0aCwge1xuICAgICAgICAgICAgJ2NvbnRlbnQtdHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJyxcbiAgICAgICAgfSwgcGF5bG9hZCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRGVsZXRlIHVzZXIgdGFyZ2V0XG4gICAgICpcbiAgICAgKiBEZWxldGUgYSBtZXNzYWdpbmcgdGFyZ2V0LlxuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHVzZXJJZFxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSB0YXJnZXRJZFxuICAgICAqIEB0aHJvd3Mge0FwcHdyaXRlRXhjZXB0aW9ufVxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlfVxuICAgICAqL1xuICAgIGFzeW5jIGRlbGV0ZVRhcmdldCh1c2VySWQsIHRhcmdldElkKSB7XG4gICAgICAgIGNvbnN0IGFwaVBhdGggPSAnL3VzZXJzL3t1c2VySWR9L3RhcmdldHMve3RhcmdldElkfScucmVwbGFjZSgne3VzZXJJZH0nLCB1c2VySWQpLnJlcGxhY2UoJ3t0YXJnZXRJZH0nLCB0YXJnZXRJZCk7XG4gICAgICAgIGxldCBwYXlsb2FkID0ge307XG4gICAgICAgIGlmICh0eXBlb2YgdXNlcklkID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEFwcHdyaXRlRXhjZXB0aW9uKCdNaXNzaW5nIHJlcXVpcmVkIHBhcmFtZXRlcjogXCJ1c2VySWRcIicpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHR5cGVvZiB0YXJnZXRJZCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBBcHB3cml0ZUV4Y2VwdGlvbignTWlzc2luZyByZXF1aXJlZCBwYXJhbWV0ZXI6IFwidGFyZ2V0SWRcIicpO1xuICAgICAgICB9XG5cblxuICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy5jbGllbnQuY2FsbCgnZGVsZXRlJywgYXBpUGF0aCwge1xuICAgICAgICAgICAgJ2NvbnRlbnQtdHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJyxcbiAgICAgICAgfSwgcGF5bG9hZCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlIHRva2VuXG4gICAgICpcbiAgICAgKiBSZXR1cm5zIGEgdG9rZW4gd2l0aCBhIHNlY3JldCBrZXkgZm9yIGNyZWF0aW5nIGEgc2Vzc2lvbi4gSWYgdGhlIHByb3ZpZGVkXG4gICAgICogdXNlciBJRCBoYXMgbm90IGJlIHJlZ2lzdGVyZWQsIGEgbmV3IHVzZXIgd2lsbCBiZSBjcmVhdGVkLiBVc2UgdGhlIHJldHVybmVkXG4gICAgICogdXNlciBJRCBhbmQgc2VjcmV0IGFuZCBzdWJtaXQgYSByZXF1ZXN0IHRvIHRoZSBbUFVUXG4gICAgICogL2FjY291bnQvc2Vzc2lvbnMvY3VzdG9tXShodHRwczovL2FwcHdyaXRlLmlvL2RvY3MvcmVmZXJlbmNlcy9jbG91ZC9jbGllbnQtd2ViL2FjY291bnQjdXBkYXRlQ3VzdG9tU2Vzc2lvbilcbiAgICAgKiBlbmRwb2ludCB0byBjb21wbGV0ZSB0aGUgbG9naW4gcHJvY2Vzcy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSB1c2VySWRcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gbGVuZ3RoXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGV4cGlyZVxuICAgICAqIEB0aHJvd3Mge0FwcHdyaXRlRXhjZXB0aW9ufVxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlfVxuICAgICAqL1xuICAgIGFzeW5jIGNyZWF0ZVRva2VuKHVzZXJJZCwgbGVuZ3RoLCBleHBpcmUpIHtcbiAgICAgICAgY29uc3QgYXBpUGF0aCA9ICcvdXNlcnMve3VzZXJJZH0vdG9rZW5zJy5yZXBsYWNlKCd7dXNlcklkfScsIHVzZXJJZCk7XG4gICAgICAgIGxldCBwYXlsb2FkID0ge307XG4gICAgICAgIGlmICh0eXBlb2YgdXNlcklkID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEFwcHdyaXRlRXhjZXB0aW9uKCdNaXNzaW5nIHJlcXVpcmVkIHBhcmFtZXRlcjogXCJ1c2VySWRcIicpO1xuICAgICAgICB9XG5cblxuICAgICAgICBpZiAodHlwZW9mIGxlbmd0aCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHBheWxvYWRbJ2xlbmd0aCddID0gbGVuZ3RoO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHR5cGVvZiBleHBpcmUgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICBwYXlsb2FkWydleHBpcmUnXSA9IGV4cGlyZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBhd2FpdCB0aGlzLmNsaWVudC5jYWxsKCdwb3N0JywgYXBpUGF0aCwge1xuICAgICAgICAgICAgJ2NvbnRlbnQtdHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJyxcbiAgICAgICAgfSwgcGF5bG9hZCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVXBkYXRlIGVtYWlsIHZlcmlmaWNhdGlvblxuICAgICAqXG4gICAgICogVXBkYXRlIHRoZSB1c2VyIGVtYWlsIHZlcmlmaWNhdGlvbiBzdGF0dXMgYnkgaXRzIHVuaXF1ZSBJRC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSB1c2VySWRcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IGVtYWlsVmVyaWZpY2F0aW9uXG4gICAgICogQHRocm93cyB7QXBwd3JpdGVFeGNlcHRpb259XG4gICAgICogQHJldHVybnMge1Byb21pc2V9XG4gICAgICovXG4gICAgYXN5bmMgdXBkYXRlRW1haWxWZXJpZmljYXRpb24odXNlcklkLCBlbWFpbFZlcmlmaWNhdGlvbikge1xuICAgICAgICBjb25zdCBhcGlQYXRoID0gJy91c2Vycy97dXNlcklkfS92ZXJpZmljYXRpb24nLnJlcGxhY2UoJ3t1c2VySWR9JywgdXNlcklkKTtcbiAgICAgICAgbGV0IHBheWxvYWQgPSB7fTtcbiAgICAgICAgaWYgKHR5cGVvZiB1c2VySWQgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgQXBwd3JpdGVFeGNlcHRpb24oJ01pc3NpbmcgcmVxdWlyZWQgcGFyYW1ldGVyOiBcInVzZXJJZFwiJyk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodHlwZW9mIGVtYWlsVmVyaWZpY2F0aW9uID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEFwcHdyaXRlRXhjZXB0aW9uKCdNaXNzaW5nIHJlcXVpcmVkIHBhcmFtZXRlcjogXCJlbWFpbFZlcmlmaWNhdGlvblwiJyk7XG4gICAgICAgIH1cblxuXG4gICAgICAgIGlmICh0eXBlb2YgZW1haWxWZXJpZmljYXRpb24gIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICBwYXlsb2FkWydlbWFpbFZlcmlmaWNhdGlvbiddID0gZW1haWxWZXJpZmljYXRpb247XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy5jbGllbnQuY2FsbCgncGF0Y2gnLCBhcGlQYXRoLCB7XG4gICAgICAgICAgICAnY29udGVudC10eXBlJzogJ2FwcGxpY2F0aW9uL2pzb24nLFxuICAgICAgICB9LCBwYXlsb2FkKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBVcGRhdGUgcGhvbmUgdmVyaWZpY2F0aW9uXG4gICAgICpcbiAgICAgKiBVcGRhdGUgdGhlIHVzZXIgcGhvbmUgdmVyaWZpY2F0aW9uIHN0YXR1cyBieSBpdHMgdW5pcXVlIElELlxuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHVzZXJJZFxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gcGhvbmVWZXJpZmljYXRpb25cbiAgICAgKiBAdGhyb3dzIHtBcHB3cml0ZUV4Y2VwdGlvbn1cbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZX1cbiAgICAgKi9cbiAgICBhc3luYyB1cGRhdGVQaG9uZVZlcmlmaWNhdGlvbih1c2VySWQsIHBob25lVmVyaWZpY2F0aW9uKSB7XG4gICAgICAgIGNvbnN0IGFwaVBhdGggPSAnL3VzZXJzL3t1c2VySWR9L3ZlcmlmaWNhdGlvbi9waG9uZScucmVwbGFjZSgne3VzZXJJZH0nLCB1c2VySWQpO1xuICAgICAgICBsZXQgcGF5bG9hZCA9IHt9O1xuICAgICAgICBpZiAodHlwZW9mIHVzZXJJZCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBBcHB3cml0ZUV4Y2VwdGlvbignTWlzc2luZyByZXF1aXJlZCBwYXJhbWV0ZXI6IFwidXNlcklkXCInKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0eXBlb2YgcGhvbmVWZXJpZmljYXRpb24gPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgQXBwd3JpdGVFeGNlcHRpb24oJ01pc3NpbmcgcmVxdWlyZWQgcGFyYW1ldGVyOiBcInBob25lVmVyaWZpY2F0aW9uXCInKTtcbiAgICAgICAgfVxuXG5cbiAgICAgICAgaWYgKHR5cGVvZiBwaG9uZVZlcmlmaWNhdGlvbiAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHBheWxvYWRbJ3Bob25lVmVyaWZpY2F0aW9uJ10gPSBwaG9uZVZlcmlmaWNhdGlvbjtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBhd2FpdCB0aGlzLmNsaWVudC5jYWxsKCdwYXRjaCcsIGFwaVBhdGgsIHtcbiAgICAgICAgICAgICdjb250ZW50LXR5cGUnOiAnYXBwbGljYXRpb24vanNvbicsXG4gICAgICAgIH0sIHBheWxvYWQpO1xuICAgIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBVc2VycztcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/node-appwrite/lib/services/users.js\n");

/***/ })

};
;